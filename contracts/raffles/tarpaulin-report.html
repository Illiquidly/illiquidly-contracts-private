<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
}

.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","ailiq_token","examples","ailiq_schema.rs"],"content":"use std::env::current_dir;\nuse std::fs::create_dir_all;\n\nuse cosmwasm_schema::{export_schema, remove_schemas, schema_for};\n\nuse cw20::{\n    AllAccountsResponse, AllAllowancesResponse, AllowanceResponse, BalanceResponse,\n    TokenInfoResponse,\n};\nuse cw20_base::msg::{ExecuteMsg, InstantiateMsg, QueryMsg};\n\nfn main() {\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"schema\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n\n    export_schema(\u0026schema_for!(InstantiateMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(ExecuteMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(QueryMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(AllowanceResponse), \u0026out_dir);\n    export_schema(\u0026schema_for!(BalanceResponse), \u0026out_dir);\n    export_schema(\u0026schema_for!(TokenInfoResponse), \u0026out_dir);\n    export_schema(\u0026schema_for!(AllAllowancesResponse), \u0026out_dir);\n    export_schema(\u0026schema_for!(AllAccountsResponse), \u0026out_dir);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","ailiq_token","src","allowances.rs"],"content":"use cosmwasm_std::{\n    attr, Addr, Binary, BlockInfo, Deps, DepsMut, Env, MessageInfo, Response, StdError, StdResult,\n    Storage, Uint128,\n};\nuse cw20::{AllowanceResponse, Cw20ReceiveMsg, Expiration};\n\nuse crate::error::ContractError;\nuse crate::state::{ALLOWANCES, BALANCES, TOKEN_INFO};\n\npub fn execute_increase_allowance(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    spender: String,\n    amount: Uint128,\n    expires: Option\u003cExpiration\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let spender_addr = deps.api.addr_validate(\u0026spender)?;\n    if spender_addr == info.sender {\n        return Err(ContractError::CannotSetOwnAccount {});\n    }\n\n    ALLOWANCES.update(\n        deps.storage,\n        (\u0026info.sender, \u0026spender_addr),\n        |allow| -\u003e StdResult\u003c_\u003e {\n            let mut val = allow.unwrap_or_default();\n            if let Some(exp) = expires {\n                val.expires = exp;\n            }\n            val.allowance += amount;\n            Ok(val)\n        },\n    )?;\n\n    let res = Response::new().add_attributes(vec![\n        attr(\"action\", \"increase_allowance\"),\n        attr(\"owner\", info.sender),\n        attr(\"spender\", spender),\n        attr(\"amount\", amount),\n    ]);\n    Ok(res)\n}\n\npub fn execute_decrease_allowance(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    spender: String,\n    amount: Uint128,\n    expires: Option\u003cExpiration\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let spender_addr = deps.api.addr_validate(\u0026spender)?;\n    if spender_addr == info.sender {\n        return Err(ContractError::CannotSetOwnAccount {});\n    }\n\n    let key = (\u0026info.sender, \u0026spender_addr);\n    // load value and delete if it hits 0, or update otherwise\n    let mut allowance = ALLOWANCES.load(deps.storage, key)?;\n    if amount \u003c allowance.allowance {\n        // update the new amount\n        allowance.allowance = allowance\n            .allowance\n            .checked_sub(amount)\n            .map_err(StdError::overflow)?;\n        if let Some(exp) = expires {\n            allowance.expires = exp;\n        }\n        ALLOWANCES.save(deps.storage, key, \u0026allowance)?;\n    } else {\n        ALLOWANCES.remove(deps.storage, key);\n    }\n\n    let res = Response::new().add_attributes(vec![\n        attr(\"action\", \"decrease_allowance\"),\n        attr(\"owner\", info.sender),\n        attr(\"spender\", spender),\n        attr(\"amount\", amount),\n    ]);\n    Ok(res)\n}\n\n// this can be used to update a lower allowance - call bucket.update with proper keys\npub fn deduct_allowance(\n    storage: \u0026mut dyn Storage,\n    owner: \u0026Addr,\n    spender: \u0026Addr,\n    block: \u0026BlockInfo,\n    amount: Uint128,\n) -\u003e Result\u003cAllowanceResponse, ContractError\u003e {\n    ALLOWANCES.update(storage, (owner, spender), |current| {\n        match current {\n            Some(mut a) =\u003e {\n                if a.expires.is_expired(block) {\n                    Err(ContractError::Expired {})\n                } else {\n                    // deduct the allowance if enough\n                    a.allowance = a\n                        .allowance\n                        .checked_sub(amount)\n                        .map_err(StdError::overflow)?;\n                    Ok(a)\n                }\n            }\n            None =\u003e Err(ContractError::NoAllowance {}),\n        }\n    })\n}\n\npub fn execute_transfer_from(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    owner: String,\n    recipient: String,\n    amount: Uint128,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let rcpt_addr = deps.api.addr_validate(\u0026recipient)?;\n    let owner_addr = deps.api.addr_validate(\u0026owner)?;\n\n    // deduct allowance before doing anything else have enough allowance\n    deduct_allowance(deps.storage, \u0026owner_addr, \u0026info.sender, \u0026env.block, amount)?;\n\n    BALANCES.update(\n        deps.storage,\n        \u0026owner_addr,\n        |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e {\n            Ok(balance.unwrap_or_default().checked_sub(amount)?)\n        },\n    )?;\n    BALANCES.update(\n        deps.storage,\n        \u0026rcpt_addr,\n        |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e { Ok(balance.unwrap_or_default() + amount) },\n    )?;\n\n    let res = Response::new().add_attributes(vec![\n        attr(\"action\", \"transfer_from\"),\n        attr(\"from\", owner),\n        attr(\"to\", recipient),\n        attr(\"by\", info.sender),\n        attr(\"amount\", amount),\n    ]);\n    Ok(res)\n}\n\npub fn execute_burn_from(\n    deps: DepsMut,\n\n    env: Env,\n    info: MessageInfo,\n    owner: String,\n    amount: Uint128,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let owner_addr = deps.api.addr_validate(\u0026owner)?;\n\n    // deduct allowance before doing anything else have enough allowance\n    deduct_allowance(deps.storage, \u0026owner_addr, \u0026info.sender, \u0026env.block, amount)?;\n\n    // lower balance\n    BALANCES.update(\n        deps.storage,\n        \u0026owner_addr,\n        |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e {\n            Ok(balance.unwrap_or_default().checked_sub(amount)?)\n        },\n    )?;\n    // reduce total_supply\n    TOKEN_INFO.update(deps.storage, |mut meta| -\u003e StdResult\u003c_\u003e {\n        meta.total_supply = meta.total_supply.checked_sub(amount)?;\n        Ok(meta)\n    })?;\n\n    let res = Response::new().add_attributes(vec![\n        attr(\"action\", \"burn_from\"),\n        attr(\"from\", owner),\n        attr(\"by\", info.sender),\n        attr(\"amount\", amount),\n    ]);\n    Ok(res)\n}\n\npub fn execute_send_from(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    owner: String,\n    contract: String,\n    amount: Uint128,\n    msg: Binary,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let rcpt_addr = deps.api.addr_validate(\u0026contract)?;\n    let owner_addr = deps.api.addr_validate(\u0026owner)?;\n\n    // deduct allowance before doing anything else have enough allowance\n    deduct_allowance(deps.storage, \u0026owner_addr, \u0026info.sender, \u0026env.block, amount)?;\n\n    // move the tokens to the contract\n    BALANCES.update(\n        deps.storage,\n        \u0026owner_addr,\n        |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e {\n            Ok(balance.unwrap_or_default().checked_sub(amount)?)\n        },\n    )?;\n    BALANCES.update(\n        deps.storage,\n        \u0026rcpt_addr,\n        |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e { Ok(balance.unwrap_or_default() + amount) },\n    )?;\n\n    let attrs = vec![\n        attr(\"action\", \"send_from\"),\n        attr(\"from\", \u0026owner),\n        attr(\"to\", \u0026contract),\n        attr(\"by\", \u0026info.sender),\n        attr(\"amount\", amount),\n    ];\n\n    // create a send message\n    let msg = Cw20ReceiveMsg {\n        sender: info.sender.into(),\n        amount,\n        msg,\n    }\n    .into_cosmos_msg(contract)?;\n\n    let res = Response::new().add_message(msg).add_attributes(attrs);\n    Ok(res)\n}\n\npub fn query_allowance(deps: Deps, owner: String, spender: String) -\u003e StdResult\u003cAllowanceResponse\u003e {\n    let owner_addr = deps.api.addr_validate(\u0026owner)?;\n    let spender_addr = deps.api.addr_validate(\u0026spender)?;\n    let allowance = ALLOWANCES\n        .may_load(deps.storage, (\u0026owner_addr, \u0026spender_addr))?\n        .unwrap_or_default();\n    Ok(allowance)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use cosmwasm_std::testing::{mock_dependencies_with_balance, mock_env, mock_info};\n    use cosmwasm_std::{coins, CosmosMsg, SubMsg, Timestamp, WasmMsg};\n    use cw20::{Cw20Coin, TokenInfoResponse};\n\n    use crate::contract::{execute, instantiate, query_balance, query_token_info};\n    use crate::msg::{ExecuteMsg, InstantiateMsg};\n\n    fn get_balance\u003cT: Into\u003cString\u003e\u003e(deps: Deps, address: T) -\u003e Uint128 {\n        query_balance(deps, address.into()).unwrap().balance\n    }\n\n    // this will set up the instantiation for other tests\n    fn do_instantiate\u003cT: Into\u003cString\u003e\u003e(\n        mut deps: DepsMut,\n        addr: T,\n        amount: Uint128,\n    ) -\u003e TokenInfoResponse {\n        let instantiate_msg = InstantiateMsg {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: addr.into(),\n                amount,\n            }],\n            mint: None,\n            marketing: None,\n        };\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n        instantiate(deps.branch(), env, info, instantiate_msg).unwrap();\n        query_token_info(deps.as_ref()).unwrap()\n    }\n\n    #[test]\n    fn increase_decrease_allowances() {\n        let mut deps = mock_dependencies_with_balance(\u0026coins(2, \"token\"));\n\n        let owner = String::from(\"addr0001\");\n        let spender = String::from(\"addr0002\");\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        do_instantiate(deps.as_mut(), owner.clone(), Uint128::new(12340000));\n\n        // no allowance to start\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        assert_eq!(allowance, AllowanceResponse::default());\n\n        // set allowance with height expiration\n        let allow1 = Uint128::new(7777);\n        let expires = Expiration::AtHeight(5432);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: allow1,\n            expires: Some(expires),\n        };\n        execute(deps.as_mut(), env.clone(), info.clone(), msg).unwrap();\n\n        // ensure it looks good\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        assert_eq!(\n            allowance,\n            AllowanceResponse {\n                allowance: allow1,\n                expires\n            }\n        );\n\n        // decrease it a bit with no expire set - stays the same\n        let lower = Uint128::new(4444);\n        let allow2 = allow1.checked_sub(lower).unwrap();\n        let msg = ExecuteMsg::DecreaseAllowance {\n            spender: spender.clone(),\n            amount: lower,\n            expires: None,\n        };\n        execute(deps.as_mut(), env.clone(), info.clone(), msg).unwrap();\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        assert_eq!(\n            allowance,\n            AllowanceResponse {\n                allowance: allow2,\n                expires\n            }\n        );\n\n        // increase it some more and override the expires\n        let raise = Uint128::new(87654);\n        let allow3 = allow2 + raise;\n        let new_expire = Expiration::AtTime(Timestamp::from_seconds(8888888888));\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: raise,\n            expires: Some(new_expire),\n        };\n        execute(deps.as_mut(), env.clone(), info.clone(), msg).unwrap();\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        assert_eq!(\n            allowance,\n            AllowanceResponse {\n                allowance: allow3,\n                expires: new_expire\n            }\n        );\n\n        // decrease it below 0\n        let msg = ExecuteMsg::DecreaseAllowance {\n            spender: spender.clone(),\n            amount: Uint128::new(99988647623876347),\n            expires: None,\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n        let allowance = query_allowance(deps.as_ref(), owner, spender).unwrap();\n        assert_eq!(allowance, AllowanceResponse::default());\n    }\n\n    #[test]\n    fn allowances_independent() {\n        let mut deps = mock_dependencies_with_balance(\u0026coins(2, \"token\"));\n\n        let owner = String::from(\"addr0001\");\n        let spender = String::from(\"addr0002\");\n        let spender2 = String::from(\"addr0003\");\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        do_instantiate(deps.as_mut(), \u0026owner, Uint128::new(12340000));\n\n        // no allowance to start\n        assert_eq!(\n            query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap(),\n            AllowanceResponse::default()\n        );\n        assert_eq!(\n            query_allowance(deps.as_ref(), owner.clone(), spender2.clone()).unwrap(),\n            AllowanceResponse::default()\n        );\n        assert_eq!(\n            query_allowance(deps.as_ref(), spender.clone(), spender2.clone()).unwrap(),\n            AllowanceResponse::default()\n        );\n\n        // set allowance with height expiration\n        let allow1 = Uint128::new(7777);\n        let expires = Expiration::AtHeight(5432);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: allow1,\n            expires: Some(expires),\n        };\n        execute(deps.as_mut(), env.clone(), info.clone(), msg).unwrap();\n\n        // set other allowance with no expiration\n        let allow2 = Uint128::new(87654);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender2.clone(),\n            amount: allow2,\n            expires: None,\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // check they are proper\n        let expect_one = AllowanceResponse {\n            allowance: allow1,\n            expires,\n        };\n        let expect_two = AllowanceResponse {\n            allowance: allow2,\n            expires: Expiration::Never {},\n        };\n        assert_eq!(\n            query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap(),\n            expect_one\n        );\n        assert_eq!(\n            query_allowance(deps.as_ref(), owner.clone(), spender2.clone()).unwrap(),\n            expect_two\n        );\n        assert_eq!(\n            query_allowance(deps.as_ref(), spender.clone(), spender2.clone()).unwrap(),\n            AllowanceResponse::default()\n        );\n\n        // also allow spender -\u003e spender2 with no interference\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let allow3 = Uint128::new(1821);\n        let expires3 = Expiration::AtTime(Timestamp::from_seconds(3767626296));\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender2.clone(),\n            amount: allow3,\n            expires: Some(expires3),\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n        let expect_three = AllowanceResponse {\n            allowance: allow3,\n            expires: expires3,\n        };\n        assert_eq!(\n            query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap(),\n            expect_one\n        );\n        assert_eq!(\n            query_allowance(deps.as_ref(), owner, spender2.clone()).unwrap(),\n            expect_two\n        );\n        assert_eq!(\n            query_allowance(deps.as_ref(), spender, spender2).unwrap(),\n            expect_three\n        );\n    }\n\n    #[test]\n    fn no_self_allowance() {\n        let mut deps = mock_dependencies_with_balance(\u0026coins(2, \"token\"));\n\n        let owner = String::from(\"addr0001\");\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        do_instantiate(deps.as_mut(), \u0026owner, Uint128::new(12340000));\n\n        // self-allowance\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: owner.clone(),\n            amount: Uint128::new(7777),\n            expires: None,\n        };\n        let err = execute(deps.as_mut(), env.clone(), info.clone(), msg).unwrap_err();\n        assert_eq!(err, ContractError::CannotSetOwnAccount {});\n\n        // decrease self-allowance\n        let msg = ExecuteMsg::DecreaseAllowance {\n            spender: owner,\n            amount: Uint128::new(7777),\n            expires: None,\n        };\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert_eq!(err, ContractError::CannotSetOwnAccount {});\n    }\n\n    #[test]\n    fn transfer_from_respects_limits() {\n        let mut deps = mock_dependencies_with_balance(\u0026[]);\n        let owner = String::from(\"addr0001\");\n        let spender = String::from(\"addr0002\");\n        let rcpt = String::from(\"addr0003\");\n\n        let start = Uint128::new(999999);\n        do_instantiate(deps.as_mut(), \u0026owner, start);\n\n        // provide an allowance\n        let allow1 = Uint128::new(77777);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: allow1,\n            expires: None,\n        };\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // valid transfer of part of the allowance\n        let transfer = Uint128::new(44444);\n        let msg = ExecuteMsg::TransferFrom {\n            owner: owner.clone(),\n            recipient: rcpt.clone(),\n            amount: transfer,\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let res = execute(deps.as_mut(), env, info, msg).unwrap();\n        assert_eq!(res.attributes[0], attr(\"action\", \"transfer_from\"));\n\n        // make sure money arrived\n        assert_eq!(\n            get_balance(deps.as_ref(), owner.clone()),\n            start.checked_sub(transfer).unwrap()\n        );\n        assert_eq!(get_balance(deps.as_ref(), rcpt.clone()), transfer);\n\n        // ensure it looks good\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        let expect = AllowanceResponse {\n            allowance: allow1.checked_sub(transfer).unwrap(),\n            expires: Expiration::Never {},\n        };\n        assert_eq!(expect, allowance);\n\n        // cannot send more than the allowance\n        let msg = ExecuteMsg::TransferFrom {\n            owner: owner.clone(),\n            recipient: rcpt.clone(),\n            amount: Uint128::new(33443),\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert!(matches!(err, ContractError::Std(StdError::Overflow { .. })));\n\n        // let us increase limit, but set the expiration (default env height is 12_345)\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: Uint128::new(1000),\n            expires: Some(Expiration::AtHeight(env.block.height)),\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // we should now get the expiration error\n        let msg = ExecuteMsg::TransferFrom {\n            owner,\n            recipient: rcpt,\n            amount: Uint128::new(33443),\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert_eq!(err, ContractError::Expired {});\n    }\n\n    #[test]\n    fn burn_from_respects_limits() {\n        let mut deps = mock_dependencies_with_balance(\u0026[]);\n        let owner = String::from(\"addr0001\");\n        let spender = String::from(\"addr0002\");\n\n        let start = Uint128::new(999999);\n        do_instantiate(deps.as_mut(), \u0026owner, start);\n\n        // provide an allowance\n        let allow1 = Uint128::new(77777);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: allow1,\n            expires: None,\n        };\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // valid burn of part of the allowance\n        let transfer = Uint128::new(44444);\n        let msg = ExecuteMsg::BurnFrom {\n            owner: owner.clone(),\n            amount: transfer,\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let res = execute(deps.as_mut(), env, info, msg).unwrap();\n        assert_eq!(res.attributes[0], attr(\"action\", \"burn_from\"));\n\n        // make sure money burnt\n        assert_eq!(\n            get_balance(deps.as_ref(), owner.clone()),\n            start.checked_sub(transfer).unwrap()\n        );\n\n        // ensure it looks good\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        let expect = AllowanceResponse {\n            allowance: allow1.checked_sub(transfer).unwrap(),\n            expires: Expiration::Never {},\n        };\n        assert_eq!(expect, allowance);\n\n        // cannot burn more than the allowance\n        let msg = ExecuteMsg::BurnFrom {\n            owner: owner.clone(),\n            amount: Uint128::new(33443),\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert!(matches!(err, ContractError::Std(StdError::Overflow { .. })));\n\n        // let us increase limit, but set the expiration (default env height is 12_345)\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: Uint128::new(1000),\n            expires: Some(Expiration::AtHeight(env.block.height)),\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // we should now get the expiration error\n        let msg = ExecuteMsg::BurnFrom {\n            owner,\n            amount: Uint128::new(33443),\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert_eq!(err, ContractError::Expired {});\n    }\n\n    #[test]\n    fn send_from_respects_limits() {\n        let mut deps = mock_dependencies_with_balance(\u0026[]);\n        let owner = String::from(\"addr0001\");\n        let spender = String::from(\"addr0002\");\n        let contract = String::from(\"cool-dex\");\n        let send_msg = Binary::from(r#\"{\"some\":123}\"#.as_bytes());\n\n        let start = Uint128::new(999999);\n        do_instantiate(deps.as_mut(), \u0026owner, start);\n\n        // provide an allowance\n        let allow1 = Uint128::new(77777);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: allow1,\n            expires: None,\n        };\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // valid send of part of the allowance\n        let transfer = Uint128::new(44444);\n        let msg = ExecuteMsg::SendFrom {\n            owner: owner.clone(),\n            amount: transfer,\n            contract: contract.clone(),\n            msg: send_msg.clone(),\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let res = execute(deps.as_mut(), env, info, msg).unwrap();\n        assert_eq!(res.attributes[0], attr(\"action\", \"send_from\"));\n        assert_eq!(1, res.messages.len());\n\n        // we record this as sent by the one who requested, not the one who was paying\n        let binary_msg = Cw20ReceiveMsg {\n            sender: spender.clone(),\n            amount: transfer,\n            msg: send_msg.clone(),\n        }\n        .into_binary()\n        .unwrap();\n        assert_eq!(\n            res.messages[0],\n            SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: contract.clone(),\n                msg: binary_msg,\n                funds: vec![],\n            }))\n        );\n\n        // make sure money sent\n        assert_eq!(\n            get_balance(deps.as_ref(), owner.clone()),\n            start.checked_sub(transfer).unwrap()\n        );\n        assert_eq!(get_balance(deps.as_ref(), contract.clone()), transfer);\n\n        // ensure it looks good\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        let expect = AllowanceResponse {\n            allowance: allow1.checked_sub(transfer).unwrap(),\n            expires: Expiration::Never {},\n        };\n        assert_eq!(expect, allowance);\n\n        // cannot send more than the allowance\n        let msg = ExecuteMsg::SendFrom {\n            owner: owner.clone(),\n            amount: Uint128::new(33443),\n            contract: contract.clone(),\n            msg: send_msg.clone(),\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert!(matches!(err, ContractError::Std(StdError::Overflow { .. })));\n\n        // let us increase limit, but set the expiration to current block (expired)\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: Uint128::new(1000),\n            expires: Some(Expiration::AtHeight(env.block.height)),\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // we should now get the expiration error\n        let msg = ExecuteMsg::SendFrom {\n            owner,\n            amount: Uint128::new(33443),\n            contract,\n            msg: send_msg,\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert_eq!(err, ContractError::Expired {});\n    }\n}\n","traces":[{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":9},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","ailiq_token","src","contract.rs"],"content":"use anyhow::{anyhow, Result};\n#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\nuse cosmwasm_std::{\n    from_binary, to_binary, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult, Uint128,\n};\n\nuse cw20_base::allowances::{\n    execute_burn_from, execute_decrease_allowance, execute_increase_allowance, execute_send_from,\n    execute_transfer_from, query_allowance,\n};\nuse cw20_base::contract::{\n    execute_burn, execute_send, execute_transfer, execute_update_marketing, execute_upload_logo,\n};\nuse cw20_base::contract::{\n    query_balance, query_download_logo, query_marketing_info, query_minter, query_token_info,\n};\n\nuse cw20_base::enumerable::{query_all_accounts, query_all_allowances};\n\nuse cw20_base::msg::InstantiateMsg as CW20InstantiateMsg;\nuse cw_4626::msg::{ExecuteMsg, InstantiateMsg};\nuse cw_4626::query::QueryMsg;\nuse cw_4626::state::{AssetInfo, State, STATE};\n\nuse crate::moving::{_repay, borrow, deposit, mint, redeem, repay, withdraw};\nuse crate::query::{\n    convert_to_assets, convert_to_shares, max_deposit, max_mint, max_redeem, max_withdraw,\n    preview_deposit, preview_mint, preview_redeem, preview_withdraw, query_asset,\n    query_total_assets,\n};\n\nuse crate::error::ContractError;\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e Result\u003cResponse\u003e {\n    // We start by initating the state of the contract\n    let borrower = msg\n        .borrower\n        .map(|x| deps.api.addr_validate(\u0026x))\n        .transpose()?;\n    let initial_state = State {\n        underlying_asset: msg.asset,\n        total_underlying_asset_supply: Uint128::zero(),\n        total_assets_borrowed: Uint128::zero(),\n        borrower,\n    };\n\n    STATE.save(deps.storage, \u0026initial_state)?;\n\n    let base_instantiate_msg = CW20InstantiateMsg {\n        name: msg.name,\n        symbol: msg.symbol,\n        decimals: msg.decimals,\n        initial_balances: vec![],\n        mint: msg.mint,\n        marketing: msg.marketing,\n    };\n\n    cw20_base::contract::instantiate(deps, env, info, base_instantiate_msg).map_err(|x| anyhow!(x))\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg) -\u003e Result\u003cResponse\u003e {\n    match msg {\n        ExecuteMsg::Transfer { recipient, amount } =\u003e {\n            execute_transfer(deps, env, info, recipient, amount).map_err(|x| anyhow!(x))\n        }\n        ExecuteMsg::Burn { amount } =\u003e {\n            execute_burn(deps, env, info, amount).map_err(|x| anyhow!(x))\n        }\n        ExecuteMsg::Send {\n            contract,\n            amount,\n            msg,\n        } =\u003e execute_send(deps, env, info, contract, amount, msg).map_err(|x| anyhow!(x)),\n        ExecuteMsg::IncreaseAllowance {\n            spender,\n            amount,\n            expires,\n        } =\u003e execute_increase_allowance(deps, env, info, spender, amount, expires)\n            .map_err(|x| anyhow!(x)),\n        ExecuteMsg::DecreaseAllowance {\n            spender,\n            amount,\n            expires,\n        } =\u003e execute_decrease_allowance(deps, env, info, spender, amount, expires)\n            .map_err(|x| anyhow!(x)),\n        ExecuteMsg::TransferFrom {\n            owner,\n            recipient,\n            amount,\n        } =\u003e {\n            execute_transfer_from(deps, env, info, owner, recipient, amount).map_err(|x| anyhow!(x))\n        }\n        ExecuteMsg::BurnFrom { owner, amount } =\u003e {\n            execute_burn_from(deps, env, info, owner, amount).map_err(|x| anyhow!(x))\n        }\n        ExecuteMsg::SendFrom {\n            owner,\n            contract,\n            amount,\n            msg,\n        } =\u003e {\n            execute_send_from(deps, env, info, owner, contract, amount, msg).map_err(|x| anyhow!(x))\n        }\n        ExecuteMsg::UpdateMarketing {\n            project,\n            description,\n            marketing,\n        } =\u003e execute_update_marketing(deps, env, info, project, description, marketing)\n            .map_err(|x| anyhow!(x)),\n        ExecuteMsg::UploadLogo(logo) =\u003e {\n            execute_upload_logo(deps, env, info, logo).map_err(|x| anyhow!(x))\n        }\n\n        // CW4626 specific functions\n        ExecuteMsg::Deposit { assets, receiver } =\u003e {\n            deposit(deps, env, info, receiver, assets).map_err(|x| anyhow!(x))\n        }\n        ExecuteMsg::Mint { shares, receiver } =\u003e {\n            mint(deps, env, info, receiver, shares).map_err(|x| anyhow!(x))\n        }\n        ExecuteMsg::Withdraw {\n            assets,\n            owner,\n            receiver,\n        } =\u003e withdraw(deps, env, info, owner, receiver, assets).map_err(|x| anyhow!(x)),\n        ExecuteMsg::Redeem {\n            shares,\n            owner,\n            receiver,\n        } =\u003e redeem(deps, env, info, owner, receiver, shares).map_err(|x| anyhow!(x)),\n        ExecuteMsg::Borrow { assets, receiver } =\u003e {\n            borrow(deps, env, info, receiver, assets).map_err(|x| anyhow!(x))\n        }\n        ExecuteMsg::Repay { owner, assets } =\u003e {\n            repay(deps, env, info, owner, assets).map_err(|x| anyhow!(x))\n        }\n        ExecuteMsg::Receive {\n            sender,\n            amount,\n            msg,\n        } =\u003e receive_assets(deps, env, info, sender, amount, msg).map_err(|x| anyhow!(x)),\n    }\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, env: Env, msg: QueryMsg) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::Balance { address } =\u003e to_binary(\u0026query_balance(deps, address)?),\n        QueryMsg::TokenInfo {} =\u003e to_binary(\u0026query_token_info(deps)?),\n        QueryMsg::Minter {} =\u003e to_binary(\u0026query_minter(deps)?),\n        QueryMsg::Allowance { owner, spender } =\u003e {\n            to_binary(\u0026query_allowance(deps, owner, spender)?)\n        }\n        QueryMsg::AllAllowances {\n            owner,\n            start_after,\n            limit,\n        } =\u003e to_binary(\u0026query_all_allowances(deps, owner, start_after, limit)?),\n        QueryMsg::AllAccounts { start_after, limit } =\u003e {\n            to_binary(\u0026query_all_accounts(deps, start_after, limit)?)\n        }\n        QueryMsg::MarketingInfo {} =\u003e to_binary(\u0026query_marketing_info(deps)?),\n        QueryMsg::DownloadLogo {} =\u003e to_binary(\u0026query_download_logo(deps)?),\n\n        // 4626 specific functions\n        QueryMsg::Asset {} =\u003e to_binary(\u0026query_asset(deps)?),\n        QueryMsg::TotalAssets {} =\u003e to_binary(\u0026query_total_assets(deps)?),\n        QueryMsg::ConvertToShares { assets } =\u003e {\n            to_binary(\u0026convert_to_shares(deps, env, assets, None)?)\n        }\n        QueryMsg::ConvertToAssets { shares } =\u003e {\n            to_binary(\u0026convert_to_assets(deps, env, shares, None)?)\n        }\n        QueryMsg::MaxDeposit { receiver } =\u003e to_binary(\u0026max_deposit(deps, env, receiver)?),\n        QueryMsg::PreviewDeposit { assets } =\u003e to_binary(\u0026preview_deposit(deps, env, assets)?),\n        QueryMsg::MaxMint { receiver } =\u003e to_binary(\u0026max_mint(deps, env, receiver)?),\n        QueryMsg::PreviewMint { shares } =\u003e to_binary(\u0026preview_mint(deps, env, shares)?),\n        QueryMsg::MaxWithdraw { owner } =\u003e to_binary(\u0026max_withdraw(deps, env, owner)?),\n        QueryMsg::PreviewWithdraw { assets } =\u003e to_binary(\u0026preview_withdraw(deps, env, assets)?),\n        QueryMsg::MaxRedeem { owner } =\u003e to_binary(\u0026max_redeem(deps, env, owner)?),\n        QueryMsg::PreviewRedeem { shares } =\u003e to_binary(\u0026preview_redeem(deps, env, shares)?),\n    }\n}\n\npub fn receive_assets(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    _sender: String,\n    amount: Uint128,\n    msg: Binary,\n) -\u003e Result\u003cResponse\u003e {\n    match from_binary(\u0026msg)? {\n        ExecuteMsg::Repay { assets, .. } =\u003e {\n            let state = STATE.load(deps.storage)?;\n            match state.underlying_asset {\n                AssetInfo::Cw20(x) =\u003e {\n                    if x != info.sender {\n                        return Err(anyhow!(ContractError::WrongAssetDeposited {\n                            sent: info.sender.to_string(),\n                            expected: x\n                        },));\n                    } else if amount != assets {\n                        return Err(anyhow!(ContractError::InsufficientAssetDeposited {\n                            sent: amount,\n                            expected: assets\n                        },));\n                    }\n                    let debt_repaid = _repay(deps.storage, amount)?;\n\n                    Ok(Response::new()\n                        .add_attribute(\"action\", \"repay\")\n                        .add_attribute(\"caller\", info.sender)\n                        .add_attribute(\"assets\", assets.to_string())\n                        .add_attribute(\"debt_repaid\", debt_repaid.to_string())\n                        .add_attribute(\"raw_deposit\", (assets - debt_repaid).to_string()))\n                }\n                AssetInfo::Coin(x) =\u003e Err(anyhow!(ContractError::WrongAssetDeposited {\n                    sent: info.sender.to_string(),\n                    expected: x\n                },)),\n            }\n        }\n        _ =\u003e Err(anyhow!(ContractError::InvalidMessage {})),\n    }\n}\n\n#[cfg(test)]\npub mod tests {\n    use super::*;\n    use crate::contract::instantiate;\n    use crate::query::convert_to_assets;\n    use cosmwasm_std::testing::{\n        mock_dependencies, mock_env, mock_info, MockQuerier, MOCK_CONTRACT_ADDR,\n    };\n    use cosmwasm_std::{coins, from_binary, BankMsg, Coin, DepsMut};\n    use cw20::BalanceResponse;\n    use cw_4626::msg::InstantiateMsg;\n    use cw_4626::state::AssetInfo;\n\n    use rand::Rng;\n\n    fn init_helper(deps: DepsMut) {\n        let instantiate_msg = InstantiateMsg {\n            name: \"Iliq treasury token\".to_string(),\n            symbol: \"ailiq\".to_string(),\n            decimals: 6u8,\n            initial_balances: vec![],\n            mint: None,\n            marketing: None,\n            asset: AssetInfo::Coin(\"uluna\".to_string()),\n            borrower: Some(\"borrower\".to_string()),\n        };\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n\n        instantiate(deps, env, info, instantiate_msg).unwrap();\n    }\n\n    fn deposit_helper(\n        deps: DepsMut,\n        address: \u0026str,\n        receiver: \u0026str,\n        assets: Vec\u003cCoin\u003e,\n    ) -\u003e Result\u003cResponse\u003e {\n        let info = mock_info(address, \u0026assets);\n        let env = mock_env();\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::Deposit {\n                assets: assets[0].amount,\n                receiver: receiver.to_string(),\n            },\n        )\n    }\n\n    fn mint_helper(\n        deps: DepsMut,\n        address: \u0026str,\n        receiver: \u0026str,\n        assets: Vec\u003cCoin\u003e,\n        shares: Uint128,\n    ) -\u003e Result\u003cResponse\u003e {\n        let info = mock_info(address, \u0026assets);\n        let env = mock_env();\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::Mint {\n                shares,\n                receiver: receiver.to_string(),\n            },\n        )\n    }\n\n    fn withdraw_helper(\n        deps: DepsMut,\n        address: \u0026str,\n        receiver: \u0026str,\n        assets: u128,\n    ) -\u003e Result\u003cResponse\u003e {\n        let info = mock_info(address, \u0026[]);\n        let env = mock_env();\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::Withdraw {\n                assets: Uint128::from(assets),\n                owner: address.to_string(),\n                receiver: receiver.to_string(),\n            },\n        )\n    }\n\n    fn redeem_helper(\n        deps: DepsMut,\n        address: \u0026str,\n        receiver: \u0026str,\n        shares: Uint128,\n    ) -\u003e Result\u003cResponse\u003e {\n        let info = mock_info(address, \u0026[]);\n        let env = mock_env();\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::Redeem {\n                shares,\n                owner: address.to_string(),\n                receiver: receiver.to_string(),\n            },\n        )\n    }\n\n    fn burn_helper(deps: DepsMut, address: \u0026str, assets: u128) -\u003e Result\u003cResponse\u003e {\n        let env = mock_env();\n        let info = mock_info(address, \u0026[]);\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::Burn {\n                amount: Uint128::from(assets),\n            },\n        )\n    }\n\n    fn equal_or_not_far_below(init: Uint128, fin: Uint128) -\u003e bool {\n        (init == fin) || ((init \u003e= fin) \u0026\u0026 (init \u003c= fin + Uint128::from(2u128)))\n    }\n\n    fn get_share_balance(deps: Deps, env: Env, address: String) -\u003e Uint128 {\n        // We need to check that in that specific case of a unique depositor, the underlying funds are unchanged\n        let balance = query(deps, env, QueryMsg::Balance { address }).unwrap();\n\n        from_binary::\u003cBalanceResponse\u003e(\u0026balance).unwrap().balance\n    }\n\n    fn get_asset_balance(deps: Deps, env: Env, address: String) -\u003e Uint128 {\n        // We need to check that in that specific case of a unique depositor, the underlying funds are unchanged\n        let share_balance = get_share_balance(deps, env.clone(), address);\n        convert_to_assets(deps, env, share_balance, None).unwrap()\n    }\n\n    #[test]\n    fn test_deposit_sanity() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n\n        let mut rng = rand::thread_rng();\n        let assets = rng.gen::\u003cu128\u003e();\n        let res =\n            deposit_helper(deps.as_mut(), \"depositor\", \"nicoco\", coins(assets, \"uluna\")).unwrap();\n\n        assert_eq!(\n            res,\n            Response::new()\n                .add_attribute(\"action\", \"deposit\")\n                .add_attribute(\"caller\", \"depositor\")\n                .add_attribute(\"owner\", \"nicoco\")\n                .add_attribute(\"assets\", assets.to_string())\n                .add_attribute(\"shares\", assets.to_string())\n        );\n\n        // Now we check the internal to be sure it updated\n        assert_eq!(\n            query_balance(deps.as_ref(), \"nicoco\".to_string()).unwrap(),\n            BalanceResponse {\n                balance: Uint128::from(assets)\n            }\n        );\n    }\n\n    #[test]\n    fn test_multiple_swaps_sanity() {\n        let mut deps = mock_dependencies();\n        let env = mock_env();\n        init_helper(deps.as_mut());\n\n        let mut rng = rand::thread_rng();\n        let assets1 = rng.gen_range(0u128..1000000u128);\n        // The funds are sent, we have to update the internal fund balance\n        deps.querier = MockQuerier::new(\u0026[(MOCK_CONTRACT_ADDR, \u0026coins(assets1, \"uluna\"))]);\n        deposit_helper(\n            deps.as_mut(),\n            \"depositor\",\n            \"nicoco\",\n            coins(assets1, \"uluna\"),\n        )\n        .unwrap();\n\n        // We burn some of the tokens to make the ratio increase\n        burn_helper(deps.as_mut(), \"nicoco\", assets1 / 2u128).unwrap();\n\n        // We need to check that in that specific case of a unique depositor, the underlying funds are unchanged\n\n        let asset_balance = get_asset_balance(deps.as_ref(), env.clone(), \"nicoco\".to_string());\n        assert!(asset_balance.u128() \u003c= assets1);\n\n        // We check it's impossible (on those 10_000 examples) to mint some free tokens\n        for _i in 0..5_000 {\n            let initial_assets = Uint128::from(rng.gen_range(0u128..1000000u128));\n            let shares =\n                convert_to_shares(deps.as_ref(), env.clone(), initial_assets, None).unwrap();\n            let final_assets = convert_to_assets(deps.as_ref(), env.clone(), shares, None).unwrap();\n            assert!(equal_or_not_far_below(initial_assets, final_assets));\n        }\n\n        for _i in 0..5_000 {\n            let initial_shares = Uint128::from(rng.gen_range(0u128..1000000u128));\n            let assets =\n                convert_to_assets(deps.as_ref(), env.clone(), initial_shares, None).unwrap();\n            let final_shares = convert_to_shares(deps.as_ref(), env.clone(), assets, None).unwrap();\n            assert!(equal_or_not_far_below(initial_shares, final_shares));\n        }\n    }\n\n    #[test]\n    fn test_multiple_deposits_sanity() {\n        let mut deps = mock_dependencies();\n        let env = mock_env();\n        init_helper(deps.as_mut());\n\n        let mut rng = rand::thread_rng();\n        let assets1 = rng.gen_range(0u128..1000000u128);\n        // The funds are sent, we have to update the internal fund balance\n        deps.querier = MockQuerier::new(\u0026[(MOCK_CONTRACT_ADDR, \u0026coins(assets1, \"uluna\"))]);\n        deposit_helper(\n            deps.as_mut(),\n            \"depositor\",\n            \"nicoco\",\n            coins(assets1, \"uluna\"),\n        )\n        .unwrap();\n\n        // We burn some of the tokens to make the ratio increase\n        burn_helper(deps.as_mut(), \"nicoco\", assets1 / 2u128).unwrap();\n\n        let assets2 = rng.gen_range(0u128..1000000u128);\n        // The funds are sent, we have to update the internal fund balance\n        deps.querier =\n            MockQuerier::new(\u0026[(MOCK_CONTRACT_ADDR, \u0026coins(assets1 + assets2, \"uluna\"))]);\n        deposit_helper(\n            deps.as_mut(),\n            \"depositor\",\n            \"nicoco\",\n            coins(assets2, \"uluna\"),\n        )\n        .unwrap();\n\n        let asset_balance = get_asset_balance(deps.as_ref(), env, \"nicoco\".to_string());\n        assert!(\n            equal_or_not_far_below(Uint128::from(assets1 + assets2), asset_balance),\n            \"first: {:?}, second: {:?}\",\n            asset_balance,\n            assets1 + assets2\n        );\n    }\n\n    #[test]\n    fn test_simple_withdraw_sanity() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n\n        let mut rng = rand::thread_rng();\n        let assets1 = rng.gen_range(0u128..1000000u128);\n        // The funds are sent, we have to update the internal fund balance\n        deps.querier = MockQuerier::new(\u0026[(MOCK_CONTRACT_ADDR, \u0026coins(assets1, \"uluna\"))]);\n        deposit_helper(\n            deps.as_mut(),\n            \"depositor\",\n            \"nicoco\",\n            coins(assets1, \"uluna\"),\n        )\n        .unwrap();\n        let res = withdraw_helper(deps.as_mut(), \"nicoco\", \"depositor\", assets1).unwrap();\n\n        assert_eq!(\n            res,\n            Response::new()\n                .add_message(BankMsg::Send {\n                    to_address: \"depositor\".to_string(),\n                    amount: coins(assets1, \"uluna\")\n                })\n                .add_attribute(\"action\", \"withdraw\")\n                .add_attribute(\"caller\", \"nicoco\")\n                .add_attribute(\"receiver\", \"depositor\")\n                .add_attribute(\"owner\", \"nicoco\")\n                .add_attribute(\"assets\", assets1.to_string())\n                .add_attribute(\"shares\", assets1.to_string())\n        );\n    }\n\n    #[test]\n    fn test_mint_sanity() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n\n        let mut rng = rand::thread_rng();\n        let shares = rng.gen::\u003cu128\u003e();\n        let res = mint_helper(\n            deps.as_mut(),\n            \"depositor\",\n            \"nicoco\",\n            coins(shares, \"uluna\"),\n            Uint128::from(shares),\n        )\n        .unwrap();\n\n        assert_eq!(\n            res,\n            Response::new()\n                .add_attribute(\"action\", \"mint\")\n                .add_attribute(\"caller\", \"depositor\")\n                .add_attribute(\"owner\", \"nicoco\")\n                .add_attribute(\"assets\", shares.to_string())\n                .add_attribute(\"shares\", shares.to_string())\n        );\n\n        // Now we check the internal to be sure it updated\n        assert_eq!(\n            query_balance(deps.as_ref(), \"nicoco\".to_string()).unwrap(),\n            BalanceResponse {\n                balance: Uint128::from(shares)\n            }\n        );\n    }\n\n    #[test]\n    fn test_mint_give_back_sanity() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n\n        let mut rng = rand::thread_rng();\n        let shares = rng.gen::\u003cu128\u003e();\n        let supplemental_assets = 69238u128;\n        let res = mint_helper(\n            deps.as_mut(),\n            \"depositor\",\n            \"nicoco\",\n            coins(shares + supplemental_assets, \"uluna\"),\n            Uint128::from(shares),\n        )\n        .unwrap();\n\n        assert_eq!(\n            res,\n            Response::new()\n                .add_message(BankMsg::Send {\n                    to_address: \"nicoco\".to_string(),\n                    amount: coins(supplemental_assets, \"uluna\")\n                })\n                .add_attribute(\"action\", \"mint\")\n                .add_attribute(\"caller\", \"depositor\")\n                .add_attribute(\"owner\", \"nicoco\")\n                .add_attribute(\"assets\", shares.to_string())\n                .add_attribute(\"shares\", shares.to_string())\n        );\n\n        // Now we check the internal to be sure it updated\n        assert_eq!(\n            query_balance(deps.as_ref(), \"nicoco\".to_string()).unwrap(),\n            BalanceResponse {\n                balance: Uint128::from(shares)\n            }\n        );\n    }\n\n    #[test]\n    fn test_multiple_swaps_after_mint_sanity() {\n        let mut deps = mock_dependencies();\n        let env = mock_env();\n        init_helper(deps.as_mut());\n\n        let mut rng = rand::thread_rng();\n        let assets1 = rng.gen_range(0u128..1000000u128);\n        // The funds are sent, we have to update the internal fund balance\n        deps.querier = MockQuerier::new(\u0026[(MOCK_CONTRACT_ADDR, \u0026coins(assets1, \"uluna\"))]);\n        mint_helper(\n            deps.as_mut(),\n            \"depositor\",\n            \"nicoco\",\n            coins(assets1, \"uluna\"),\n            Uint128::from(assets1),\n        )\n        .unwrap();\n\n        // We burn some of the tokens to make the ratio increase\n        burn_helper(deps.as_mut(), \"nicoco\", assets1 / 2u128).unwrap();\n\n        // We need to check that in that specific case of a unique depositor, the underlying funds are unchanged\n\n        let asset_balance = get_asset_balance(deps.as_ref(), env.clone(), \"nicoco\".to_string());\n        assert!(asset_balance \u003c= Uint128::from(assets1));\n\n        // We check it's impossible (on those 10_000 examples) to mint some free tokens\n        for _i in 0..5_000 {\n            let initial_assets = Uint128::from(rng.gen_range(0u128..1000000u128));\n            let shares =\n                convert_to_shares(deps.as_ref(), env.clone(), initial_assets, None).unwrap();\n            let final_assets = convert_to_assets(deps.as_ref(), env.clone(), shares, None).unwrap();\n            assert!(equal_or_not_far_below(initial_assets, final_assets));\n        }\n\n        for _i in 0..5_000 {\n            let initial_shares = Uint128::from(rng.gen_range(0u128..1000000u128));\n            let assets =\n                convert_to_assets(deps.as_ref(), env.clone(), initial_shares, None).unwrap();\n            let final_shares = convert_to_shares(deps.as_ref(), env.clone(), assets, None).unwrap();\n            assert!(equal_or_not_far_below(initial_shares, final_shares));\n        }\n    }\n\n    #[test]\n    fn test_multiple_mints_sanity() {\n        let mut deps = mock_dependencies();\n        let env = mock_env();\n        init_helper(deps.as_mut());\n\n        let mut rng = rand::thread_rng();\n        let assets1 = rng.gen_range(0u128..1000000u128);\n        // The funds are sent, we have to update the internal fund balance\n        deps.querier = MockQuerier::new(\u0026[(MOCK_CONTRACT_ADDR, \u0026coins(assets1, \"uluna\"))]);\n        mint_helper(\n            deps.as_mut(),\n            \"depositor\",\n            \"nicoco\",\n            coins(assets1, \"uluna\"),\n            Uint128::from(assets1),\n        )\n        .unwrap();\n\n        // We burn some of the tokens to make the ratio increase\n        burn_helper(deps.as_mut(), \"nicoco\", assets1 / 2u128).unwrap();\n\n        // We want to deposit at least some assets\n        let shares2 = rng.gen_range(0u128..1000000u128);\n        let assets2 = assets1 * shares2 / (assets1 - assets1 / 2);\n        println!(\"{:?} - {:?}\", shares2, assets2);\n\n        // The funds are sent, we have to update the internal fund balance\n        deps.querier =\n            MockQuerier::new(\u0026[(MOCK_CONTRACT_ADDR, \u0026coins(assets1 + assets2, \"uluna\"))]);\n        mint_helper(\n            deps.as_mut(),\n            \"depositor\",\n            \"nicoco\",\n            coins(assets2, \"uluna\"),\n            Uint128::from(shares2),\n        )\n        .unwrap();\n\n        let asset_balance = get_asset_balance(deps.as_ref(), env, \"nicoco\".to_string());\n        assert!(\n            equal_or_not_far_below(Uint128::from(assets1 + assets2), asset_balance),\n            \"first: {:?}, second: {:?}\",\n            asset_balance,\n            assets1 + assets2\n        );\n    }\n\n    #[test]\n    fn test_simple_redeem_sanity() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n\n        let mut rng = rand::thread_rng();\n        let assets1 = rng.gen_range(0u128..1000000u128);\n        // The funds are sent, we have to update the internal fund balance\n        deps.querier = MockQuerier::new(\u0026[(MOCK_CONTRACT_ADDR, \u0026coins(assets1, \"uluna\"))]);\n        mint_helper(\n            deps.as_mut(),\n            \"depositor\",\n            \"nicoco\",\n            coins(assets1, \"uluna\"),\n            Uint128::from(assets1),\n        )\n        .unwrap();\n        let res =\n            redeem_helper(deps.as_mut(), \"nicoco\", \"depositor\", Uint128::from(assets1)).unwrap();\n\n        assert_eq!(\n            res,\n            Response::new()\n                .add_message(BankMsg::Send {\n                    to_address: \"depositor\".to_string(),\n                    amount: coins(assets1, \"uluna\")\n                })\n                .add_attribute(\"action\", \"redeem\")\n                .add_attribute(\"caller\", \"nicoco\")\n                .add_attribute(\"receiver\", \"depositor\")\n                .add_attribute(\"owner\", \"nicoco\")\n                .add_attribute(\"assets\", assets1.to_string())\n                .add_attribute(\"shares\", assets1.to_string())\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","ailiq_token","src","enumerable.rs"],"content":"use cosmwasm_std::{Deps, Order, StdResult};\nuse cw20::{AllAccountsResponse, AllAllowancesResponse, AllowanceInfo};\n\nuse crate::state::{ALLOWANCES, BALANCES};\nuse cw_storage_plus::Bound;\n\n// settings for pagination\nconst MAX_LIMIT: u32 = 30;\nconst DEFAULT_LIMIT: u32 = 10;\n\npub fn query_all_allowances(\n    deps: Deps,\n    owner: String,\n    start_after: Option\u003cString\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e StdResult\u003cAllAllowancesResponse\u003e {\n    let owner_addr = deps.api.addr_validate(\u0026owner)?;\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n    let start = start_after.map(|s| Bound::ExclusiveRaw(s.into_bytes()));\n\n    let allowances = ALLOWANCES\n        .prefix(\u0026owner_addr)\n        .range(deps.storage, start, None, Order::Ascending)\n        .take(limit)\n        .map(|item| {\n            item.map(|(addr, allow)| AllowanceInfo {\n                spender: addr.into(),\n                allowance: allow.allowance,\n                expires: allow.expires,\n            })\n        })\n        .collect::\u003cStdResult\u003c_\u003e\u003e()?;\n    Ok(AllAllowancesResponse { allowances })\n}\n\npub fn query_all_accounts(\n    deps: Deps,\n    start_after: Option\u003cString\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e StdResult\u003cAllAccountsResponse\u003e {\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n    let start = start_after.map(|s| Bound::ExclusiveRaw(s.into()));\n\n    let accounts = BALANCES\n        .keys(deps.storage, start, None, Order::Ascending)\n        .take(limit)\n        .map(|item| item.map(Into::into))\n        .collect::\u003cStdResult\u003c_\u003e\u003e()?;\n\n    Ok(AllAccountsResponse { accounts })\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use cosmwasm_std::testing::{mock_dependencies_with_balance, mock_env, mock_info};\n    use cosmwasm_std::{coins, DepsMut, Uint128};\n    use cw20::{Cw20Coin, Expiration, TokenInfoResponse};\n\n    use crate::contract::{execute, instantiate, query_token_info};\n    use crate::msg::{ExecuteMsg, InstantiateMsg};\n\n    // this will set up the instantiation for other tests\n    fn do_instantiate(mut deps: DepsMut, addr: \u0026str, amount: Uint128) -\u003e TokenInfoResponse {\n        let instantiate_msg = InstantiateMsg {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: addr.into(),\n                amount,\n            }],\n            mint: None,\n            marketing: None,\n        };\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n        instantiate(deps.branch(), env, info, instantiate_msg).unwrap();\n        query_token_info(deps.as_ref()).unwrap()\n    }\n\n    #[test]\n    fn query_all_allowances_works() {\n        let mut deps = mock_dependencies_with_balance(\u0026coins(2, \"token\"));\n\n        let owner = String::from(\"owner\");\n        // these are in alphabetical order same than insert order\n        let spender1 = String::from(\"earlier\");\n        let spender2 = String::from(\"later\");\n\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        do_instantiate(deps.as_mut(), \u0026owner, Uint128::new(12340000));\n\n        // no allowance to start\n        let allowances = query_all_allowances(deps.as_ref(), owner.clone(), None, None).unwrap();\n        assert_eq!(allowances.allowances, vec![]);\n\n        // set allowance with height expiration\n        let allow1 = Uint128::new(7777);\n        let expires = Expiration::AtHeight(5432);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender1.clone(),\n            amount: allow1,\n            expires: Some(expires),\n        };\n        execute(deps.as_mut(), env.clone(), info.clone(), msg).unwrap();\n\n        // set allowance with no expiration\n        let allow2 = Uint128::new(54321);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender2.clone(),\n            amount: allow2,\n            expires: None,\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // query list gets 2\n        let allowances = query_all_allowances(deps.as_ref(), owner.clone(), None, None).unwrap();\n        assert_eq!(allowances.allowances.len(), 2);\n\n        // first one is spender1 (order of CanonicalAddr uncorrelated with String)\n        let allowances = query_all_allowances(deps.as_ref(), owner.clone(), None, Some(1)).unwrap();\n        assert_eq!(allowances.allowances.len(), 1);\n        let allow = \u0026allowances.allowances[0];\n        assert_eq!(\u0026allow.spender, \u0026spender1);\n        assert_eq!(\u0026allow.expires, \u0026expires);\n        assert_eq!(\u0026allow.allowance, \u0026allow1);\n\n        // next one is spender2\n        let allowances = query_all_allowances(\n            deps.as_ref(),\n            owner,\n            Some(allow.spender.clone()),\n            Some(10000),\n        )\n        .unwrap();\n        assert_eq!(allowances.allowances.len(), 1);\n        let allow = \u0026allowances.allowances[0];\n        assert_eq!(\u0026allow.spender, \u0026spender2);\n        assert_eq!(\u0026allow.expires, \u0026Expiration::Never {});\n        assert_eq!(\u0026allow.allowance, \u0026allow2);\n    }\n\n    #[test]\n    fn query_all_accounts_works() {\n        let mut deps = mock_dependencies_with_balance(\u0026coins(2, \"token\"));\n\n        // insert order and lexicographical order are different\n        let acct1 = String::from(\"acct01\");\n        let acct2 = String::from(\"zebra\");\n        let acct3 = String::from(\"nice\");\n        let acct4 = String::from(\"aaaardvark\");\n        let expected_order = [acct4.clone(), acct1.clone(), acct3.clone(), acct2.clone()];\n\n        do_instantiate(deps.as_mut(), \u0026acct1, Uint128::new(12340000));\n\n        // put money everywhere (to create balanaces)\n        let info = mock_info(acct1.as_ref(), \u0026[]);\n        let env = mock_env();\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            ExecuteMsg::Transfer {\n                recipient: acct2,\n                amount: Uint128::new(222222),\n            },\n        )\n        .unwrap();\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            ExecuteMsg::Transfer {\n                recipient: acct3,\n                amount: Uint128::new(333333),\n            },\n        )\n        .unwrap();\n        execute(\n            deps.as_mut(),\n            env,\n            info,\n            ExecuteMsg::Transfer {\n                recipient: acct4,\n                amount: Uint128::new(444444),\n            },\n        )\n        .unwrap();\n\n        // make sure we get the proper results\n        let accounts = query_all_accounts(deps.as_ref(), None, None).unwrap();\n        assert_eq!(accounts.accounts, expected_order);\n\n        // let's do pagination\n        let accounts = query_all_accounts(deps.as_ref(), None, Some(2)).unwrap();\n        assert_eq!(accounts.accounts, expected_order[0..2].to_vec());\n\n        let accounts =\n            query_all_accounts(deps.as_ref(), Some(accounts.accounts[1].clone()), Some(1)).unwrap();\n        assert_eq!(accounts.accounts, expected_order[2..3].to_vec());\n\n        let accounts =\n            query_all_accounts(deps.as_ref(), Some(accounts.accounts[0].clone()), Some(777))\n                .unwrap();\n        assert_eq!(accounts.accounts, expected_order[3..].to_vec());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","ailiq_token","src","error.rs"],"content":"use cosmwasm_std::{StdError, Uint128};\nuse thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized {},\n\n    #[error(\"Invalid Execute Message: lender contract\")]\n    InvalidMessage {},\n\n    #[error(\"Cannot set to own account\")]\n    CannotSetOwnAccount {},\n\n    #[error(\"Invalid zero amount\")]\n    InvalidZeroAmount {},\n\n    #[error(\"Allowance is expired\")]\n    Expired {},\n\n    #[error(\"No allowance for this account\")]\n    NoAllowance {},\n\n    #[error(\"Minting cannot exceed the cap\")]\n    CannotExceedCap {},\n\n    #[error(\"Logo binary data exceeds 5KB limit\")]\n    LogoTooBig {},\n\n    #[error(\"Invalid xml preamble for SVG\")]\n    InvalidXmlPreamble {},\n\n    #[error(\"Invalid png header\")]\n    InvalidPngHeader {},\n\n    #[error(\"Wrong asset deposited into the vault: sent {sent:?}, expected: {expected:?}\")]\n    WrongAssetDeposited { sent: String, expected: String },\n\n    #[error(\"Not enough assets deposited into the vault: sent {sent:?}, expected: {expected:?}\")]\n    InsufficientAssetDeposited { sent: Uint128, expected: Uint128 },\n\n    #[error(\"You can't deposit 0 assets\")]\n    ZeroDeposit {},\n\n    #[error(\"You can't burn assets right now, sorry (check your balance is high enough and you have the right to burn those tokens\")]\n    UnableToBurn {},\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","ailiq_token","src","lib.rs"],"content":"pub mod contract;\nmod error;\npub mod moving;\npub mod msg;\npub mod query;\n\npub use crate::error::ContractError;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","ailiq_token","src","moving.rs"],"content":"use crate::error::ContractError;\n#[cfg(not(feature = \"library\"))]\nuse anyhow::{anyhow, Result};\nuse cosmwasm_std::{\n    BankMsg, Coin, DepsMut, Env, MessageInfo, Response, StdResult, Storage, Uint128,\n};\nuse cw20::Cw20ExecuteMsg;\nuse cw20_base::allowances::execute_burn_from;\nuse cw20_base::contract::execute_burn;\nuse cw20_base::state::{BALANCES, TOKEN_INFO};\nuse cw_4626::state::{AssetInfo, State, STATE};\nuse utils::msg::into_cosmos_msg;\n\nuse crate::query::{convert_to_assets, convert_to_shares};\n\npub fn deposit(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    receiver: String,\n    deposit_amount: Uint128,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let state = STATE.load(deps.storage)?;\n\n    // Cannot deposit 0 amount\n    if deposit_amount == Uint128::zero() {\n        return Err(ContractError::ZeroDeposit {});\n    };\n    let mint_amount = convert_to_shares(\n        deps.as_ref(),\n        env.clone(),\n        deposit_amount,\n        info.funds.get(0).map(|x| x.amount),\n    )?;\n\n    // We mint new tokens to the receiver, in return for the deposit\n    _execute_mint(deps, receiver.clone(), mint_amount)?;\n\n    // Then we make sure the funds are correctly deposited to the contract\n    let res = Response::new();\n    let res = match state.underlying_asset {\n        AssetInfo::Coin(x) =\u003e {\n            // We need to check if the funds sent match the AssetInfo we have\n            if info.funds.len() != 1 || info.funds[0].denom != x {\n                return Err(ContractError::WrongAssetDeposited {\n                    sent: info.funds[0].denom.clone(),\n                    expected: x,\n                });\n            } else if deposit_amount != info.funds[0].amount {\n                return Err(ContractError::InsufficientAssetDeposited {\n                    sent: info.funds[0].amount,\n                    expected: deposit_amount,\n                });\n            }\n            res\n        }\n        AssetInfo::Cw20(x) =\u003e {\n            // If the vault relies on a CW20, we create a CW20 transferFrom message\n            res.add_message(into_cosmos_msg(\n                Cw20ExecuteMsg::TransferFrom {\n                    owner: info.sender.to_string(),\n                    recipient: env.contract.address.into(),\n                    amount: deposit_amount,\n                },\n                x,\n                None,\n            )?)\n        }\n    };\n\n    Ok(res\n        .add_attribute(\"action\", \"deposit\")\n        .add_attribute(\"caller\", info.sender)\n        .add_attribute(\"owner\", receiver)\n        .add_attribute(\"assets\", deposit_amount.to_string())\n        .add_attribute(\"shares\", mint_amount.to_string()))\n}\n\npub fn mint(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    receiver: String,\n    mint_amount: Uint128,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let state = STATE.load(deps.storage)?;\n\n    // Cannot deposit 0 amount\n    if mint_amount == Uint128::zero() {\n        return Err(ContractError::ZeroDeposit {});\n    }\n\n    // Computing the necessary deposit amount to get that number of shares\n    let deposit_amount = convert_to_assets(\n        deps.as_ref(),\n        env.clone(),\n        mint_amount,\n        info.funds.get(0).map(|x| x.amount),\n    )?;\n\n    // We mint new tokens to the receiver, in return for the deposit\n    _execute_mint(deps, receiver.clone(), mint_amount)?;\n\n    // Then we make sure the funds are correctly deposited to the contract\n    let res = Response::new();\n    let res = match state.underlying_asset {\n        AssetInfo::Coin(x) =\u003e {\n            // We need to check if the funds sent match the AssetInfo we have\n            if info.funds.len() != 1 || info.funds[0].denom != x {\n                return Err(ContractError::WrongAssetDeposited {\n                    sent: info.funds[0].denom.clone(),\n                    expected: x,\n                });\n            } else if deposit_amount \u003e info.funds[0].amount {\n                return Err(ContractError::InsufficientAssetDeposited {\n                    sent: info.funds[0].amount,\n                    expected: deposit_amount,\n                });\n            }\n            let cashback_amount = info.funds[0].amount - deposit_amount;\n            if cashback_amount \u003e Uint128::zero() {\n                res.add_message(BankMsg::Send {\n                    to_address: receiver.clone(),\n                    amount: vec![Coin {\n                        denom: info.funds[0].denom.clone(),\n                        amount: cashback_amount,\n                    }],\n                })\n            } else {\n                res\n            }\n        }\n        AssetInfo::Cw20(x) =\u003e {\n            // If the vault relies on a CW20, we create a CW20 transferFrom message\n            res.add_message(into_cosmos_msg(\n                Cw20ExecuteMsg::TransferFrom {\n                    owner: info.sender.to_string(),\n                    recipient: env.contract.address.into(),\n                    amount: deposit_amount,\n                },\n                x,\n                None,\n            )?)\n        }\n    };\n\n    Ok(res\n        .add_attribute(\"action\", \"mint\")\n        .add_attribute(\"caller\", info.sender)\n        .add_attribute(\"owner\", receiver)\n        .add_attribute(\"assets\", deposit_amount.to_string())\n        .add_attribute(\"shares\", mint_amount.to_string()))\n}\n\npub fn _add_asset_transfer_message(\n    state: \u0026State,\n    res: Response,\n    receiver: String,\n    assets: Uint128,\n) -\u003e Result\u003cResponse\u003e {\n    Ok(match state.underlying_asset.clone() {\n        AssetInfo::Coin(x) =\u003e res.add_message(BankMsg::Send {\n            to_address: receiver,\n            amount: vec![Coin {\n                denom: x,\n                amount: assets,\n            }],\n        }),\n        AssetInfo::Cw20(x) =\u003e {\n            // If the vault relies on a CW20, we create a CW20 transferFrom message\n            res.add_message(into_cosmos_msg(\n                Cw20ExecuteMsg::Transfer {\n                    recipient: receiver,\n                    amount: assets,\n                },\n                x,\n                None,\n            )?)\n        }\n    })\n}\n\npub fn withdraw(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    owner: String,\n    receiver: String,\n    assets: Uint128,\n) -\u003e Result\u003cResponse\u003e {\n    let state = STATE.load(deps.storage)?;\n    // Cannot withdraw 0 assets\n    if assets == Uint128::zero() {\n        return Err(anyhow::anyhow!(ContractError::ZeroDeposit {}));\n    }\n\n    let shares_needed = convert_to_shares(deps.as_ref(), env.clone(), assets, None)?;\n\n    // We burn shares_needed token from the owner balance in the info.sender's name\n    if info.sender == deps.api.addr_validate(\u0026owner)? {\n        execute_burn(deps, env, info.clone(), shares_needed)\n    } else {\n        execute_burn_from(deps, env, info.clone(), owner.clone(), shares_needed)\n    }?;\n\n    // We transfer the underlying asset to the receiver\n    let res = _add_asset_transfer_message(\u0026state, Response::new(), receiver.clone(), assets)?;\n    Ok(res\n        .add_attribute(\"action\", \"withdraw\")\n        .add_attribute(\"caller\", info.sender)\n        .add_attribute(\"receiver\", receiver)\n        .add_attribute(\"owner\", owner)\n        .add_attribute(\"assets\", assets)\n        .add_attribute(\"shares\", shares_needed))\n}\n\npub fn redeem(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    owner: String,\n    receiver: String,\n    shares: Uint128,\n) -\u003e Result\u003cResponse\u003e {\n    let state = STATE.load(deps.storage)?;\n\n    // Cannot withdraw 0 assets\n    if shares == Uint128::zero() {\n        return Err(anyhow::anyhow!(ContractError::ZeroDeposit {}));\n    }\n\n    let assets_needed = convert_to_shares(deps.as_ref(), env.clone(), shares, None)?;\n\n    // We burn shares_needed token from the owner balance in the info.sender's name\n    if info.sender == deps.api.addr_validate(\u0026owner)? {\n        execute_burn(deps, env, info.clone(), shares)\n    } else {\n        execute_burn_from(deps, env, info.clone(), owner.clone(), shares)\n    }?;\n\n    // We transfer the underlying asset to the reciever\n    let res =\n        _add_asset_transfer_message(\u0026state, Response::new(), receiver.clone(), assets_needed)?;\n    Ok(res\n        .add_attribute(\"action\", \"redeem\")\n        .add_attribute(\"caller\", info.sender)\n        .add_attribute(\"receiver\", receiver)\n        .add_attribute(\"owner\", owner)\n        .add_attribute(\"assets\", assets_needed.to_string())\n        .add_attribute(\"shares\", shares))\n}\n\n/// Mint new tokens without checks (eveyone can mint)\npub fn _execute_mint(\n    deps: DepsMut,\n    recipient: String,\n    amount: Uint128,\n) -\u003e Result\u003c(), ContractError\u003e {\n    if amount == Uint128::zero() {\n        return Err(ContractError::InvalidZeroAmount {});\n    }\n\n    let mut config = TOKEN_INFO.load(deps.storage)?;\n\n    // update supply and enforce cap\n    config.total_supply += amount;\n    if let Some(limit) = config.get_cap() {\n        if config.total_supply \u003e limit {\n            return Err(ContractError::CannotExceedCap {});\n        }\n    }\n    TOKEN_INFO.save(deps.storage, \u0026config)?;\n\n    // add amount to recipient balance\n    let rcpt_addr = deps.api.addr_validate(\u0026recipient)?;\n    BALANCES.update(\n        deps.storage,\n        \u0026rcpt_addr,\n        |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e { Ok(balance.unwrap_or_default() + amount) },\n    )?;\n\n    Ok(())\n}\n\n// Borrow mecanism\n/// Withdraw some underlying asset, with no repercussion.\n/// A configuration error could lead to draining of assets\npub fn borrow(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    receiver: String,\n    assets: Uint128,\n) -\u003e Result\u003cResponse\u003e {\n    let mut state = STATE.load(deps.storage)?;\n    // Only the authorized address can borrow assets (this usually is a contract address)\n    if state.borrower.is_none() || info.sender != state.borrower.clone().unwrap() {\n        return Err(anyhow::anyhow!(ContractError::Unauthorized {}));\n    }\n\n    // We update the internal state of the contract, more assets were borrowed\n    state.total_assets_borrowed += assets;\n    STATE.save(deps.storage, \u0026state)?;\n\n    let res = _add_asset_transfer_message(\u0026state, Response::new(), receiver.clone(), assets)?;\n\n    // We send the funds to the receiver\n    Ok(res\n        .add_attribute(\"action\", \"borrower\")\n        .add_attribute(\"caller\", info.sender)\n        .add_attribute(\"receiver\", receiver)\n        .add_attribute(\"assets\", assets.to_string()))\n}\n\n// Borrow mecanism\n/// Repay funds to lower the amount of debt of the contract\n/// If more funds than the current debt are sent via this mecanism, assets are deposited in the vault but no extra tokens are minted\npub fn repay(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    owner: Option\u003cString\u003e,\n    assets: Uint128,\n) -\u003e Result\u003cResponse\u003e {\n    let debt_repaid = _repay(deps.storage, assets)?;\n    let state = STATE.load(deps.storage)?;\n\n    // Then we make sure the funds are correctly deposited to the contract\n    let res = Response::new();\n    let res = match state.underlying_asset {\n        AssetInfo::Coin(x) =\u003e {\n            // We need to check if the funds sent match the AssetInfo we have\n            if info.funds.len() != 1 || info.funds[0].denom != x {\n                return Err(anyhow!(ContractError::WrongAssetDeposited {\n                    sent: info.funds[0].denom.clone(),\n                    expected: x,\n                }));\n            } else if assets != info.funds[0].amount {\n                return Err(anyhow!(ContractError::InsufficientAssetDeposited {\n                    sent: info.funds[0].amount,\n                    expected: assets,\n                }));\n            }\n            res\n        }\n        AssetInfo::Cw20(x) =\u003e {\n            // If the vault relies on a CW20, we create a CW20 transferFrom message\n            res.add_message(into_cosmos_msg(\n                Cw20ExecuteMsg::TransferFrom {\n                    owner: owner.unwrap_or_else(|| info.sender.to_string()),\n                    recipient: env.contract.address.into(),\n                    amount: assets,\n                },\n                x,\n                None,\n            )?)\n        }\n    };\n\n    Ok(res\n        .add_attribute(\"action\", \"repay\")\n        .add_attribute(\"caller\", info.sender)\n        .add_attribute(\"assets\", assets.to_string())\n        .add_attribute(\"debt_repaid\", debt_repaid.to_string())\n        .add_attribute(\"raw_deposit\", (assets - debt_repaid).to_string()))\n}\n\npub fn _repay(storage: \u0026mut dyn Storage, assets: Uint128) -\u003e Result\u003cUint128\u003e {\n    let mut state = STATE.load(storage)?;\n\n    // Cannot deposit 0 amount\n    if assets == Uint128::zero() {\n        return Err(anyhow!(ContractError::ZeroDeposit {}));\n    };\n    // Then we update the total debt\n    // If the current debt is higher than the repay amount, we repay some of the debt with the deposit\n    // Else we repay all the debt and simply deposit the rest in the contract without minting new vault tokens\n    let debt_repaid = if state.total_assets_borrowed \u003e assets {\n        state.total_assets_borrowed -= assets;\n        assets\n    } else {\n        state.total_assets_borrowed = Uint128::zero();\n        state.total_assets_borrowed\n    };\n    STATE.save(storage, \u0026state)?;\n    Ok(debt_repaid)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","ailiq_token","src","msg.rs"],"content":"use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\npub use cw20::Cw20ExecuteMsg as ExecuteMsg;\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    /// Returns the current balance of the given address, 0 if unset.\n    /// Return type: BalanceResponse.\n    Balance { address: String },\n    /// Returns metadata on the contract - name, decimals, supply, etc.\n    /// Return type: TokenInfoResponse.\n    TokenInfo {},\n    /// Only with \"mintable\" extension.\n    /// Returns who can mint and the hard cap on maximum tokens after minting.\n    /// Return type: MinterResponse.\n    Minter {},\n    /// Only with \"allowance\" extension.\n    /// Returns how much spender can use from owner account, 0 if unset.\n    /// Return type: AllowanceResponse.\n    Allowance { owner: String, spender: String },\n    /// Only with \"enumerable\" extension (and \"allowances\")\n    /// Returns all allowances this owner has approved. Supports pagination.\n    /// Return type: AllAllowancesResponse.\n    AllAllowances {\n        owner: String,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    },\n    /// Only with \"enumerable\" extension\n    /// Returns all accounts that have balances. Supports pagination.\n    /// Return type: AllAccountsResponse.\n    AllAccounts {\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    },\n    /// Only with \"marketing\" extension\n    /// Returns more metadata on the contract to display in the client:\n    /// - description, logo, project url, etc.\n    /// Return type: MarketingInfoResponse\n    MarketingInfo {},\n    /// Only with \"marketing\" extension\n    /// Downloads the mbeded logo data (if stored on chain). Errors if no logo data ftored for this\n    /// contract.\n    /// Return type: DownloadLogoResponse.\n    DownloadLogo {},\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","ailiq_token","src","query.rs"],"content":"#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::{Deps, Env, StdResult, Uint128};\nuse cw20_base::state::{TokenInfo, TOKEN_INFO};\n\nuse bignumber::{Decimal256, Uint256};\nuse cw_4626::state::{query_asset_balance, query_asset_liabilities, AssetInfo, STATE};\n\nuse cw20_base::contract::query_balance;\npub fn query_asset(deps: Deps) -\u003e StdResult\u003cAssetInfo\u003e {\n    let state = STATE.load(deps.storage)?;\n    Ok(state.underlying_asset)\n}\n\npub fn query_total_assets(deps: Deps) -\u003e StdResult\u003cUint128\u003e {\n    let state = STATE.load(deps.storage)?;\n    Ok(state.total_underlying_asset_supply)\n}\n\npub fn compute_exchange_rate(\n    deps: Deps,\n    env: Env,\n    token_info: \u0026TokenInfo,\n    deposit_amount: Option\u003cUint128\u003e,\n) -\u003e StdResult\u003cDecimal256\u003e {\n    let share_supply = token_info.total_supply;\n    if share_supply.is_zero() {\n        return Ok(Decimal256::one());\n    }\n\n    let asset_balance =\n        query_asset_balance(deps, env.clone())? - deposit_amount.unwrap_or_else(Uint128::zero);\n    let liabilities = query_asset_liabilities(deps, env)?;\n    let total_assets =\n        Decimal256::from_uint256(Uint256::from((asset_balance + liabilities).u128()));\n    Ok(total_assets / Decimal256::from_uint256(Uint256::from(share_supply.u128())))\n}\n\npub fn convert_to_shares(\n    deps: Deps,\n    env: Env,\n    assets: Uint128,\n    deposit_amount: Option\u003cUint128\u003e,\n) -\u003e StdResult\u003cUint128\u003e {\n    let token_info = TOKEN_INFO.load(deps.storage)?;\n\n    let exchange_rate = compute_exchange_rate(deps, env, \u0026token_info, deposit_amount)?;\n    Ok((Uint256::from(assets.u128()) / exchange_rate).into())\n}\n\npub fn convert_to_assets(\n    deps: Deps,\n    env: Env,\n    shares: Uint128,\n    deposit_amount: Option\u003cUint128\u003e,\n) -\u003e StdResult\u003cUint128\u003e {\n    let token_info = TOKEN_INFO.load(deps.storage)?;\n    let exchange_rate = compute_exchange_rate(deps, env, \u0026token_info, deposit_amount)?;\n    Ok((Uint256::from(shares) * exchange_rate).into())\n}\npub fn preview_deposit(deps: Deps, env: Env, assets: Uint128) -\u003e StdResult\u003cUint128\u003e {\n    convert_to_shares(deps, env, assets, None)\n}\n\npub fn preview_mint(deps: Deps, env: Env, shares: Uint128) -\u003e StdResult\u003cUint128\u003e {\n    convert_to_assets(deps, env, shares, None)\n}\n\npub fn preview_withdraw(deps: Deps, env: Env, assets: Uint128) -\u003e StdResult\u003cUint128\u003e {\n    convert_to_shares(deps, env, assets, None)\n}\n\npub fn preview_redeem(deps: Deps, env: Env, shares: Uint128) -\u003e StdResult\u003cUint128\u003e {\n    convert_to_assets(deps, env, shares, None)\n}\n\npub fn max_deposit(_deps: Deps, _env: Env, _receiver: String) -\u003e StdResult\u003cUint128\u003e {\n    Ok(Uint128::MAX)\n}\n\npub fn max_mint(_deps: Deps, _env: Env, _receiver: String) -\u003e StdResult\u003cUint256\u003e {\n    Ok(Uint256::from(Uint128::MAX))\n}\n\npub fn max_withdraw(deps: Deps, env: Env, owner: String) -\u003e StdResult\u003cUint128\u003e {\n    convert_to_shares(deps, env.clone(), max_redeem(deps, env, owner)?, None)\n}\n\npub fn max_redeem(deps: Deps, _env: Env, owner: String) -\u003e StdResult\u003cUint128\u003e {\n    Ok(query_balance(deps, owner)?.balance)\n}\n\n#[cfg(test)]\npub mod tests {\n    use super::*;\n    use crate::contract::instantiate;\n    use cosmwasm_std::testing::{mock_dependencies, mock_env, mock_info};\n    use cosmwasm_std::DepsMut;\n    use cw_4626::msg::InstantiateMsg;\n    fn init_helper(deps: DepsMut) {\n        let instantiate_msg = InstantiateMsg {\n            name: \"Iliq treasury token\".to_string(),\n            symbol: \"ailiq\".to_string(),\n            decimals: 6u8,\n            initial_balances: vec![],\n            mint: None,\n            marketing: None,\n            asset: AssetInfo::Coin(\"uluna\".to_string()),\n            borrower: Some(\"borrower\".to_string()),\n        };\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n\n        instantiate(deps, env, info, instantiate_msg).unwrap();\n    }\n\n    #[test]\n    fn test_convert_sanity() {\n        let mut deps = mock_dependencies();\n        let env = mock_env();\n        init_helper(deps.as_mut());\n        let initial_assets = Uint128::from(6764562356574737676u128);\n        let shares = convert_to_shares(deps.as_ref(), env.clone(), initial_assets, None).unwrap();\n\n        let final_assets = convert_to_assets(deps.as_ref(), env, shares, None).unwrap();\n\n        assert_eq!(initial_assets, final_assets);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","fee_contract","examples","fee_schema.rs"],"content":"use std::env::current_dir;\nuse std::fs::create_dir_all;\n\nuse cosmwasm_schema::{export_schema, remove_schemas, schema_for};\n\nuse fee_contract_export::msg::{ExecuteMsg, InstantiateMsg, QueryMsg};\n\nfn main() {\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"schema\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n\n    export_schema(\u0026schema_for!(InstantiateMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(ExecuteMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(QueryMsg), \u0026out_dir);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","fee_contract","src","contract.rs"],"content":"#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::{\n    entry_point, to_binary, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdError, StdResult,\n    Uint128,\n};\n\nuse fee_contract_export::error::ContractError;\nuse fee_contract_export::msg::{ExecuteMsg, FeeResponse, InstantiateMsg, MigrateMsg, QueryMsg};\nuse fee_contract_export::state::{ContractInfo, FeeInfo};\n\nuse p2p_trading_export::query::{load_trade, load_trade_and_accepted_counter_trade};\n\nuse crate::state::{is_admin, CONTRACT_INFO, FEE_RATES};\nuse fee_distributor_export::msg::ExecuteMsg as FeeDistributorMsg;\nuse p2p_trading_export::msg::ExecuteMsg as P2PExecuteMsg;\nuse p2p_trading_export::state::AssetInfo;\nuse utils::msg::into_cosmos_msg;\n\nconst ASSET_FEE_RATE: u128 = 40u128; // In thousands\nconst FEE_MAX: u128 = 10_000_000u128;\nconst FIRST_TEER_RATE: u128 = 500_000u128;\nconst FIRST_TEER_LIMIT: u128 = 4u128;\nconst SECOND_TEER_RATE: u128 = 200_000u128;\nconst SECOND_TEER_LIMIT: u128 = 14u128;\nconst THIRD_TEER_RATE: u128 = 50_000u128;\nconst ACCEPTABLE_FEE_DEVIATION: u128 = 50u128; // In thousands\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // Verify the contract name\n    msg.validate()?;\n    // store token info\n    let data = ContractInfo {\n        name: msg.name,\n        owner: msg\n            .owner\n            .map(|x| deps.api.addr_validate(\u0026x))\n            .unwrap_or(Ok(info.sender))?,\n        p2p_contract: deps.api.addr_validate(\u0026msg.p2p_contract)?,\n        fee_distributor: deps.api.addr_validate(\u0026msg.fee_distributor)?,\n    };\n    CONTRACT_INFO.save(deps.storage, \u0026data)?;\n    // Initialisation with fixed rates\n    FEE_RATES.save(\n        deps.storage,\n        \u0026FeeInfo {\n            asset_fee_rate: Uint128::from(ASSET_FEE_RATE), // In thousandths\n            fee_max: Uint128::from(FEE_MAX),               // In uusd\n            first_teer_limit: Uint128::from(FIRST_TEER_LIMIT),\n            first_teer_rate: Uint128::from(FIRST_TEER_RATE),\n            second_teer_limit: Uint128::from(SECOND_TEER_LIMIT),\n            second_teer_rate: Uint128::from(SECOND_TEER_RATE),\n            third_teer_rate: Uint128::from(THIRD_TEER_RATE),\n            acceptable_fee_deviation: Uint128::from(ACCEPTABLE_FEE_DEVIATION),\n        },\n    )?;\n    Ok(Response::default().add_attribute(\"fee_contract\", \"init\"))\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    match msg {\n        ExecuteMsg::PayFeeAndWithdraw { trade_id } =\u003e {\n            pay_fee_and_withdraw(deps, env, info, trade_id)\n        }\n        ExecuteMsg::UpdateFeeRates {\n            asset_fee_rate,\n            fee_max,\n            first_teer_limit,\n            first_teer_rate,\n            second_teer_limit,\n            second_teer_rate,\n            third_teer_rate,\n            acceptable_fee_deviation,\n        } =\u003e update_fee_rates(\n            deps,\n            env,\n            info,\n            asset_fee_rate,\n            fee_max,\n            first_teer_limit,\n            first_teer_rate,\n            second_teer_limit,\n            second_teer_rate,\n            third_teer_rate,\n            acceptable_fee_deviation,\n        ),\n    }\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn migrate(_deps: DepsMut, _env: Env, _msg: MigrateMsg) -\u003e Result\u003cResponse, ContractError\u003e {\n    // No state migrations performed, just returned a Response\n    Ok(Response::default())\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -\u003e Result\u003cBinary, ContractError\u003e {\n    match msg {\n        QueryMsg::ContractInfo {} =\u003e {\n            to_binary(\u0026contract_info(deps)?).map_err(|_| ContractError::BinaryEncodingError {})\n        }\n        QueryMsg::FeeRates {} =\u003e {\n            to_binary(\u0026fee_rates(deps)?).map_err(|_| ContractError::BinaryEncodingError {})\n        }\n        QueryMsg::Fee {\n            trade_id,\n            counter_id,\n        } =\u003e to_binary(\u0026query_fee_for(deps, trade_id, counter_id)?)\n            .map_err(|_| ContractError::BinaryEncodingError {}),\n        QueryMsg::SimulateFee {\n            trade_id,\n            counter_assets,\n        } =\u003e to_binary(\u0026simulate_fee(deps, trade_id, counter_assets)?)\n            .map_err(|_| ContractError::BinaryEncodingError {}),\n    }\n}\n\n/// This function is used to withdraw funds from an accepted trade.\n/// It uses information from the trades and counter trades to determine how much needs to be paid\n/// If the fee is sufficient, it sends the fee to the fee_depositor contract (responsible for fee distribution)\npub fn pay_fee_and_withdraw(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    trade_id: u64,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // The fee can be paid in any Terra native currency.\n    // It needs to be paid in a single currency\n    if info.funds.len() != 1 {\n        return Err(ContractError::FeeNotPaid {});\n    }\n\n    let funds = info.funds[0].clone();\n    let contract_info = CONTRACT_INFO.load(deps.storage)?;\n    let (trade_info, counter_info) = load_trade_and_accepted_counter_trade(\n        deps.as_ref(),\n        contract_info.p2p_contract.clone(),\n        trade_id,\n        None,\n    )?;\n    // Querying the required fee amount in \"uusd\"\n    let fee_amount = fee_amount_raw(\n        deps.as_ref(),\n        \u0026trade_info.associated_assets,\n        \u0026counter_info.associated_assets,\n    )?;\n    // We accept a small fee deviation, in case the exchange rates fluctuate a bit between the query and the paiement.\n    let acceptable_fee_deviation = FEE_RATES.load(deps.storage)?.acceptable_fee_deviation;\n\n    if funds.denom == \"uluna\" {\n        if funds.amount + funds.amount * acceptable_fee_deviation / Uint128::from(1_000u128)\n            \u003c fee_amount\n        {\n            return Err(ContractError::FeeNotPaidCorrectly {\n                required: fee_amount.u128(),\n                provided: funds.amount.u128(),\n            });\n        }\n    } else {\n        return Err(ContractError::FeeNotPaid {});\n    }\n\n    // Then we distribute the funds to the fee_distributor contract\n    let contract_addresses: Vec\u003cString\u003e = trade_info\n        .associated_assets\n        .iter()\n        .chain(counter_info.associated_assets.iter())\n        .filter_map(|x| match x {\n            AssetInfo::Cw721Coin(cw721) =\u003e Some(cw721.address.clone()),\n            AssetInfo::Cw1155Coin(cw1155) =\u003e Some(cw1155.address.clone()),\n            _ =\u003e None,\n        })\n        .collect();\n    let distribute_message = into_cosmos_msg(\n        FeeDistributorMsg::DepositFees {\n            addresses: contract_addresses,\n        },\n        contract_info.fee_distributor,\n        Some(info.funds),\n    )?;\n\n    // Then we call withdraw on the p2p contract\n    let withdraw_message = P2PExecuteMsg::WithdrawPendingAssets {\n        trader: info.sender.into(),\n        trade_id,\n    };\n    let message = into_cosmos_msg(withdraw_message, contract_info.p2p_contract, None)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"payed_trade_fee\")\n        .add_message(message)\n        .add_message(distribute_message))\n}\n\npub fn modify_contract_owner(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    owner: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    is_admin(deps.as_ref(), info.sender)?;\n\n    let owner_addr = deps.api.addr_validate(\u0026owner)?;\n    CONTRACT_INFO.update::\u003c_, StdError\u003e(deps.storage, |mut x| {\n        x.owner = owner_addr;\n        Ok(x)\n    })?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"parameter_update\")\n        .add_attribute(\"parameter\", \"owner\"))\n}\n\n#[allow(clippy::too_many_arguments)]\npub fn update_fee_rates(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    asset_fee_rate: Option\u003cUint128\u003e,\n    fee_max: Option\u003cUint128\u003e,\n    first_teer_limit: Option\u003cUint128\u003e,\n    first_teer_rate: Option\u003cUint128\u003e,\n    second_teer_limit: Option\u003cUint128\u003e,\n    second_teer_rate: Option\u003cUint128\u003e,\n    third_teer_rate: Option\u003cUint128\u003e,\n    acceptable_fee_deviation: Option\u003cUint128\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    is_admin(deps.as_ref(), info.sender)?;\n\n    FEE_RATES.update::\u003c_, StdError\u003e(deps.storage, |x| {\n        Ok(FeeInfo {\n            asset_fee_rate: asset_fee_rate.unwrap_or(x.asset_fee_rate),\n            fee_max: fee_max.unwrap_or(x.fee_max),\n            first_teer_limit: first_teer_limit.unwrap_or(x.first_teer_limit),\n            first_teer_rate: first_teer_rate.unwrap_or(x.first_teer_rate),\n            second_teer_limit: second_teer_limit.unwrap_or(x.second_teer_limit),\n            second_teer_rate: second_teer_rate.unwrap_or(x.second_teer_rate),\n            third_teer_rate: third_teer_rate.unwrap_or(x.third_teer_rate),\n            acceptable_fee_deviation: acceptable_fee_deviation\n                .unwrap_or(x.acceptable_fee_deviation),\n        })\n    })?;\n\n    // We verify the rates are ordered\n    let new_fee_rates = FEE_RATES.load(deps.storage)?;\n    if new_fee_rates.second_teer_limit \u003c= new_fee_rates.first_teer_limit {\n        return Err(ContractError::TeersNotOrdered {});\n    }\n\n    Ok(Response::new().add_attribute(\"updated\", \"fee_rates\"))\n}\n\n/// Compute the fee amount for trade and counter_trade assets\n/// This function contains 2 parts\n/// 1. Compute a fee relative to the number of tokens exchanged in the transaction (cw20, cw721 and cw1155)\n/// 2. Compute a percentage fee amount for all terra native funds\npub fn fee_amount_raw(\n    deps: Deps,\n    trade_assets: \u0026[AssetInfo],\n    counter_assets: \u0026[AssetInfo],\n) -\u003e Result\u003cUint128, ContractError\u003e {\n    let fee_info = FEE_RATES.load(deps.storage)?;\n\n    // Accumulate results to compute\n    // 1. The percentage fee for terra native tokens\n    // 2. The number of exchanged tokens in the transaction\n    let (fund_fee, asset_number) = trade_assets.iter().chain(counter_assets.iter()).try_fold(\n        (Uint128::zero(), Uint128::zero()),\n        |(fund_fee, asset_number), x| -\u003e Result\u003c(Uint128, Uint128), ContractError\u003e {\n            match x {\n                AssetInfo::Coin(coin) =\u003e {\n                    if coin.denom != \"uluna\" {\n                        return Err(ContractError::FeeNotPaid {});\n                    }\n\n                    let fee = coin.amount * fee_info.asset_fee_rate / Uint128::from(1_000u128);\n                    Ok((fund_fee + fee, asset_number))\n                }\n                _ =\u003e Ok((fund_fee, asset_number + Uint128::from(1u128))),\n            }\n        },\n    )?;\n\n    // We compute the fee dependant on the number of exchanged tokens (in teers, just like taxes)\n    let fee = fee_info.first_teer_rate * asset_number.min(fee_info.first_teer_limit)\n        + fee_info.second_teer_rate\n            * (asset_number\n                .min(fee_info.second_teer_limit)\n                .max(fee_info.first_teer_limit)\n                - fee_info.first_teer_limit)\n        + fee_info.third_teer_rate\n            * (asset_number.max(fee_info.second_teer_limit) - fee_info.second_teer_limit)\n                .min(fee_info.fee_max);\n\n    Ok((fee + fund_fee) / Uint128::from(2u128))\n}\n\npub fn contract_info(deps: Deps) -\u003e StdResult\u003cContractInfo\u003e {\n    CONTRACT_INFO.load(deps.storage)\n}\n\npub fn fee_rates(deps: Deps) -\u003e StdResult\u003cFeeInfo\u003e {\n    FEE_RATES.load(deps.storage)\n}\n\n/// Allows to simulate the fee that will need to be paid when withdrawing assets\n/// If `counter_id` is not specified, the accepted counter_trade will be considered for computing the fee\n/// If it is specified, the counter_id provided will be considered\npub fn query_fee_for(\n    deps: Deps,\n    trade_id: u64,\n    counter_id: Option\u003cu64\u003e,\n) -\u003e Result\u003cFeeResponse, ContractError\u003e {\n    let contract_info = CONTRACT_INFO.load(deps.storage)?;\n\n    let (trade_info, counter_info) = load_trade_and_accepted_counter_trade(\n        deps,\n        contract_info.p2p_contract,\n        trade_id,\n        counter_id,\n    )?;\n    let fee = fee_amount_raw(\n        deps,\n        \u0026trade_info.associated_assets,\n        \u0026counter_info.associated_assets,\n    )?;\n\n    Ok(FeeResponse { fee })\n}\n\n/// Allows to simulate the fee that will need to be paid if the submitted assets are those of the accepted counter trade\npub fn simulate_fee(\n    deps: Deps,\n    trade_id: u64,\n    counter_assets: Vec\u003cAssetInfo\u003e,\n) -\u003e Result\u003cFeeResponse, ContractError\u003e {\n    let contract_info = CONTRACT_INFO.load(deps.storage)?;\n\n    let trade_info = load_trade(deps, contract_info.p2p_contract, trade_id)?;\n    let fee = fee_amount_raw(deps, \u0026trade_info.associated_assets, \u0026counter_assets)?;\n\n    Ok(FeeResponse { fee })\n}\n\n#[cfg(test)]\npub mod tests {\n    use super::*;\n    use cosmwasm_std::testing::{mock_dependencies, mock_env, mock_info};\n    use p2p_trading_export::state::Cw20Coin;\n    //use cosmwasm_std::{coins, Coin, SubMsg};\n\n    fn init_helper(deps: DepsMut) -\u003e Response {\n        let instantiate_msg = InstantiateMsg {\n            name: \"fee_contract\".to_string(),\n            owner: None,\n            p2p_contract: \"p2p\".to_string(),\n            fee_distributor: \"treasury\".to_string(),\n        };\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n\n        instantiate(deps, env, info, instantiate_msg).unwrap()\n    }\n\n    #[test]\n    fn test_init_sanity() {\n        let mut deps = mock_dependencies();\n        let res = init_helper(deps.as_mut());\n        assert_eq!(0, res.messages.len());\n    }\n\n    #[test]\n    fn test_update_fee_rates() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n        execute(\n            deps.as_mut(),\n            env,\n            info,\n            ExecuteMsg::UpdateFeeRates {\n                asset_fee_rate: Some(Uint128::from(5u128)), // In thousandths\n                fee_max: Some(Uint128::from(6u128)),        // In uusd\n                first_teer_limit: Some(Uint128::from(7u128)),\n                first_teer_rate: Some(Uint128::from(8u128)),\n                second_teer_limit: Some(Uint128::from(9u128)),\n                second_teer_rate: Some(Uint128::from(10u128)),\n                third_teer_rate: Some(Uint128::from(11u128)),\n                acceptable_fee_deviation: Some(Uint128::from(12u128)),\n            },\n        )\n        .unwrap();\n\n        let fee_rate = FEE_RATES.load(\u0026deps.storage).unwrap();\n        assert_eq!(\n            fee_rate,\n            FeeInfo {\n                asset_fee_rate: Uint128::from(5u128), // In thousandths\n                fee_max: Uint128::from(6u128),        // In uusd\n                first_teer_limit: Uint128::from(7u128),\n                first_teer_rate: Uint128::from(8u128),\n                second_teer_limit: Uint128::from(9u128),\n                second_teer_rate: Uint128::from(10u128),\n                third_teer_rate: Uint128::from(11u128),\n                acceptable_fee_deviation: Uint128::from(12u128),\n            }\n        );\n    }\n\n    #[test]\n    fn test_fee_amount() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n\n        let fee = fee_amount_raw(deps.as_ref(), \u0026[], \u0026[]).unwrap();\n        assert_eq!(fee, Uint128::zero());\n\n        let fee = fee_amount_raw(\n            deps.as_ref(),\n            \u0026[AssetInfo::Cw20Coin(Cw20Coin {\n                amount: Uint128::from(42u64),\n                address: \"token\".to_string(),\n            })],\n            \u0026[],\n        )\n        .unwrap();\n        assert_eq!(fee, Uint128::new(250_000u128));\n\n        let fee = fee_amount_raw(\n            deps.as_ref(),\n            \u0026[AssetInfo::Cw20Coin(Cw20Coin {\n                amount: Uint128::from(42u64),\n                address: \"token\".to_string(),\n            })],\n            \u0026[AssetInfo::Cw20Coin(Cw20Coin {\n                amount: Uint128::from(42u64),\n                address: \"token\".to_string(),\n            })],\n        )\n        .unwrap();\n        assert_eq!(fee, Uint128::new(500_000u128));\n\n        let fee = fee_amount_raw(\n            deps.as_ref(),\n            \u0026[\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    amount: Uint128::from(42u64),\n                    address: \"token\".to_string(),\n                }),\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    amount: Uint128::from(42u64),\n                    address: \"token\".to_string(),\n                }),\n            ],\n            \u0026[],\n        )\n        .unwrap();\n        assert_eq!(fee, Uint128::new(500_000u128));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","fee_contract","src","lib.rs"],"content":"pub mod contract;\npub mod state;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","fee_contract","src","state.rs"],"content":"use cosmwasm_std::{Addr, Deps};\nuse cw_storage_plus::Item;\nuse fee_contract_export::error::ContractError;\nuse fee_contract_export::state::{ContractInfo, FeeInfo};\n\npub const CONTRACT_INFO: Item\u003cContractInfo\u003e = Item::new(\"contract_info\");\npub const FEE_RATES: Item\u003cFeeInfo\u003e = Item::new(\"fee_rates\");\n\npub fn is_admin(deps: Deps, addr: Addr) -\u003e Result\u003c(), ContractError\u003e {\n    if CONTRACT_INFO.load(deps.storage)?.owner == addr {\n        Ok(())\n    } else {\n        Err(ContractError::Unauthorized {})\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","fee_distributor","examples","fee_distributor_schema.rs"],"content":"use std::env::current_dir;\nuse std::fs::create_dir_all;\n\nuse cosmwasm_schema::{export_schema, remove_schemas, schema_for};\n\nuse fee_distributor_export::msg::{ExecuteMsg, InstantiateMsg, QueryMsg};\n\nfn main() {\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"schema\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n\n    export_schema(\u0026schema_for!(InstantiateMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(ExecuteMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(QueryMsg), \u0026out_dir);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","fee_distributor","src","contract.rs"],"content":"use cosmwasm_std::{\n    coin, coins, entry_point, to_binary, BankMsg, Binary, Coin, Deps, DepsMut, Env, MessageInfo,\n    Order, Response, StdError, StdResult, Uint128,\n};\nuse cw_storage_plus::Bound;\nuse itertools::Itertools;\n#[cfg(not(feature = \"library\"))]\nuse std::convert::TryInto;\nuse utils::state::maybe_addr;\n\nuse fee_distributor_export::msg::{ExecuteMsg, InstantiateMsg, MigrateMsg, QueryMsg};\nuse fee_distributor_export::state::ContractInfo;\n\nuse crate::error::ContractError;\nuse crate::state::{is_admin, ALLOCATED_FUNDS, ASSOCIATED_FEE_ADDRESS, CONTRACT_INFO};\n\nconst PROJECTS_ALLOCATION: u128 = 75u128; // In percent\nconst DEFAULT_LIMIT: u32 = 10u32;\nconst MAX_LIMIT: u32 = 30u32;\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // Verify the contract name\n    msg.validate()?;\n\n    // store contract info\n    let data = ContractInfo {\n        name: msg.name,\n        owner: msg\n            .owner\n            .map(|x| deps.api.addr_validate(\u0026x))\n            .unwrap_or(Ok(info.sender))?,\n        treasury: deps.api.addr_validate(\u0026msg.treasury)?,\n        projects_allocation: Uint128::from(PROJECTS_ALLOCATION),\n    };\n    CONTRACT_INFO.save(deps.storage, \u0026data)?;\n    Ok(Response::default()\n        .add_attribute(\"action\", \"init\")\n        .add_attribute(\"contract_name\", \"fee_distributor\"))\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    match msg {\n        ExecuteMsg::ModifyContractInfo {\n            owner,\n            treasury,\n            projects_allocation,\n        } =\u003e modify_contract_info(deps, env, info, owner, treasury, projects_allocation),\n        ExecuteMsg::AddAssociatedAddress {\n            address,\n            fee_address,\n        } =\u003e add_associated_address(deps, env, info, address, fee_address),\n        ExecuteMsg::DepositFees { addresses } =\u003e deposit_fees(deps, env, info, addresses),\n        ExecuteMsg::WithdrawFees { addresses } =\u003e withdraw_fees(deps, env, info, addresses),\n    }\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn migrate(_deps: DepsMut, _env: Env, _msg: MigrateMsg) -\u003e Result\u003cResponse, ContractError\u003e {\n    // No state migrations performed, just returned a Response\n    Ok(Response::default())\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::ContractInfo {} =\u003e to_binary(\u0026contract_info(deps)?),\n        QueryMsg::Amount { address } =\u003e to_binary(\u0026query_amount(deps, address)?),\n        QueryMsg::Addresses { start_after, limit } =\u003e {\n            to_binary(\u0026query_addresses(deps, start_after, limit)?)\n        }\n    }\n}\n\n/// Modify all contract info using this function\n/// Must be the admin to change the parameters\npub fn modify_contract_info(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    owner: Option\u003cString\u003e,\n    treasury: Option\u003cString\u003e,\n    projects_allocation: Option\u003cUint128\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    is_admin(deps.as_ref(), info.sender)?;\n\n    let mut contract_info = CONTRACT_INFO.load(deps.storage)?;\n    contract_info.owner = maybe_addr(deps.api, owner)?.unwrap_or(contract_info.owner);\n    contract_info.treasury = maybe_addr(deps.api, treasury)?.unwrap_or(contract_info.treasury);\n    contract_info.projects_allocation =\n        projects_allocation.unwrap_or(contract_info.projects_allocation);\n\n    if contract_info.projects_allocation.u128() \u003e 100u128 {\n        return Err(ContractError::AllocationTooHigh {});\n    }\n    CONTRACT_INFO.save(deps.storage, \u0026contract_info)?;\n\n    Ok(Response::new().add_attribute(\"action\", \"parameter_update\"))\n}\n\n/// Add or modify the address associated to a token to withdraw the funds deposited in the contract\npub fn add_associated_address(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    address: String,\n    fee_address: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    is_admin(deps.as_ref(), info.sender)?;\n\n    let valid_address = deps.api.addr_validate(\u0026address)?;\n    let valid_fee_address = deps.api.addr_validate(\u0026fee_address)?;\n    ASSOCIATED_FEE_ADDRESS.save(deps.storage, \u0026valid_address, \u0026valid_fee_address)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"associated_address_update\")\n        .add_attribute(\"address\", address)\n        .add_attribute(\"associated_addreee\", fee_address))\n}\n\n/// Main Function of this contract\n/// Deposit Fees and distribute them according to the addresses provided\npub fn deposit_fees(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    addresses: Vec\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // The deposited funds must be a unique fund type\n    if info.funds.len() != 1 {\n        return Err(ContractError::DepositNotCorrect {});\n    }\n\n    let fund = info.funds[0].clone();\n    let contract_info = CONTRACT_INFO.load(deps.storage)?;\n    let n_addresses: u128 = addresses.len().try_into().unwrap();\n    let each_project_allocation = if n_addresses \u003e 0 {\n        fund.amount * contract_info.projects_allocation\n            / Uint128::from(100u128)\n            / Uint128::from(n_addresses)\n    } else {\n        Uint128::zero()\n    };\n    let treasury_allocation = fund.amount - each_project_allocation * Uint128::from(n_addresses);\n    let each_project_fund = coin(each_project_allocation.u128(), fund.denom.clone());\n    // First we save the fees that just arrived into the contract memory\n    for address in \u0026addresses {\n        let valid_address = deps.api.addr_validate(address)?;\n        ALLOCATED_FUNDS.update::\u003c_, StdError\u003e(deps.storage, \u0026valid_address, |x| {\n            match x {\n                Some(mut funds) =\u003e {\n                    // We check the sent funds are with the right format\n                    let existing_denom = funds.iter_mut().find(|c| c.denom == fund.denom.clone());\n\n                    if let Some(existing_fund) = existing_denom {\n                        *existing_fund = Coin {\n                            denom: fund.denom.clone(),\n                            amount: existing_fund.amount + each_project_fund.amount,\n                        };\n                    } else {\n                        funds.push(each_project_fund.clone());\n                    }\n                    Ok(funds)\n                }\n                None =\u003e Ok(vec![each_project_fund.clone()]),\n            }\n        })?;\n    }\n    // Then we try to distribute the fees from the addresses that were just credited (if they have an associated address)\n    let fee_withdrawal_messages = if !addresses.is_empty() {\n        _withdraw_registered_addresses(deps, env, info, addresses)?\n    } else {\n        vec![]\n    };\n\n    // We send the treasury allocation\n    let treasury_message = BankMsg::Send {\n        to_address: contract_info.treasury.to_string(),\n        amount: coins(treasury_allocation.u128(), fund.denom.clone()),\n    };\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"saved_fee\")\n        .add_attribute(\"action\", \"distributed_fee\")\n        .add_message(treasury_message)\n        .add_messages(fee_withdrawal_messages))\n}\n\n/// Manually triggers withdrawal for the indicated addresses\n/// The fees will be withdrawn only if the indicated addresses have an associated address registered\n/// This function won't error if one or more addresses doesn't have an associated address\npub fn withdraw_fees(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    addresses: Vec\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let messages = _withdraw_registered_addresses(deps, env, info, addresses)?;\n    Ok(Response::new()\n        .add_attribute(\"action\", \"distributed_fee\")\n        .add_messages(messages))\n}\n\n/// Internal function\n/// It withdraws the fees for tokens with associated addresses in the list provided in argument\npub fn _withdraw_registered_addresses(\n    deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    addresses: Vec\u003cString\u003e,\n) -\u003e StdResult\u003cVec\u003cBankMsg\u003e\u003e {\n    let addresses: Vec\u003cString\u003e = addresses.into_iter().unique().collect();\n    let mut messages = vec![];\n    for address in \u0026addresses {\n        let valid_address = deps.api.addr_validate(address)?;\n        let loaded_funds = ALLOCATED_FUNDS.load(deps.storage, \u0026valid_address);\n        let associated_address = ASSOCIATED_FEE_ADDRESS.load(deps.storage, \u0026valid_address);\n        if let (Ok(loaded_funds), Ok(associated_address)) = (loaded_funds, associated_address) {\n            messages.push(BankMsg::Send {\n                to_address: associated_address.to_string(),\n                amount: loaded_funds,\n            });\n            ALLOCATED_FUNDS.save(deps.storage, \u0026valid_address, \u0026vec![])?;\n        }\n    }\n    Ok(messages)\n}\n\npub fn contract_info(deps: Deps) -\u003e StdResult\u003cContractInfo\u003e {\n    CONTRACT_INFO.load(deps.storage)\n}\n\n/// Query the amount of fee deposited in the contract for a given token address (cw721 and cw1155 supposedly)\npub fn query_amount(deps: Deps, address: String) -\u003e StdResult\u003cVec\u003cCoin\u003e\u003e {\n    let address = deps.api.addr_validate(\u0026address)?;\n    ALLOCATED_FUNDS.load(deps.storage, \u0026address).or(Ok(vec![]))\n}\n\npub fn query_addresses(\n    deps: Deps,\n    start_after: Option\u003cString\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e StdResult\u003cVec\u003cString\u003e\u003e {\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n    let addr = maybe_addr(deps.api, start_after)?;\n    let start = addr.as_ref().map(Bound::exclusive);\n\n    ALLOCATED_FUNDS\n        .keys(deps.storage, start, None, Order::Ascending)\n        .take(limit)\n        .map(|x| x.map(|s| s.to_string()))\n        .collect::\u003cResult\u003cVec\u003cString\u003e, StdError\u003e\u003e()\n}\n\n#[cfg(test)]\npub mod tests {\n    use super::*;\n    use cosmwasm_std::{\n        from_binary,\n        testing::{mock_dependencies, mock_env, mock_info},\n        SubMsg,\n    };\n    //use cosmwasm_std::{coins, Coin, SubMsg};\n\n    fn init_helper(deps: DepsMut) -\u003e Response {\n        let instantiate_msg = InstantiateMsg {\n            name: \"fee_contract\".to_string(),\n            owner: None,\n            treasury: \"treasury\".to_string(),\n        };\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n\n        instantiate(deps, env, info, instantiate_msg).unwrap()\n    }\n\n    #[test]\n    fn test_init_sanity() {\n        let mut deps = mock_dependencies();\n        let res = init_helper(deps.as_mut());\n        assert_eq!(0, res.messages.len());\n    }\n\n    #[test]\n    fn test_modify_info() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            ExecuteMsg::ModifyContractInfo {\n                owner: Some(\"memyselfandi\".to_string()),\n                treasury: Some(\"newtreasury\".to_string()),\n                projects_allocation: Some(Uint128::from(34u128)),\n            },\n        )\n        .unwrap();\n\n        let err = execute(\n            deps.as_mut(),\n            env,\n            info,\n            ExecuteMsg::ModifyContractInfo {\n                owner: Some(\"memyselfandi\".to_string()),\n                treasury: Some(\"newtreasury\".to_string()),\n                projects_allocation: Some(Uint128::from(34u128)),\n            },\n        )\n        .unwrap_err();\n        assert_eq!(err, ContractError::Unauthorized {})\n    }\n\n    #[test]\n    fn test_deposit_funds() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n\n        let info = mock_info(\"creator\", \u0026coins(54u128, \"uluna\"));\n        let env = mock_env();\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            ExecuteMsg::DepositFees {\n                addresses: vec![\"test\".to_string()],\n            },\n        )\n        .unwrap();\n        let response = query(\n            deps.as_ref(),\n            env.clone(),\n            QueryMsg::Amount {\n                address: \"test\".to_string(),\n            },\n        )\n        .unwrap();\n        assert_eq!(\n            from_binary::\u003cVec\u003cCoin\u003e\u003e(\u0026response).unwrap(),\n            coins(54u128 * 75u128 / 100u128, \"uluna\")\n        );\n\n        let response = execute(\n            deps.as_mut(),\n            env,\n            info,\n            ExecuteMsg::DepositFees {\n                addresses: vec![\"test\".to_string()],\n            },\n        )\n        .unwrap();\n        assert_eq!(\n            response.messages,\n            vec![SubMsg::new(BankMsg::Send {\n                to_address: \"treasury\".to_string(),\n                amount: coins(54u128 - 54u128 * 75u128 / 100u128, \"uluna\")\n            })]\n        );\n    }\n\n    #[test]\n    fn test_deposit_funds_before_and_after() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n\n        let info = mock_info(\"creator\", \u0026coins(54u128, \"uluna\"));\n        let env = mock_env();\n\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            ExecuteMsg::DepositFees {\n                addresses: vec![\"test\".to_string()],\n            },\n        )\n        .unwrap();\n\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            ExecuteMsg::DepositFees {\n                addresses: vec![\"test\".to_string()],\n            },\n        )\n        .unwrap();\n\n        let response = query(\n            deps.as_ref(),\n            env.clone(),\n            QueryMsg::Amount {\n                address: \"test\".to_string(),\n            },\n        )\n        .unwrap();\n        assert_eq!(\n            from_binary::\u003cVec\u003cCoin\u003e\u003e(\u0026response).unwrap(),\n            coins(\n                54u128 * 75u128 / 100u128 + 54u128 * 75u128 / 100u128,\n                \"uluna\"\n            )\n        );\n\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            ExecuteMsg::AddAssociatedAddress {\n                address: \"test\".to_string(),\n                fee_address: \"fee\".to_string(),\n            },\n        )\n        .unwrap();\n\n        let response = execute(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            ExecuteMsg::DepositFees {\n                addresses: vec![\"test\".to_string()],\n            },\n        )\n        .unwrap();\n\n        assert_eq!(\n            response.messages,\n            vec![\n                SubMsg::new(BankMsg::Send {\n                    to_address: \"treasury\".to_string(),\n                    amount: coins(54u128 - 54u128 * 75u128 / 100u128, \"uluna\")\n                }),\n                SubMsg::new(BankMsg::Send {\n                    to_address: \"fee\".to_string(),\n                    amount: coins(54u128 * 75u128 / 100u128 * 3u128, \"uluna\")\n                })\n            ]\n        );\n\n        let response = query(\n            deps.as_ref(),\n            env.clone(),\n            QueryMsg::Amount {\n                address: \"test\".to_string(),\n            },\n        )\n        .unwrap();\n        assert_eq!(from_binary::\u003cVec\u003cCoin\u003e\u003e(\u0026response).unwrap(), vec![]);\n\n        let response = execute(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            ExecuteMsg::DepositFees {\n                addresses: vec![\"test\".to_string()],\n            },\n        )\n        .unwrap();\n\n        assert_eq!(\n            response.messages,\n            vec![\n                SubMsg::new(BankMsg::Send {\n                    to_address: \"treasury\".to_string(),\n                    amount: coins(54u128 - 54u128 * 75u128 / 100u128, \"uluna\")\n                }),\n                SubMsg::new(BankMsg::Send {\n                    to_address: \"fee\".to_string(),\n                    amount: coins(54u128 * 75u128 / 100u128, \"uluna\")\n                })\n            ]\n        );\n\n        let response = query(\n            deps.as_ref(),\n            env,\n            QueryMsg::Amount {\n                address: \"test\".to_string(),\n            },\n        )\n        .unwrap();\n        assert_eq!(from_binary::\u003cVec\u003cCoin\u003e\u003e(\u0026response).unwrap(), vec![]);\n    }\n\n    #[test]\n    fn test_multiple_addresses() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n\n        let info = mock_info(\"creator\", \u0026coins(54u128, \"uluna\"));\n        let env = mock_env();\n\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            ExecuteMsg::DepositFees {\n                addresses: vec![\n                    \"test\".to_string(),\n                    \"test1\".to_string(),\n                    \"test2\".to_string(),\n                    \"test3\".to_string(),\n                    \"test4\".to_string(),\n                    \"test5\".to_string(),\n                    \"test6\".to_string(),\n                    \"test7\".to_string(),\n                    \"test8\".to_string(),\n                    \"test9\".to_string(),\n                ],\n            },\n        )\n        .unwrap();\n\n        let response = query(\n            deps.as_ref(),\n            env.clone(),\n            QueryMsg::Addresses {\n                start_after: None,\n                limit: Some(4u32),\n            },\n        )\n        .unwrap();\n        assert_eq!(\n            from_binary::\u003cVec\u003cString\u003e\u003e(\u0026response).unwrap(),\n            [\"test\", \"test1\", \"test2\", \"test3\"]\n        );\n\n        let response = query(\n            deps.as_ref(),\n            env,\n            QueryMsg::Addresses {\n                start_after: Some(\"test3\".to_string()),\n                limit: Some(8u32),\n            },\n        )\n        .unwrap();\n        assert_eq!(\n            from_binary::\u003cVec\u003cString\u003e\u003e(\u0026response).unwrap(),\n            [\"test4\", \"test5\", \"test6\", \"test7\", \"test8\", \"test9\"]\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","fee_distributor","src","error.rs"],"content":"use cosmwasm_std::StdError;\nuse thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized {},\n\n    #[error(\"Fee not paid correctly, please provide only one native asset at a time\")]\n    DepositNotCorrect {},\n\n    #[error(\"Projects fee allocation cannot be higher than 100%\")]\n    AllocationTooHigh {},\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","fee_distributor","src","lib.rs"],"content":"pub mod contract;\nmod error;\npub mod state;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","fee_distributor","src","state.rs"],"content":"use crate::error::ContractError;\nuse cosmwasm_std::{Addr, Coin, Deps};\nuse cw_storage_plus::{Item, Map};\nuse fee_distributor_export::state::ContractInfo;\n\npub const CONTRACT_INFO: Item\u003cContractInfo\u003e = Item::new(\"contract_info\");\npub const ALLOCATED_FUNDS: Map\u003c\u0026Addr, Vec\u003cCoin\u003e\u003e = Map::new(\"allocated_funds\");\npub const ASSOCIATED_FEE_ADDRESS: Map\u003c\u0026Addr, Addr\u003e = Map::new(\"associated_fee_address\");\n\npub fn is_admin(deps: Deps, addr: Addr) -\u003e Result\u003c(), ContractError\u003e {\n    if CONTRACT_INFO.load(deps.storage)?.owner == addr {\n        Ok(())\n    } else {\n        Err(ContractError::Unauthorized {})\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","iliq_token","examples","iliq_schema.rs"],"content":"use std::env::current_dir;\nuse std::fs::create_dir_all;\n\nuse cosmwasm_schema::{export_schema, remove_schemas, schema_for};\n\nuse cw20::{\n    AllAccountsResponse, AllAllowancesResponse, AllowanceResponse, BalanceResponse,\n    TokenInfoResponse,\n};\nuse cw20_base::msg::{ExecuteMsg, InstantiateMsg, QueryMsg};\n\nfn main() {\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"schema\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n\n    export_schema(\u0026schema_for!(InstantiateMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(ExecuteMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(QueryMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(AllowanceResponse), \u0026out_dir);\n    export_schema(\u0026schema_for!(BalanceResponse), \u0026out_dir);\n    export_schema(\u0026schema_for!(TokenInfoResponse), \u0026out_dir);\n    export_schema(\u0026schema_for!(AllAllowancesResponse), \u0026out_dir);\n    export_schema(\u0026schema_for!(AllAccountsResponse), \u0026out_dir);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","iliq_token","src","allowances.rs"],"content":"use cosmwasm_std::{\n    attr, Addr, Binary, BlockInfo, Deps, DepsMut, Env, MessageInfo, Response, StdError, StdResult,\n    Storage, Uint128,\n};\nuse cw20::{AllowanceResponse, Cw20ReceiveMsg, Expiration};\n\nuse crate::error::ContractError;\nuse crate::state::{ALLOWANCES, BALANCES, TOKEN_INFO};\n\npub fn execute_increase_allowance(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    spender: String,\n    amount: Uint128,\n    expires: Option\u003cExpiration\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let spender_addr = deps.api.addr_validate(\u0026spender)?;\n    if spender_addr == info.sender {\n        return Err(ContractError::CannotSetOwnAccount {});\n    }\n\n    ALLOWANCES.update(\n        deps.storage,\n        (\u0026info.sender, \u0026spender_addr),\n        |allow| -\u003e StdResult\u003c_\u003e {\n            let mut val = allow.unwrap_or_default();\n            if let Some(exp) = expires {\n                val.expires = exp;\n            }\n            val.allowance += amount;\n            Ok(val)\n        },\n    )?;\n\n    let res = Response::new().add_attributes(vec![\n        attr(\"action\", \"increase_allowance\"),\n        attr(\"owner\", info.sender),\n        attr(\"spender\", spender),\n        attr(\"amount\", amount),\n    ]);\n    Ok(res)\n}\n\npub fn execute_decrease_allowance(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    spender: String,\n    amount: Uint128,\n    expires: Option\u003cExpiration\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let spender_addr = deps.api.addr_validate(\u0026spender)?;\n    if spender_addr == info.sender {\n        return Err(ContractError::CannotSetOwnAccount {});\n    }\n\n    let key = (\u0026info.sender, \u0026spender_addr);\n    // load value and delete if it hits 0, or update otherwise\n    let mut allowance = ALLOWANCES.load(deps.storage, key)?;\n    if amount \u003c allowance.allowance {\n        // update the new amount\n        allowance.allowance = allowance\n            .allowance\n            .checked_sub(amount)\n            .map_err(StdError::overflow)?;\n        if let Some(exp) = expires {\n            allowance.expires = exp;\n        }\n        ALLOWANCES.save(deps.storage, key, \u0026allowance)?;\n    } else {\n        ALLOWANCES.remove(deps.storage, key);\n    }\n\n    let res = Response::new().add_attributes(vec![\n        attr(\"action\", \"decrease_allowance\"),\n        attr(\"owner\", info.sender),\n        attr(\"spender\", spender),\n        attr(\"amount\", amount),\n    ]);\n    Ok(res)\n}\n\n// this can be used to update a lower allowance - call bucket.update with proper keys\npub fn deduct_allowance(\n    storage: \u0026mut dyn Storage,\n    owner: \u0026Addr,\n    spender: \u0026Addr,\n    block: \u0026BlockInfo,\n    amount: Uint128,\n) -\u003e Result\u003cAllowanceResponse, ContractError\u003e {\n    ALLOWANCES.update(storage, (owner, spender), |current| {\n        match current {\n            Some(mut a) =\u003e {\n                if a.expires.is_expired(block) {\n                    Err(ContractError::Expired {})\n                } else {\n                    // deduct the allowance if enough\n                    a.allowance = a\n                        .allowance\n                        .checked_sub(amount)\n                        .map_err(StdError::overflow)?;\n                    Ok(a)\n                }\n            }\n            None =\u003e Err(ContractError::NoAllowance {}),\n        }\n    })\n}\n\npub fn execute_transfer_from(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    owner: String,\n    recipient: String,\n    amount: Uint128,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let rcpt_addr = deps.api.addr_validate(\u0026recipient)?;\n    let owner_addr = deps.api.addr_validate(\u0026owner)?;\n\n    // deduct allowance before doing anything else have enough allowance\n    deduct_allowance(deps.storage, \u0026owner_addr, \u0026info.sender, \u0026env.block, amount)?;\n\n    BALANCES.update(\n        deps.storage,\n        \u0026owner_addr,\n        |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e {\n            Ok(balance.unwrap_or_default().checked_sub(amount)?)\n        },\n    )?;\n    BALANCES.update(\n        deps.storage,\n        \u0026rcpt_addr,\n        |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e { Ok(balance.unwrap_or_default() + amount) },\n    )?;\n\n    let res = Response::new().add_attributes(vec![\n        attr(\"action\", \"transfer_from\"),\n        attr(\"from\", owner),\n        attr(\"to\", recipient),\n        attr(\"by\", info.sender),\n        attr(\"amount\", amount),\n    ]);\n    Ok(res)\n}\n\npub fn execute_burn_from(\n    deps: DepsMut,\n\n    env: Env,\n    info: MessageInfo,\n    owner: String,\n    amount: Uint128,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let owner_addr = deps.api.addr_validate(\u0026owner)?;\n\n    // deduct allowance before doing anything else have enough allowance\n    deduct_allowance(deps.storage, \u0026owner_addr, \u0026info.sender, \u0026env.block, amount)?;\n\n    // lower balance\n    BALANCES.update(\n        deps.storage,\n        \u0026owner_addr,\n        |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e {\n            Ok(balance.unwrap_or_default().checked_sub(amount)?)\n        },\n    )?;\n    // reduce total_supply\n    TOKEN_INFO.update(deps.storage, |mut meta| -\u003e StdResult\u003c_\u003e {\n        meta.total_supply = meta.total_supply.checked_sub(amount)?;\n        Ok(meta)\n    })?;\n\n    let res = Response::new().add_attributes(vec![\n        attr(\"action\", \"burn_from\"),\n        attr(\"from\", owner),\n        attr(\"by\", info.sender),\n        attr(\"amount\", amount),\n    ]);\n    Ok(res)\n}\n\npub fn execute_send_from(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    owner: String,\n    contract: String,\n    amount: Uint128,\n    msg: Binary,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let rcpt_addr = deps.api.addr_validate(\u0026contract)?;\n    let owner_addr = deps.api.addr_validate(\u0026owner)?;\n\n    // deduct allowance before doing anything else have enough allowance\n    deduct_allowance(deps.storage, \u0026owner_addr, \u0026info.sender, \u0026env.block, amount)?;\n\n    // move the tokens to the contract\n    BALANCES.update(\n        deps.storage,\n        \u0026owner_addr,\n        |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e {\n            Ok(balance.unwrap_or_default().checked_sub(amount)?)\n        },\n    )?;\n    BALANCES.update(\n        deps.storage,\n        \u0026rcpt_addr,\n        |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e { Ok(balance.unwrap_or_default() + amount) },\n    )?;\n\n    let attrs = vec![\n        attr(\"action\", \"send_from\"),\n        attr(\"from\", \u0026owner),\n        attr(\"to\", \u0026contract),\n        attr(\"by\", \u0026info.sender),\n        attr(\"amount\", amount),\n    ];\n\n    // create a send message\n    let msg = Cw20ReceiveMsg {\n        sender: info.sender.into(),\n        amount,\n        msg,\n    }\n    .into_cosmos_msg(contract)?;\n\n    let res = Response::new().add_message(msg).add_attributes(attrs);\n    Ok(res)\n}\n\npub fn query_allowance(deps: Deps, owner: String, spender: String) -\u003e StdResult\u003cAllowanceResponse\u003e {\n    let owner_addr = deps.api.addr_validate(\u0026owner)?;\n    let spender_addr = deps.api.addr_validate(\u0026spender)?;\n    let allowance = ALLOWANCES\n        .may_load(deps.storage, (\u0026owner_addr, \u0026spender_addr))?\n        .unwrap_or_default();\n    Ok(allowance)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use cosmwasm_std::testing::{mock_dependencies_with_balance, mock_env, mock_info};\n    use cosmwasm_std::{coins, CosmosMsg, SubMsg, Timestamp, WasmMsg};\n    use cw20::{Cw20Coin, TokenInfoResponse};\n\n    use crate::contract::{execute, instantiate, query_balance, query_token_info};\n    use crate::msg::{ExecuteMsg, InstantiateMsg};\n\n    fn get_balance\u003cT: Into\u003cString\u003e\u003e(deps: Deps, address: T) -\u003e Uint128 {\n        query_balance(deps, address.into()).unwrap().balance\n    }\n\n    // this will set up the instantiation for other tests\n    fn do_instantiate\u003cT: Into\u003cString\u003e\u003e(\n        mut deps: DepsMut,\n        addr: T,\n        amount: Uint128,\n    ) -\u003e TokenInfoResponse {\n        let instantiate_msg = InstantiateMsg {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: addr.into(),\n                amount,\n            }],\n            mint: None,\n            marketing: None,\n        };\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n        instantiate(deps.branch(), env, info, instantiate_msg).unwrap();\n        query_token_info(deps.as_ref()).unwrap()\n    }\n\n    #[test]\n    fn increase_decrease_allowances() {\n        let mut deps = mock_dependencies_with_balance(\u0026coins(2, \"token\"));\n\n        let owner = String::from(\"addr0001\");\n        let spender = String::from(\"addr0002\");\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        do_instantiate(deps.as_mut(), owner.clone(), Uint128::new(12340000));\n\n        // no allowance to start\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        assert_eq!(allowance, AllowanceResponse::default());\n\n        // set allowance with height expiration\n        let allow1 = Uint128::new(7777);\n        let expires = Expiration::AtHeight(5432);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: allow1,\n            expires: Some(expires),\n        };\n        execute(deps.as_mut(), env.clone(), info.clone(), msg).unwrap();\n\n        // ensure it looks good\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        assert_eq!(\n            allowance,\n            AllowanceResponse {\n                allowance: allow1,\n                expires\n            }\n        );\n\n        // decrease it a bit with no expire set - stays the same\n        let lower = Uint128::new(4444);\n        let allow2 = allow1.checked_sub(lower).unwrap();\n        let msg = ExecuteMsg::DecreaseAllowance {\n            spender: spender.clone(),\n            amount: lower,\n            expires: None,\n        };\n        execute(deps.as_mut(), env.clone(), info.clone(), msg).unwrap();\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        assert_eq!(\n            allowance,\n            AllowanceResponse {\n                allowance: allow2,\n                expires\n            }\n        );\n\n        // increase it some more and override the expires\n        let raise = Uint128::new(87654);\n        let allow3 = allow2 + raise;\n        let new_expire = Expiration::AtTime(Timestamp::from_seconds(8888888888));\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: raise,\n            expires: Some(new_expire),\n        };\n        execute(deps.as_mut(), env.clone(), info.clone(), msg).unwrap();\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        assert_eq!(\n            allowance,\n            AllowanceResponse {\n                allowance: allow3,\n                expires: new_expire\n            }\n        );\n\n        // decrease it below 0\n        let msg = ExecuteMsg::DecreaseAllowance {\n            spender: spender.clone(),\n            amount: Uint128::new(99988647623876347),\n            expires: None,\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n        let allowance = query_allowance(deps.as_ref(), owner, spender).unwrap();\n        assert_eq!(allowance, AllowanceResponse::default());\n    }\n\n    #[test]\n    fn allowances_independent() {\n        let mut deps = mock_dependencies_with_balance(\u0026coins(2, \"token\"));\n\n        let owner = String::from(\"addr0001\");\n        let spender = String::from(\"addr0002\");\n        let spender2 = String::from(\"addr0003\");\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        do_instantiate(deps.as_mut(), \u0026owner, Uint128::new(12340000));\n\n        // no allowance to start\n        assert_eq!(\n            query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap(),\n            AllowanceResponse::default()\n        );\n        assert_eq!(\n            query_allowance(deps.as_ref(), owner.clone(), spender2.clone()).unwrap(),\n            AllowanceResponse::default()\n        );\n        assert_eq!(\n            query_allowance(deps.as_ref(), spender.clone(), spender2.clone()).unwrap(),\n            AllowanceResponse::default()\n        );\n\n        // set allowance with height expiration\n        let allow1 = Uint128::new(7777);\n        let expires = Expiration::AtHeight(5432);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: allow1,\n            expires: Some(expires),\n        };\n        execute(deps.as_mut(), env.clone(), info.clone(), msg).unwrap();\n\n        // set other allowance with no expiration\n        let allow2 = Uint128::new(87654);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender2.clone(),\n            amount: allow2,\n            expires: None,\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // check they are proper\n        let expect_one = AllowanceResponse {\n            allowance: allow1,\n            expires,\n        };\n        let expect_two = AllowanceResponse {\n            allowance: allow2,\n            expires: Expiration::Never {},\n        };\n        assert_eq!(\n            query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap(),\n            expect_one\n        );\n        assert_eq!(\n            query_allowance(deps.as_ref(), owner.clone(), spender2.clone()).unwrap(),\n            expect_two\n        );\n        assert_eq!(\n            query_allowance(deps.as_ref(), spender.clone(), spender2.clone()).unwrap(),\n            AllowanceResponse::default()\n        );\n\n        // also allow spender -\u003e spender2 with no interference\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let allow3 = Uint128::new(1821);\n        let expires3 = Expiration::AtTime(Timestamp::from_seconds(3767626296));\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender2.clone(),\n            amount: allow3,\n            expires: Some(expires3),\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n        let expect_three = AllowanceResponse {\n            allowance: allow3,\n            expires: expires3,\n        };\n        assert_eq!(\n            query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap(),\n            expect_one\n        );\n        assert_eq!(\n            query_allowance(deps.as_ref(), owner, spender2.clone()).unwrap(),\n            expect_two\n        );\n        assert_eq!(\n            query_allowance(deps.as_ref(), spender, spender2).unwrap(),\n            expect_three\n        );\n    }\n\n    #[test]\n    fn no_self_allowance() {\n        let mut deps = mock_dependencies_with_balance(\u0026coins(2, \"token\"));\n\n        let owner = String::from(\"addr0001\");\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        do_instantiate(deps.as_mut(), \u0026owner, Uint128::new(12340000));\n\n        // self-allowance\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: owner.clone(),\n            amount: Uint128::new(7777),\n            expires: None,\n        };\n        let err = execute(deps.as_mut(), env.clone(), info.clone(), msg).unwrap_err();\n        assert_eq!(err, ContractError::CannotSetOwnAccount {});\n\n        // decrease self-allowance\n        let msg = ExecuteMsg::DecreaseAllowance {\n            spender: owner,\n            amount: Uint128::new(7777),\n            expires: None,\n        };\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert_eq!(err, ContractError::CannotSetOwnAccount {});\n    }\n\n    #[test]\n    fn transfer_from_respects_limits() {\n        let mut deps = mock_dependencies_with_balance(\u0026[]);\n        let owner = String::from(\"addr0001\");\n        let spender = String::from(\"addr0002\");\n        let rcpt = String::from(\"addr0003\");\n\n        let start = Uint128::new(999999);\n        do_instantiate(deps.as_mut(), \u0026owner, start);\n\n        // provide an allowance\n        let allow1 = Uint128::new(77777);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: allow1,\n            expires: None,\n        };\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // valid transfer of part of the allowance\n        let transfer = Uint128::new(44444);\n        let msg = ExecuteMsg::TransferFrom {\n            owner: owner.clone(),\n            recipient: rcpt.clone(),\n            amount: transfer,\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let res = execute(deps.as_mut(), env, info, msg).unwrap();\n        assert_eq!(res.attributes[0], attr(\"action\", \"transfer_from\"));\n\n        // make sure money arrived\n        assert_eq!(\n            get_balance(deps.as_ref(), owner.clone()),\n            start.checked_sub(transfer).unwrap()\n        );\n        assert_eq!(get_balance(deps.as_ref(), rcpt.clone()), transfer);\n\n        // ensure it looks good\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        let expect = AllowanceResponse {\n            allowance: allow1.checked_sub(transfer).unwrap(),\n            expires: Expiration::Never {},\n        };\n        assert_eq!(expect, allowance);\n\n        // cannot send more than the allowance\n        let msg = ExecuteMsg::TransferFrom {\n            owner: owner.clone(),\n            recipient: rcpt.clone(),\n            amount: Uint128::new(33443),\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert!(matches!(err, ContractError::Std(StdError::Overflow { .. })));\n\n        // let us increase limit, but set the expiration (default env height is 12_345)\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: Uint128::new(1000),\n            expires: Some(Expiration::AtHeight(env.block.height)),\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // we should now get the expiration error\n        let msg = ExecuteMsg::TransferFrom {\n            owner,\n            recipient: rcpt,\n            amount: Uint128::new(33443),\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert_eq!(err, ContractError::Expired {});\n    }\n\n    #[test]\n    fn burn_from_respects_limits() {\n        let mut deps = mock_dependencies_with_balance(\u0026[]);\n        let owner = String::from(\"addr0001\");\n        let spender = String::from(\"addr0002\");\n\n        let start = Uint128::new(999999);\n        do_instantiate(deps.as_mut(), \u0026owner, start);\n\n        // provide an allowance\n        let allow1 = Uint128::new(77777);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: allow1,\n            expires: None,\n        };\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // valid burn of part of the allowance\n        let transfer = Uint128::new(44444);\n        let msg = ExecuteMsg::BurnFrom {\n            owner: owner.clone(),\n            amount: transfer,\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let res = execute(deps.as_mut(), env, info, msg).unwrap();\n        assert_eq!(res.attributes[0], attr(\"action\", \"burn_from\"));\n\n        // make sure money burnt\n        assert_eq!(\n            get_balance(deps.as_ref(), owner.clone()),\n            start.checked_sub(transfer).unwrap()\n        );\n\n        // ensure it looks good\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        let expect = AllowanceResponse {\n            allowance: allow1.checked_sub(transfer).unwrap(),\n            expires: Expiration::Never {},\n        };\n        assert_eq!(expect, allowance);\n\n        // cannot burn more than the allowance\n        let msg = ExecuteMsg::BurnFrom {\n            owner: owner.clone(),\n            amount: Uint128::new(33443),\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert!(matches!(err, ContractError::Std(StdError::Overflow { .. })));\n\n        // let us increase limit, but set the expiration (default env height is 12_345)\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: Uint128::new(1000),\n            expires: Some(Expiration::AtHeight(env.block.height)),\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // we should now get the expiration error\n        let msg = ExecuteMsg::BurnFrom {\n            owner,\n            amount: Uint128::new(33443),\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert_eq!(err, ContractError::Expired {});\n    }\n\n    #[test]\n    fn send_from_respects_limits() {\n        let mut deps = mock_dependencies_with_balance(\u0026[]);\n        let owner = String::from(\"addr0001\");\n        let spender = String::from(\"addr0002\");\n        let contract = String::from(\"cool-dex\");\n        let send_msg = Binary::from(r#\"{\"some\":123}\"#.as_bytes());\n\n        let start = Uint128::new(999999);\n        do_instantiate(deps.as_mut(), \u0026owner, start);\n\n        // provide an allowance\n        let allow1 = Uint128::new(77777);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: allow1,\n            expires: None,\n        };\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // valid send of part of the allowance\n        let transfer = Uint128::new(44444);\n        let msg = ExecuteMsg::SendFrom {\n            owner: owner.clone(),\n            amount: transfer,\n            contract: contract.clone(),\n            msg: send_msg.clone(),\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let res = execute(deps.as_mut(), env, info, msg).unwrap();\n        assert_eq!(res.attributes[0], attr(\"action\", \"send_from\"));\n        assert_eq!(1, res.messages.len());\n\n        // we record this as sent by the one who requested, not the one who was paying\n        let binary_msg = Cw20ReceiveMsg {\n            sender: spender.clone(),\n            amount: transfer,\n            msg: send_msg.clone(),\n        }\n        .into_binary()\n        .unwrap();\n        assert_eq!(\n            res.messages[0],\n            SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: contract.clone(),\n                msg: binary_msg,\n                funds: vec![],\n            }))\n        );\n\n        // make sure money sent\n        assert_eq!(\n            get_balance(deps.as_ref(), owner.clone()),\n            start.checked_sub(transfer).unwrap()\n        );\n        assert_eq!(get_balance(deps.as_ref(), contract.clone()), transfer);\n\n        // ensure it looks good\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        let expect = AllowanceResponse {\n            allowance: allow1.checked_sub(transfer).unwrap(),\n            expires: Expiration::Never {},\n        };\n        assert_eq!(expect, allowance);\n\n        // cannot send more than the allowance\n        let msg = ExecuteMsg::SendFrom {\n            owner: owner.clone(),\n            amount: Uint128::new(33443),\n            contract: contract.clone(),\n            msg: send_msg.clone(),\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert!(matches!(err, ContractError::Std(StdError::Overflow { .. })));\n\n        // let us increase limit, but set the expiration to current block (expired)\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: Uint128::new(1000),\n            expires: Some(Expiration::AtHeight(env.block.height)),\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // we should now get the expiration error\n        let msg = ExecuteMsg::SendFrom {\n            owner,\n            amount: Uint128::new(33443),\n            contract,\n            msg: send_msg,\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert_eq!(err, ContractError::Expired {});\n    }\n}\n","traces":[{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":9},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","iliq_token","src","contract.rs"],"content":"#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\nuse cosmwasm_std::{to_binary, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult};\n\nuse cw20_base::allowances::{\n    execute_burn_from, execute_decrease_allowance, execute_increase_allowance, execute_send_from,\n    execute_transfer_from, query_allowance,\n};\nuse cw20_base::contract::{\n    execute_burn, execute_mint, execute_send, execute_transfer, execute_update_marketing,\n    execute_upload_logo,\n};\nuse cw20_base::contract::{\n    query_balance, query_download_logo, query_marketing_info, query_minter, query_token_info,\n};\n\nuse cw20_base::enumerable::{query_all_accounts, query_all_allowances};\nuse cw20_base::ContractError;\n\nuse crate::msg::{ExecuteMsg, InstantiateMsg, QueryMsg};\n/*\nuse crate::state::{MinterData, TokenInfo, BALANCES, LOGO, MARKETING_INFO, TOKEN_INFO};\n*/\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let base_instantiate_msg = cw20_base::msg::InstantiateMsg {\n        name: msg.name,\n        symbol: msg.symbol,\n        decimals: msg.decimals,\n        initial_balances: msg.initial_balances,\n        mint: msg.mint,\n        marketing: msg.marketing,\n    };\n\n    cw20_base::contract::instantiate(deps, env, info, base_instantiate_msg)\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    match msg {\n        ExecuteMsg::Transfer { recipient, amount } =\u003e {\n            execute_transfer(deps, env, info, recipient, amount)\n        }\n        ExecuteMsg::Burn { amount } =\u003e execute_burn(deps, env, info, amount),\n        ExecuteMsg::Send {\n            contract,\n            amount,\n            msg,\n        } =\u003e execute_send(deps, env, info, contract, amount, msg),\n        ExecuteMsg::Mint { recipient, amount } =\u003e execute_mint(deps, env, info, recipient, amount),\n        ExecuteMsg::IncreaseAllowance {\n            spender,\n            amount,\n            expires,\n        } =\u003e execute_increase_allowance(deps, env, info, spender, amount, expires),\n        ExecuteMsg::DecreaseAllowance {\n            spender,\n            amount,\n            expires,\n        } =\u003e execute_decrease_allowance(deps, env, info, spender, amount, expires),\n        ExecuteMsg::TransferFrom {\n            owner,\n            recipient,\n            amount,\n        } =\u003e execute_transfer_from(deps, env, info, owner, recipient, amount),\n        ExecuteMsg::BurnFrom { owner, amount } =\u003e execute_burn_from(deps, env, info, owner, amount),\n        ExecuteMsg::SendFrom {\n            owner,\n            contract,\n            amount,\n            msg,\n        } =\u003e execute_send_from(deps, env, info, owner, contract, amount, msg),\n        ExecuteMsg::UpdateMarketing {\n            project,\n            description,\n            marketing,\n        } =\u003e execute_update_marketing(deps, env, info, project, description, marketing),\n        ExecuteMsg::UploadLogo(logo) =\u003e execute_upload_logo(deps, env, info, logo),\n    }\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::Balance { address } =\u003e to_binary(\u0026query_balance(deps, address)?),\n        QueryMsg::TokenInfo {} =\u003e to_binary(\u0026query_token_info(deps)?),\n        QueryMsg::Minter {} =\u003e to_binary(\u0026query_minter(deps)?),\n        QueryMsg::Allowance { owner, spender } =\u003e {\n            to_binary(\u0026query_allowance(deps, owner, spender)?)\n        }\n        QueryMsg::AllAllowances {\n            owner,\n            start_after,\n            limit,\n        } =\u003e to_binary(\u0026query_all_allowances(deps, owner, start_after, limit)?),\n        QueryMsg::AllAccounts { start_after, limit } =\u003e {\n            to_binary(\u0026query_all_accounts(deps, start_after, limit)?)\n        }\n        QueryMsg::MarketingInfo {} =\u003e to_binary(\u0026query_marketing_info(deps)?),\n        QueryMsg::DownloadLogo {} =\u003e to_binary(\u0026query_download_logo(deps)?),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","iliq_token","src","enumerable.rs"],"content":"use cosmwasm_std::{Deps, Order, StdResult};\nuse cw20::{AllAccountsResponse, AllAllowancesResponse, AllowanceInfo};\n\nuse crate::state::{ALLOWANCES, BALANCES};\nuse cw_storage_plus::Bound;\n\n// settings for pagination\nconst MAX_LIMIT: u32 = 30;\nconst DEFAULT_LIMIT: u32 = 10;\n\npub fn query_all_allowances(\n    deps: Deps,\n    owner: String,\n    start_after: Option\u003cString\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e StdResult\u003cAllAllowancesResponse\u003e {\n    let owner_addr = deps.api.addr_validate(\u0026owner)?;\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n    let start = start_after.map(|s| Bound::ExclusiveRaw(s.into_bytes()));\n\n    let allowances = ALLOWANCES\n        .prefix(\u0026owner_addr)\n        .range(deps.storage, start, None, Order::Ascending)\n        .take(limit)\n        .map(|item| {\n            item.map(|(addr, allow)| AllowanceInfo {\n                spender: addr.into(),\n                allowance: allow.allowance,\n                expires: allow.expires,\n            })\n        })\n        .collect::\u003cStdResult\u003c_\u003e\u003e()?;\n    Ok(AllAllowancesResponse { allowances })\n}\n\npub fn query_all_accounts(\n    deps: Deps,\n    start_after: Option\u003cString\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e StdResult\u003cAllAccountsResponse\u003e {\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n    let start = start_after.map(|s| Bound::ExclusiveRaw(s.into()));\n\n    let accounts = BALANCES\n        .keys(deps.storage, start, None, Order::Ascending)\n        .take(limit)\n        .map(|item| item.map(Into::into))\n        .collect::\u003cStdResult\u003c_\u003e\u003e()?;\n\n    Ok(AllAccountsResponse { accounts })\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use cosmwasm_std::testing::{mock_dependencies_with_balance, mock_env, mock_info};\n    use cosmwasm_std::{coins, DepsMut, Uint128};\n    use cw20::{Cw20Coin, Expiration, TokenInfoResponse};\n\n    use crate::contract::{execute, instantiate, query_token_info};\n    use crate::msg::{ExecuteMsg, InstantiateMsg};\n\n    // this will set up the instantiation for other tests\n    fn do_instantiate(mut deps: DepsMut, addr: \u0026str, amount: Uint128) -\u003e TokenInfoResponse {\n        let instantiate_msg = InstantiateMsg {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: addr.into(),\n                amount,\n            }],\n            mint: None,\n            marketing: None,\n        };\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n        instantiate(deps.branch(), env, info, instantiate_msg).unwrap();\n        query_token_info(deps.as_ref()).unwrap()\n    }\n\n    #[test]\n    fn query_all_allowances_works() {\n        let mut deps = mock_dependencies_with_balance(\u0026coins(2, \"token\"));\n\n        let owner = String::from(\"owner\");\n        // these are in alphabetical order same than insert order\n        let spender1 = String::from(\"earlier\");\n        let spender2 = String::from(\"later\");\n\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        do_instantiate(deps.as_mut(), \u0026owner, Uint128::new(12340000));\n\n        // no allowance to start\n        let allowances = query_all_allowances(deps.as_ref(), owner.clone(), None, None).unwrap();\n        assert_eq!(allowances.allowances, vec![]);\n\n        // set allowance with height expiration\n        let allow1 = Uint128::new(7777);\n        let expires = Expiration::AtHeight(5432);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender1.clone(),\n            amount: allow1,\n            expires: Some(expires),\n        };\n        execute(deps.as_mut(), env.clone(), info.clone(), msg).unwrap();\n\n        // set allowance with no expiration\n        let allow2 = Uint128::new(54321);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender2.clone(),\n            amount: allow2,\n            expires: None,\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // query list gets 2\n        let allowances = query_all_allowances(deps.as_ref(), owner.clone(), None, None).unwrap();\n        assert_eq!(allowances.allowances.len(), 2);\n\n        // first one is spender1 (order of CanonicalAddr uncorrelated with String)\n        let allowances = query_all_allowances(deps.as_ref(), owner.clone(), None, Some(1)).unwrap();\n        assert_eq!(allowances.allowances.len(), 1);\n        let allow = \u0026allowances.allowances[0];\n        assert_eq!(\u0026allow.spender, \u0026spender1);\n        assert_eq!(\u0026allow.expires, \u0026expires);\n        assert_eq!(\u0026allow.allowance, \u0026allow1);\n\n        // next one is spender2\n        let allowances = query_all_allowances(\n            deps.as_ref(),\n            owner,\n            Some(allow.spender.clone()),\n            Some(10000),\n        )\n        .unwrap();\n        assert_eq!(allowances.allowances.len(), 1);\n        let allow = \u0026allowances.allowances[0];\n        assert_eq!(\u0026allow.spender, \u0026spender2);\n        assert_eq!(\u0026allow.expires, \u0026Expiration::Never {});\n        assert_eq!(\u0026allow.allowance, \u0026allow2);\n    }\n\n    #[test]\n    fn query_all_accounts_works() {\n        let mut deps = mock_dependencies_with_balance(\u0026coins(2, \"token\"));\n\n        // insert order and lexicographical order are different\n        let acct1 = String::from(\"acct01\");\n        let acct2 = String::from(\"zebra\");\n        let acct3 = String::from(\"nice\");\n        let acct4 = String::from(\"aaaardvark\");\n        let expected_order = [acct4.clone(), acct1.clone(), acct3.clone(), acct2.clone()];\n\n        do_instantiate(deps.as_mut(), \u0026acct1, Uint128::new(12340000));\n\n        // put money everywhere (to create balanaces)\n        let info = mock_info(acct1.as_ref(), \u0026[]);\n        let env = mock_env();\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            ExecuteMsg::Transfer {\n                recipient: acct2,\n                amount: Uint128::new(222222),\n            },\n        )\n        .unwrap();\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            ExecuteMsg::Transfer {\n                recipient: acct3,\n                amount: Uint128::new(333333),\n            },\n        )\n        .unwrap();\n        execute(\n            deps.as_mut(),\n            env,\n            info,\n            ExecuteMsg::Transfer {\n                recipient: acct4,\n                amount: Uint128::new(444444),\n            },\n        )\n        .unwrap();\n\n        // make sure we get the proper results\n        let accounts = query_all_accounts(deps.as_ref(), None, None).unwrap();\n        assert_eq!(accounts.accounts, expected_order);\n\n        // let's do pagination\n        let accounts = query_all_accounts(deps.as_ref(), None, Some(2)).unwrap();\n        assert_eq!(accounts.accounts, expected_order[0..2].to_vec());\n\n        let accounts =\n            query_all_accounts(deps.as_ref(), Some(accounts.accounts[1].clone()), Some(1)).unwrap();\n        assert_eq!(accounts.accounts, expected_order[2..3].to_vec());\n\n        let accounts =\n            query_all_accounts(deps.as_ref(), Some(accounts.accounts[0].clone()), Some(777))\n                .unwrap();\n        assert_eq!(accounts.accounts, expected_order[3..].to_vec());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","iliq_token","src","error.rs"],"content":"use cosmwasm_std::StdError;\nuse thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized {},\n\n    #[error(\"Cannot set to own account\")]\n    CannotSetOwnAccount {},\n\n    #[error(\"Invalid zero amount\")]\n    InvalidZeroAmount {},\n\n    #[error(\"Allowance is expired\")]\n    Expired {},\n\n    #[error(\"No allowance for this account\")]\n    NoAllowance {},\n\n    #[error(\"Minting cannot exceed the cap\")]\n    CannotExceedCap {},\n\n    #[error(\"Logo binary data exceeds 5KB limit\")]\n    LogoTooBig {},\n\n    #[error(\"Invalid xml preamble for SVG\")]\n    InvalidXmlPreamble {},\n\n    #[error(\"Invalid png header\")]\n    InvalidPngHeader {},\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","iliq_token","src","lib.rs"],"content":"pub mod contract;\nmod error;\npub mod msg;\n\npub use crate::error::ContractError;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","iliq_token","src","msg.rs"],"content":"use cosmwasm_std::{StdError, StdResult, Uint128};\nuse cw20::MinterResponse;\nuse cw20_base::msg::InstantiateMarketingInfo;\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\npub use cw20::Cw20ExecuteMsg as ExecuteMsg;\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct InstantiateMsg {\n    pub custom: String,\n    pub name: String,\n    pub symbol: String,\n    pub decimals: u8,\n    pub initial_balances: Vec\u003ccw20::Cw20Coin\u003e,\n    pub mint: Option\u003cMinterResponse\u003e,\n    pub marketing: Option\u003cInstantiateMarketingInfo\u003e,\n}\n\nimpl InstantiateMsg {\n    pub fn get_cap(\u0026self) -\u003e Option\u003cUint128\u003e {\n        self.mint.as_ref().and_then(|v| v.cap)\n    }\n\n    pub fn validate(\u0026self) -\u003e StdResult\u003c()\u003e {\n        // Check name, symbol, decimals\n        if !is_valid_name(\u0026self.name) {\n            return Err(StdError::generic_err(\n                \"Name is not in the expected format (3-50 UTF-8 bytes)\",\n            ));\n        }\n        if !is_valid_symbol(\u0026self.symbol) {\n            return Err(StdError::generic_err(\n                \"Ticker symbol is not in expected format [a-zA-Z\\\\-]{3,12}\",\n            ));\n        }\n        if self.decimals \u003e 18 {\n            return Err(StdError::generic_err(\"Decimals must not exceed 18\"));\n        }\n        Ok(())\n    }\n}\n\nfn is_valid_name(name: \u0026str) -\u003e bool {\n    let bytes = name.as_bytes();\n    if bytes.len() \u003c 3 || bytes.len() \u003e 50 {\n        return false;\n    }\n    true\n}\n\nfn is_valid_symbol(symbol: \u0026str) -\u003e bool {\n    let bytes = symbol.as_bytes();\n    if bytes.len() \u003c 3 || bytes.len() \u003e 12 {\n        return false;\n    }\n    for byte in bytes.iter() {\n        if (*byte != 45) \u0026\u0026 (*byte \u003c 65 || *byte \u003e 90) \u0026\u0026 (*byte \u003c 97 || *byte \u003e 122) {\n            return false;\n        }\n    }\n    true\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    /// Returns the current balance of the given address, 0 if unset.\n    /// Return type: BalanceResponse.\n    Balance { address: String },\n    /// Returns metadata on the contract - name, decimals, supply, etc.\n    /// Return type: TokenInfoResponse.\n    TokenInfo {},\n    /// Only with \"mintable\" extension.\n    /// Returns who can mint and the hard cap on maximum tokens after minting.\n    /// Return type: MinterResponse.\n    Minter {},\n    /// Only with \"allowance\" extension.\n    /// Returns how much spender can use from owner account, 0 if unset.\n    /// Return type: AllowanceResponse.\n    Allowance { owner: String, spender: String },\n    /// Only with \"enumerable\" extension (and \"allowances\")\n    /// Returns all allowances this owner has approved. Supports pagination.\n    /// Return type: AllAllowancesResponse.\n    AllAllowances {\n        owner: String,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    },\n    /// Only with \"enumerable\" extension\n    /// Returns all accounts that have balances. Supports pagination.\n    /// Return type: AllAccountsResponse.\n    AllAccounts {\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    },\n    /// Only with \"marketing\" extension\n    /// Returns more metadata on the contract to display in the client:\n    /// - description, logo, project url, etc.\n    /// Return type: MarketingInfoResponse\n    MarketingInfo {},\n    /// Only with \"marketing\" extension\n    /// Downloads the mbeded logo data (if stored on chain). Errors if no logo data ftored for this\n    /// contract.\n    /// Return type: DownloadLogoResponse.\n    DownloadLogo {},\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","lender","examples","lender_schema.rs"],"content":"use std::env::current_dir;\nuse std::fs::create_dir_all;\n\nuse cosmwasm_schema::{export_schema, remove_schemas, schema_for};\n\nuse lender_export::msg::{ExecuteMsg, InstantiateMsg, QueryMsg};\n\nfn main() {\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"schema\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n\n    export_schema(\u0026schema_for!(InstantiateMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(ExecuteMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(QueryMsg), \u0026out_dir);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","lender","src","allowances.rs"],"content":"use cosmwasm_std::{\n    attr, Addr, Binary, BlockInfo, Deps, DepsMut, Env, MessageInfo, Response, StdError, StdResult,\n    Storage, Uint128,\n};\nuse cw20::{AllowanceResponse, Cw20ReceiveMsg, Expiration};\n\nuse crate::error::ContractError;\nuse crate::state::{ALLOWANCES, BALANCES, TOKEN_INFO};\n\npub fn execute_increase_allowance(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    spender: String,\n    amount: Uint128,\n    expires: Option\u003cExpiration\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let spender_addr = deps.api.addr_validate(\u0026spender)?;\n    if spender_addr == info.sender {\n        return Err(ContractError::CannotSetOwnAccount {});\n    }\n\n    ALLOWANCES.update(\n        deps.storage,\n        (\u0026info.sender, \u0026spender_addr),\n        |allow| -\u003e StdResult\u003c_\u003e {\n            let mut val = allow.unwrap_or_default();\n            if let Some(exp) = expires {\n                val.expires = exp;\n            }\n            val.allowance += amount;\n            Ok(val)\n        },\n    )?;\n\n    let res = Response::new().add_attributes(vec![\n        attr(\"action\", \"increase_allowance\"),\n        attr(\"owner\", info.sender),\n        attr(\"spender\", spender),\n        attr(\"amount\", amount),\n    ]);\n    Ok(res)\n}\n\npub fn execute_decrease_allowance(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    spender: String,\n    amount: Uint128,\n    expires: Option\u003cExpiration\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let spender_addr = deps.api.addr_validate(\u0026spender)?;\n    if spender_addr == info.sender {\n        return Err(ContractError::CannotSetOwnAccount {});\n    }\n\n    let key = (\u0026info.sender, \u0026spender_addr);\n    // load value and delete if it hits 0, or update otherwise\n    let mut allowance = ALLOWANCES.load(deps.storage, key)?;\n    if amount \u003c allowance.allowance {\n        // update the new amount\n        allowance.allowance = allowance\n            .allowance\n            .checked_sub(amount)\n            .map_err(StdError::overflow)?;\n        if let Some(exp) = expires {\n            allowance.expires = exp;\n        }\n        ALLOWANCES.save(deps.storage, key, \u0026allowance)?;\n    } else {\n        ALLOWANCES.remove(deps.storage, key);\n    }\n\n    let res = Response::new().add_attributes(vec![\n        attr(\"action\", \"decrease_allowance\"),\n        attr(\"owner\", info.sender),\n        attr(\"spender\", spender),\n        attr(\"amount\", amount),\n    ]);\n    Ok(res)\n}\n\n// this can be used to update a lower allowance - call bucket.update with proper keys\npub fn deduct_allowance(\n    storage: \u0026mut dyn Storage,\n    owner: \u0026Addr,\n    spender: \u0026Addr,\n    block: \u0026BlockInfo,\n    amount: Uint128,\n) -\u003e Result\u003cAllowanceResponse, ContractError\u003e {\n    ALLOWANCES.update(storage, (owner, spender), |current| {\n        match current {\n            Some(mut a) =\u003e {\n                if a.expires.is_expired(block) {\n                    Err(ContractError::Expired {})\n                } else {\n                    // deduct the allowance if enough\n                    a.allowance = a\n                        .allowance\n                        .checked_sub(amount)\n                        .map_err(StdError::overflow)?;\n                    Ok(a)\n                }\n            }\n            None =\u003e Err(ContractError::NoAllowance {}),\n        }\n    })\n}\n\npub fn execute_transfer_from(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    owner: String,\n    recipient: String,\n    amount: Uint128,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let rcpt_addr = deps.api.addr_validate(\u0026recipient)?;\n    let owner_addr = deps.api.addr_validate(\u0026owner)?;\n\n    // deduct allowance before doing anything else have enough allowance\n    deduct_allowance(deps.storage, \u0026owner_addr, \u0026info.sender, \u0026env.block, amount)?;\n\n    BALANCES.update(\n        deps.storage,\n        \u0026owner_addr,\n        |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e {\n            Ok(balance.unwrap_or_default().checked_sub(amount)?)\n        },\n    )?;\n    BALANCES.update(\n        deps.storage,\n        \u0026rcpt_addr,\n        |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e { Ok(balance.unwrap_or_default() + amount) },\n    )?;\n\n    let res = Response::new().add_attributes(vec![\n        attr(\"action\", \"transfer_from\"),\n        attr(\"from\", owner),\n        attr(\"to\", recipient),\n        attr(\"by\", info.sender),\n        attr(\"amount\", amount),\n    ]);\n    Ok(res)\n}\n\npub fn execute_burn_from(\n    deps: DepsMut,\n\n    env: Env,\n    info: MessageInfo,\n    owner: String,\n    amount: Uint128,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let owner_addr = deps.api.addr_validate(\u0026owner)?;\n\n    // deduct allowance before doing anything else have enough allowance\n    deduct_allowance(deps.storage, \u0026owner_addr, \u0026info.sender, \u0026env.block, amount)?;\n\n    // lower balance\n    BALANCES.update(\n        deps.storage,\n        \u0026owner_addr,\n        |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e {\n            Ok(balance.unwrap_or_default().checked_sub(amount)?)\n        },\n    )?;\n    // reduce total_supply\n    TOKEN_INFO.update(deps.storage, |mut meta| -\u003e StdResult\u003c_\u003e {\n        meta.total_supply = meta.total_supply.checked_sub(amount)?;\n        Ok(meta)\n    })?;\n\n    let res = Response::new().add_attributes(vec![\n        attr(\"action\", \"burn_from\"),\n        attr(\"from\", owner),\n        attr(\"by\", info.sender),\n        attr(\"amount\", amount),\n    ]);\n    Ok(res)\n}\n\npub fn execute_send_from(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    owner: String,\n    contract: String,\n    amount: Uint128,\n    msg: Binary,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let rcpt_addr = deps.api.addr_validate(\u0026contract)?;\n    let owner_addr = deps.api.addr_validate(\u0026owner)?;\n\n    // deduct allowance before doing anything else have enough allowance\n    deduct_allowance(deps.storage, \u0026owner_addr, \u0026info.sender, \u0026env.block, amount)?;\n\n    // move the tokens to the contract\n    BALANCES.update(\n        deps.storage,\n        \u0026owner_addr,\n        |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e {\n            Ok(balance.unwrap_or_default().checked_sub(amount)?)\n        },\n    )?;\n    BALANCES.update(\n        deps.storage,\n        \u0026rcpt_addr,\n        |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e { Ok(balance.unwrap_or_default() + amount) },\n    )?;\n\n    let attrs = vec![\n        attr(\"action\", \"send_from\"),\n        attr(\"from\", \u0026owner),\n        attr(\"to\", \u0026contract),\n        attr(\"by\", \u0026info.sender),\n        attr(\"amount\", amount),\n    ];\n\n    // create a send message\n    let msg = Cw20ReceiveMsg {\n        sender: info.sender.into(),\n        amount,\n        msg,\n    }\n    .into_cosmos_msg(contract)?;\n\n    let res = Response::new().add_message(msg).add_attributes(attrs);\n    Ok(res)\n}\n\npub fn query_allowance(deps: Deps, owner: String, spender: String) -\u003e StdResult\u003cAllowanceResponse\u003e {\n    let owner_addr = deps.api.addr_validate(\u0026owner)?;\n    let spender_addr = deps.api.addr_validate(\u0026spender)?;\n    let allowance = ALLOWANCES\n        .may_load(deps.storage, (\u0026owner_addr, \u0026spender_addr))?\n        .unwrap_or_default();\n    Ok(allowance)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use cosmwasm_std::testing::{mock_dependencies_with_balance, mock_env, mock_info};\n    use cosmwasm_std::{coins, CosmosMsg, SubMsg, Timestamp, WasmMsg};\n    use cw20::{Cw20Coin, TokenInfoResponse};\n\n    use crate::contract::{execute, instantiate, query_balance, query_token_info};\n    use crate::msg::{ExecuteMsg, InstantiateMsg};\n\n    fn get_balance\u003cT: Into\u003cString\u003e\u003e(deps: Deps, address: T) -\u003e Uint128 {\n        query_balance(deps, address.into()).unwrap().balance\n    }\n\n    // this will set up the instantiation for other tests\n    fn do_instantiate\u003cT: Into\u003cString\u003e\u003e(\n        mut deps: DepsMut,\n        addr: T,\n        amount: Uint128,\n    ) -\u003e TokenInfoResponse {\n        let instantiate_msg = InstantiateMsg {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: addr.into(),\n                amount,\n            }],\n            mint: None,\n            marketing: None,\n        };\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n        instantiate(deps.branch(), env, info, instantiate_msg).unwrap();\n        query_token_info(deps.as_ref()).unwrap()\n    }\n\n    #[test]\n    fn increase_decrease_allowances() {\n        let mut deps = mock_dependencies_with_balance(\u0026coins(2, \"token\"));\n\n        let owner = String::from(\"addr0001\");\n        let spender = String::from(\"addr0002\");\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        do_instantiate(deps.as_mut(), owner.clone(), Uint128::new(12340000));\n\n        // no allowance to start\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        assert_eq!(allowance, AllowanceResponse::default());\n\n        // set allowance with height expiration\n        let allow1 = Uint128::new(7777);\n        let expires = Expiration::AtHeight(5432);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: allow1,\n            expires: Some(expires),\n        };\n        execute(deps.as_mut(), env.clone(), info.clone(), msg).unwrap();\n\n        // ensure it looks good\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        assert_eq!(\n            allowance,\n            AllowanceResponse {\n                allowance: allow1,\n                expires\n            }\n        );\n\n        // decrease it a bit with no expire set - stays the same\n        let lower = Uint128::new(4444);\n        let allow2 = allow1.checked_sub(lower).unwrap();\n        let msg = ExecuteMsg::DecreaseAllowance {\n            spender: spender.clone(),\n            amount: lower,\n            expires: None,\n        };\n        execute(deps.as_mut(), env.clone(), info.clone(), msg).unwrap();\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        assert_eq!(\n            allowance,\n            AllowanceResponse {\n                allowance: allow2,\n                expires\n            }\n        );\n\n        // increase it some more and override the expires\n        let raise = Uint128::new(87654);\n        let allow3 = allow2 + raise;\n        let new_expire = Expiration::AtTime(Timestamp::from_seconds(8888888888));\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: raise,\n            expires: Some(new_expire),\n        };\n        execute(deps.as_mut(), env.clone(), info.clone(), msg).unwrap();\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        assert_eq!(\n            allowance,\n            AllowanceResponse {\n                allowance: allow3,\n                expires: new_expire\n            }\n        );\n\n        // decrease it below 0\n        let msg = ExecuteMsg::DecreaseAllowance {\n            spender: spender.clone(),\n            amount: Uint128::new(99988647623876347),\n            expires: None,\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n        let allowance = query_allowance(deps.as_ref(), owner, spender).unwrap();\n        assert_eq!(allowance, AllowanceResponse::default());\n    }\n\n    #[test]\n    fn allowances_independent() {\n        let mut deps = mock_dependencies_with_balance(\u0026coins(2, \"token\"));\n\n        let owner = String::from(\"addr0001\");\n        let spender = String::from(\"addr0002\");\n        let spender2 = String::from(\"addr0003\");\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        do_instantiate(deps.as_mut(), \u0026owner, Uint128::new(12340000));\n\n        // no allowance to start\n        assert_eq!(\n            query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap(),\n            AllowanceResponse::default()\n        );\n        assert_eq!(\n            query_allowance(deps.as_ref(), owner.clone(), spender2.clone()).unwrap(),\n            AllowanceResponse::default()\n        );\n        assert_eq!(\n            query_allowance(deps.as_ref(), spender.clone(), spender2.clone()).unwrap(),\n            AllowanceResponse::default()\n        );\n\n        // set allowance with height expiration\n        let allow1 = Uint128::new(7777);\n        let expires = Expiration::AtHeight(5432);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: allow1,\n            expires: Some(expires),\n        };\n        execute(deps.as_mut(), env.clone(), info.clone(), msg).unwrap();\n\n        // set other allowance with no expiration\n        let allow2 = Uint128::new(87654);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender2.clone(),\n            amount: allow2,\n            expires: None,\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // check they are proper\n        let expect_one = AllowanceResponse {\n            allowance: allow1,\n            expires,\n        };\n        let expect_two = AllowanceResponse {\n            allowance: allow2,\n            expires: Expiration::Never {},\n        };\n        assert_eq!(\n            query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap(),\n            expect_one\n        );\n        assert_eq!(\n            query_allowance(deps.as_ref(), owner.clone(), spender2.clone()).unwrap(),\n            expect_two\n        );\n        assert_eq!(\n            query_allowance(deps.as_ref(), spender.clone(), spender2.clone()).unwrap(),\n            AllowanceResponse::default()\n        );\n\n        // also allow spender -\u003e spender2 with no interference\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let allow3 = Uint128::new(1821);\n        let expires3 = Expiration::AtTime(Timestamp::from_seconds(3767626296));\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender2.clone(),\n            amount: allow3,\n            expires: Some(expires3),\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n        let expect_three = AllowanceResponse {\n            allowance: allow3,\n            expires: expires3,\n        };\n        assert_eq!(\n            query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap(),\n            expect_one\n        );\n        assert_eq!(\n            query_allowance(deps.as_ref(), owner, spender2.clone()).unwrap(),\n            expect_two\n        );\n        assert_eq!(\n            query_allowance(deps.as_ref(), spender, spender2).unwrap(),\n            expect_three\n        );\n    }\n\n    #[test]\n    fn no_self_allowance() {\n        let mut deps = mock_dependencies_with_balance(\u0026coins(2, \"token\"));\n\n        let owner = String::from(\"addr0001\");\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        do_instantiate(deps.as_mut(), \u0026owner, Uint128::new(12340000));\n\n        // self-allowance\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: owner.clone(),\n            amount: Uint128::new(7777),\n            expires: None,\n        };\n        let err = execute(deps.as_mut(), env.clone(), info.clone(), msg).unwrap_err();\n        assert_eq!(err, ContractError::CannotSetOwnAccount {});\n\n        // decrease self-allowance\n        let msg = ExecuteMsg::DecreaseAllowance {\n            spender: owner,\n            amount: Uint128::new(7777),\n            expires: None,\n        };\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert_eq!(err, ContractError::CannotSetOwnAccount {});\n    }\n\n    #[test]\n    fn transfer_from_respects_limits() {\n        let mut deps = mock_dependencies_with_balance(\u0026[]);\n        let owner = String::from(\"addr0001\");\n        let spender = String::from(\"addr0002\");\n        let rcpt = String::from(\"addr0003\");\n\n        let start = Uint128::new(999999);\n        do_instantiate(deps.as_mut(), \u0026owner, start);\n\n        // provide an allowance\n        let allow1 = Uint128::new(77777);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: allow1,\n            expires: None,\n        };\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // valid transfer of part of the allowance\n        let transfer = Uint128::new(44444);\n        let msg = ExecuteMsg::TransferFrom {\n            owner: owner.clone(),\n            recipient: rcpt.clone(),\n            amount: transfer,\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let res = execute(deps.as_mut(), env, info, msg).unwrap();\n        assert_eq!(res.attributes[0], attr(\"action\", \"transfer_from\"));\n\n        // make sure money arrived\n        assert_eq!(\n            get_balance(deps.as_ref(), owner.clone()),\n            start.checked_sub(transfer).unwrap()\n        );\n        assert_eq!(get_balance(deps.as_ref(), rcpt.clone()), transfer);\n\n        // ensure it looks good\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        let expect = AllowanceResponse {\n            allowance: allow1.checked_sub(transfer).unwrap(),\n            expires: Expiration::Never {},\n        };\n        assert_eq!(expect, allowance);\n\n        // cannot send more than the allowance\n        let msg = ExecuteMsg::TransferFrom {\n            owner: owner.clone(),\n            recipient: rcpt.clone(),\n            amount: Uint128::new(33443),\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert!(matches!(err, ContractError::Std(StdError::Overflow { .. })));\n\n        // let us increase limit, but set the expiration (default env height is 12_345)\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: Uint128::new(1000),\n            expires: Some(Expiration::AtHeight(env.block.height)),\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // we should now get the expiration error\n        let msg = ExecuteMsg::TransferFrom {\n            owner,\n            recipient: rcpt,\n            amount: Uint128::new(33443),\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert_eq!(err, ContractError::Expired {});\n    }\n\n    #[test]\n    fn burn_from_respects_limits() {\n        let mut deps = mock_dependencies_with_balance(\u0026[]);\n        let owner = String::from(\"addr0001\");\n        let spender = String::from(\"addr0002\");\n\n        let start = Uint128::new(999999);\n        do_instantiate(deps.as_mut(), \u0026owner, start);\n\n        // provide an allowance\n        let allow1 = Uint128::new(77777);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: allow1,\n            expires: None,\n        };\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // valid burn of part of the allowance\n        let transfer = Uint128::new(44444);\n        let msg = ExecuteMsg::BurnFrom {\n            owner: owner.clone(),\n            amount: transfer,\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let res = execute(deps.as_mut(), env, info, msg).unwrap();\n        assert_eq!(res.attributes[0], attr(\"action\", \"burn_from\"));\n\n        // make sure money burnt\n        assert_eq!(\n            get_balance(deps.as_ref(), owner.clone()),\n            start.checked_sub(transfer).unwrap()\n        );\n\n        // ensure it looks good\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        let expect = AllowanceResponse {\n            allowance: allow1.checked_sub(transfer).unwrap(),\n            expires: Expiration::Never {},\n        };\n        assert_eq!(expect, allowance);\n\n        // cannot burn more than the allowance\n        let msg = ExecuteMsg::BurnFrom {\n            owner: owner.clone(),\n            amount: Uint128::new(33443),\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert!(matches!(err, ContractError::Std(StdError::Overflow { .. })));\n\n        // let us increase limit, but set the expiration (default env height is 12_345)\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: Uint128::new(1000),\n            expires: Some(Expiration::AtHeight(env.block.height)),\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // we should now get the expiration error\n        let msg = ExecuteMsg::BurnFrom {\n            owner,\n            amount: Uint128::new(33443),\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert_eq!(err, ContractError::Expired {});\n    }\n\n    #[test]\n    fn send_from_respects_limits() {\n        let mut deps = mock_dependencies_with_balance(\u0026[]);\n        let owner = String::from(\"addr0001\");\n        let spender = String::from(\"addr0002\");\n        let contract = String::from(\"cool-dex\");\n        let send_msg = Binary::from(r#\"{\"some\":123}\"#.as_bytes());\n\n        let start = Uint128::new(999999);\n        do_instantiate(deps.as_mut(), \u0026owner, start);\n\n        // provide an allowance\n        let allow1 = Uint128::new(77777);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: allow1,\n            expires: None,\n        };\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // valid send of part of the allowance\n        let transfer = Uint128::new(44444);\n        let msg = ExecuteMsg::SendFrom {\n            owner: owner.clone(),\n            amount: transfer,\n            contract: contract.clone(),\n            msg: send_msg.clone(),\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let res = execute(deps.as_mut(), env, info, msg).unwrap();\n        assert_eq!(res.attributes[0], attr(\"action\", \"send_from\"));\n        assert_eq!(1, res.messages.len());\n\n        // we record this as sent by the one who requested, not the one who was paying\n        let binary_msg = Cw20ReceiveMsg {\n            sender: spender.clone(),\n            amount: transfer,\n            msg: send_msg.clone(),\n        }\n        .into_binary()\n        .unwrap();\n        assert_eq!(\n            res.messages[0],\n            SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: contract.clone(),\n                msg: binary_msg,\n                funds: vec![],\n            }))\n        );\n\n        // make sure money sent\n        assert_eq!(\n            get_balance(deps.as_ref(), owner.clone()),\n            start.checked_sub(transfer).unwrap()\n        );\n        assert_eq!(get_balance(deps.as_ref(), contract.clone()), transfer);\n\n        // ensure it looks good\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        let expect = AllowanceResponse {\n            allowance: allow1.checked_sub(transfer).unwrap(),\n            expires: Expiration::Never {},\n        };\n        assert_eq!(expect, allowance);\n\n        // cannot send more than the allowance\n        let msg = ExecuteMsg::SendFrom {\n            owner: owner.clone(),\n            amount: Uint128::new(33443),\n            contract: contract.clone(),\n            msg: send_msg.clone(),\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert!(matches!(err, ContractError::Std(StdError::Overflow { .. })));\n\n        // let us increase limit, but set the expiration to current block (expired)\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: Uint128::new(1000),\n            expires: Some(Expiration::AtHeight(env.block.height)),\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // we should now get the expiration error\n        let msg = ExecuteMsg::SendFrom {\n            owner,\n            amount: Uint128::new(33443),\n            contract,\n            msg: send_msg,\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert_eq!(err, ContractError::Expired {});\n    }\n}\n","traces":[{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":9},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","lender","src","contract.rs"],"content":"use anyhow::{anyhow, Result};\n#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\nuse cosmwasm_std::{\n    from_binary, to_binary, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult, Uint128,\n};\n\nuse lender_export::msg::{ExecuteMsg, InstantiateMsg, QueryMsg, ZonesResponse};\nuse lender_export::state::{ContractInfo, State, BORROWS, CONTRACT_INFO, STATE};\n\nuse crate::error::ContractError;\nuse crate::execute::{\n    _execute_repay, execute_borrow, execute_borrow_more, execute_raise_interest_rate,\n};\nuse crate::query::{\n    get_asset_interests, get_asset_price, get_expensive_zone_limit_price,\n    get_safe_zone_limit_price, get_vault_token_asset,\n};\nuse crate::state::{set_lock, set_oracle, set_owner};\nuse cw_4626::state::AssetInfo;\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e Result\u003cResponse\u003e {\n    // We start by initating the state of the contract\n    let initial_state = State {\n        borrow_locked: false,\n    };\n\n    STATE.save(deps.storage, \u0026initial_state)?;\n\n    let vault_token = deps.api.addr_validate(\u0026msg.vault_token)?;\n    // Then the contract info\n    let contract_info = ContractInfo {\n        name: msg.name,\n        oracle: msg\n            .oracle\n            .map(|x| deps.api.addr_validate(\u0026x))\n            .transpose()?\n            .unwrap_or_else(|| info.sender.clone()),\n        owner: msg\n            .owner\n            .map(|x| deps.api.addr_validate(\u0026x))\n            .transpose()?\n            .unwrap_or(info.sender),\n        vault_token: vault_token.clone(),\n        vault_asset: get_vault_token_asset(deps.as_ref(), vault_token.to_string())?,\n        increasor_incentives: msg.increasor_incentives,\n        interests_fee_rate: msg.interests_fee_rate,\n        fee_distributor: deps.api.addr_validate(\u0026msg.fee_distributor)?,\n    };\n    CONTRACT_INFO.save(deps.storage, \u0026contract_info)?;\n\n    Ok(Response::default()\n        .add_attribute(\"action\", \"init\")\n        .add_attribute(\"contract\", \"lender\")\n        .add_attribute(\"owner\", contract_info.owner))\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg) -\u003e Result\u003cResponse\u003e {\n    match msg {\n        // Functions used to borrow funds\n        ExecuteMsg::Borrow {\n            asset_info,\n            assets_to_borrow,\n            borrow_mode,\n        } =\u003e execute_borrow(deps, env, info, asset_info, assets_to_borrow, borrow_mode),\n        ExecuteMsg::BorrowMore {\n            loan_id,\n            assets_to_borrow,\n        } =\u003e execute_borrow_more(deps, env, info, loan_id, assets_to_borrow),\n\n        // Functions used to repay or liquidate loans\n        ExecuteMsg::Receive {\n            sender,\n            amount,\n            msg,\n        } =\u003e receive_assets(deps, env, info, sender, amount, msg),\n\n        ExecuteMsg::Repay {\n            borrower,\n            loan_id,\n            assets,\n        } =\u003e execute_repay_native_funds(deps, env, info, borrower, loan_id, assets),\n\n        // Function used to raise the interests rate\n        ExecuteMsg::RaiseRate { borrower, loan_id } =\u003e {\n            execute_raise_interest_rate(deps, env, info, borrower, loan_id)\n        }\n\n        // Contract Administration\n        ExecuteMsg::SetOwner { owner } =\u003e set_owner(deps, info, owner),\n        ExecuteMsg::SetOracle { oracle } =\u003e set_oracle(deps, info, oracle),\n        ExecuteMsg::ToggleLock { lock } =\u003e set_lock(deps, info, lock),\n    }\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, env: Env, msg: QueryMsg) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::State {} =\u003e to_binary(\u0026STATE.load(deps.storage)?),\n        QueryMsg::ContratInfo {} =\u003e to_binary(\u0026CONTRACT_INFO.load(deps.storage)?),\n        QueryMsg::BorrowInfo { borrower, loan_id } =\u003e {\n            let borrower = deps.api.addr_validate(\u0026borrower)?;\n            to_binary(\u0026BORROWS.load(deps.storage, (\u0026borrower, loan_id))?)\n        }\n        QueryMsg::BorrowZones { asset_info } =\u003e {\n            let collateral_price = get_asset_price(deps, env, asset_info)?;\n            let safe_zone_limit = get_safe_zone_limit_price(collateral_price)?;\n            let expensive_zone_limit = get_expensive_zone_limit_price(collateral_price)?;\n            to_binary(\u0026ZonesResponse {\n                safe_zone_limit,\n                expensive_zone_limit,\n            })\n        }\n        QueryMsg::BorrowTerms {\n            asset_info,\n            borrow_mode,\n            borrow_zone,\n        } =\u003e to_binary(\u0026get_asset_interests(\n            deps,\n            env,\n            asset_info,\n            borrow_mode,\n            borrow_zone,\n        )?),\n    }\n}\n\npub fn receive_assets(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    sender: String,\n    amount: Uint128,\n    msg: Binary,\n) -\u003e Result\u003cResponse\u003e {\n    match from_binary(\u0026msg)? {\n        ExecuteMsg::Repay {\n            borrower,\n            loan_id,\n            assets,\n        } =\u003e {\n            // This function can accept a Cw20 Token solely\n            // We make sure the sent assets correspond to the vault saved\n            let contract_info = CONTRACT_INFO.load(deps.storage)?;\n            if let AssetInfo::Cw20(x) = contract_info.vault_asset {\n                if deps.api.addr_validate(\u0026x)? != info.sender {\n                    return Err(anyhow!(ContractError::AssetsSentDontMatch {}));\n                }\n            } else {\n                return Err(anyhow!(ContractError::AssetsSentDontMatch {}));\n            }\n\n            // We make sure the amount sent is the amount specified in the repay message\n            if assets != amount {\n                return Err(anyhow!(ContractError::AssetsSentDontMatch {}));\n            }\n\n            let sender = deps.api.addr_validate(\u0026sender)?;\n            // We now call the repay function accordingly\n            _execute_repay(deps, env, sender, borrower, loan_id, assets)\n        }\n        _ =\u003e Err(anyhow!(ContractError::ReceiveMsgNotAccepted {})),\n    }\n}\n\npub fn execute_repay_native_funds(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    borrower: String,\n    loan_id: u64,\n    assets: Uint128,\n) -\u003e Result\u003cResponse\u003e {\n    let contract_info = CONTRACT_INFO.load(deps.storage)?;\n    // We test that the funds sent match the assets\n    if info.funds.len() != 1 {\n        return Err(anyhow!(ContractError::AssetsSentDontMatch {}));\n    }\n\n    // This function can accept a native tokens solely\n    // We make sure the sent assets correspond to the vault saved\n    if let AssetInfo::Coin(x) = contract_info.vault_asset {\n        if x != info.funds[0].denom {\n            return Err(anyhow!(ContractError::AssetsSentDontMatch {}));\n        }\n    } else {\n        return Err(anyhow!(ContractError::AssetsSentDontMatch {}));\n    }\n    // We make sure the amount sent is the amount specified in the repay message\n    if assets != info.funds[0].amount {\n        return Err(anyhow!(ContractError::AssetsSentDontMatch {}));\n    }\n\n    // We now call the repay function accordingly\n    _execute_repay(deps, env, info.sender, borrower, loan_id, assets)\n}\n\n#[cfg(test)]\npub mod tests {\n    use super::*;\n    use crate::contract::instantiate;\n    use crate::custom_mock_querier::tests::mock_dependencies;\n    use crate::error::ContractError;\n    use cosmwasm_std::testing::{mock_env, mock_info};\n    use cosmwasm_std::{coins, Api, Coin, CosmosMsg, DepsMut, Uint128, WasmMsg};\n    use cw721::Cw721ExecuteMsg;\n    use cw_4626::msg::ExecuteMsg as Cw4626ExecuteMsg;\n    use fee_distributor_export::msg::ExecuteMsg as DistributorExecuteMsg;\n    use lender_export::msg::InstantiateMsg;\n    use lender_export::state::{BorrowMode, Cw721Info};\n    use utils::msg::into_cosmos_msg;\n\n    fn init_helper(deps: DepsMut) {\n        let instantiate_msg = InstantiateMsg {\n            name: \"Iliq treasury token\".to_string(),\n            owner: Some(\"creator\".to_string()),\n            oracle: Some(\"oracle\".to_string()),\n            vault_token: \"vault_token\".to_string(),\n            increasor_incentives: Uint128::from(100u128),\n            interests_fee_rate: Uint128::from(1_000u128),\n            fee_distributor: \"distributor\".to_string(),\n        };\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n\n        instantiate(deps, env, info, instantiate_msg).unwrap();\n    }\n\n    fn borrow_helper(\n        deps: DepsMut,\n        sender: \u0026str,\n        nft_address: \u0026str,\n        token_id: \u0026str,\n        assets: Vec\u003cCoin\u003e,\n        principle: u128,\n    ) -\u003e Result\u003cResponse\u003e {\n        let info = mock_info(sender, \u0026assets);\n        let env = mock_env();\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::Borrow {\n                asset_info: Cw721Info {\n                    nft_address: nft_address.to_string(),\n                    token_id: token_id.to_string(),\n                },\n                assets_to_borrow: Uint128::from(principle),\n                borrow_mode: BorrowMode::Fixed,\n            },\n        )\n    }\n\n    fn borrow_continuous_helper(\n        deps: DepsMut,\n        sender: \u0026str,\n        nft_address: \u0026str,\n        token_id: \u0026str,\n        assets: Vec\u003cCoin\u003e,\n        principle: u128,\n    ) -\u003e Result\u003cResponse\u003e {\n        let info = mock_info(sender, \u0026assets);\n        let env = mock_env();\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::Borrow {\n                asset_info: Cw721Info {\n                    nft_address: nft_address.to_string(),\n                    token_id: token_id.to_string(),\n                },\n                assets_to_borrow: Uint128::from(principle),\n                borrow_mode: BorrowMode::Continuous,\n            },\n        )\n    }\n\n    fn borrow_more_helper(\n        deps: DepsMut,\n        sender: \u0026str,\n        loan_id: u64,\n        assets: Vec\u003cCoin\u003e,\n        principle: u128,\n    ) -\u003e Result\u003cResponse\u003e {\n        let info = mock_info(sender, \u0026assets);\n        let env = mock_env();\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::BorrowMore {\n                loan_id,\n                assets_to_borrow: Uint128::from(principle),\n            },\n        )\n    }\n\n    fn repay_helper(\n        deps: DepsMut,\n        address: \u0026str,\n        borrower: \u0026str,\n        loan_id: u64,\n        assets: u128,\n        block_height_delay: Option\u003cu64\u003e,\n    ) -\u003e Result\u003cResponse\u003e {\n        let mut env = mock_env();\n        if let Some(block_height) = block_height_delay {\n            env.block.height += block_height\n        }\n\n        let info = mock_info(address, \u0026coins(assets, \"utest\"));\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::Repay {\n                borrower: borrower.to_string(),\n                loan_id,\n                assets: Uint128::from(assets),\n            },\n        )\n    }\n\n    #[test]\n    fn test_init_sanity() {\n        let mut deps = mock_dependencies(\u0026[]);\n        init_helper(deps.as_mut());\n    }\n\n    #[test]\n    fn test_borrow_sanity() {\n        let mut deps = mock_dependencies(\u0026[]);\n        init_helper(deps.as_mut());\n\n        let err = borrow_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"nft\",\n            \"token_id\",\n            vec![],\n            8_600_000_000u128,\n        )\n        .unwrap_err();\n        assert_eq!(\n            err.downcast::\u003cContractError\u003e().unwrap(),\n            ContractError::TooMuchBorrowed {\n                collateral_address: \"nft\".to_string(),\n                wanted: Uint128::from(8_600_000_000u128),\n                limit: Uint128::from(53661300u128)\n            }\n        );\n\n        let res = borrow_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"nft\",\n            \"token_id\",\n            vec![],\n            8742u128,\n        )\n        .unwrap();\n        assert_eq!(\n            res,\n            Response::new()\n                .add_message(\n                    into_cosmos_msg(\n                        Cw721ExecuteMsg::TransferNft {\n                            recipient: \"cosmos2contract\".to_string(),\n                            token_id: \"token_id\".to_string(),\n                        },\n                        \"nft\".to_string(),\n                        None\n                    )\n                    .unwrap()\n                )\n                .add_message(\n                    into_cosmos_msg(\n                        Cw4626ExecuteMsg::Borrow {\n                            receiver: \"creator\".to_string(),\n                            assets: Uint128::from(8742u128)\n                        },\n                        \"vault_token\".to_string(),\n                        None\n                    )\n                    .unwrap()\n                )\n                .add_attribute(\"action\", \"borrow\")\n                .add_attribute(\"collateral_address\", \"nft\")\n                .add_attribute(\"collateral_token_id\", \"token_id\")\n                .add_attribute(\"borrower\", \"creator\")\n        );\n\n        // We verify the internal structure has changed\n        let borrower = deps.api.addr_validate(\"creator\").unwrap();\n        assert_eq!(\n            BORROWS\n                .load(\u0026deps.storage, (\u0026borrower, 0u64))\n                .unwrap()\n                .principle,\n            Uint128::from(8742u128)\n        )\n    }\n\n    #[test]\n    fn test_repay_sanity() {\n        let mut deps = mock_dependencies(\u0026[]);\n        init_helper(deps.as_mut());\n\n        // If the person is not the creator, it can't liquidate before the duration ends\n        borrow_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"nft\",\n            \"token_id\",\n            vec![],\n            8742u128,\n        )\n        .unwrap();\n        let err = repay_helper(\n            deps.as_mut(),\n            \"bad_guy\",\n            \"creator\",\n            0u64,\n            8742u128 + 67u128,\n            None,\n        )\n        .unwrap_err();\n        assert_eq!(\n            err.downcast::\u003cContractError\u003e().unwrap(),\n            ContractError::CannotLiquidateBeforeDefault {}\n        );\n\n        // If the loan doesn't exist it should return an error\n        repay_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"anyone\",\n            0u64,\n            8742u128 + 67u128,\n            None,\n        )\n        .unwrap_err();\n\n        // We should return the asset to the borrower at then end of the loan\n        let res = repay_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"creator\",\n            0u64,\n            8742u128 + 67u128,\n            None,\n        )\n        .unwrap();\n\n        // We print the messages for debugging\n        res.messages.iter().for_each(|x| {\n            if let CosmosMsg::Wasm(WasmMsg::Execute { msg, .. }) = x.msg.clone() {\n                println!(\"{:?}\", std::str::from_utf8(msg.as_slice()));\n            }\n        });\n\n        assert_eq!(\n            res,\n            Response::new()\n                .add_message(\n                    into_cosmos_msg(\n                        Cw721ExecuteMsg::TransferNft {\n                            recipient: \"creator\".to_string(),\n                            token_id: \"token_id\".to_string(),\n                        },\n                        \"nft\".to_string(),\n                        None\n                    )\n                    .unwrap()\n                )\n                .add_message(\n                    into_cosmos_msg(\n                        DistributorExecuteMsg::DepositFees {\n                            addresses: vec![\"nft\".to_string()],\n                        },\n                        \"distributor\".to_string(),\n                        Some(coins(6u128, \"utest\"))\n                    )\n                    .unwrap()\n                )\n                .add_message(\n                    into_cosmos_msg(\n                        Cw4626ExecuteMsg::Repay {\n                            owner: None,\n                            assets: Uint128::from(8803u128)\n                        },\n                        \"vault_token\".to_string(),\n                        Some(coins(8803u128, \"utest\"))\n                    )\n                    .unwrap()\n                )\n                .add_attribute(\"action\", \"repay\")\n                .add_attribute(\"caller\", \"creator\")\n                .add_attribute(\"borrower\", \"creator\")\n                .add_attribute(\"assets\", 8809u128.to_string())\n                .add_attribute(\"collateral_withdrawn\", \"true\")\n        );\n        let err = repay_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"creator\",\n            0u64,\n            8742u128 + 67u128,\n            None,\n        )\n        .unwrap_err();\n        assert_eq!(\n            err.downcast::\u003cContractError\u003e().unwrap(),\n            ContractError::AssetAlreadyWithdrawn {}\n        );\n    }\n\n    #[test]\n    fn test_liquidate_sanity() {\n        let mut deps = mock_dependencies(\u0026[]);\n        init_helper(deps.as_mut());\n\n        // If the person is not the creator, it can't liquidate before the duration ends\n        borrow_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"nft\",\n            \"token_id\",\n            vec![],\n            8742u128,\n        )\n        .unwrap();\n\n        repay_helper(\n            deps.as_mut(),\n            \"bad_guy\",\n            \"creator\",\n            0u64,\n            8742u128 + 67u128,\n            None,\n        )\n        .unwrap_err();\n\n        // We allow the querier to deliver response from the vault token\n        let err = repay_helper(\n            deps.as_mut(),\n            \"bad_guy\",\n            \"creator\",\n            0u64,\n            8u128,\n            Some(765u64),\n        )\n        .unwrap_err();\n        assert_eq!(\n            err.downcast::\u003cContractError\u003e().unwrap(),\n            ContractError::CanOnlyLiquidateWholeLoan {}\n        );\n\n        let res = repay_helper(\n            deps.as_mut(),\n            \"bad_guy\",\n            \"creator\",\n            0u64,\n            8742u128 + 67u128,\n            Some(765u64),\n        )\n        .unwrap();\n        // We print the messages for debugging\n        res.messages.iter().for_each(|x| {\n            if let CosmosMsg::Wasm(WasmMsg::Execute { msg, .. }) = x.msg.clone() {\n                println!(\"{:?}\", std::str::from_utf8(msg.as_slice()));\n            }\n        });\n\n        assert_eq!(\n            res,\n            Response::new()\n                .add_message(\n                    into_cosmos_msg(\n                        Cw721ExecuteMsg::TransferNft {\n                            recipient: \"bad_guy\".to_string(),\n                            token_id: \"token_id\".to_string(),\n                        },\n                        \"nft\".to_string(),\n                        None\n                    )\n                    .unwrap()\n                )\n                .add_message(\n                    into_cosmos_msg(\n                        DistributorExecuteMsg::DepositFees {\n                            addresses: vec![\"nft\".to_string()],\n                        },\n                        \"distributor\".to_string(),\n                        Some(coins(6u128, \"utest\"))\n                    )\n                    .unwrap()\n                )\n                .add_message(\n                    into_cosmos_msg(\n                        Cw4626ExecuteMsg::Repay {\n                            owner: None,\n                            assets: Uint128::from(8803u128)\n                        },\n                        \"vault_token\".to_string(),\n                        Some(coins(8803u128, \"utest\"))\n                    )\n                    .unwrap()\n                )\n                .add_attribute(\"action\", \"repay\")\n                .add_attribute(\"caller\", \"bad_guy\")\n                .add_attribute(\"borrower\", \"creator\")\n                .add_attribute(\"assets\", 8809u128.to_string())\n                .add_attribute(\"collateral_withdrawn\", \"true\")\n        );\n    }\n\n    #[test]\n    fn test_no_borrow_fixed() {\n        let mut deps = mock_dependencies(\u0026[]);\n        init_helper(deps.as_mut());\n\n        borrow_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"nft\",\n            \"token_id\",\n            vec![],\n            50_000_000u128,\n        )\n        .unwrap();\n\n        // You can't borrow too much funds for a unique collateral\n        borrow_more_helper(deps.as_mut(), \"creator\", 0u64, vec![], 50_000_000u128).unwrap_err();\n\n        borrow_more_helper(deps.as_mut(), \"creator\", 0u64, vec![], 1_000_000u128).unwrap_err();\n    }\n\n    #[test]\n    fn test_borrow_more_sanity() {\n        let mut deps = mock_dependencies(\u0026[]);\n        init_helper(deps.as_mut());\n\n        borrow_continuous_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"nft\",\n            \"token_id\",\n            vec![],\n            50_000_000u128,\n        )\n        .unwrap();\n\n        // You can't borrow too much funds for a unique collateral\n        borrow_more_helper(deps.as_mut(), \"creator\", 0u64, vec![], 50_000_000u128).unwrap_err();\n\n        let res =\n            borrow_more_helper(deps.as_mut(), \"creator\", 0u64, vec![], 1_000_000u128).unwrap();\n\n        assert_eq!(\n            res,\n            Response::new()\n                .add_message(\n                    into_cosmos_msg(\n                        Cw4626ExecuteMsg::Borrow {\n                            receiver: \"creator\".to_string(),\n                            assets: Uint128::from(1_000_000u128),\n                        },\n                        \"vault_token\".to_string(),\n                        None,\n                    )\n                    .unwrap()\n                )\n                .add_attribute(\"action\", \"borrow\")\n                .add_attribute(\"borrower\", \"creator\")\n                .add_attribute(\"loan_id\", \"0\")\n                .add_attribute(\"asset_borrowed\", \"1000000\")\n        );\n\n        // We verify the internal structure has changed\n        let borrower = deps.api.addr_validate(\"creator\").unwrap();\n        assert_eq!(\n            BORROWS\n                .load(\u0026deps.storage, (\u0026borrower, 0u64))\n                .unwrap()\n                .principle,\n            Uint128::from(51_000_000u128)\n        )\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","lender","src","custom_mock_querier.rs"],"content":"#[cfg(test)]\npub mod tests {\n    use cosmwasm_std::testing::{\n        MockApi, MockQuerierCustomHandlerResult, MockStorage, MOCK_CONTRACT_ADDR,\n    };\n\n    use cosmwasm_std::{\n        from_binary, from_slice, to_binary, AllBalanceResponse, BalanceResponse, BankQuery, Binary,\n        Coin, ContractResult, CustomQuery, Empty, OwnedDeps, Querier, QuerierResult, QueryRequest,\n        SystemError, SystemResult, WasmQuery,\n    };\n\n    use serde::de::DeserializeOwned;\n    use std::collections::HashMap;\n    use std::marker::PhantomData;\n\n    use cw_4626::query::QueryMsg as Cw4626QueryMsg;\n    use cw_4626::state::AssetInfo;\n\n    // All external requirements that can be injected for unit tests.\n    /// It sets the given balance for the contract itself, nothing else\n    pub fn mock_dependencies(\n        contract_balance: \u0026[Coin],\n    ) -\u003e OwnedDeps\u003cMockStorage, MockApi, MockQuerier\u003e {\n        OwnedDeps {\n            storage: MockStorage::default(),\n            api: MockApi::default(),\n            querier: MockQuerier::new(\u0026[(MOCK_CONTRACT_ADDR, contract_balance)]),\n            custom_query_type: PhantomData,\n        }\n    }\n\n    /// MockQuerier holds an immutable table of bank balances\n    pub struct MockQuerier\u003cC: DeserializeOwned = Empty\u003e {\n        bank: BankQuerier,\n        #[cfg(feature = \"staking\")]\n        staking: StakingQuerier,\n        // placeholder to add support later\n        wasm: CustomWasmQuerier,\n        /// A handler to handle custom queries. This is set to a dummy handler that\n        /// always errors by default. Update it via `with_custom_handler`.\n        ///\n        /// Use box to avoid the need of another generic type\n        custom_handler: Box\u003cdyn for\u003c'a\u003e Fn(\u0026'a C) -\u003e MockQuerierCustomHandlerResult\u003e,\n    }\n\n    impl\u003cC: DeserializeOwned\u003e MockQuerier\u003cC\u003e {\n        pub fn new(balances: \u0026[(\u0026str, \u0026[Coin])]) -\u003e Self {\n            MockQuerier {\n                bank: BankQuerier::new(balances),\n                #[cfg(feature = \"staking\")]\n                staking: StakingQuerier::default(),\n                wasm: CustomWasmQuerier {},\n                // strange argument notation suggested as a workaround here: https://github.com/rust-lang/rust/issues/41078#issuecomment-294296365\n                custom_handler: Box::from(|_: \u0026_| -\u003e MockQuerierCustomHandlerResult {\n                    SystemResult::Err(SystemError::UnsupportedRequest {\n                        kind: \"custom\".to_string(),\n                    })\n                }),\n            }\n        }\n\n        // set a new balance for the given address and return the old balance\n        pub fn update_balance(\n            \u0026mut self,\n            addr: impl Into\u003cString\u003e,\n            balance: Vec\u003cCoin\u003e,\n        ) -\u003e Option\u003cVec\u003cCoin\u003e\u003e {\n            self.bank.balances.insert(addr.into(), balance)\n        }\n\n        #[cfg(feature = \"staking\")]\n        pub fn update_staking(\n            \u0026mut self,\n            denom: \u0026str,\n            validators: \u0026[crate::query::Validator],\n            delegations: \u0026[crate::query::FullDelegation],\n        ) {\n            self.staking = StakingQuerier::new(denom, validators, delegations);\n        }\n\n        pub fn with_custom_handler\u003cCH: 'static\u003e(mut self, handler: CH) -\u003e Self\n        where\n            CH: Fn(\u0026C) -\u003e MockQuerierCustomHandlerResult,\n        {\n            self.custom_handler = Box::from(handler);\n            self\n        }\n    }\n\n    impl\u003cC: CustomQuery + DeserializeOwned\u003e Querier for MockQuerier\u003cC\u003e {\n        fn raw_query(\u0026self, bin_request: \u0026[u8]) -\u003e QuerierResult {\n            let request: QueryRequest\u003cC\u003e = match from_slice(bin_request) {\n                Ok(v) =\u003e v,\n                Err(e) =\u003e {\n                    return SystemResult::Err(SystemError::InvalidRequest {\n                        error: format!(\"Parsing query request: {}\", e),\n                        request: bin_request.into(),\n                    })\n                }\n            };\n            self.handle_query(\u0026request)\n        }\n    }\n\n    impl\u003cC: CustomQuery + DeserializeOwned\u003e MockQuerier\u003cC\u003e {\n        pub fn handle_query(\u0026self, request: \u0026QueryRequest\u003cC\u003e) -\u003e QuerierResult {\n            match \u0026request {\n                QueryRequest::Bank(bank_query) =\u003e self.bank.query(bank_query),\n                QueryRequest::Custom(custom_query) =\u003e (*self.custom_handler)(custom_query),\n                #[cfg(feature = \"staking\")]\n                QueryRequest::Staking(staking_query) =\u003e self.staking.query(staking_query),\n                QueryRequest::Wasm(msg) =\u003e self.wasm.query(msg),\n                #[cfg(feature = \"stargate\")]\n                QueryRequest::Stargate { .. } =\u003e {\n                    SystemResult::Err(SystemError::UnsupportedRequest {\n                        kind: \"Stargate\".to_string(),\n                    })\n                }\n                #[cfg(feature = \"stargate\")]\n                QueryRequest::Ibc(_) =\u003e SystemResult::Err(SystemError::UnsupportedRequest {\n                    kind: \"Ibc\".to_string(),\n                }),\n                _ =\u003e SystemResult::Err(SystemError::UnsupportedRequest {\n                    kind: \"custom\".to_string(),\n                }),\n            }\n        }\n    }\n\n    #[derive(Clone, Default)]\n    pub struct BankQuerier {\n        balances: HashMap\u003cString, Vec\u003cCoin\u003e\u003e,\n    }\n\n    impl BankQuerier {\n        pub fn new(balances: \u0026[(\u0026str, \u0026[Coin])]) -\u003e Self {\n            let mut map = HashMap::new();\n            for (addr, coins) in balances.iter() {\n                map.insert(addr.to_string(), coins.to_vec());\n            }\n            BankQuerier { balances: map }\n        }\n\n        pub fn query(\u0026self, request: \u0026BankQuery) -\u003e QuerierResult {\n            let contract_result: ContractResult\u003cBinary\u003e = match request {\n                BankQuery::Balance { address, denom } =\u003e {\n                    // proper error on not found, serialize result on found\n                    let amount = self\n                        .balances\n                        .get(address)\n                        .and_then(|v| v.iter().find(|c| \u0026c.denom == denom).map(|c| c.amount))\n                        .unwrap_or_default();\n                    let bank_res = BalanceResponse {\n                        amount: Coin {\n                            amount,\n                            denom: denom.to_string(),\n                        },\n                    };\n                    to_binary(\u0026bank_res).into()\n                }\n                BankQuery::AllBalances { address } =\u003e {\n                    // proper error on not found, serialize result on found\n                    let bank_res = AllBalanceResponse {\n                        amount: self.balances.get(address).cloned().unwrap_or_default(),\n                    };\n                    to_binary(\u0026bank_res).into()\n                }\n                _ =\u003e {\n                    return SystemResult::Err(SystemError::UnsupportedRequest {\n                        kind: \"custom\".to_string(),\n                    })\n                }\n            };\n            // system result is always ok in the mock implementation\n            SystemResult::Ok(contract_result)\n        }\n    }\n\n    #[cfg(feature = \"staking\")]\n    #[derive(Clone, Default)]\n    pub struct StakingQuerier {\n        denom: String,\n        validators: Vec\u003cValidator\u003e,\n        delegations: Vec\u003cFullDelegation\u003e,\n    }\n\n    #[cfg(feature = \"staking\")]\n    impl StakingQuerier {\n        pub fn new(denom: \u0026str, validators: \u0026[Validator], delegations: \u0026[FullDelegation]) -\u003e Self {\n            StakingQuerier {\n                denom: denom.to_string(),\n                validators: validators.to_vec(),\n                delegations: delegations.to_vec(),\n            }\n        }\n\n        pub fn query(\u0026self, request: \u0026StakingQuery) -\u003e QuerierResult {\n            let contract_result: ContractResult\u003cBinary\u003e = match request {\n                StakingQuery::BondedDenom {} =\u003e {\n                    let res = BondedDenomResponse {\n                        denom: self.denom.clone(),\n                    };\n                    to_binary(\u0026res).into()\n                }\n                StakingQuery::AllValidators {} =\u003e {\n                    let res = AllValidatorsResponse {\n                        validators: self.validators.clone(),\n                    };\n                    to_binary(\u0026res).into()\n                }\n                StakingQuery::Validator { address } =\u003e {\n                    let validator: Option\u003cValidator\u003e = self\n                        .validators\n                        .iter()\n                        .find(|validator| validator.address == *address)\n                        .cloned();\n                    let res = ValidatorResponse { validator };\n                    to_binary(\u0026res).into()\n                }\n                StakingQuery::AllDelegations { delegator } =\u003e {\n                    let delegations: Vec\u003c_\u003e = self\n                        .delegations\n                        .iter()\n                        .filter(|d| d.delegator.as_str() == delegator)\n                        .cloned()\n                        .map(|d| d.into())\n                        .collect();\n                    let res = AllDelegationsResponse { delegations };\n                    to_binary(\u0026res).into()\n                }\n                StakingQuery::Delegation {\n                    delegator,\n                    validator,\n                } =\u003e {\n                    let delegation = self\n                        .delegations\n                        .iter()\n                        .find(|d| d.delegator.as_str() == delegator \u0026\u0026 d.validator == *validator);\n                    let res = DelegationResponse {\n                        delegation: delegation.cloned(),\n                    };\n                    to_binary(\u0026res).into()\n                }\n            };\n            // system result is always ok in the mock implementation\n            SystemResult::Ok(contract_result)\n        }\n    }\n\n    #[derive(Clone, Default)]\n    struct CustomWasmQuerier {\n        // FIXME: actually provide a way to call out\n    }\n\n    impl CustomWasmQuerier {\n        fn query(\u0026self, request: \u0026WasmQuery) -\u003e QuerierResult {\n            match request {\n                WasmQuery::Smart { contract_addr, msg } =\u003e {\n                    if contract_addr == \"vault_token\" {\n                        let msg: Cw4626QueryMsg = from_binary(msg).unwrap();\n                        match msg {\n                            Cw4626QueryMsg::Asset {} =\u003e {\n                                let contract_result: ContractResult\u003cBinary\u003e =\n                                    to_binary(\u0026AssetInfo::Coin(\"utest\".to_string())).into();\n                                SystemResult::Ok(contract_result)\n                            }\n                            _ =\u003e SystemResult::Err(SystemError::UnsupportedRequest {\n                                kind: \"message of vault token\".to_string(),\n                            }),\n                        }\n                    } else {\n                        SystemResult::Err(SystemError::NoSuchContract {\n                            addr: contract_addr.clone(),\n                        })\n                    }\n                }\n                _ =\u003e SystemResult::Err(SystemError::UnsupportedRequest {\n                    kind: \"custom\".to_string(),\n                }),\n            }\n        }\n    }\n}\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":30},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","lender","src","enumerable.rs"],"content":"use cosmwasm_std::{Deps, Order, StdResult};\nuse cw20::{AllAccountsResponse, AllAllowancesResponse, AllowanceInfo};\n\nuse crate::state::{ALLOWANCES, BALANCES};\nuse cw_storage_plus::Bound;\n\n// settings for pagination\nconst MAX_LIMIT: u32 = 30;\nconst DEFAULT_LIMIT: u32 = 10;\n\npub fn query_all_allowances(\n    deps: Deps,\n    owner: String,\n    start_after: Option\u003cString\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e StdResult\u003cAllAllowancesResponse\u003e {\n    let owner_addr = deps.api.addr_validate(\u0026owner)?;\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n    let start = start_after.map(|s| Bound::ExclusiveRaw(s.into_bytes()));\n\n    let allowances = ALLOWANCES\n        .prefix(\u0026owner_addr)\n        .range(deps.storage, start, None, Order::Ascending)\n        .take(limit)\n        .map(|item| {\n            item.map(|(addr, allow)| AllowanceInfo {\n                spender: addr.into(),\n                allowance: allow.allowance,\n                expires: allow.expires,\n            })\n        })\n        .collect::\u003cStdResult\u003c_\u003e\u003e()?;\n    Ok(AllAllowancesResponse { allowances })\n}\n\npub fn query_all_accounts(\n    deps: Deps,\n    start_after: Option\u003cString\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e StdResult\u003cAllAccountsResponse\u003e {\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n    let start = start_after.map(|s| Bound::ExclusiveRaw(s.into()));\n\n    let accounts = BALANCES\n        .keys(deps.storage, start, None, Order::Ascending)\n        .take(limit)\n        .map(|item| item.map(Into::into))\n        .collect::\u003cStdResult\u003c_\u003e\u003e()?;\n\n    Ok(AllAccountsResponse { accounts })\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use cosmwasm_std::testing::{mock_dependencies_with_balance, mock_env, mock_info};\n    use cosmwasm_std::{coins, DepsMut, Uint128};\n    use cw20::{Cw20Coin, Expiration, TokenInfoResponse};\n\n    use crate::contract::{execute, instantiate, query_token_info};\n    use crate::msg::{ExecuteMsg, InstantiateMsg};\n\n    // this will set up the instantiation for other tests\n    fn do_instantiate(mut deps: DepsMut, addr: \u0026str, amount: Uint128) -\u003e TokenInfoResponse {\n        let instantiate_msg = InstantiateMsg {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: addr.into(),\n                amount,\n            }],\n            mint: None,\n            marketing: None,\n        };\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n        instantiate(deps.branch(), env, info, instantiate_msg).unwrap();\n        query_token_info(deps.as_ref()).unwrap()\n    }\n\n    #[test]\n    fn query_all_allowances_works() {\n        let mut deps = mock_dependencies_with_balance(\u0026coins(2, \"token\"));\n\n        let owner = String::from(\"owner\");\n        // these are in alphabetical order same than insert order\n        let spender1 = String::from(\"earlier\");\n        let spender2 = String::from(\"later\");\n\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        do_instantiate(deps.as_mut(), \u0026owner, Uint128::new(12340000));\n\n        // no allowance to start\n        let allowances = query_all_allowances(deps.as_ref(), owner.clone(), None, None).unwrap();\n        assert_eq!(allowances.allowances, vec![]);\n\n        // set allowance with height expiration\n        let allow1 = Uint128::new(7777);\n        let expires = Expiration::AtHeight(5432);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender1.clone(),\n            amount: allow1,\n            expires: Some(expires),\n        };\n        execute(deps.as_mut(), env.clone(), info.clone(), msg).unwrap();\n\n        // set allowance with no expiration\n        let allow2 = Uint128::new(54321);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender2.clone(),\n            amount: allow2,\n            expires: None,\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // query list gets 2\n        let allowances = query_all_allowances(deps.as_ref(), owner.clone(), None, None).unwrap();\n        assert_eq!(allowances.allowances.len(), 2);\n\n        // first one is spender1 (order of CanonicalAddr uncorrelated with String)\n        let allowances = query_all_allowances(deps.as_ref(), owner.clone(), None, Some(1)).unwrap();\n        assert_eq!(allowances.allowances.len(), 1);\n        let allow = \u0026allowances.allowances[0];\n        assert_eq!(\u0026allow.spender, \u0026spender1);\n        assert_eq!(\u0026allow.expires, \u0026expires);\n        assert_eq!(\u0026allow.allowance, \u0026allow1);\n\n        // next one is spender2\n        let allowances = query_all_allowances(\n            deps.as_ref(),\n            owner,\n            Some(allow.spender.clone()),\n            Some(10000),\n        )\n        .unwrap();\n        assert_eq!(allowances.allowances.len(), 1);\n        let allow = \u0026allowances.allowances[0];\n        assert_eq!(\u0026allow.spender, \u0026spender2);\n        assert_eq!(\u0026allow.expires, \u0026Expiration::Never {});\n        assert_eq!(\u0026allow.allowance, \u0026allow2);\n    }\n\n    #[test]\n    fn query_all_accounts_works() {\n        let mut deps = mock_dependencies_with_balance(\u0026coins(2, \"token\"));\n\n        // insert order and lexicographical order are different\n        let acct1 = String::from(\"acct01\");\n        let acct2 = String::from(\"zebra\");\n        let acct3 = String::from(\"nice\");\n        let acct4 = String::from(\"aaaardvark\");\n        let expected_order = [acct4.clone(), acct1.clone(), acct3.clone(), acct2.clone()];\n\n        do_instantiate(deps.as_mut(), \u0026acct1, Uint128::new(12340000));\n\n        // put money everywhere (to create balanaces)\n        let info = mock_info(acct1.as_ref(), \u0026[]);\n        let env = mock_env();\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            ExecuteMsg::Transfer {\n                recipient: acct2,\n                amount: Uint128::new(222222),\n            },\n        )\n        .unwrap();\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            ExecuteMsg::Transfer {\n                recipient: acct3,\n                amount: Uint128::new(333333),\n            },\n        )\n        .unwrap();\n        execute(\n            deps.as_mut(),\n            env,\n            info,\n            ExecuteMsg::Transfer {\n                recipient: acct4,\n                amount: Uint128::new(444444),\n            },\n        )\n        .unwrap();\n\n        // make sure we get the proper results\n        let accounts = query_all_accounts(deps.as_ref(), None, None).unwrap();\n        assert_eq!(accounts.accounts, expected_order);\n\n        // let's do pagination\n        let accounts = query_all_accounts(deps.as_ref(), None, Some(2)).unwrap();\n        assert_eq!(accounts.accounts, expected_order[0..2].to_vec());\n\n        let accounts =\n            query_all_accounts(deps.as_ref(), Some(accounts.accounts[1].clone()), Some(1)).unwrap();\n        assert_eq!(accounts.accounts, expected_order[2..3].to_vec());\n\n        let accounts =\n            query_all_accounts(deps.as_ref(), Some(accounts.accounts[0].clone()), Some(777))\n                .unwrap();\n        assert_eq!(accounts.accounts, expected_order[3..].to_vec());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","lender","src","error.rs"],"content":"use cosmwasm_std::{StdError, Uint128};\nuse thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized {},\n\n    #[error(\"The contract doesn't accept borrowing. You can only repay your debts\")]\n    BorrowLocked {},\n\n    #[error(\"You can't borrow more than the borrow limit on this asset. Asset: {collateral_address}, wanted: {wanted:?}, limit: {limit:?}\")]\n    TooMuchBorrowed {\n        collateral_address: String,\n        wanted: Uint128,\n        limit: Uint128,\n    },\n\n    #[error(\"Only the borrower can repay a loan if it's not defaulted\")]\n    CannotLiquidateBeforeDefault {},\n\n    #[error(\"The Loan is defaulted, you can't repay your own debt anymore...\")]\n    CannotRepayWhenDefaulted {},\n\n    #[error(\"Fixed loans cannot be repaid partially. Expected assets : {expected:?}, Provided assets: {provided:?}\")]\n    CanOnlyRepayWholeFixedLoan {\n        expected: Uint128,\n        provided: Uint128,\n    },\n\n    #[error(\"Loans cannot be liquidated partially, this is not Anchor\")]\n    CanOnlyLiquidateWholeLoan {},\n\n    #[error(\"You can't repay a loan whose collateral has already been withdrawn\")]\n    AssetAlreadyWithdrawn {},\n\n    // Rate increase-decrease errors\n    #[error(\"Only the original borrower can decrease their interest rate\")]\n    OnlyBorrowerCanLowerRate {},\n\n    #[error(\"You can't have multiple rate increasors\")]\n    CantIncreaseRateMultipleTimes {},\n\n    #[error(\"You can only change to the safe zone from the expensive zone\")]\n    OnlyFromExpensiveZone {},\n\n    #[error(\"You need to repay the expensive zone before going forward\")]\n    NeedToRepayExpensiveZone {},\n\n    #[error(\"You can only change to the expensive zone from the safe zone\")]\n    OnlyFromSafeZone {},\n\n    #[error(\"A fixed interest/duration loan, doesn't have an interest rate\")]\n    FixedLoanNoInterestRate {},\n\n    #[error(\"Unavailable for a fixed loan\")]\n    UnavailableFixedLoan {},\n\n    #[error(\"The format of your transfer message was wrong for the lender contract\")]\n    ReceiveMsgNotAccepted {},\n\n    #[error(\"The assets you sent don't match the message you used\")]\n    AssetsSentDontMatch {},\n\n    #[error(\"The value of the paramter you are trying to change is not acceptable\")]\n    ParamNotAccepted {},\n\n    #[error(\"A repaiement must cover the increasor incentives\")]\n    MustAtLeastCoverIncreasorIncentive {},\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","lender","src","execute.rs"],"content":"use crate::error::ContractError;\n#[cfg(not(feature = \"library\"))]\nuse anyhow::{anyhow, Result};\nuse cosmwasm_std::{\n    coins, to_binary, Addr, BankMsg, CosmosMsg, Deps, DepsMut, Env, MessageInfo, Response, Uint128,\n};\nuse lender_export::state::{\n    BorrowInfo, BorrowMode, BorrowZone, ContractInfo, Cw721Info, InterestType, RateIncreasor,\n    BORROWS, CONTRACT_INFO, PERCENTAGE_RATE, STATE,\n};\nuse serde::Serialize;\nuse utils::msg::into_cosmos_msg;\n\nuse crate::query::{\n    can_repay_loan, get_asset_interests, get_asset_price, get_borrower_interest_rate,\n    get_interests_with, get_last_collateral, get_liquidation_value, get_loan_value,\n    get_new_interests_accrued, get_safe_zone_limit_price, get_total_interests, get_zone,\n};\nuse cw20::Cw20ExecuteMsg;\nuse cw721::Cw721ExecuteMsg;\nuse cw_4626::msg::ExecuteMsg as Cw4626ExecuteMsg;\nuse cw_4626::state::AssetInfo;\nuse fee_distributor_export::msg::ExecuteMsg as DistributorExecuteMsg;\n\npub fn _diff_abs(x: u128, y: u128) -\u003e u128 {\n    std::cmp::max(x, y) - std::cmp::min(x, y)\n}\n\npub fn diff_abs(x: Uint128, y: Uint128) -\u003e Uint128 {\n    Uint128::from(_diff_abs(x.u128(), y.u128()))\n}\n\n// Borrow mecanism\n/// Withdraw some of the assets from the vault\n/// Updates the internal structure for the loan to be liquidated when the terms allow it\npub fn execute_borrow(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    collateral_info: Cw721Info,\n    assets_to_borrow: Uint128,\n    borrow_mode: BorrowMode,\n) -\u003e Result\u003cResponse\u003e {\n    // First we checked it is allowed to borrow assets\n    let state = STATE.load(deps.storage)?;\n    if state.borrow_locked {\n        return Err(anyhow::anyhow!(ContractError::BorrowLocked {}));\n    }\n\n    let contract_info = CONTRACT_INFO.load(deps.storage)?;\n\n    // First we query the terms of a loan involving the asset\n    let asset_price = get_asset_price(deps.as_ref(), env.clone(), collateral_info.clone())?;\n    let borrow_limit = get_safe_zone_limit_price(asset_price)?;\n    // Then we verify the borrow limit is indeed above the assets_to_borrow\n    if assets_to_borrow \u003e borrow_limit {\n        return Err(anyhow::anyhow!(ContractError::TooMuchBorrowed {\n            collateral_address: collateral_info.nft_address,\n            wanted: assets_to_borrow,\n            limit: borrow_limit\n        }));\n    }\n    // We get the interest rate depending on the mode chosen by the sender\n    let interests = get_asset_interests(\n        deps.as_ref(),\n        env.clone(),\n        collateral_info.clone(),\n        borrow_mode,\n        BorrowZone::SafeZone,\n    )?;\n\n    // We get the last collateral_id that was saved\n    let new_collateral_id = get_last_collateral(deps.as_ref(), \u0026info.sender)\n        .map(|x| x + 1)\n        .unwrap_or(0u64);\n    // We save the borrow info to memory\n    BORROWS.save(\n        deps.storage,\n        (\u0026info.sender, new_collateral_id),\n        \u0026BorrowInfo {\n            principle: assets_to_borrow,\n            interests,\n            start_block: env.block.height,\n            collateral: Some(collateral_info.clone()),\n            borrow_zone: BorrowZone::SafeZone,\n            rate_increasor: None,\n        },\n    )?;\n\n    // Then we transfer the collateral asset to this contract\n    let deposit_message = into_cosmos_msg(\n        Cw721ExecuteMsg::TransferNft {\n            recipient: env.contract.address.into(),\n            token_id: collateral_info.token_id.clone(),\n        },\n        collateral_info.nft_address.clone(),\n        None,\n    )?;\n\n    // And we transfer the borrowed assets to the lender\n    let borrow_message = into_cosmos_msg(\n        Cw4626ExecuteMsg::Borrow {\n            receiver: info.sender.to_string(),\n            assets: assets_to_borrow,\n        },\n        contract_info.vault_token,\n        None,\n    )?;\n\n    Ok(Response::new()\n        .add_message(deposit_message)\n        .add_message(borrow_message)\n        .add_attribute(\"action\", \"borrow\")\n        .add_attribute(\"collateral_address\", collateral_info.nft_address)\n        .add_attribute(\"collateral_token_id\", collateral_info.token_id)\n        .add_attribute(\"borrower\", info.sender))\n}\n\n// Borrow more assets for a same collateral\n/// Withdraw some of the assets from the vault\npub fn execute_borrow_more(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    loan_id: u64,\n    assets_to_borrow: Uint128,\n) -\u003e Result\u003cResponse\u003e {\n    // First we checked it is allowed to borrow assets\n    let state = STATE.load(deps.storage)?;\n    if state.borrow_locked {\n        return Err(anyhow::anyhow!(ContractError::BorrowLocked {}));\n    }\n    let contract_info = CONTRACT_INFO.load(deps.storage)?;\n\n    // First we make sure the loan indeed has a collateral\n    let borrower = info.sender.clone();\n    let mut borrow_info = BORROWS.load(deps.storage, (\u0026borrower, loan_id))?;\n    let collateral_info = borrow_info\n        .clone()\n        .collateral\n        .ok_or(ContractError::AssetAlreadyWithdrawn {})?;\n\n    // Then the loan type should be a continuous one to borrow more\n    if let InterestType::Fixed { .. } = borrow_info.interests {\n        return Err(anyhow!(ContractError::UnavailableFixedLoan {}));\n    }\n\n    // First you need to repay the increasor if you want to borrow more\n    if borrow_info.borrow_zone != BorrowZone::SafeZone {\n        return Err(anyhow!(ContractError::NeedToRepayExpensiveZone {}));\n    }\n\n    // We update the loan interests accrued up to there\n    _update_interests_accrued(env.clone(), \u0026mut borrow_info)?;\n\n    let asset_price = get_asset_price(deps.as_ref(), env.clone(), collateral_info.clone())?;\n    let borrow_limit = get_safe_zone_limit_price(asset_price)?;\n    let current_loan_value = get_loan_value(env.clone(), \u0026borrow_info);\n\n    // Then we verify the borrow limit is indeed above the total assets to borrow\n    if current_loan_value + assets_to_borrow \u003e borrow_limit {\n        return Err(anyhow::anyhow!(ContractError::TooMuchBorrowed {\n            collateral_address: collateral_info.nft_address,\n            wanted: current_loan_value + assets_to_borrow,\n            limit: borrow_limit\n        }));\n    }\n\n    // We set the new principle\n    borrow_info.principle += assets_to_borrow;\n\n    // We set the new interests rate\n    borrow_info.interests = get_asset_interests(\n        deps.as_ref(),\n        env.clone(),\n        collateral_info,\n        BorrowMode::Continuous,\n        BorrowZone::SafeZone,\n    )?;\n    borrow_info.start_block = env.block.height;\n\n    // We save the borrow info to memory\n    BORROWS.save(deps.storage, (\u0026info.sender, loan_id), \u0026borrow_info)?;\n\n    // And we transfer the borrowed assets to the lender\n    let borrow_message = into_cosmos_msg(\n        Cw4626ExecuteMsg::Borrow {\n            receiver: info.sender.to_string(),\n            assets: assets_to_borrow,\n        },\n        contract_info.vault_token,\n        None,\n    )?;\n\n    Ok(Response::new()\n        .add_message(borrow_message)\n        .add_attribute(\"action\", \"borrow\")\n        .add_attribute(\"borrower\", info.sender)\n        .add_attribute(\"loan_id\", loan_id.to_string())\n        .add_attribute(\"asset_borrowed\", assets_to_borrow))\n}\n\n// Borrow mecanism\n/// Repay a loan.\n/// This function has multiple use cases\n/// 1. Repay your own loans in whole and get your collateral back\n///    In order to do that, you need to send exactly or more than the amount of assets that match the value of the lonan\n/// 2. Repay parts of your loan to lower your LTV (only possible for continuous loans)\n///      This will effectively lower your LTV and allow you to continue borrowing your funds\n///     If you have a fixed loan this option is not available to you\n/// 3. Liquidate someone elses loan (only possible when the loan is defaulted)\npub fn _execute_repay(\n    deps: DepsMut,\n    env: Env,\n    sender: Addr,\n\n    borrower: String,\n    loan_id: u64,\n    assets: Uint128,\n) -\u003e Result\u003cResponse\u003e {\n    let contract_info = CONTRACT_INFO.load(deps.storage)?;\n    // We load the borrow object that they want to repay\n    let borrower = deps.api.addr_validate(\u0026borrower)?;\n    let mut borrow_info = BORROWS.load(deps.storage, (\u0026borrower, loan_id))?;\n\n    // We check the sender can repay the loan\n    can_repay_loan(\n        deps.as_ref(),\n        env.clone(),\n        sender.clone(),\n        borrower.clone(),\n        \u0026borrow_info,\n    )?;\n\n    // We check if there is even a collateral backing the loan\n    let asset_info = borrow_info\n        .clone()\n        .collateral\n        .ok_or(ContractError::AssetAlreadyWithdrawn {})?;\n    let nft_address = asset_info.nft_address.clone();\n\n    let loan_value = get_loan_value(env.clone(), \u0026borrow_info);\n\n    // First we start by dealing with the increasor incentives\n    // This function will repay the incresor their share, or fail\n\n    let (increasor_incentive, increasor_message) =\n        send_interests_to_increasor(env.clone(), contract_info.clone(), \u0026borrow_info)?\n            .unwrap_or((Uint128::zero(), vec![]));\n\n    let assets_left_to_repay: Uint128 = assets\n        .checked_sub(increasor_incentive)\n        .map_err(|_| anyhow!(ContractError::MustAtLeastCoverIncreasorIncentive {}))?;\n\n    // We erase the increasor from memory\n    borrow_info.rate_increasor = None;\n\n    // Then, we update the interests accrued to the loan\n    _update_interests_accrued(env.clone(), \u0026mut borrow_info)?;\n\n    // Now we can go to the repay part\n    let repay_messages = if sender == borrower {\n        if assets \u003e= loan_value {\n            // Case 1. The borrower repays the whole loan\n\n            // We save the interests repaid for later use\n            // This will always be safe (per construction, increasor_incentive is a perentage of the interests)\n            let interests_repaid = assets_left_to_repay - borrow_info.principle;\n\n            // We update the internal state of the contract to reflect the loan has ended\n            // The collateral has been withdrawn\n            // The principle is not existent anymore\n            borrow_info.collateral = None;\n            borrow_info.principle = Uint128::zero();\n            [\n                // We send the borrower their collateral back\n                vec![into_cosmos_msg(\n                    Cw721ExecuteMsg::TransferNft {\n                        recipient: borrower.to_string(),\n                        token_id: asset_info.token_id,\n                    },\n                    nft_address.clone(),\n                    None,\n                )?],\n                // We repay the vault and the fee_depositor\n                create_repay_and_fee_messages(\n                    contract_info,\n                    interests_repaid,\n                    assets_left_to_repay,\n                    nft_address,\n                )?,\n            ]\n            .concat()\n        } else {\n            // Case 2. If the borrower repays the loan only partially\n\n            // We repay part of the loan, interests first, principle second\n            let interests_repaid = _repay_some_loan(env.clone(), \u0026mut borrow_info, assets)?;\n\n            // We update the interest rate\n\n            let borrow_zone = get_zone(deps.as_ref(), env.clone(), \u0026borrow_info)?;\n            if borrow_zone == BorrowZone::SafeZone\n                \u0026\u0026 borrow_info.borrow_zone == BorrowZone::ExpensiveZone\n            {\n                borrow_info.borrow_zone = BorrowZone::SafeZone;\n                borrow_info.interests = get_asset_interests(\n                    deps.as_ref(),\n                    env,\n                    asset_info,\n                    BorrowMode::Continuous,\n                    BorrowZone::SafeZone,\n                )?;\n            }\n            // And we repay the vault\n            create_repay_and_fee_messages(\n                contract_info,\n                interests_repaid,\n                assets_left_to_repay,\n                borrow_info.collateral.clone().unwrap().nft_address,\n            )?\n        }\n    } else {\n        // Case 3. Someone else liquidates the collateral\n        // TODO\n        // They can only liquidate a loan if they pay enough assets to the contract (liquidation value)\n        let liquidation_value = get_liquidation_value(env, \u0026borrow_info)?;\n        if assets \u003c liquidation_value {\n            return Err(anyhow::anyhow!(ContractError::CanOnlyLiquidateWholeLoan {}));\n        }\n\n        // We save those variables to create cosmos messages\n        let interests_repaid = assets_left_to_repay - borrow_info.principle;\n\n        // The loan is ended\n        // The collateral has been withdrawn\n        // The principle is not existent anymore\n        // The loan has been liquidated\n        borrow_info.collateral = None;\n        borrow_info.principle = Uint128::zero();\n        borrow_info.borrow_zone = BorrowZone::LiquidationZone;\n\n        [\n            vec![into_cosmos_msg(\n                Cw721ExecuteMsg::TransferNft {\n                    recipient: sender.to_string(),\n                    token_id: asset_info.token_id,\n                },\n                nft_address.clone(),\n                None,\n            )?],\n            create_repay_and_fee_messages(\n                contract_info,\n                interests_repaid,\n                assets_left_to_repay,\n                nft_address,\n            )?,\n        ]\n        .concat()\n    };\n\n    // We save the changes to memory\n    BORROWS.save(deps.storage, (\u0026borrower, loan_id), \u0026borrow_info)?;\n\n    Ok(Response::new()\n        .add_messages(increasor_message)\n        .add_messages(repay_messages)\n        .add_attribute(\"action\", \"repay\")\n        .add_attribute(\"caller\", sender)\n        .add_attribute(\"borrower\", borrower)\n        .add_attribute(\"assets\", assets.to_string())\n        .add_attribute(\n            \"collateral_withdrawn\",\n            borrow_info.collateral.is_none().to_string(),\n        ))\n}\n\n// In this function, we check if there was an increasor of interest rate between the last update and now\n// If so, we need to send funds back to them when updating the interest rate\npub fn send_interests_to_increasor(\n    env: Env,\n    contract_info: ContractInfo,\n    borrow_info: \u0026BorrowInfo,\n) -\u003e Result\u003cOption\u003c(Uint128, Vec\u003cCosmosMsg\u003e)\u003e\u003e {\n    // If we had someone increase the rate of the loan\n    if let Some(increasor) = borrow_info.rate_increasor.clone() {\n        let current_rate = get_borrower_interest_rate(borrow_info)?;\n        let previous_rate = increasor.previous_rate;\n        if current_rate \u003e previous_rate {\n            // We compute their incentive\n            let incentive = get_interests_with(\n                env,\n                borrow_info.principle,\n                current_rate - previous_rate,\n                borrow_info.start_block,\n            ) * contract_info.increasor_incentives\n                / Uint128::from(PERCENTAGE_RATE);\n\n            if incentive == Uint128::zero() {\n                Ok(None)\n            } else {\n                // If there is an incentive to give, we create a message to do so\n                let send_messages = send_asset(\n                    contract_info.vault_asset,\n                    increasor.increasor.to_string(),\n                    incentive,\n                )?;\n                Ok(Some((incentive, vec![send_messages])))\n            }\n        } else {\n            Ok(None)\n        }\n    } else {\n        Ok(None)\n    }\n}\n\npub fn create_repay_and_fee_messages(\n    contract_info: ContractInfo,\n    interests_due: Uint128,\n    assets: Uint128,\n    nft_address: String,\n) -\u003e Result\u003cVec\u003cCosmosMsg\u003e\u003e {\n    let fee = interests_due * contract_info.interests_fee_rate / Uint128::from(PERCENTAGE_RATE);\n    println!(\n        \"fee : {:?}, repaiement : {:?}, interests : {:?}\",\n        fee,\n        assets - fee,\n        interests_due\n    );\n    Ok(vec![\n        // We send the fee to the fee depositor\n        send_asset_to_contract(\n            contract_info.vault_asset.clone(),\n            contract_info.fee_distributor.to_string(),\n            fee,\n            DistributorExecuteMsg::DepositFees {\n                addresses: vec![nft_address],\n            },\n        )?,\n        // We send the rest to the vault\n        send_asset_to_contract(\n            contract_info.vault_asset,\n            contract_info.vault_token.to_string(),\n            assets - fee,\n            Cw4626ExecuteMsg::Repay {\n                owner: None,\n                assets: assets - fee,\n            },\n        )?,\n    ])\n}\n\npub fn _repay_some_loan(\n    env: Env,\n    mut borrow_info: \u0026mut BorrowInfo,\n    assets: Uint128,\n) -\u003e Result\u003cUint128\u003e {\n    let total_interests = get_total_interests(env, borrow_info);\n    match borrow_info.interests {\n        InterestType::Fixed { .. } =\u003e {\n            Err(anyhow::anyhow!(ContractError::CanOnlyRepayWholeFixedLoan {\n                expected: borrow_info.principle + total_interests,\n                provided: assets\n            }))\n        }\n\n        InterestType::Continuous {\n            last_interest_rate, ..\n        } =\u003e {\n            if assets \u003e total_interests {\n                borrow_info.interests = {\n                    InterestType::Continuous {\n                        interests_accrued: Uint128::zero(),\n                        last_interest_rate,\n                    }\n                };\n                // We diminish the principle\n                if assets - total_interests \u003c= borrow_info.principle {\n                    borrow_info.principle -= assets - total_interests;\n                } else {\n                    borrow_info.principle = Uint128::zero();\n                }\n\n                Ok(total_interests)\n            } else {\n                borrow_info.interests = InterestType::Continuous {\n                    interests_accrued: total_interests - assets,\n                    last_interest_rate,\n                };\n                Ok(assets)\n            }\n        }\n    }\n}\n\npub fn send_asset(asset: AssetInfo, recipient: String, assets: Uint128) -\u003e Result\u003cCosmosMsg\u003e {\n    match asset {\n        AssetInfo::Coin(denom) =\u003e Ok(CosmosMsg::from(BankMsg::Send {\n            to_address: recipient,\n            amount: coins(assets.u128(), denom),\n        })),\n        AssetInfo::Cw20(address) =\u003e into_cosmos_msg(\n            Cw20ExecuteMsg::Transfer {\n                recipient,\n                amount: assets,\n            },\n            address,\n            None,\n        )\n        .map_err(|x| anyhow!(x)),\n    }\n}\n\npub fn send_asset_to_contract\u003cM: Serialize\u003e(\n    asset: AssetInfo,\n    contract: String,\n    assets: Uint128,\n    msg: M,\n) -\u003e Result\u003cCosmosMsg\u003e {\n    match asset {\n        AssetInfo::Coin(denom) =\u003e Ok(into_cosmos_msg(\n            msg,\n            contract,\n            Some(coins(assets.u128(), denom)),\n        )?),\n        AssetInfo::Cw20(address) =\u003e into_cosmos_msg(\n            Cw20ExecuteMsg::Send {\n                contract,\n                amount: assets,\n                msg: to_binary(\u0026msg)?,\n            },\n            address,\n            None,\n        )\n        .map_err(|x| anyhow!(x)),\n    }\n}\n\npub fn execute_raise_interest_rate(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    borrower: String,\n    loan_id: u64,\n) -\u003e Result\u003cResponse\u003e {\n    let borrower = deps.api.addr_validate(\u0026borrower)?;\n    let mut borrow_info = BORROWS.load(deps.storage, (\u0026borrower, loan_id))?;\n    let zone = get_zone(deps.as_ref(), env.clone(), \u0026borrow_info)?;\n\n    // We start by updating the interest rate accrued so far\n    _update_interests_accrued(env.clone(), \u0026mut borrow_info)?;\n\n    if zone == BorrowZone::ExpensiveZone {\n        // You can only increase the rate from the safe zone\n        if borrow_info.borrow_zone != BorrowZone::SafeZone {\n            return Err(anyhow!(ContractError::OnlyFromSafeZone {}));\n        }\n        // The sender is saved in the increasor object\n        if borrow_info.rate_increasor.is_some() {\n            return Err(anyhow!(ContractError::CantIncreaseRateMultipleTimes {}));\n        }\n        borrow_info.rate_increasor = Some(RateIncreasor {\n            increasor: info.sender,\n            previous_rate: get_borrower_interest_rate(\u0026borrow_info)?,\n        });\n\n        // We increase the interest rate\n        borrow_info.borrow_zone = BorrowZone::ExpensiveZone;\n        set_interest_rate(deps.as_ref(), env, \u0026mut borrow_info)?;\n    }\n\n    Ok(Response::new())\n}\n\npub fn set_interest_rate(deps: Deps, env: Env, borrow_info: \u0026mut BorrowInfo) -\u003e Result\u003c()\u003e {\n    match borrow_info.interests {\n        InterestType::Fixed { .. } =\u003e {\n            return Err(anyhow!(ContractError::FixedLoanNoInterestRate {}))\n        }\n        InterestType::Continuous { .. } =\u003e {\n            borrow_info.interests = get_asset_interests(\n                deps,\n                env,\n                borrow_info\n                    .collateral\n                    .clone()\n                    .ok_or(ContractError::AssetAlreadyWithdrawn {})?,\n                BorrowMode::Continuous,\n                borrow_info.borrow_zone.clone(),\n            )?;\n        }\n    };\n    Ok(())\n}\npub fn _update_interests_accrued(env: Env, borrow_info: \u0026mut BorrowInfo) -\u003e Result\u003cUint128\u003e {\n    // We get the interests accrued since the last call\n    let new_interest_accrued = get_new_interests_accrued(env.clone(), borrow_info);\n\n    // We update the borrow info accordingly (only in the continuous case)\n    // And we return the current interests due\n    match borrow_info.interests {\n        InterestType::Fixed { interests, .. } =\u003e Ok(interests),\n\n        InterestType::Continuous {\n            interests_accrued,\n            last_interest_rate,\n        } =\u003e {\n            let new_interests = interests_accrued + new_interest_accrued;\n            if new_interest_accrued \u003e Uint128::zero() {\n                borrow_info.interests = {\n                    InterestType::Continuous {\n                        interests_accrued: new_interests,\n                        last_interest_rate,\n                    }\n                };\n                borrow_info.start_block = env.block.height;\n            }\n            Ok(new_interests)\n        }\n    }\n}\n","traces":[{"line":521,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":522,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":523,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":528,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":533,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":12},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","lender","src","lib.rs"],"content":"pub mod contract;\npub mod custom_mock_querier;\npub mod error;\npub mod execute;\npub mod query;\npub mod state;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","lender","src","query.rs"],"content":"use crate::error::ContractError;\n#[cfg(not(feature = \"library\"))]\nuse anyhow::{anyhow, Result};\nuse cosmwasm_std::{Addr, Deps, Env, Order, StdResult, Uint128};\nuse cw_4626::query::QueryMsg as Cw4626QueryMsg;\nuse cw_4626::state::AssetInfo;\nuse lender_export::state::{\n    BorrowInfo, BorrowMode, BorrowZone, Cw721Info, InterestType, InterestsInfo, BORROWS,\n    MIN_BLOCK_OFFSET, PERCENTAGE_RATE,\n};\n\nconst SAFE_ZONE_LIMIT: u128 = 3_333u128;\nconst EXPENSIVE_ZONE_LIMIT: u128 = 6_666u128;\nconst ZONE_LIMIT_PERCENTAGE_POINT: u128 = 10_000u128;\n\npub fn get_vault_token_asset(deps: Deps, vault_token: String) -\u003e Result\u003cAssetInfo\u003e {\n    let asset_info: AssetInfo = deps\n        .querier\n        .query_wasm_smart(vault_token, \u0026Cw4626QueryMsg::Asset {})\n        .map_err(|x| anyhow!(x))?;\n    Ok(asset_info)\n}\n\npub fn get_asset_interests(\n    _deps: Deps,\n    _env: Env,\n    _asset_info: Cw721Info,\n    mode: BorrowMode,\n    zone: BorrowZone,\n) -\u003e StdResult\u003cInterestType\u003e {\n    // TODO, determine a borrowing strategy !\n\n    let interests_info = InterestsInfo {\n        safe_interest_rate: Uint128::from(78u128), // In 1/PERCENTAGE_RATE per block\n        expensive_interest_rate: Uint128::from(78u128), // In 1/PERCENTAGE_RATE per block\n    };\n\n    match mode {\n        BorrowMode::Fixed =\u003e Ok(InterestType::Fixed {\n            interests: Uint128::from(67u128),\n            duration: 67u64,\n        }),\n        BorrowMode::Continuous =\u003e Ok(match zone {\n            BorrowZone::SafeZone =\u003e InterestType::Continuous {\n                last_interest_rate: interests_info.safe_interest_rate,\n                interests_accrued: Uint128::zero(),\n            },\n            BorrowZone::ExpensiveZone | BorrowZone::LiquidationZone =\u003e InterestType::Continuous {\n                last_interest_rate: interests_info.expensive_interest_rate,\n                interests_accrued: Uint128::zero(),\n            },\n        }),\n    }\n}\n\npub fn get_borrower_interest_rate(borrow_info: \u0026BorrowInfo) -\u003e Result\u003cUint128\u003e {\n    match borrow_info.interests {\n        InterestType::Fixed { .. } =\u003e Err(anyhow!(ContractError::FixedLoanNoInterestRate {})),\n        InterestType::Continuous {\n            last_interest_rate, ..\n        } =\u003e Ok(last_interest_rate),\n    }\n}\n\npub fn get_asset_price(_deps: Deps, _env: Env, _asset_info: Cw721Info) -\u003e StdResult\u003cUint128\u003e {\n    // TODO, query the oracle contract for the asset price\n    Ok(Uint128::from(161_000_000u128))\n}\n\npub fn get_safe_zone_limit_price(asset_price: Uint128) -\u003e StdResult\u003cUint128\u003e {\n    Ok(asset_price * Uint128::from(SAFE_ZONE_LIMIT) / Uint128::from(ZONE_LIMIT_PERCENTAGE_POINT))\n}\n\npub fn get_expensive_zone_limit_price(asset_price: Uint128) -\u003e StdResult\u003cUint128\u003e {\n    Ok(asset_price * Uint128::from(EXPENSIVE_ZONE_LIMIT)\n        / Uint128::from(ZONE_LIMIT_PERCENTAGE_POINT))\n}\n\npub fn get_zone(deps: Deps, env: Env, borrow_info: \u0026BorrowInfo) -\u003e Result\u003cBorrowZone\u003e {\n    match borrow_info.interests {\n        InterestType::Fixed { .. } =\u003e Ok(BorrowZone::SafeZone),\n        InterestType::Continuous { .. } =\u003e {\n            let loan_value = get_loan_value(env.clone(), borrow_info);\n            let asset_price = get_asset_price(\n                deps,\n                env,\n                borrow_info\n                    .clone()\n                    .collateral\n                    .ok_or(ContractError::AssetAlreadyWithdrawn {})?,\n            )?;\n            if loan_value \u003c= get_safe_zone_limit_price(asset_price)? {\n                Ok(BorrowZone::SafeZone)\n            } else if loan_value \u003c= get_expensive_zone_limit_price(asset_price)? {\n                Ok(BorrowZone::ExpensiveZone)\n            } else {\n                Ok(BorrowZone::LiquidationZone)\n            }\n        }\n    }\n}\n\npub fn get_last_collateral(deps: Deps, owner: \u0026Addr) -\u003e Option\u003cu64\u003e {\n    let first_collateral = BORROWS\n        .prefix(owner)\n        .keys(deps.storage, None, None, Order::Descending)\n        .take(1)\n        .collect::\u003cVec\u003cStdResult\u003cu64\u003e\u003e\u003e();\n\n    if let Some(\u0026Ok(collateral)) = first_collateral.first() {\n        Some(collateral)\n    } else {\n        None\n    }\n}\n\npub fn get_total_interests(env: Env, borrow_info: \u0026BorrowInfo) -\u003e Uint128 {\n    let old_interests = match borrow_info.interests {\n        InterestType::Fixed { interests, .. } =\u003e interests,\n        InterestType::Continuous {\n            interests_accrued, ..\n        } =\u003e interests_accrued,\n    };\n    println!(\"{:?}\", old_interests);\n    old_interests + get_new_interests_accrued(env, borrow_info)\n}\n\npub fn get_loan_value(env: Env, borrow_info: \u0026BorrowInfo) -\u003e Uint128 {\n    let interests = get_total_interests(env, borrow_info);\n    borrow_info.principle + interests\n}\n\npub fn get_new_interests_accrued(env: Env, borrow_info: \u0026BorrowInfo) -\u003e Uint128 {\n    match borrow_info.interests {\n        InterestType::Fixed { .. } =\u003e Uint128::zero(),\n        InterestType::Continuous {\n            last_interest_rate, ..\n        } =\u003e get_interests_with(\n            env,\n            borrow_info.principle,\n            last_interest_rate,\n            borrow_info.start_block,\n        ),\n    }\n}\n\npub fn get_interests_with(\n    env: Env,\n    principle: Uint128,\n    interest_rate: Uint128,\n    start_block: u64,\n) -\u003e Uint128 {\n    interest_rate\n        * principle\n        * Uint128::from((env.block.height - start_block) / MIN_BLOCK_OFFSET * MIN_BLOCK_OFFSET)\n        / Uint128::from(PERCENTAGE_RATE)\n    // Here we divide and multiply by MIN_BLOCK_OFFSET to make sure the interests due don't fluctuate too much\n}\npub fn get_liquidation_value(env: Env, borrow_info: \u0026BorrowInfo) -\u003e Result\u003cUint128\u003e {\n    // TODO determine a liquidation strategy\n    Ok(get_loan_value(env, borrow_info))\n}\n\npub fn is_loan_defaulted(deps: Deps, env: Env, borrow_info: \u0026BorrowInfo) -\u003e Result\u003cbool\u003e {\n    // If a duration was specified, the loan defaults if and only if the duration has expired\n    if let InterestType::Fixed { duration, .. } = borrow_info.interests {\n        if borrow_info.start_block + duration \u003c env.block.height {\n            Ok(true)\n        } else {\n            Ok(false)\n        }\n    } else {\n        // Else, we want to rely on the price oracle to determine if the loan is liquidated\n        let asset_info = borrow_info\n            .collateral\n            .clone()\n            .ok_or(ContractError::AssetAlreadyWithdrawn {})?;\n        // We query the asset price using the on-chain oracle\n        let asset_price = get_asset_price(deps, env.clone(), asset_info)?;\n\n        // The loan is considered liquidated when the loan value is more than EXPENSIVE_ZONE_LIMIT*asset_price\n        if get_loan_value(env, borrow_info) \u003e get_expensive_zone_limit_price(asset_price)? {\n            Ok(true)\n        } else {\n            Ok(false)\n        }\n    }\n}\n\npub fn can_repay_loan(\n    deps: Deps,\n    env: Env,\n    sender: Addr,\n    borrower: Addr,\n    borrow_info: \u0026BorrowInfo,\n) -\u003e Result\u003c()\u003e {\n    let loan_defaulted = is_loan_defaulted(deps, env, borrow_info)?;\n\n    if sender == borrower {\n        if loan_defaulted {\n            Err(anyhow::anyhow!(ContractError::CannotRepayWhenDefaulted {}))\n        } else {\n            Ok(())\n        }\n    } else if loan_defaulted {\n        // If the sender is not the borrower and the loan has defaulted,\n        // The sender can repay the loan to claim the associated NFT at a discount\n        Ok(())\n    } else {\n        Err(anyhow::anyhow!(\n            ContractError::CannotLiquidateBeforeDefault {}\n        ))\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","lender","src","state.rs"],"content":"use crate::error::ContractError;\nuse anyhow::{anyhow, Result};\nuse cosmwasm_std::{Addr, DepsMut, MessageInfo, Response, Storage, Uint128};\nuse lender_export::state::{ContractInfo, CONTRACT_INFO, PERCENTAGE_RATE, STATE};\n\npub fn is_owner(storage: \u0026dyn Storage, sender: Addr) -\u003e Result\u003cContractInfo, ContractError\u003e {\n    let contract_info = CONTRACT_INFO.load(storage)?;\n    if sender == contract_info.owner {\n        Ok(contract_info)\n    } else {\n        Err(ContractError::Unauthorized {})\n    }\n}\n\npub fn set_owner(deps: DepsMut, info: MessageInfo, owner: String) -\u003e Result\u003cResponse\u003e {\n    let mut contract_info = is_owner(deps.storage, info.sender.clone())?;\n    contract_info.owner = deps.api.addr_validate(\u0026owner)?;\n    CONTRACT_INFO.save(deps.storage, \u0026contract_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"set_owner\")\n        .add_attribute(\"caller\", info.sender)\n        .add_attribute(\"owner\", owner))\n}\n\npub fn set_oracle(deps: DepsMut, info: MessageInfo, oracle: String) -\u003e Result\u003cResponse\u003e {\n    let mut contract_info = is_owner(deps.storage, info.sender.clone())?;\n    contract_info.oracle = deps.api.addr_validate(\u0026oracle)?;\n    CONTRACT_INFO.save(deps.storage, \u0026contract_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"set_oracle\")\n        .add_attribute(\"caller\", info.sender)\n        .add_attribute(\"oracle\", oracle))\n}\n\npub fn set_lock(deps: DepsMut, info: MessageInfo, lock: bool) -\u003e Result\u003cResponse\u003e {\n    is_owner(deps.storage, info.sender.clone())?;\n\n    STATE.update::\u003c_, anyhow::Error\u003e(deps.storage, |mut x| {\n        x.borrow_locked = lock;\n        Ok(x)\n    })?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"set_oracle\")\n        .add_attribute(\"caller\", info.sender)\n        .add_attribute(\"lock\", lock.to_string()))\n}\n\npub fn set_increasor_incentives(\n    deps: DepsMut,\n    info: MessageInfo,\n    incentives: Uint128,\n) -\u003e Result\u003cResponse\u003e {\n    let mut contract_info = is_owner(deps.storage, info.sender.clone())?;\n    if incentives.u128() \u003e PERCENTAGE_RATE {\n        return Err(anyhow!(ContractError::ParamNotAccepted {}));\n    }\n    contract_info.increasor_incentives = incentives;\n    CONTRACT_INFO.save(deps.storage, \u0026contract_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"set_oracle\")\n        .add_attribute(\"caller\", info.sender)\n        .add_attribute(\"increasor_incentives\", incentives.to_string()))\n}\n\npub fn set_interests_fee_rate(deps: DepsMut, info: MessageInfo, rate: Uint128) -\u003e Result\u003cResponse\u003e {\n    let mut contract_info = is_owner(deps.storage, info.sender.clone())?;\n    if rate.u128() \u003e PERCENTAGE_RATE {\n        return Err(anyhow!(ContractError::ParamNotAccepted {}));\n    }\n    contract_info.interests_fee_rate = rate;\n    CONTRACT_INFO.save(deps.storage, \u0026contract_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"set_oracle\")\n        .add_attribute(\"caller\", info.sender)\n        .add_attribute(\"interests_fee_rate\", rate.to_string()))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","nft-loans","examples","loans_schema.rs"],"content":"use std::env::current_dir;\nuse std::fs::create_dir_all;\n\nuse cosmwasm_schema::{export_schema, remove_schemas, schema_for};\n\nuse nft_loans_export::msg::{ExecuteMsg, InstantiateMsg, QueryMsg};\n\nfn main() {\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"schema\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n\n    export_schema(\u0026schema_for!(InstantiateMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(ExecuteMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(QueryMsg), \u0026out_dir);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","nft-loans","src","contract.rs"],"content":"#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\nuse cosmwasm_std::{\n    coins, to_binary, Addr, BankMsg, Binary, CosmosMsg, Deps, DepsMut, Env, MessageInfo, Order,\n    Response, StdError, StdResult, Uint128,\n};\nuse cw_storage_plus::Bound;\n\nuse crate::error::ContractError;\n\nuse crate::state::{\n    add_new_offer, can_repay_loan, get_active_loan, get_offer, is_active_lender,\n    is_collateral_withdrawable, is_lender, is_loan_acceptable, is_loan_counterable,\n    is_loan_defaulted, is_loan_modifiable, is_owner, BORROWER_INFO, COLLATERAL_INFO, CONTRACT_INFO,\n    LENDER_OFFERS,\n};\n\nuse cw1155::Cw1155ExecuteMsg;\nuse cw721::Cw721ExecuteMsg;\n\nuse nft_loans_export::msg::{\n    CollateralResponse, ExecuteMsg, InstantiateMsg, MigrateMsg, OfferResponse, QueryMsg,\n};\nuse nft_loans_export::state::{\n    BorrowerInfo, CollateralInfo, ContractInfo, LoanState, LoanTerms, OfferInfo, OfferState,\n};\nuse utils::msg::into_cosmos_msg;\nuse utils::state::{AssetInfo, Cw1155Coin, Cw721Coin};\n\nuse fee_distributor_export::msg::ExecuteMsg as FeeDistributorMsg;\n\nconst MAX_QUERY_LIMIT: u32 = 30;\nconst DEFAULT_QUERY_LIMIT: u32 = 10;\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // Verify the contract name\n    msg.validate()?;\n    // store token info\n    let data = ContractInfo {\n        name: msg.name,\n        owner: deps\n            .api\n            .addr_validate(\u0026msg.owner.unwrap_or_else(|| info.sender.to_string()))?,\n        fee_distributor: msg.fee_distributor,\n        fee_rate: msg.fee_rate,\n    };\n    CONTRACT_INFO.save(deps.storage, \u0026data)?;\n    Ok(Response::default()\n        .add_attribute(\"action\", \"initialization\")\n        .add_attribute(\"contract\", \"p2p-loans\"))\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    match msg {\n        ExecuteMsg::DepositCollateral {\n            address,\n            token_id,\n            value,\n            terms,\n        } =\u003e deposit_collateral(deps, env, info, address, token_id, value, terms),\n        ExecuteMsg::WithdrawCollateral { loan_id } =\u003e withdraw_collateral(deps, env, info, loan_id),\n\n        ExecuteMsg::SetTerms { loan_id, terms } =\u003e set_loan_terms(deps, env, info, loan_id, terms),\n        ExecuteMsg::AcceptLoan { borrower, loan_id } =\u003e {\n            accept_loan(deps, env, info, borrower, loan_id)\n        }\n\n        ExecuteMsg::AcceptOffer { loan_id, offer_id } =\u003e {\n            accept_offer(deps, env, info, loan_id, offer_id)\n        }\n        ExecuteMsg::MakeOffer {\n            borrower,\n            loan_id,\n            terms,\n        } =\u003e make_offer(deps, env, info, borrower, loan_id, terms),\n\n        ExecuteMsg::CancelOffer {\n            borrower,\n            loan_id,\n            offer_id,\n        } =\u003e cancel_offer(deps, env, info, borrower, loan_id, offer_id),\n\n        ExecuteMsg::RefuseOffer { loan_id, offer_id } =\u003e {\n            refuse_offer(deps, env, info, loan_id, offer_id)\n        }\n\n        ExecuteMsg::WithdrawRefusedOffer {\n            borrower,\n            loan_id,\n            offer_id,\n        } =\u003e withdraw_refused_offer(deps, env, info, borrower, loan_id, offer_id),\n\n        ExecuteMsg::RepayBorrowedFunds { loan_id } =\u003e {\n            repay_borrowed_funds(deps, env, info, loan_id)\n        }\n        ExecuteMsg::WithdrawDefaultedLoan { borrower, loan_id } =\u003e {\n            withdraw_defaulted_loan(deps, env, info, borrower, loan_id)\n        }\n\n        // Internal Contract Logic\n        ExecuteMsg::SetOwner { owner } =\u003e set_owner(deps, env, info, owner),\n\n        ExecuteMsg::SetFeeDistributor { fee_depositor } =\u003e {\n            set_fee_distributor(deps, env, info, fee_depositor)\n        }\n\n        ExecuteMsg::SetFeeRate { fee_rate } =\u003e set_fee_rate(deps, env, info, fee_rate),\n\n        // Generic (will have to remove at the end of development)\n        _ =\u003e Err(ContractError::Std(StdError::generic_err(\n            \"Ow whaou, please wait just a bit, it's not implemented yet !\",\n        ))),\n    }\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn migrate(_deps: DepsMut, _env: Env, _msg: MigrateMsg) -\u003e Result\u003cResponse, ContractError\u003e {\n    // No state migrations performed, just returned a Response\n    Ok(Response::default())\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::ContractInfo {} =\u003e to_binary(\u0026query_contract_info(deps)?),\n        QueryMsg::CollateralInfo { borrower, loan_id } =\u003e {\n            to_binary(\u0026query_collateral_info(deps, borrower, loan_id)?)\n        }\n        QueryMsg::BorrowerInfo { borrower } =\u003e to_binary(\u0026query_borrower_info(deps, borrower)?),\n    }\n}\n\n/// Owner only function\n/// Sets a new owner\n/// The owner can set the parameters of the contract\n/// * Owner\n/// * Fee distributor contract\n/// * Fee Rate\npub fn set_owner(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    new_owner: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut contract_info = is_owner(deps.storage, info.sender)?;\n\n    let new_owner = deps.api.addr_validate(\u0026new_owner)?;\n    contract_info.owner = new_owner.clone();\n    CONTRACT_INFO.save(deps.storage, \u0026contract_info)?;\n\n    Ok(Response::default()\n        .add_attribute(\"action\", \"changed-contract-parameter\")\n        .add_attribute(\"parameter\", \"owner\")\n        .add_attribute(\"value\", new_owner))\n}\n\n/// Owner only function\n/// Sets a new fee-distributor contract\n/// This contract distributes fees back to the projects (and Illiquidly DAO gets to keep a small amount too)\npub fn set_fee_distributor(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    new_distributor: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut contract_info = is_owner(deps.storage, info.sender)?;\n\n    contract_info.fee_distributor = new_distributor.clone();\n    CONTRACT_INFO.save(deps.storage, \u0026contract_info)?;\n\n    Ok(Response::default()\n        .add_attribute(\"action\", \"changed-contract-parameter\")\n        .add_attribute(\"parameter\", \"fee_distributor\")\n        .add_attribute(\"value\", new_distributor))\n}\n\n/// Owner only function\n/// Sets a new fee rate\n/// fee_rate is in units of a 1/100_000th, so e.g. if fee_rate=5_000, the fee_rate is 5%\n/// It correspond to the part of interests that are kept by the organisation (for redistribution and DAO purposes)\npub fn set_fee_rate(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    new_fee_rate: Uint128,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut contract_info = is_owner(deps.storage, info.sender)?;\n\n    contract_info.fee_rate = new_fee_rate;\n    CONTRACT_INFO.save(deps.storage, \u0026contract_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"changed-contract-parameter\")\n        .add_attribute(\"parameter\", \"fee_rate\")\n        .add_attribute(\"value\", new_fee_rate))\n}\n\n/// Deposit an NFT collateral\n/// This is the first entry point of the loan flow.\n/// Users deposit their collateral for other users to accept their terms in exchange of interest paid at the end of the loan duration\n/// The borrower (the person that deposits collaterals) can specify terms at which they wish to borrow funds against their collateral\n/// If terms are specified, fund lenders can accept the loan directly\n/// If not, lenders can propose terms than may be accepted by the borrower in return to start the loan\n/// This deposit function allows CW721 and CW1155 tokens to be deposited\npub fn deposit_collateral(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    address: String,\n    token_id: String,\n    value: Option\u003cUint128\u003e,\n    terms: Option\u003cLoanTerms\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let borrower = info.sender;\n\n    // We prepare for storing and transfering the token from the borrower to the contract\n    // Yes this is custodial, we could change that to make it non-custodial\n    // REQUIRED TODO make it non-custodial for the lender\n    let (asset_info, transfer_message) = if let Some(value) = value {\n        // In case of a Cw1155\n        (\n            AssetInfo::Cw1155Coin(Cw1155Coin {\n                address: address.clone(),\n                token_id: token_id.clone(),\n                value,\n            }),\n            into_cosmos_msg(\n                Cw1155ExecuteMsg::SendFrom {\n                    from: borrower.to_string(),\n                    to: env.contract.address.into(),\n                    token_id,\n                    value,\n                    msg: None,\n                },\n                address,\n                None,\n            )?,\n        )\n    } else {\n        // In case of a CW721\n        (\n            AssetInfo::Cw721Coin(Cw721Coin {\n                address: address.clone(),\n                token_id: token_id.clone(),\n            }),\n            into_cosmos_msg(\n                Cw721ExecuteMsg::TransferNft {\n                    recipient: env.contract.address.into(),\n                    token_id,\n                },\n                address,\n                None,\n            )?,\n        )\n    };\n\n    // We save the collateral info in our internal structure\n    // First we update the number of collateral a user has deposited (to make sure the id assigned is unique)\n    let loan_id = BORROWER_INFO\n        .update::\u003c_, ContractError\u003e(deps.storage, \u0026borrower.clone(), |x| match x {\n            Some(mut info) =\u003e {\n                info.last_collateral_id += 1;\n                Ok(info)\n            }\n            None =\u003e Ok(BorrowerInfo::default()),\n        })?\n        .last_collateral_id;\n    // Then we save an collateral info object\n    COLLATERAL_INFO.save(\n        deps.storage,\n        (\u0026borrower, loan_id),\n        \u0026CollateralInfo {\n            terms,\n            associated_asset: asset_info,\n            ..Default::default()\n        },\n    )?;\n\n    Ok(Response::new()\n        .add_message(transfer_message)\n        .add_attribute(\"action\", \"deposit-collateral\")\n        .add_attribute(\"borrower\", borrower)\n        .add_attribute(\"loan_id\", loan_id.to_string()))\n}\n\n/// Withdraw an NFT collateral\n/// This simply cancels the potential loan\npub fn withdraw_collateral(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    loan_id: u64,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // We query the loan info\n    let borrower = info.sender;\n    let mut collateral = COLLATERAL_INFO.load(deps.storage, (\u0026borrower, loan_id))?;\n    is_collateral_withdrawable(\u0026collateral)?;\n\n    // We start by creating the transfer message\n    let transfer_message = _withdraw_asset(\n        collateral.associated_asset.clone(),\n        env.contract.address,\n        borrower.clone(),\n    )?;\n\n    // We update the internal state, the loan proposal is no longer valid\n    collateral.state = LoanState::AssetWithdrawn;\n    COLLATERAL_INFO.save(deps.storage, (\u0026borrower, loan_id), \u0026collateral)?;\n\n    Ok(Response::new()\n        .add_message(transfer_message)\n        .add_attribute(\"action\", \"withdraw-collateral\")\n        .add_attribute(\"event\", \"cancel-loan\")\n        .add_attribute(\"borrower\", borrower)\n        .add_attribute(\"loan_id\", loan_id.to_string()))\n}\n\n/// Change the loan terms of a loan before it's accepted by anyone\n/// Or just add some terms because you didn't have the chance before\n/// If you want to update the terms of your collateral, because no-one wanted to accept it or because the market changed\npub fn set_loan_terms(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    loan_id: u64,\n    terms: LoanTerms,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // We query the loan info\n    let borrower = info.sender;\n    let mut collateral = COLLATERAL_INFO.load(deps.storage, (\u0026borrower, loan_id))?;\n    is_loan_modifiable(\u0026collateral)?;\n\n    // Update the terms\n    collateral.terms = Some(terms);\n    COLLATERAL_INFO.save(deps.storage, (\u0026borrower, loan_id), \u0026collateral)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"modify-loan_terms\")\n        .add_attribute(\"borrower\", borrower)\n        .add_attribute(\"loan_id\", loan_id.to_string()))\n}\n\n/// Make an offer (offer some terms) to lend some money against someone's collateral\n/// The borrower will then be able to accept those terms if they please them\npub fn make_offer(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    borrower: String,\n    loan_id: u64,\n    terms: LoanTerms,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // We query the loan info\n    let borrower = deps.api.addr_validate(\u0026borrower)?;\n    let mut collateral = COLLATERAL_INFO.load(deps.storage, (\u0026borrower, loan_id))?;\n    is_loan_counterable(\u0026collateral)?;\n\n    // Make sure the transaction contains funds that match the principle indicated in the terms\n    if info.funds.len() != 1 {\n        return Err(ContractError::MultipleCoins {});\n    } else if terms.principle != info.funds[0].clone() {\n        return Err(ContractError::FundsDontMatchTerms {});\n    }\n\n    let offer_id = add_new_offer(\n        deps.storage,\n        \u0026mut collateral,\n        (borrower.clone(), loan_id),\n        OfferInfo {\n            lender: info.sender.clone(),\n            terms,\n            state: OfferState::Published,\n            deposited_funds: Some(info.funds[0].clone()),\n        },\n    )?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"make-offer\")\n        .add_attribute(\"borrower\", borrower)\n        .add_attribute(\"lender\", info.sender)\n        .add_attribute(\"loan_id\", loan_id.to_string())\n        .add_attribute(\"offer_id\", offer_id.to_string()))\n}\n\n/// Cancel an offer you made in case the market changes or whatever\n/// The borrower won't be able to accept the loan if you cancel it\npub fn cancel_offer(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    borrower: String,\n    loan_id: u64,\n    offer_id: u64,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let lender = info.sender;\n    // We query the loan info\n    let borrower = deps.api.addr_validate(\u0026borrower)?;\n    let mut collateral = COLLATERAL_INFO.load(deps.storage, (\u0026borrower, loan_id))?;\n\n    // We can cancel an offer only if the Borrower is still searching for a loan\n    if collateral.state != LoanState::Published {\n        return Err(ContractError::Unauthorized {});\n    }\n    // We need to verify the offer exists and it belongs to the address calling the contract and that's in the right state to be cancelled\n    let mut offer = is_lender(lender.clone(), \u0026collateral, offer_id as usize)?;\n    if offer.state != OfferState::Published {\n        return Err(ContractError::CantChangeOfferState {\n            from: offer.state,\n            to: OfferState::Cancelled,\n        });\n    }\n\n    // The funds deposited for lending are withdrawn\n    let withdraw_response = _withdraw_offer_unsafe(\n        deps.as_ref(),\n        borrower.clone(),\n        lender.clone(),\n        loan_id,\n        offer_id as usize,\n    )?;\n\n    // We save the changes in the collateral object\n    offer.state = OfferState::Cancelled;\n    collateral.offers[offer_id as usize] = offer;\n    // And mark the deposited funds as withdrawn\n    collateral.offers[offer_id as usize].deposited_funds = None;\n    COLLATERAL_INFO.save(deps.storage, (\u0026borrower, loan_id), \u0026collateral)?;\n\n    Ok(Response::new()\n        .add_message(withdraw_response)\n        .add_attribute(\"action\", \"cancel-offer\")\n        .add_attribute(\"action\", \"withdraw-funds\")\n        .add_attribute(\"borrower\", borrower)\n        .add_attribute(\"lender\", lender)\n        .add_attribute(\"loan_id\", loan_id.to_string())\n        .add_attribute(\"offer_id\", offer_id.to_string()))\n}\n\n/// Withdraw the funds from a refused offer\n/// In case the borrower refuses your offer, you need to manually withdraw your funds\n/// This is actually done in order for you to know where your funds are and keep control of your transfers\npub fn withdraw_refused_offer(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    borrower: String,\n    loan_id: u64,\n    offer_id: u64,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let lender = info.sender;\n    // We query the loan info\n    let borrower = deps.api.addr_validate(\u0026borrower)?;\n    let mut collateral = COLLATERAL_INFO.load(deps.storage, (\u0026borrower, loan_id))?;\n\n    // We need to verify the offer exists and the sender is actually the owner of the offer\n    let offer = is_lender(lender.clone(), \u0026collateral, offer_id as usize)?;\n\n    // TODO, please verify this shit right there\n    if offer.state != OfferState::Refused {\n        return Err(ContractError::NotWithdrawable {});\n    }\n\n    // The funds deposited for lending are withdrawn\n    let withdraw_message = _withdraw_offer_unsafe(\n        deps.as_ref(),\n        borrower.clone(),\n        lender.clone(),\n        loan_id,\n        offer_id as usize,\n    )?;\n\n    // And we mark the deposited funds as withdrawn\n    collateral.offers[offer_id as usize].deposited_funds = None;\n    COLLATERAL_INFO.save(deps.storage, (\u0026borrower, loan_id), \u0026collateral)?;\n\n    Ok(Response::new()\n        .add_message(withdraw_message)\n        .add_attribute(\"action\", \"withdraw-funds\")\n        .add_attribute(\"event\", \"refused-offer\")\n        .add_attribute(\"borrower\", borrower)\n        .add_attribute(\"lender\", lender)\n        .add_attribute(\"loan_id\", loan_id.to_string())\n        .add_attribute(\"offer_id\", offer_id.to_string()))\n}\n\n/// This creates withdraw messages to withdraw the funds from an offer (to the lender of the borrower depending on the situation\n/// This function does not do any checks on the validity of the procedure\n/// Be careful when using this internal function\npub fn _withdraw_offer_unsafe(\n    deps: Deps,\n    borrower: Addr,\n    recipient: Addr,\n    loan_id: u64,\n    offer_id: usize,\n) -\u003e Result\u003cBankMsg, ContractError\u003e {\n    // We query the loan info\n    let collateral = COLLATERAL_INFO.load(deps.storage, (\u0026borrower, loan_id))?;\n    let offer = get_offer(\u0026collateral, offer_id)?;\n\n    // We get the funds to withdraw\n    let funds_to_withdraw = offer\n        .deposited_funds\n        .ok_or(ContractError::NoFundsToWithdraw {})?;\n\n    Ok(BankMsg::Send {\n        to_address: recipient.to_string(),\n        amount: vec![funds_to_withdraw],\n    })\n}\n\n/// Refuse an offer to a borrowers collateral\n/// This is needed only for printing and db procedure, and not actually needed in the flow\n/// This however blocks other interactions with the offer (except withdrawing the funds)\npub fn refuse_offer(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    loan_id: u64,\n    offer_id: u64,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // We query the loan info\n    let borrower = info.sender;\n    let mut collateral = COLLATERAL_INFO.load(deps.storage, (\u0026borrower, loan_id))?;\n\n    // Mark the offer as refused\n    let mut offer = get_offer(\u0026collateral, offer_id as usize)?;\n    offer.state = OfferState::Refused;\n    collateral.offers[offer_id as usize] = offer.clone();\n\n    // And save the changes to the collateral object\n    COLLATERAL_INFO.save(deps.storage, (\u0026borrower, loan_id), \u0026collateral)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"refuse-offer\")\n        .add_attribute(\"borrower\", borrower)\n        .add_attribute(\"lender\", offer.lender)\n        .add_attribute(\"loan_id\", loan_id.to_string())\n        .add_attribute(\"offer_id\", offer_id.to_string()))\n}\n\n/// Accept a loan and its terms directly\n/// As soon as the lender executes this messages, the loan starts and the borrower will need to repay the loan before the term\npub fn accept_loan(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    borrower: String,\n    loan_id: u64,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // We query the loan info\n    let borrower = deps.api.addr_validate(\u0026borrower)?;\n    let mut collateral = COLLATERAL_INFO.load(deps.storage, (\u0026borrower, loan_id))?;\n\n    // We verify the loan is acceptable as is\n    is_loan_acceptable(\u0026collateral)?;\n    let terms: LoanTerms = collateral\n        .terms\n        .clone()\n        .ok_or(ContractError::NoTermsSpecified {})?;\n\n    // We verify the funds received from the lender\n    if info.funds.len() != 1 {\n        return Err(ContractError::MultipleCoins {});\n    } else if terms.principle != info.funds[0].clone() {\n        return Err(ContractError::FundsDontMatchTerms {});\n    }\n\n    // Then we can save the original offer as accepted\n    collateral.state = LoanState::Started;\n    collateral.start_block = Some(env.block.height);\n\n    // We add this offer at the end of the list of offers.\n    // All other offers are marked as refused automatically (see `get_offer` in state.rs)\n    let offer_id = add_new_offer(\n        deps.storage,\n        \u0026mut collateral,\n        (borrower.clone(), loan_id),\n        OfferInfo {\n            lender: info.sender.clone(),\n            terms: terms.clone(),\n            state: OfferState::Accepted,\n            deposited_funds: Some(info.funds[0].clone()),\n        },\n    )?;\n    // We update the active loan variable\n    collateral.active_loan = Some(offer_id);\n    COLLATERAL_INFO.save(deps.storage, (\u0026borrower, loan_id), \u0026collateral)?;\n\n    // We withdraw funds to the borrower\n    let message = _withdraw_offer_unsafe(\n        deps.as_ref(),\n        borrower.clone(),\n        borrower.clone(),\n        loan_id,\n        offer_id as usize,\n    )?;\n\n    Ok(Response::new()\n        .add_message(message)\n        .add_attribute(\"action\", \"start-loan\")\n        .add_attribute(\"denom-borrowed\", terms.principle.denom)\n        .add_attribute(\"amount_borrowed\", terms.principle.amount.to_string())\n        .add_attribute(\"borrower\", borrower)\n        .add_attribute(\"lender\", info.sender)\n        .add_attribute(\"loan_id\", loan_id.to_string())\n        .add_attribute(\"offer_id\", offer_id.to_string()))\n}\n\n/// Accept an offer someone made for your collateral\n/// As soon as the borrower executes this messages, the loan starts and the they will need to repay the loan before the term\npub fn accept_offer(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    loan_id: u64,\n    offer_id: u64,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // We query the loan info\n    let borrower = info.sender;\n    let mut collateral = COLLATERAL_INFO.load(deps.storage, (\u0026borrower, loan_id))?;\n    is_loan_acceptable(\u0026collateral)?;\n    let offer_id_usize = offer_id as usize;\n    let mut offer = get_offer(\u0026collateral, offer_id_usize)?;\n\n    // We verify the offer is still valid\n    if offer.state == OfferState::Published {\n        // We can start the loan right away !\n        collateral.state = LoanState::Started;\n        collateral.start_block = Some(env.block.height);\n        collateral.active_loan = Some(offer_id);\n        offer.state = OfferState::Accepted;\n        collateral.offers[offer_id_usize] = offer.clone();\n\n        COLLATERAL_INFO.save(deps.storage, (\u0026borrower, loan_id), \u0026collateral)?;\n    } else {\n        return Err(ContractError::OfferNotFound {});\n    };\n\n    // We transfer the funds directly when the offer is accepted\n    let message = _withdraw_offer_unsafe(\n        deps.as_ref(),\n        borrower.clone(),\n        borrower.clone(),\n        loan_id,\n        offer_id as usize,\n    )?;\n\n    Ok(Response::new()\n        .add_message(message)\n        .add_attribute(\"action\", \"start-loan\")\n        .add_attribute(\"denom-borrowed\", offer.terms.principle.denom)\n        .add_attribute(\"amount_borrowed\", offer.terms.principle.amount.to_string())\n        .add_attribute(\"borrower\", borrower)\n        .add_attribute(\"lender\", offer.lender)\n        .add_attribute(\"loan_id\", loan_id.to_string())\n        .add_attribute(\"offer_id\", offer_id.to_string()))\n}\n\n/// Repay Borrowed funds and get back your collateral\n/// This function receives principle + interest funds to end the loan and unlock the collateral\npub fn repay_borrowed_funds(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    loan_id: u64,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let contract_info = CONTRACT_INFO.load(deps.storage)?;\n    // We query the loan info\n    let borrower = info.sender;\n    let mut collateral = COLLATERAL_INFO.load(deps.storage, (\u0026borrower, loan_id))?;\n    can_repay_loan(env.clone(), \u0026collateral)?;\n    let offer = get_active_loan(\u0026collateral)?;\n\n    // We verify the sent funds correspond to the principle + interests\n    let interests = offer.terms.interest;\n    if info.funds.len() != 1 {\n        return Err(ContractError::MultipleCoins {});\n    } else if offer.terms.principle.denom != info.funds[0].denom.clone() {\n        return Err(ContractError::Std(StdError::generic_err(\n            \"You didn't send the right kind of funds\",\n        )));\n    } else if offer.terms.principle.amount + interests \u003e info.funds[0].amount {\n        return Err(ContractError::Std(StdError::generic_err(\n            format!(\n                \"Fund sent do not match the loan terms (principle + interests). Needed : {needed}, Received : {received}\", \n                needed = offer.terms.principle.amount + interests,\n                received = info.funds[0].amount.clone()\n            )\n        )));\n    }\n\n    // We save the collateral state\n    collateral.state = LoanState::Ended;\n    COLLATERAL_INFO.save(deps.storage, (\u0026borrower, loan_id), \u0026collateral)?;\n\n    // We prepare the funds to send back to the lender\n    let lender_payback = offer.terms.principle.amount\n        + interests * (Uint128::new(100_000u128) - contract_info.fee_rate)\n            / Uint128::new(100_000u128);\n\n    // And the funds to send to the fee_depositor contract\n    let fee_depositor_payback = info.funds[0].amount - lender_payback;\n\n    // The fee depositor needs to know which assets where involved in the transaction\n    let collateral_address = match \u0026collateral.associated_asset {\n        AssetInfo::Cw1155Coin(cw1155) =\u003e cw1155.address.clone(),\n        AssetInfo::Cw721Coin(cw721) =\u003e cw721.address.clone(),\n        _ =\u003e {\n            return Err(ContractError::Std(StdError::generic_err(\n                \"Unreachable error\",\n            )))\n        }\n    };\n\n    Ok(Response::new()\n        // We get the funds back to the lender\n        .add_message(BankMsg::Send {\n            to_address: offer.lender.to_string(),\n            amount: coins(lender_payback.u128(), info.funds[0].denom.clone()),\n        })\n        // And the collateral back to the borrower\n        .add_message(_withdraw_asset(\n            collateral.associated_asset.clone(),\n            env.contract.address,\n            borrower.clone(),\n        )?)\n        // And we pay the fee to the treasury\n        .add_message(into_cosmos_msg(\n            FeeDistributorMsg::DepositFees {\n                addresses: vec![collateral_address],\n            },\n            contract_info.fee_distributor,\n            Some(coins(\n                fee_depositor_payback.u128(),\n                info.funds[0].denom.clone(),\n            )),\n        )?)\n        .add_attribute(\"action\", \"repay-loan\")\n        .add_attribute(\"borrower\", borrower)\n        .add_attribute(\"lender\", offer.lender)\n        .add_attribute(\"loan_id\", loan_id.to_string()))\n}\n\n/// Withdraw the collateral from a defaulted loan\n/// If the loan duration has exceeded, the collateral can be withdrawn by the lender\n/// This closes the loan and puts it in a defaulted state\npub fn withdraw_defaulted_loan(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    borrower: String,\n    loan_id: u64,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // We query the loan info\n    let borrower = deps.api.addr_validate(\u0026borrower)?;\n    let mut collateral = COLLATERAL_INFO.load(deps.storage, (\u0026borrower, loan_id))?;\n    is_loan_defaulted(env.clone(), \u0026collateral)?;\n    let offer = is_active_lender(info.sender, \u0026collateral)?;\n\n    // We need to test if the loan hasn't already been defaulted\n    if collateral.state == LoanState::Defaulted {\n        return Err(ContractError::LoanAlreadyDefaulted {});\n    }\n\n    // Saving the collateral state, the loan is defaulted, we can default it again\n    collateral.state = LoanState::Defaulted;\n    COLLATERAL_INFO.save(deps.storage, (\u0026borrower, loan_id), \u0026collateral)?;\n\n    // We create the collateral withdrawal message\n    let withdraw_message = _withdraw_asset(\n        collateral.associated_asset.clone(),\n        env.contract.address,\n        offer.lender.clone(),\n    )?;\n\n    Ok(Response::new()\n        .add_message(withdraw_message)\n        .add_attribute(\"action\", \"default-loan\")\n        .add_attribute(\"borrower\", borrower)\n        .add_attribute(\"lender\", offer.lender)\n        .add_attribute(\"loan_id\", loan_id.to_string()))\n}\n\npub fn _withdraw_asset(asset: AssetInfo, sender: Addr, recipient: Addr) -\u003e StdResult\u003cCosmosMsg\u003e {\n    match asset {\n        AssetInfo::Cw1155Coin(cw1155) =\u003e {\n            let address = cw1155.address;\n            let token_id = cw1155.token_id;\n            into_cosmos_msg(\n                Cw1155ExecuteMsg::SendFrom {\n                    from: sender.to_string(),\n                    to: recipient.to_string(),\n                    token_id,\n                    value: cw1155.value,\n                    msg: None,\n                },\n                address,\n                None,\n            )\n        }\n\n        AssetInfo::Cw721Coin(cw721) =\u003e {\n            let address = cw721.address;\n            let token_id = cw721.token_id;\n            into_cosmos_msg(\n                Cw721ExecuteMsg::TransferNft {\n                    recipient: recipient.to_string(),\n                    token_id,\n                },\n                address,\n                None,\n            )\n        }\n        _ =\u003e Err(StdError::generic_err(\"Unreachable error\")),\n    }\n}\n\n// TODO we need more queries, to query loan by user\npub fn query_contract_info(deps: Deps) -\u003e StdResult\u003cContractInfo\u003e {\n    CONTRACT_INFO.load(deps.storage)\n}\n\npub fn query_collateral_info(\n    deps: Deps,\n    borrower: String,\n    loan_id: u64,\n) -\u003e StdResult\u003cCollateralInfo\u003e {\n    let borrower = deps.api.addr_validate(\u0026borrower)?;\n    COLLATERAL_INFO\n        .load(deps.storage, (\u0026borrower, loan_id))\n        .map_err(|_| StdError::generic_err(\"LoanNotFound\"))\n}\n\npub fn query_offer_info(\n    deps: Deps,\n    borrower: String,\n    loan_id: u64,\n    offer_id: u64,\n) -\u003e StdResult\u003cOfferInfo\u003e {\n    let borrower = deps.api.addr_validate(\u0026borrower)?;\n    let collateral = COLLATERAL_INFO\n        .load(deps.storage, (\u0026borrower, loan_id))\n        .map_err(|_| StdError::generic_err(\"LoanNotFound\"))?;\n\n    get_offer(\u0026collateral, offer_id as usize).map_err(|_| StdError::generic_err(\"OfferNotFound\"))\n}\n\npub fn query_borrower_info(deps: Deps, borrower: String) -\u003e StdResult\u003cBorrowerInfo\u003e {\n    let borrower = deps.api.addr_validate(\u0026borrower)?;\n    BORROWER_INFO\n        .load(deps.storage, \u0026borrower)\n        .map_err(|_| StdError::generic_err(\"UnknownBorrower\"))\n}\n\npub fn query_collaterals(\n    deps: Deps,\n    borrower: String,\n    start_after: Option\u003cu64\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e StdResult\u003cVec\u003cCollateralResponse\u003e\u003e {\n    let borrower = deps.api.addr_validate(\u0026borrower)?;\n    let limit = limit.unwrap_or(DEFAULT_QUERY_LIMIT).min(MAX_QUERY_LIMIT) as usize;\n    let start = start_after.map(Bound::exclusive);\n\n    COLLATERAL_INFO\n        .prefix(\u0026borrower)\n        .range(deps.storage, None, start, Order::Descending)\n        .map(|result| {\n            result.map(|(loan_id, el)| CollateralResponse {\n                borrower: borrower.to_string(),\n                loan_id,\n                collateral: el,\n            })\n        })\n        .take(limit)\n        .collect()\n}\n\npub fn query_offers(\n    deps: Deps,\n    lender: String,\n    start_after: Option\u003cu32\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e StdResult\u003cVec\u003cOfferResponse\u003e\u003e {\n    let lender = deps.api.addr_validate(\u0026lender)?;\n    let limit = limit.unwrap_or(DEFAULT_QUERY_LIMIT).min(MAX_QUERY_LIMIT) as usize;\n    let start = start_after.unwrap_or(0u32) as usize;\n\n    Ok(LENDER_OFFERS\n        .load(deps.storage, \u0026lender)\n        .unwrap_or_default()\n        .iter()\n        .skip(start)\n        .map(|x| OfferResponse {\n            lender: lender.to_string(),\n            borrower: x.0.to_string(),\n            loan_id: x.1,\n            offer_id: x.2,\n        })\n        .take(limit)\n        .collect())\n}\n\n#[cfg(test)]\npub mod tests {\n    use super::*;\n    use cosmwasm_std::{\n        coin, coins,\n        testing::{mock_dependencies, mock_env, mock_info},\n        Api, Coin, SubMsg,\n    };\n\n    fn init_helper(deps: DepsMut) {\n        let instantiate_msg = InstantiateMsg {\n            name: \"nft-loan\".to_string(),\n            owner: None,\n            fee_distributor: \"T\".to_string(),\n            fee_rate: Uint128::new(5_000u128),\n        };\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n\n        instantiate(deps, env, info, instantiate_msg).unwrap();\n    }\n\n    #[test]\n    fn test_init_sanity() {\n        let mut deps = mock_dependencies();\n        let instantiate_msg = InstantiateMsg {\n            name: \"p2p-trading\".to_string(),\n            owner: Some(\"this_address\".to_string()),\n            fee_distributor: \"T\".to_string(),\n            fee_rate: Uint128::new(5_000u128),\n        };\n        let info = mock_info(\"owner\", \u0026[]);\n        let env = mock_env();\n\n        let res_init = instantiate(deps.as_mut(), env.clone(), info, instantiate_msg).unwrap();\n        assert_eq!(0, res_init.messages.len());\n\n        let contract = CONTRACT_INFO.load(\u0026deps.storage).unwrap();\n        assert_eq!(\n            contract,\n            ContractInfo {\n                name: \"p2p-trading\".to_string(),\n                owner: deps.api.addr_validate(\"this_address\").unwrap(),\n                fee_distributor: \"T\".to_string(),\n                fee_rate: Uint128::new(5_000u128),\n            }\n        );\n\n        let info = mock_info(\"this_address\", \u0026[]);\n        let bad_info = mock_info(\"bad_person\", \u0026[]);\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            ExecuteMsg::SetFeeDistributor {\n                fee_depositor: \"S\".to_string(),\n            },\n        )\n        .unwrap();\n        assert_eq!(\n            CONTRACT_INFO.load(\u0026deps.storage).unwrap().fee_distributor,\n            \"S\".to_string()\n        );\n\n        let unauthorized = execute(\n            deps.as_mut(),\n            env.clone(),\n            bad_info.clone(),\n            ExecuteMsg::SetFeeDistributor {\n                fee_depositor: \"S\".to_string(),\n            },\n        )\n        .unwrap_err();\n        assert_eq!(unauthorized, ContractError::Unauthorized {});\n\n        // We test changing the owner\n        let unauthorized = execute(\n            deps.as_mut(),\n            env.clone(),\n            bad_info.clone(),\n            ExecuteMsg::SetOwner {\n                owner: \"new_owner\".to_string(),\n            },\n        )\n        .unwrap_err();\n        assert_eq!(unauthorized, ContractError::Unauthorized {});\n\n        // We test changing the owner\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            ExecuteMsg::SetOwner {\n                owner: \"new_owner\".to_string(),\n            },\n        )\n        .unwrap();\n        assert_eq!(\n            CONTRACT_INFO.load(\u0026deps.storage).unwrap().owner,\n            \"new_owner\".to_string()\n        );\n\n        let info = mock_info(\"new_owner\", \u0026[]);\n\n        let unauthorized = execute(\n            deps.as_mut(),\n            env.clone(),\n            bad_info,\n            ExecuteMsg::SetFeeRate {\n                fee_rate: Uint128::new(500u128),\n            },\n        )\n        .unwrap_err();\n        assert_eq!(unauthorized, ContractError::Unauthorized {});\n\n        execute(\n            deps.as_mut(),\n            env,\n            info,\n            ExecuteMsg::SetFeeRate {\n                fee_rate: Uint128::new(500u128),\n            },\n        )\n        .unwrap();\n        assert_eq!(\n            CONTRACT_INFO.load(\u0026deps.storage).unwrap().fee_rate,\n            Uint128::new(500u128)\n        );\n    }\n\n    fn add_collateral_helper(\n        deps: DepsMut,\n        creator: \u0026str,\n        address: \u0026str,\n        token_id: \u0026str,\n        value: Option\u003cUint128\u003e,\n        terms: Option\u003cLoanTerms\u003e,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(creator, \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::DepositCollateral {\n                address: address.to_string(),\n                token_id: token_id.to_string(),\n                value,\n                terms,\n            },\n        )\n    }\n\n    fn set_terms_helper(\n        deps: DepsMut,\n        borrower: \u0026str,\n        loan_id: u64,\n        terms: LoanTerms,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(borrower, \u0026[]);\n        let env = mock_env();\n\n        execute(deps, env, info, ExecuteMsg::SetTerms { loan_id, terms })\n    }\n\n    fn make_offer_helper(\n        deps: DepsMut,\n        lender: \u0026str,\n        borrower: \u0026str,\n        loan_id: u64,\n        terms: LoanTerms,\n        coins: Vec\u003cCoin\u003e,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(lender, \u0026coins);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::MakeOffer {\n                borrower: borrower.to_string(),\n                loan_id,\n                terms,\n            },\n        )\n    }\n\n    fn cancel_offer_helper(\n        deps: DepsMut,\n        lender: \u0026str,\n        borrower: \u0026str,\n        loan_id: u64,\n        offer_id: u64,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(lender, \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::CancelOffer {\n                borrower: borrower.to_string(),\n                loan_id,\n                offer_id,\n            },\n        )\n    }\n\n    fn refuse_offer_helper(\n        deps: DepsMut,\n        borrower: \u0026str,\n        loan_id: u64,\n        offer_id: u64,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(borrower, \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::RefuseOffer { loan_id, offer_id },\n        )\n    }\n\n    fn accept_loan_helper(\n        deps: DepsMut,\n        lender: \u0026str,\n        borrower: \u0026str,\n        loan_id: u64,\n        coins: Vec\u003cCoin\u003e,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(lender, \u0026coins);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::AcceptLoan {\n                borrower: borrower.to_string(),\n                loan_id,\n            },\n        )\n    }\n\n    fn accept_offer_helper(\n        deps: DepsMut,\n        borrower: \u0026str,\n        loan_id: u64,\n        offer_id: u64,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(borrower, \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::AcceptOffer { loan_id, offer_id },\n        )\n    }\n\n    fn withdraw_collateral_helper(\n        deps: DepsMut,\n        creator: \u0026str,\n        loan_id: u64,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(creator, \u0026[]);\n        let env = mock_env();\n\n        execute(deps, env, info, ExecuteMsg::WithdrawCollateral { loan_id })\n    }\n\n    fn withdraw_refused_offer_helper(\n        deps: DepsMut,\n        lender: \u0026str,\n        borrower: \u0026str,\n        loan_id: u64,\n        offer_id: u64,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(lender, \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::WithdrawRefusedOffer {\n                borrower: borrower.to_string(),\n                loan_id,\n                offer_id,\n            },\n        )\n    }\n    fn repay_borrowed_funds_helper(\n        deps: DepsMut,\n        borrower: \u0026str,\n        loan_id: u64,\n        funds: Vec\u003cCoin\u003e,\n        env: Env,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(borrower, \u0026funds);\n\n        execute(deps, env, info, ExecuteMsg::RepayBorrowedFunds { loan_id })\n    }\n    fn withdraw_defaulted_loan_helper(\n        deps: DepsMut,\n        lender: \u0026str,\n        borrower: \u0026str,\n        loan_id: u64,\n        env: Env,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(lender, \u0026[]);\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::WithdrawDefaultedLoan {\n                borrower: borrower.to_string(),\n                loan_id,\n            },\n        )\n    }\n\n    #[test]\n    fn test_add_collateral() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n        // We make sure the collateral is deposited correctly\n        let res = add_collateral_helper(deps.as_mut(), \"creator\", \"nft\", \"58\", None, None).unwrap();\n        assert_eq!(1, res.messages.len());\n\n        // Other collaterals\n        add_collateral_helper(deps.as_mut(), \"creator\", \"nft\", \"59\", None, None).unwrap();\n        add_collateral_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"nft\",\n            \"59\",\n            Some(Uint128::from(459u128)),\n            None,\n        )\n        .unwrap();\n\n        let creator_addr = deps.api.addr_validate(\"creator\").unwrap();\n        let coll_info = COLLATERAL_INFO\n            .load(\u0026deps.storage, (\u0026creator_addr, 0))\n            .unwrap();\n        assert_eq!(\n            coll_info,\n            CollateralInfo {\n                associated_asset: AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft\".to_string(),\n                    token_id: \"58\".to_string()\n                }),\n                ..Default::default()\n            }\n        );\n\n        let coll_info = COLLATERAL_INFO\n            .load(\u0026deps.storage, (\u0026creator_addr, 1))\n            .unwrap();\n        assert_eq!(\n            coll_info,\n            CollateralInfo {\n                associated_asset: AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft\".to_string(),\n                    token_id: \"59\".to_string()\n                }),\n                ..Default::default()\n            }\n        );\n\n        let coll_info = COLLATERAL_INFO\n            .load(\u0026deps.storage, (\u0026creator_addr, 2))\n            .unwrap();\n        assert_eq!(\n            coll_info,\n            CollateralInfo {\n                associated_asset: AssetInfo::Cw1155Coin(Cw1155Coin {\n                    address: \"nft\".to_string(),\n                    token_id: \"59\".to_string(),\n                    value: Uint128::from(459u128)\n                }),\n                ..Default::default()\n            }\n        );\n    }\n\n    #[test]\n    fn test_withdraw_collateral() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n        add_collateral_helper(deps.as_mut(), \"creator\", \"nft\", \"58\", None, None).unwrap();\n        add_collateral_helper(deps.as_mut(), \"creator\", \"nft\", \"59\", None, None).unwrap();\n        add_collateral_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"nft\",\n            \"59\",\n            Some(Uint128::from(459u128)),\n            None,\n        )\n        .unwrap();\n\n        withdraw_collateral_helper(deps.as_mut(), \"creator\", 1).unwrap();\n        withdraw_collateral_helper(deps.as_mut(), \"creator\", 0).unwrap();\n\n        let creator_addr = deps.api.addr_validate(\"creator\").unwrap();\n        let coll_info = COLLATERAL_INFO\n            .load(\u0026deps.storage, (\u0026creator_addr, 0))\n            .unwrap();\n        assert_eq!(\n            coll_info,\n            CollateralInfo {\n                associated_asset: AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft\".to_string(),\n                    token_id: \"58\".to_string()\n                }),\n                state: LoanState::AssetWithdrawn,\n                ..Default::default()\n            }\n        );\n\n        let coll_info = COLLATERAL_INFO\n            .load(\u0026deps.storage, (\u0026creator_addr, 1))\n            .unwrap();\n        assert_eq!(\n            coll_info,\n            CollateralInfo {\n                associated_asset: AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft\".to_string(),\n                    token_id: \"59\".to_string()\n                }),\n                state: LoanState::AssetWithdrawn,\n                ..Default::default()\n            }\n        );\n\n        let coll_info = COLLATERAL_INFO\n            .load(\u0026deps.storage, (\u0026creator_addr, 2))\n            .unwrap();\n        assert_eq!(\n            coll_info,\n            CollateralInfo {\n                terms: None,\n                associated_asset: AssetInfo::Cw1155Coin(Cw1155Coin {\n                    address: \"nft\".to_string(),\n                    token_id: \"59\".to_string(),\n                    value: Uint128::from(459u128)\n                }),\n                ..Default::default()\n            }\n        );\n        // You shouldn't be able to repay the loan now\n        let repay_err = repay_borrowed_funds_helper(\n            deps.as_mut(),\n            \"creator\",\n            0,\n            coins(506, \"luna\"),\n            mock_env(),\n        )\n        .unwrap_err();\n        assert_eq!(\n            repay_err,\n            ContractError::WrongLoanState {\n                state: LoanState::AssetWithdrawn\n            }\n        )\n    }\n\n    #[test]\n    fn test_accept_loan() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n        add_collateral_helper(deps.as_mut(), \"creator\", \"nft\", \"58\", None, None).unwrap();\n        add_collateral_helper(deps.as_mut(), \"creator\", \"nft\", \"59\", None, None).unwrap();\n        add_collateral_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"nft\",\n            \"59\",\n            Some(Uint128::from(459u128)),\n            None,\n        )\n        .unwrap();\n\n        let terms = LoanTerms {\n            principle: coin(456, \"luna\"),\n            interest: Uint128::new(0),\n            duration_in_blocks: 0,\n        };\n        set_terms_helper(deps.as_mut(), \"creator\", 0, terms.clone()).unwrap();\n\n        // The funds have to match the terms\n        let err = accept_loan_helper(deps.as_mut(), \"anyone\", \"creator\", 0, coins(123, \"luna\"))\n            .unwrap_err();\n        assert_eq!(err, ContractError::FundsDontMatchTerms {});\n        let err = accept_loan_helper(\n            deps.as_mut(),\n            \"anyone\",\n            \"creator\",\n            0,\n            vec![coin(123, \"luna\"), coin(457, \"uusd\")],\n        )\n        .unwrap_err();\n        assert_eq!(err, ContractError::MultipleCoins {});\n\n        accept_loan_helper(deps.as_mut(), \"anyone\", \"creator\", 0, coins(456, \"luna\")).unwrap();\n        accept_loan_helper(\n            deps.as_mut(),\n            \"anyone_else\",\n            \"creator\",\n            0,\n            coins(456, \"luna\"),\n        )\n        .unwrap_err();\n        let creator_addr = deps.api.addr_validate(\"creator\").unwrap();\n        let coll_info = COLLATERAL_INFO\n            .load(\u0026deps.storage, (\u0026creator_addr, 0))\n            .unwrap();\n\n        assert_eq!(\n            coll_info,\n            CollateralInfo {\n                terms: Some(terms.clone()),\n                associated_asset: AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft\".to_string(),\n                    token_id: \"58\".to_string()\n                }),\n                state: LoanState::Started,\n                active_loan: Some(0),\n                start_block: Some(12345),\n                offers: vec![OfferInfo {\n                    lender: deps.api.addr_validate(\"anyone\").unwrap(),\n                    terms,\n                    state: OfferState::Accepted,\n                    deposited_funds: Some(coin(456, \"luna\")),\n                }]\n            }\n        );\n    }\n\n    #[test]\n    fn test_accept_loan_and_modify() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n\n        let terms = LoanTerms {\n            principle: coin(456, \"luna\"),\n            interest: Uint128::new(0),\n            duration_in_blocks: 0,\n        };\n        add_collateral_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"nft\",\n            \"58\",\n            Some(Uint128::from(8_u128)),\n            Some(terms.clone()),\n        )\n        .unwrap();\n        accept_loan_helper(deps.as_mut(), \"anyone\", \"creator\", 0, coins(456, \"luna\")).unwrap();\n\n        // We try to modify the loan\n        let modify_err = set_terms_helper(deps.as_mut(), \"creator\", 0, terms.clone()).unwrap_err();\n        assert_eq!(modify_err, ContractError::NotModifiable {});\n\n        // We try to counter the loan, and propose new terms\n        let offer_err = make_offer_helper(\n            deps.as_mut(),\n            \"anyone\",\n            \"creator\",\n            0,\n            terms,\n            coins(456, \"luna\"),\n        )\n        .unwrap_err();\n\n        assert_eq!(offer_err, ContractError::NotCounterable {});\n    }\n\n    #[test]\n    fn test_repay_loan_early() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n\n        let terms = LoanTerms {\n            principle: coin(456, \"luna\"),\n            interest: Uint128::new(0),\n            duration_in_blocks: 0,\n        };\n        add_collateral_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"nft\",\n            \"58\",\n            Some(Uint128::from(8_u128)),\n            Some(terms),\n        )\n        .unwrap();\n        let repay_err = repay_borrowed_funds_helper(\n            deps.as_mut(),\n            \"creator\",\n            0,\n            coins(506, \"luna\"),\n            mock_env(),\n        )\n        .unwrap_err();\n        assert_eq!(\n            repay_err,\n            ContractError::WrongLoanState {\n                state: LoanState::Published\n            }\n        )\n    }\n\n    #[test]\n    fn test_make_offer() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n        add_collateral_helper(deps.as_mut(), \"creator\", \"nft\", \"58\", None, None).unwrap();\n        add_collateral_helper(deps.as_mut(), \"creator\", \"nft\", \"59\", None, None).unwrap();\n        add_collateral_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"nft\",\n            \"59\",\n            Some(Uint128::from(459u128)),\n            None,\n        )\n        .unwrap();\n\n        let terms = LoanTerms {\n            principle: coin(456, \"luna\"),\n            interest: Uint128::new(0),\n            duration_in_blocks: 0,\n        };\n\n        let err = make_offer_helper(\n            deps.as_mut(),\n            \"anyone\",\n            \"creator\",\n            0,\n            terms.clone(),\n            coins(6765, \"luna\"),\n        )\n        .unwrap_err();\n        assert_eq!(err, ContractError::FundsDontMatchTerms {});\n\n        let err = make_offer_helper(\n            deps.as_mut(),\n            \"anyone\",\n            \"creator\",\n            0,\n            terms.clone(),\n            vec![coin(456, \"luna\"), coin(456, \"luna\")],\n        )\n        .unwrap_err();\n        assert_eq!(err, ContractError::MultipleCoins {});\n\n        make_offer_helper(\n            deps.as_mut(),\n            \"anyone\",\n            \"creator\",\n            0,\n            terms,\n            coins(456, \"luna\"),\n        )\n        .unwrap();\n    }\n\n    #[test]\n    fn test_cancel_offer() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n        add_collateral_helper(deps.as_mut(), \"creator\", \"nft\", \"58\", None, None).unwrap();\n        add_collateral_helper(deps.as_mut(), \"creator\", \"nft\", \"59\", None, None).unwrap();\n        add_collateral_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"nft\",\n            \"59\",\n            Some(Uint128::from(459u128)),\n            None,\n        )\n        .unwrap();\n\n        let terms = LoanTerms {\n            principle: coin(456, \"luna\"),\n            interest: Uint128::new(0),\n            duration_in_blocks: 0,\n        };\n\n        make_offer_helper(\n            deps.as_mut(),\n            \"anyone\",\n            \"creator\",\n            0,\n            terms,\n            coins(456, \"luna\"),\n        )\n        .unwrap();\n\n        cancel_offer_helper(deps.as_mut(), \"anyone_else\", \"creator\", 0, 0).unwrap_err();\n\n        let res = cancel_offer_helper(deps.as_mut(), \"anyone\", \"creator\", 0, 0).unwrap();\n\n        assert_eq!(\n            res.messages,\n            vec![SubMsg::new(BankMsg::Send {\n                to_address: \"anyone\".to_string(),\n                amount: coins(456, \"luna\"),\n            }),]\n        );\n\n        cancel_offer_helper(deps.as_mut(), \"anyone\", \"creator\", 0, 0).unwrap_err();\n    }\n\n    #[test]\n    fn test_refuse_offer() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n        add_collateral_helper(deps.as_mut(), \"creator\", \"nft\", \"58\", None, None).unwrap();\n        add_collateral_helper(deps.as_mut(), \"creator\", \"nft\", \"59\", None, None).unwrap();\n        add_collateral_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"nft\",\n            \"59\",\n            Some(Uint128::from(459u128)),\n            None,\n        )\n        .unwrap();\n\n        let terms = LoanTerms {\n            principle: coin(456, \"luna\"),\n            interest: Uint128::new(0),\n            duration_in_blocks: 0,\n        };\n\n        make_offer_helper(\n            deps.as_mut(),\n            \"anyone\",\n            \"creator\",\n            0,\n            terms,\n            coins(456, \"luna\"),\n        )\n        .unwrap();\n\n        refuse_offer_helper(deps.as_mut(), \"bad_person\", 0, 0).unwrap_err();\n        refuse_offer_helper(deps.as_mut(), \"creator\", 0, 0).unwrap();\n\n        let offer = COLLATERAL_INFO\n            .load(\n                \u0026deps.storage,\n                (\u0026deps.api.addr_validate(\"creator\").unwrap(), 0u64),\n            )\n            .unwrap()\n            .offers[0]\n            .clone();\n\n        assert_eq!(offer.state, OfferState::Refused);\n    }\n\n    #[test]\n    fn test_cancel_accepted() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n\n        let terms = LoanTerms {\n            principle: coin(456, \"luna\"),\n            interest: Uint128::new(0),\n            duration_in_blocks: 0,\n        };\n\n        add_collateral_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"nft\",\n            \"58\",\n            Some(Uint128::new(45u128)),\n            Some(terms),\n        )\n        .unwrap();\n\n        accept_loan_helper(deps.as_mut(), \"anyone\", \"creator\", 0, coins(456, \"luna\")).unwrap();\n\n        withdraw_collateral_helper(deps.as_mut(), \"creator\", 0).unwrap_err();\n        cancel_offer_helper(deps.as_mut(), \"anyone\", \"creator\", 0, 0).unwrap_err();\n    }\n\n    #[test]\n    fn test_withdraw_refused() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n\n        let terms = LoanTerms {\n            principle: coin(456, \"luna\"),\n            interest: Uint128::new(0),\n            duration_in_blocks: 0,\n        };\n\n        add_collateral_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"nft\",\n            \"58\",\n            Some(Uint128::new(45u128)),\n            Some(terms.clone()),\n        )\n        .unwrap();\n        make_offer_helper(\n            deps.as_mut(),\n            \"anyone\",\n            \"creator\",\n            0,\n            terms.clone(),\n            coins(456, \"luna\"),\n        )\n        .unwrap();\n\n        make_offer_helper(\n            deps.as_mut(),\n            \"anyone\",\n            \"creator\",\n            0,\n            terms,\n            coins(456, \"luna\"),\n        )\n        .unwrap();\n\n        withdraw_refused_offer_helper(deps.as_mut(), \"anyone\", \"creator\", 0, 0).unwrap_err();\n        withdraw_refused_offer_helper(deps.as_mut(), \"anyone\", \"creator\", 0, 1).unwrap_err();\n        let err =\n            withdraw_refused_offer_helper(deps.as_mut(), \"anyone\", \"creator\", 0, 2).unwrap_err();\n        assert_eq!(err, ContractError::OfferNotFound {});\n\n        let err = accept_offer_helper(deps.as_mut(), \"creator\", 0, 87).unwrap_err();\n        assert_eq!(err, ContractError::OfferNotFound {});\n        accept_offer_helper(deps.as_mut(), \"creator\", 0, 0).unwrap();\n\n        withdraw_refused_offer_helper(deps.as_mut(), \"anyone\", \"creator\", 0, 0).unwrap_err();\n        withdraw_refused_offer_helper(deps.as_mut(), \"anyone_else\", \"creator\", 0, 1).unwrap_err();\n        withdraw_refused_offer_helper(deps.as_mut(), \"anyone\", \"creator\", 0, 1).unwrap();\n        withdraw_refused_offer_helper(deps.as_mut(), \"anyone\", \"creator\", 0, 1).unwrap_err();\n    }\n    #[test]\n    fn test_accept_cancelled_offer() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n        add_collateral_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"nft\",\n            \"58\",\n            Some(Uint128::new(45u128)),\n            None,\n        )\n        .unwrap();\n\n        let terms = LoanTerms {\n            principle: coin(456, \"luna\"),\n            interest: Uint128::new(0),\n            duration_in_blocks: 0,\n        };\n\n        make_offer_helper(\n            deps.as_mut(),\n            \"anyone\",\n            \"creator\",\n            0,\n            terms,\n            coins(456, \"luna\"),\n        )\n        .unwrap();\n\n        cancel_offer_helper(deps.as_mut(), \"anyone\", \"creator\", 0, 0).unwrap();\n        let err = accept_offer_helper(deps.as_mut(), \"creator\", 0, 0).unwrap_err();\n        assert_eq!(err, ContractError::OfferNotFound {})\n    }\n\n    #[test]\n    fn test_normal_flow() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n\n        let terms = LoanTerms {\n            principle: coin(456, \"luna\"),\n            interest: Uint128::new(50),\n            duration_in_blocks: 1,\n        };\n\n        add_collateral_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"nft\",\n            \"58\",\n            Some(Uint128::new(45u128)),\n            Some(terms.clone()),\n        )\n        .unwrap();\n        make_offer_helper(\n            deps.as_mut(),\n            \"anyone\",\n            \"creator\",\n            0,\n            terms,\n            coins(456, \"luna\"),\n        )\n        .unwrap();\n\n        accept_offer_helper(deps.as_mut(), \"creator\", 0, 0).unwrap();\n        // Loan starts\n\n        let env = mock_env();\n        let not_now_err =\n            withdraw_defaulted_loan_helper(deps.as_mut(), \"anyone\", \"creator\", 0, env.clone())\n                .unwrap_err();\n        assert_eq!(\n            not_now_err,\n            ContractError::WrongLoanState {\n                state: LoanState::Started\n            }\n        );\n\n        let err = repay_borrowed_funds_helper(\n            deps.as_mut(),\n            \"creator\",\n            0,\n            coins(456, \"luna\"),\n            env.clone(),\n        )\n        .unwrap_err();\n        assert_eq!(err, ContractError::Std(\n            StdError::generic_err(\"Fund sent do not match the loan terms (principle + interests). Needed : 506, Received : 456\")\n        ));\n        let err = repay_borrowed_funds_helper(\n            deps.as_mut(),\n            \"creator\",\n            0,\n            vec![coin(456, \"luna\"), coin(456, \"luna\")],\n            env.clone(),\n        )\n        .unwrap_err();\n        assert_eq!(err, ContractError::MultipleCoins {});\n        let err = repay_borrowed_funds_helper(\n            deps.as_mut(),\n            \"creator\",\n            0,\n            coins(456, \"uust\"),\n            env.clone(),\n        )\n        .unwrap_err();\n        assert_eq!(\n            err,\n            ContractError::Std(StdError::generic_err(\n                \"You didn't send the right kind of funds\",\n            ))\n        );\n\n        repay_borrowed_funds_helper(\n            deps.as_mut(),\n            \"bad_person\",\n            0,\n            coins(506, \"luna\"),\n            env.clone(),\n        )\n        .unwrap_err();\n\n        let res = repay_borrowed_funds_helper(deps.as_mut(), \"creator\", 0, coins(506, \"luna\"), env)\n            .unwrap();\n        let env = mock_env();\n        assert_eq!(\n            res.messages,\n            vec![\n                SubMsg::new(BankMsg::Send {\n                    to_address: \"anyone\".to_string(),\n                    amount: coins(503, \"luna\"),\n                }),\n                SubMsg::new(\n                    into_cosmos_msg(\n                        Cw1155ExecuteMsg::SendFrom {\n                            from: env.contract.address.to_string(),\n                            to: \"creator\".to_string(),\n                            token_id: \"58\".to_string(),\n                            value: Uint128::new(45u128),\n                            msg: None,\n                        },\n                        \"nft\",\n                        None\n                    )\n                    .unwrap()\n                ),\n                SubMsg::new(\n                    into_cosmos_msg(\n                        FeeDistributorMsg::DepositFees {\n                            addresses: vec![\"nft\".to_string()]\n                        },\n                        \"T\",\n                        Some(coins(3, \"luna\"))\n                    )\n                    .unwrap()\n                )\n            ]\n        );\n    }\n\n    #[test]\n    fn test_defaulted_flow() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n\n        let terms = LoanTerms {\n            principle: coin(456, \"luna\"),\n            interest: Uint128::new(0),\n            duration_in_blocks: 0,\n        };\n\n        add_collateral_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"nft\",\n            \"58\",\n            Some(Uint128::new(45u128)),\n            None,\n        )\n        .unwrap();\n        make_offer_helper(\n            deps.as_mut(),\n            \"anyone\",\n            \"creator\",\n            0,\n            terms,\n            coins(456, \"luna\"),\n        )\n        .unwrap();\n\n        accept_offer_helper(deps.as_mut(), \"creator\", 0, 0).unwrap();\n        let mut env = mock_env();\n        env.block.height = 12346;\n        let err = repay_borrowed_funds_helper(\n            deps.as_mut(),\n            \"creator\",\n            0,\n            coins(456, \"luna\"),\n            env.clone(),\n        )\n        .unwrap_err();\n        assert_eq!(\n            err,\n            ContractError::WrongLoanState {\n                state: LoanState::Defaulted {},\n            }\n        );\n\n        let err =\n            withdraw_defaulted_loan_helper(deps.as_mut(), \"bad_person\", \"creator\", 0, env.clone())\n                .unwrap_err();\n        assert_eq!(err, ContractError::Unauthorized {});\n        withdraw_defaulted_loan_helper(deps.as_mut(), \"anyone\", \"creator\", 0, env.clone()).unwrap();\n        withdraw_defaulted_loan_helper(deps.as_mut(), \"anyone\", \"creator\", 0, env).unwrap_err();\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","nft-loans","src","error.rs"],"content":"use cosmwasm_std::StdError;\nuse nft_loans_export::state::{LoanState, OfferState};\nuse thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized {},\n\n    #[error(\"An unplanned bug just happened :/\")]\n    ContractBug {},\n\n    #[error(\"You need to send exactly one coin with this transaction\")]\n    MultipleCoins {},\n\n    #[error(\"Fund sent do not match the loan terms\")]\n    FundsDontMatchTerms {},\n\n    #[error(\"Sorry, your asset is not withdrawable at this stage\")]\n    NotWithdrawable {},\n\n    #[error(\"Sorry, your asset is not withdrawable at this stage\")]\n    NotModifiable {},\n\n    #[error(\"Sorry, no assets to withdraw here\")]\n    NoFundsToWithdraw {},\n\n    #[error(\"Sorry, you can't accept this loan\")]\n    NotAcceptable {},\n\n    #[error(\"Sorry, you can't make an offer on this trade\")]\n    NotCounterable {},\n\n    #[error(\"This loan doesn't have any terms\")]\n    NoTermsSpecified {},\n\n    #[error(\"Sorry, this loan doesn't exist :/\")]\n    LoanNotFound {},\n\n    #[error(\"Sorry, this offer doesn't exist :/\")]\n    OfferNotFound {},\n\n    #[error(\"Wrong state of the loan for the current operation : {state:?}\")]\n    WrongLoanState { state: LoanState },\n\n    #[error(\"Can change the state of the offer from {from:?} to {to:?}\")]\n    CantChangeOfferState { from: OfferState, to: OfferState },\n\n    #[error(\"The loan has already been defaulted, you can't withdraw the funds again\")]\n    LoanAlreadyDefaulted {},\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","nft-loans","src","lib.rs"],"content":"pub mod contract;\nmod error;\npub mod state;\n\npub use crate::error::ContractError;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","nft-loans","src","query.rs"],"content":"use cosmwasm_std::{Api, Pair};\n#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::{Deps, Order, StdResult};\n\nuse cw_storage_plus::{Bound, PrimaryKey, U64Key};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse std::convert::TryInto;\n\nuse crate::state::{CONTRACT_INFO, COUNTER_TRADE_INFO, TRADE_INFO};\nuse p2p_trading_export::msg::QueryFilters;\nuse p2p_trading_export::state::{AssetInfo, ContractInfo, CounterTradeInfo, TradeInfo};\n\n// settings for pagination\nconst MAX_LIMIT: u32 = 30;\nconst DEFAULT_LIMIT: u32 = 10;\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug, Default)]\npub struct TradeResponse {\n    pub trade_id: u64,\n    pub counter_id: Option\u003cu64\u003e,\n    pub trade_info: TradeInfo,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug, Default)]\npub struct AllTradesResponse {\n    pub trades: Vec\u003cTradeResponse\u003e,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug, Default)]\npub struct AllCounterTradesResponse {\n    pub counter_trades: Vec\u003cTradeResponse\u003e,\n}\n\npub fn query_contract_info(deps: Deps) -\u003e StdResult\u003cContractInfo\u003e {\n    CONTRACT_INFO.load(deps.storage)\n}\n\n// parse trades to human readable format\nfn parse_trades(_: \u0026dyn Api, item: StdResult\u003cPair\u003cTradeInfo\u003e\u003e) -\u003e StdResult\u003cTradeResponse\u003e {\n    item.map(|(k, trade)| {\n        let trade_id = k.try_into().unwrap();\n        TradeResponse {\n            trade_id: u64::from_be_bytes(trade_id),\n            counter_id: None,\n            trade_info: trade,\n        }\n    })\n}\n\npub fn trade_filter(\n    api: \u0026dyn Api,\n    trade_info: \u0026StdResult\u003cTradeResponse\u003e,\n    filters: \u0026Option\u003cQueryFilters\u003e,\n) -\u003e bool {\n    if let Some(filters) = filters {\n        let trade = trade_info.as_ref().unwrap();\n\n        (match \u0026filters.states {\n            Some(state) =\u003e state.contains(\u0026trade.trade_info.state.to_string()),\n            None =\u003e true,\n        } \u0026\u0026 match \u0026filters.owner {\n            Some(owner) =\u003e trade.trade_info.owner == owner.clone(),\n            None =\u003e true,\n        } \u0026\u0026 match \u0026filters.whitelisted_user {\n            Some(whitelisted_user) =\u003e trade\n                .trade_info\n                .whitelisted_users\n                .contains(\u0026api.addr_validate(whitelisted_user).unwrap()),\n            None =\u003e true,\n        } \u0026\u0026 match \u0026filters.wanted_nft {\n            Some(wanted_nft) =\u003e trade\n                .trade_info\n                .additionnal_info\n                .nfts_wanted\n                .contains(\u0026api.addr_validate(wanted_nft).unwrap()),\n            None =\u003e true,\n        } \u0026\u0026 match \u0026filters.contains_token {\n            Some(token) =\u003e trade\n                .trade_info\n                .associated_assets\n                .iter()\n                .any(|asset| match asset {\n                    AssetInfo::Cw20Coin(x) =\u003e x.address == token.as_ref(),\n                    AssetInfo::Cw721Coin(x) =\u003e x.address == token.as_ref(),\n                    AssetInfo::Cw1155Coin(x) =\u003e x.address == token.as_ref(),\n                }),\n            None =\u003e true,\n        })\n    } else {\n        true\n    }\n}\n\npub fn query_all_trades(\n    deps: Deps,\n    start_after: Option\u003cu64\u003e,\n    limit: Option\u003cu32\u003e,\n    filters: Option\u003cQueryFilters\u003e,\n) -\u003e StdResult\u003cAllTradesResponse\u003e {\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n    let start = start_after.map(|s| Bound::Exclusive(U64Key::new(s).joined_key()));\n\n    let trades: StdResult\u003cVec\u003cTradeResponse\u003e\u003e = TRADE_INFO\n        .range(deps.storage, None, start, Order::Descending)\n        .map(|kv_item| parse_trades(deps.api, kv_item))\n        .filter(|response| trade_filter(deps.api, response, \u0026filters))\n        .take(limit)\n        .collect();\n\n    Ok(AllTradesResponse { trades: trades? })\n}\n\n// parse counter trades to human readable format\nfn parse_all_counter_trades(\n    _: \u0026dyn Api,\n    item: StdResult\u003cPair\u003cTradeInfo\u003e\u003e,\n) -\u003e StdResult\u003cTradeResponse\u003e {\n    item.map(|(ck, trade)| {\n        // First two bytes define size [0,8] since we know it's u64 skip it.\n        let (trade_id, counter_id) = (\u0026ck[2..10], \u0026ck[10..]);\n        let trade_id = trade_id.try_into().unwrap();\n        let counter_id = counter_id.try_into().unwrap();\n\n        TradeResponse {\n            trade_id: u64::from_be_bytes(trade_id),\n            counter_id: Some(u64::from_be_bytes(counter_id)),\n            trade_info: trade,\n        }\n    })\n}\n\npub fn query_all_counter_trades(\n    deps: Deps,\n    start_after: Option\u003cCounterTradeInfo\u003e,\n    limit: Option\u003cu32\u003e,\n    filters: Option\u003cQueryFilters\u003e,\n) -\u003e StdResult\u003cAllCounterTradesResponse\u003e {\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n\n    let start = start_after.map(|s| {\n        Bound::Exclusive((U64Key::new(s.trade_id), U64Key::new(s.counter_id)).joined_key())\n    });\n\n    let counter_trades: StdResult\u003cVec\u003cTradeResponse\u003e\u003e = COUNTER_TRADE_INFO\n        .range(deps.storage, None, start, Order::Descending)\n        .map(|kv_item| parse_all_counter_trades(deps.api, kv_item))\n        .filter(|response| trade_filter(deps.api, response, \u0026filters))\n        .take(limit)\n        .collect();\n\n    Ok(AllCounterTradesResponse {\n        counter_trades: counter_trades?,\n    })\n}\n\n// parse counter trades to human readable format\nfn parse_counter_trades(\n    _: \u0026dyn Api,\n    item: StdResult\u003cPair\u003cTradeInfo\u003e\u003e,\n    trade_id: Vec\u003cu8\u003e,\n) -\u003e StdResult\u003cTradeResponse\u003e {\n    item.map(|(counter_id, trade)| {\n        let trade_id = trade_id.try_into().unwrap();\n        let counter_id = counter_id.try_into().unwrap();\n\n        TradeResponse {\n            trade_id: u64::from_be_bytes(trade_id),\n            counter_id: Some(u64::from_be_bytes(counter_id)),\n            trade_info: trade,\n        }\n    })\n}\n\npub fn query_counter_trades(deps: Deps, trade_id: u64) -\u003e StdResult\u003cAllCounterTradesResponse\u003e {\n    let counter_trades: StdResult\u003cVec\u003cTradeResponse\u003e\u003e = COUNTER_TRADE_INFO\n        .prefix(trade_id.into())\n        .range(deps.storage, None, None, Order::Descending)\n        .map(|kv_item| parse_counter_trades(deps.api, kv_item, U64Key::new(trade_id).joined_key()))\n        .collect();\n\n    Ok(AllCounterTradesResponse {\n        counter_trades: counter_trades?,\n    })\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","nft-loans","src","state.rs"],"content":"use cw_storage_plus::{Item, Map};\n\nuse cosmwasm_std::{Addr, Env, Storage};\n\nuse crate::error::ContractError;\nuse nft_loans_export::state::{\n    BorrowerInfo, CollateralInfo, ContractInfo, LoanState, OfferInfo, OfferState,\n};\n\npub const CONTRACT_INFO: Item\u003cContractInfo\u003e = Item::new(\"contract_info\");\n\npub const COLLATERAL_INFO: Map\u003c(\u0026Addr, u64), CollateralInfo\u003e = Map::new(\"collateral_info\");\n\npub const BORROWER_INFO: Map\u003c\u0026Addr, BorrowerInfo\u003e = Map::new(\"borrower_info\");\n\npub const LENDER_OFFERS: Map\u003c\u0026Addr, Vec\u003c(Addr, u64, u64)\u003e\u003e = Map::new(\"lender_offers\");\n\npub fn is_owner(storage: \u0026dyn Storage, sender: Addr) -\u003e Result\u003cContractInfo, ContractError\u003e {\n    let contract_info = CONTRACT_INFO.load(storage)?;\n    if sender == contract_info.owner {\n        Ok(contract_info)\n    } else {\n        Err(ContractError::Unauthorized {})\n    }\n}\n\npub fn add_new_offer(\n    storage: \u0026mut dyn Storage,\n    collateral: \u0026mut CollateralInfo,\n    collateral_key: (Addr, u64),\n    offer: OfferInfo,\n) -\u003e Result\u003cu64, ContractError\u003e {\n    // We add the new offer to the collateral object\n    collateral.offers.push(offer.clone());\n    COLLATERAL_INFO.save(storage, (\u0026collateral_key.0, collateral_key.1), collateral)?;\n    let offer_id = (collateral.offers.len() - 1) as u64;\n    // We add the new offer to the lender object\n    LENDER_OFFERS.update::\u003c_, ContractError\u003e(storage, \u0026offer.lender, |x| match x {\n        Some(mut offers) =\u003e {\n            offers.push((collateral_key.0, collateral_key.1, offer_id));\n            Ok(offers)\n        }\n        None =\u003e Ok(vec![(collateral_key.0, collateral_key.1, offer_id)]),\n    })?;\n    Ok(offer_id)\n}\n\npub fn is_collateral_withdrawable(collateral: \u0026CollateralInfo) -\u003e Result\u003c(), ContractError\u003e {\n    match collateral.state {\n        LoanState::Published =\u003e Ok(()),\n        _ =\u003e Err(ContractError::NotWithdrawable {}),\n    }\n}\n\npub fn is_loan_modifiable(collateral: \u0026CollateralInfo) -\u003e Result\u003c(), ContractError\u003e {\n    match collateral.state {\n        LoanState::Published =\u003e Ok(()),\n        _ =\u003e Err(ContractError::NotModifiable {}),\n    }\n}\n\npub fn is_loan_acceptable(collateral: \u0026CollateralInfo) -\u003e Result\u003c(), ContractError\u003e {\n    match collateral.state {\n        LoanState::Published =\u003e Ok(()),\n        _ =\u003e Err(ContractError::NotAcceptable {}),\n    }\n}\n\npub fn is_loan_counterable(collateral: \u0026CollateralInfo) -\u003e Result\u003c(), ContractError\u003e {\n    match collateral.state {\n        LoanState::Published =\u003e Ok(()),\n        _ =\u003e Err(ContractError::NotCounterable {}),\n    }\n}\n\npub fn can_repay_loan(env: Env, collateral: \u0026CollateralInfo) -\u003e Result\u003c(), ContractError\u003e {\n    if is_loan_defaulted(env, collateral).is_ok() {\n        Err(ContractError::WrongLoanState {\n            state: LoanState::Defaulted {},\n        })\n    } else if collateral.state != LoanState::Started {\n        Err(ContractError::WrongLoanState {\n            state: collateral.state.clone(),\n        })\n    } else {\n        Ok(())\n    }\n}\n\npub fn is_loan_defaulted(env: Env, collateral: \u0026CollateralInfo) -\u003e Result\u003c(), ContractError\u003e {\n    // If there is no offer, the loan can't be defaulted\n    let offer = get_active_loan(collateral)?;\n    match \u0026collateral.state {\n        LoanState::Started =\u003e {\n            if collateral.start_block.unwrap() + offer.terms.duration_in_blocks \u003c env.block.height {\n                Ok(())\n            } else {\n                Err(ContractError::WrongLoanState {\n                    state: LoanState::Started,\n                })\n            }\n        }\n        LoanState::Defaulted =\u003e Ok(()),\n        _ =\u003e Err(ContractError::WrongLoanState {\n            state: collateral.state.clone(),\n        }),\n    }\n}\n\npub fn get_offer(collateral: \u0026CollateralInfo, offer_id: usize) -\u003e Result\u003cOfferInfo, ContractError\u003e {\n    if offer_id \u003c collateral.offers.len() {\n        let mut offer = collateral.offers[offer_id].clone();\n        // We check the status of the offer.\n        // A refused offer isn't marked as such but depends o=n the overlying collateral info state\n        offer.state = match \u0026offer.state {\n            OfferState::Published =\u003e {\n                if collateral.state != LoanState::Published {\n                    OfferState::Refused\n                } else {\n                    OfferState::Published\n                }\n            }\n            _ =\u003e offer.state,\n        };\n        Ok(offer)\n    } else {\n        Err(ContractError::OfferNotFound {})\n    }\n}\n\npub fn get_active_loan(collateral: \u0026CollateralInfo) -\u003e Result\u003cOfferInfo, ContractError\u003e {\n    let offer_id = collateral\n        .active_loan\n        .ok_or(ContractError::OfferNotFound {})?;\n    get_offer(collateral, offer_id as usize)\n}\n\npub fn is_lender(\n    lender: Addr,\n    collateral: \u0026CollateralInfo,\n    offer_id: usize,\n) -\u003e Result\u003cOfferInfo, ContractError\u003e {\n    let offer = get_offer(collateral, offer_id)?;\n    if lender != offer.lender {\n        return Err(ContractError::Unauthorized {});\n    }\n    Ok(offer)\n}\n\npub fn is_active_lender(\n    lender: Addr,\n    collateral: \u0026CollateralInfo,\n) -\u003e Result\u003cOfferInfo, ContractError\u003e {\n    let offer = get_active_loan(collateral)?;\n    if lender != offer.lender {\n        return Err(ContractError::Unauthorized {});\n    }\n    Ok(offer)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","oracle_contract","examples","oracle_schema.rs"],"content":"use std::env::current_dir;\nuse std::fs::create_dir_all;\n\nuse cosmwasm_schema::{export_schema, remove_schemas, schema_for};\n\nuse oracle_export::msg::{ExecuteMsg, InstantiateMsg, QueryMsg};\n\nfn main() {\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"schema\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n\n    export_schema(\u0026schema_for!(InstantiateMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(ExecuteMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(QueryMsg), \u0026out_dir);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","oracle_contract","src","contract.rs"],"content":"#[cfg(not(feature = \"library\"))]\nuse anyhow::{anyhow, Result};\nuse cosmwasm_std::{\n    entry_point, to_binary, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdError, Uint128,\n};\n\nuse crate::error::ContractError;\nuse oracle_export::msg::{ExecuteMsg, InstantiateMsg, MigrateMsg, NftPriceResponse, QueryMsg};\nuse oracle_export::state::{ContractInfo, NftPrice};\n\nuse crate::state::{is_owner, CONTRACT_INFO, NFT_PRICES};\nuse cw_4626::state::AssetInfo;\n\nconst DEFAULT_TIMEOUT: u64 = 8 * 3600; // Price timeout in seconds (8hrs)\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // Verify the contract name\n    msg.validate()?;\n    // store token info\n    let data = ContractInfo {\n        name: msg.name,\n        owner: msg\n            .owner\n            .map(|x| deps.api.addr_validate(\u0026x))\n            .unwrap_or(Ok(info.sender))?,\n        timeout: msg.timeout.unwrap_or(DEFAULT_TIMEOUT),\n    };\n    CONTRACT_INFO.save(deps.storage, \u0026data)?;\n    // Initialisation with fixed rates\n\n    Ok(Response::default().add_attribute(\"fee_contract\", \"init\"))\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg) -\u003e Result\u003cResponse\u003e {\n    match msg {\n        ExecuteMsg::SetNftPrice {\n            contract,\n            oracle_owner,\n            price,\n            unit,\n        } =\u003e execute_set_nft_price(\n            deps,\n            env,\n            info.clone(),\n            contract,\n            oracle_owner.unwrap_or_else(|| info.sender.to_string()),\n            unit,\n            price,\n        ),\n        ExecuteMsg::SetOwner { owner } =\u003e set_owner(deps, env, info, owner),\n        ExecuteMsg::SetTimeout { timeout } =\u003e set_timeout(deps, env, info, timeout),\n    }\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn migrate(_deps: DepsMut, _env: Env, _msg: MigrateMsg) -\u003e Result\u003cResponse, ContractError\u003e {\n    // No state migrations performed, just returned a Response\n    Ok(Response::default())\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, env: Env, msg: QueryMsg) -\u003e Result\u003cBinary\u003e {\n    match msg {\n        QueryMsg::ContractInfo {} =\u003e to_binary(\u0026contract_info(deps)?).map_err(|e| anyhow!(e)),\n        QueryMsg::NftPrice { contract, unit } =\u003e {\n            to_binary(\u0026query_nft_price(deps, env, contract, unit)?).map_err(|e| anyhow!(e))\n        }\n    }\n}\n\n/// This function is used to withdraw funds from an accepted trade.\n/// It uses information from the trades and counter trades to determine how much needs to be paid\n/// If the fee is sufficient, it sends the fee to the fee_depositor contract (responsible for fee distribution)\npub fn execute_set_nft_price(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    contract: String,\n    oracle_owner: String,\n    unit: AssetInfo,\n    price: Uint128,\n) -\u003e Result\u003cResponse\u003e {\n    let contract_info = CONTRACT_INFO.load(deps.storage)?;\n    let contract_addr = deps.api.addr_validate(\u0026contract)?;\n    let oracle_owner_addr = deps.api.addr_validate(\u0026oracle_owner)?;\n    NFT_PRICES.update(deps.storage, (\u0026contract_addr, unit.clone()), |x| match x {\n        Some(nft_price) =\u003e {\n            if info.sender != nft_price.oracle_owner {\n                return Err(anyhow!(ContractError::Unauthorized {}));\n            }\n            Ok(NftPrice {\n                price,\n                oracle_owner: oracle_owner_addr,\n                last_update: env.block.time,\n            })\n        }\n        None =\u003e {\n            if info.sender != contract_info.owner {\n                return Err(anyhow!(ContractError::Unauthorized {}));\n            }\n            Ok(NftPrice {\n                price,\n                oracle_owner: oracle_owner_addr,\n                last_update: env.block.time,\n            })\n        }\n    })?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"set_oracle_price\")\n        .add_attribute(\"nft\", contract)\n        .add_attribute(\"unit\", unit.to_string())\n        .add_attribute(\"price\", price.to_string()))\n}\n\npub fn set_owner(deps: DepsMut, _env: Env, info: MessageInfo, owner: String) -\u003e Result\u003cResponse\u003e {\n    is_owner(deps.as_ref(), info.sender)?;\n\n    let owner_addr = deps.api.addr_validate(\u0026owner)?;\n    CONTRACT_INFO.update::\u003c_, StdError\u003e(deps.storage, |mut x| {\n        x.owner = owner_addr;\n        Ok(x)\n    })?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"parameter_update\")\n        .add_attribute(\"parameter\", \"owner\")\n        .add_attribute(\"value\", owner))\n}\n\npub fn set_timeout(deps: DepsMut, _env: Env, info: MessageInfo, timeout: u64) -\u003e Result\u003cResponse\u003e {\n    is_owner(deps.as_ref(), info.sender)?;\n\n    CONTRACT_INFO.update::\u003c_, StdError\u003e(deps.storage, |mut x| {\n        x.timeout = timeout;\n        Ok(x)\n    })?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"parameter_update\")\n        .add_attribute(\"parameter\", \"timeout\")\n        .add_attribute(\"value\", timeout.to_string()))\n}\n\npub fn contract_info(deps: Deps) -\u003e Result\u003cContractInfo\u003e {\n    CONTRACT_INFO.load(deps.storage).map_err(|e| anyhow!(e))\n}\n\npub fn query_nft_price(\n    deps: Deps,\n    env: Env,\n    contract: String,\n    unit: AssetInfo,\n) -\u003e Result\u003cNftPriceResponse\u003e {\n    let contract_addr = deps.api.addr_validate(\u0026contract)?;\n    let nft_price = NFT_PRICES.load(deps.storage, (\u0026contract_addr, unit.clone()))?;\n    let contract_info = CONTRACT_INFO.load(deps.storage)?;\n\n    Ok(NftPriceResponse {\n        contract,\n        price: nft_price.price,\n        unit,\n        oracle_owner: nft_price.oracle_owner.to_string(),\n        timeout: nft_price.last_update.plus_seconds(contract_info.timeout) \u003c env.block.time,\n    })\n}\n\n#[cfg(test)]\npub mod tests {\n    use super::*;\n    use cosmwasm_std::testing::{mock_dependencies, mock_env, mock_info};\n    use cosmwasm_std::{Api, Timestamp};\n    //use cosmwasm_std::{coins, Coin, SubMsg};\n\n    fn init_helper(deps: DepsMut) -\u003e Response {\n        let instantiate_msg = InstantiateMsg {\n            name: \"oracle\".to_string(),\n            owner: None,\n            timeout: Some(8 * 3600u64),\n        };\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n\n        instantiate(deps, env, info, instantiate_msg).unwrap()\n    }\n\n    #[test]\n    fn test_init_sanity() {\n        let mut deps = mock_dependencies();\n        let res = init_helper(deps.as_mut());\n        assert_eq!(0, res.messages.len());\n    }\n\n    #[test]\n    fn test_owner_sanity() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n        let env = mock_env();\n        let info = mock_info(\"bad_person\", \u0026[]);\n        let err = execute(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            ExecuteMsg::SetOwner {\n                owner: \"new_person\".to_string(),\n            },\n        )\n        .unwrap_err();\n        assert_eq!(\n            err.downcast::\u003cContractError\u003e().unwrap(),\n            ContractError::Unauthorized {}\n        );\n        let info = mock_info(\"creator\", \u0026[]);\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            ExecuteMsg::SetOwner {\n                owner: \"new_person\".to_string(),\n            },\n        )\n        .unwrap();\n        let info = mock_info(\"creator\", \u0026[]);\n        let err = execute(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            ExecuteMsg::SetOwner {\n                owner: \"new_person\".to_string(),\n            },\n        )\n        .unwrap_err();\n        assert_eq!(\n            err.downcast::\u003cContractError\u003e().unwrap(),\n            ContractError::Unauthorized {}\n        );\n        let info = mock_info(\"new_person\", \u0026[]);\n        execute(\n            deps.as_mut(),\n            env,\n            info,\n            ExecuteMsg::SetOwner {\n                owner: \"creaor\".to_string(),\n            },\n        )\n        .unwrap();\n    }\n\n    #[test]\n    fn test_timeout_sanity() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n        let env = mock_env();\n        let info = mock_info(\"bad_person\", \u0026[]);\n        let err = execute(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            ExecuteMsg::SetTimeout { timeout: 4687u64 },\n        )\n        .unwrap_err();\n        assert_eq!(\n            err.downcast::\u003cContractError\u003e().unwrap(),\n            ContractError::Unauthorized {}\n        );\n        let info = mock_info(\"creator\", \u0026[]);\n        execute(\n            deps.as_mut(),\n            env,\n            info,\n            ExecuteMsg::SetTimeout { timeout: 4687u64 },\n        )\n        .unwrap();\n        let contract_info = CONTRACT_INFO.load(\u0026deps.storage).unwrap();\n        assert_eq!(\n            contract_info,\n            ContractInfo {\n                name: \"oracle\".to_string(),\n                owner: deps.api.addr_validate(\"creator\").unwrap(),\n                timeout: 4687u64,\n            }\n        );\n    }\n\n    fn execute_set_nft_price(\n        deps: DepsMut,\n        info: MessageInfo,\n        contract: \u0026str,\n        owner: \u0026str,\n        unit: AssetInfo,\n        price: u128,\n    ) -\u003e Result\u003cResponse\u003e {\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::SetNftPrice {\n                contract: contract.to_string(),\n                oracle_owner: Some(owner.to_string()),\n                unit,\n                price: Uint128::from(price),\n            },\n        )\n    }\n\n    #[test]\n    fn test_set_nft_price() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n\n        let info = mock_info(\"bad_person\", \u0026[]);\n        let asset_info = AssetInfo::Coin(\"uluna\".to_string());\n        let err = execute_set_nft_price(\n            deps.as_mut(),\n            info,\n            \"nft\",\n            \"creator\",\n            asset_info.clone(),\n            456u128,\n        )\n        .unwrap_err();\n        assert_eq!(\n            err.downcast::\u003cContractError\u003e().unwrap(),\n            ContractError::Unauthorized {}\n        );\n\n        let info = mock_info(\"creator\", \u0026[]);\n        let res = execute_set_nft_price(\n            deps.as_mut(),\n            info,\n            \"nft\",\n            \"creator\",\n            asset_info.clone(),\n            456u128,\n        )\n        .unwrap();\n        assert_eq!(\n            res,\n            Response::new()\n                .add_attribute(\"action\", \"set_oracle_price\")\n                .add_attribute(\"nft\", \"nft\")\n                .add_attribute(\"unit\", asset_info.to_string())\n                .add_attribute(\"price\", 456u128.to_string())\n        );\n        // We verify the contract storage\n        let addr = deps.api.addr_validate(\"nft\").unwrap();\n        let owner_addr = deps.api.addr_validate(\"creator\").unwrap();\n        let price = NFT_PRICES.load(\u0026deps.storage, (\u0026addr, asset_info)).unwrap();\n        assert_eq!(\n            price,\n            NftPrice {\n                price: Uint128::from(456u128),\n                oracle_owner: owner_addr,\n                last_update: Timestamp::from_nanos(1571797419879305533u64)\n            }\n        )\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","oracle_contract","src","error.rs"],"content":"use cosmwasm_std::StdError;\nuse thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized {},\n\n    #[error(\"Fee not paid correctly, required: {required:?}uust, provided {provided:?}uust\")]\n    FeeNotPaidCorrectly { required: u128, provided: u128 },\n\n    #[error(\"Fee not paid\")]\n    FeeNotPaid {},\n\n    #[error(\"Trade not accepted\")]\n    TradeNotAccepted {},\n\n    #[error(\"Fee Teers not ordered, you can't change them\")]\n    TeersNotOrdered {},\n\n    #[error(\"Error when encoding response message to binary string\")]\n    BinaryEncodingError {},\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","oracle_contract","src","lib.rs"],"content":"pub mod contract;\npub mod error;\npub mod state;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","oracle_contract","src","state.rs"],"content":"use crate::error::ContractError;\nuse cosmwasm_std::{Addr, Deps};\nuse cw_4626::state::AssetInfo;\nuse cw_storage_plus::{Item, Map};\nuse oracle_export::state::{ContractInfo, NftPrice};\npub const CONTRACT_INFO: Item\u003cContractInfo\u003e = Item::new(\"contract_info\");\npub const NFT_PRICES: Map\u003c(\u0026Addr, AssetInfo), NftPrice\u003e = Map::new(\"fee_rates\");\n\npub fn is_owner(deps: Deps, addr: Addr) -\u003e Result\u003c(), ContractError\u003e {\n    if CONTRACT_INFO.load(deps.storage)?.owner == addr {\n        Ok(())\n    } else {\n        Err(ContractError::Unauthorized {})\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","p2p-trading","examples","p2p_schema.rs"],"content":"use std::env::current_dir;\nuse std::fs::create_dir_all;\n\nuse cosmwasm_schema::{export_schema, remove_schemas, schema_for};\n\nuse p2p_trading_export::msg::{ExecuteMsg, InstantiateMsg, QueryMsg};\n\nfn main() {\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"schema\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n\n    export_schema(\u0026schema_for!(InstantiateMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(ExecuteMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(QueryMsg), \u0026out_dir);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","p2p-trading","src","contract.rs"],"content":"#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\nuse cosmwasm_std::{\n    to_binary, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdError, StdResult,\n};\n\nuse cw2::set_contract_version;\n\nuse crate::error::ContractError;\n\nuse crate::state::{\n    is_fee_contract, is_owner, load_counter_trade, load_trade, CONTRACT_INFO, COUNTER_TRADE_INFO,\n    TRADE_INFO,\n};\nuse p2p_trading_export::msg::{ExecuteMsg, InstantiateMsg, MigrateMsg, QueryMsg};\nuse p2p_trading_export::state::{AssetInfo, ContractInfo, TradeState};\n\nuse crate::counter_trade::{\n    add_asset_to_counter_trade, cancel_counter_trade, confirm_counter_trade, suggest_counter_trade,\n    withdraw_all_from_counter, withdraw_counter_trade_assets_while_creating,\n};\nuse crate::trade::{\n    accept_trade, add_asset_to_trade, add_nfts_wanted, add_whitelisted_users, cancel_trade,\n    check_and_create_withdraw_messages, confirm_trade, create_trade, refuse_counter_trade,\n    remove_nfts_wanted, remove_whitelisted_users, withdraw_all_from_trade,\n    withdraw_trade_assets_while_creating,\n};\n\nuse crate::messages::{review_counter_trade, set_comment};\nuse crate::query::{\n    query_all_counter_trades, query_all_trades, query_contract_info, query_counter_trades,\n};\n\nconst CONTRACT_NAME: \u0026str = \"illiquidly.io:p2p-trading\";\nconst CONTRACT_VERSION: \u0026str = \"0.1.0\";\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // Verify the contract name\n\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    msg.validate()?;\n    // store token info\n    let data = ContractInfo {\n        name: msg.name,\n        owner: deps\n            .api\n            .addr_validate(\u0026msg.owner.unwrap_or_else(|| info.sender.to_string()))?,\n        fee_contract: None,\n        last_trade_id: None,\n    };\n    CONTRACT_INFO.save(deps.storage, \u0026data)?;\n    Ok(Response::default()\n        .add_attribute(\"action\", \"init\")\n        .add_attribute(\"contract\", \"p2p-trading\")\n        .add_attribute(\"owner\", data.owner))\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    match msg {\n        // Trade Creation Messages\n        ExecuteMsg::CreateTrade {\n            whitelisted_users,\n            comment,\n        } =\u003e create_trade(deps, env, info, whitelisted_users, comment),\n\n        ExecuteMsg::AddAsset {\n            trade_id,\n            counter_id,\n            to_last_trade,\n            to_last_counter,\n            asset,\n        } =\u003e add_asset(\n            deps,\n            env,\n            info,\n            trade_id,\n            counter_id,\n            to_last_trade,\n            to_last_counter,\n            asset,\n        ),\n        ExecuteMsg::RemoveAssets {\n            trade_id,\n            counter_id,\n            assets,\n        } =\u003e withdraw_assets_while_creating(deps, env, info, trade_id, counter_id, assets),\n\n        ExecuteMsg::AddWhitelistedUsers {\n            trade_id,\n            whitelisted_users,\n        } =\u003e add_whitelisted_users(\n            deps.storage,\n            deps.api,\n            env,\n            info,\n            trade_id,\n            whitelisted_users,\n        ),\n\n        ExecuteMsg::RemoveWhitelistedUsers {\n            trade_id,\n            whitelisted_users,\n        } =\u003e remove_whitelisted_users(deps, env, info, trade_id, whitelisted_users),\n\n        ExecuteMsg::AddNFTsWanted {\n            trade_id,\n            nfts_wanted,\n        } =\u003e add_nfts_wanted(deps, env, info, trade_id, nfts_wanted),\n\n        ExecuteMsg::RemoveNFTsWanted {\n            trade_id,\n            nfts_wanted,\n        } =\u003e remove_nfts_wanted(deps, env, info, trade_id, nfts_wanted),\n\n        ExecuteMsg::SetComment {\n            trade_id,\n            counter_id,\n            comment,\n        } =\u003e set_comment(deps, env, info, trade_id, counter_id, comment),\n\n        ExecuteMsg::ConfirmTrade { trade_id } =\u003e confirm_trade(deps, env, info, trade_id),\n\n        //Counter Trade Creation Messages\n        ExecuteMsg::SuggestCounterTrade { trade_id, comment } =\u003e {\n            suggest_counter_trade(deps, env, info, trade_id, comment)\n        }\n\n        ExecuteMsg::ConfirmCounterTrade {\n            trade_id,\n            counter_id,\n        } =\u003e confirm_counter_trade(deps, env, info, trade_id, counter_id),\n\n        // After Create Messages\n        ExecuteMsg::AcceptTrade {\n            trade_id,\n            counter_id,\n            comment,\n        } =\u003e accept_trade(deps, env, info, trade_id, counter_id, comment),\n\n        // After Create Messages\n        ExecuteMsg::CancelTrade { trade_id } =\u003e cancel_trade(deps, env, info, trade_id),\n        ExecuteMsg::CancelCounterTrade {\n            trade_id,\n            counter_id,\n        } =\u003e cancel_counter_trade(deps, env, info, trade_id, counter_id),\n\n        ExecuteMsg::RefuseCounterTrade {\n            trade_id,\n            counter_id,\n        } =\u003e refuse_counter_trade(deps, env, info, trade_id, counter_id),\n\n        ExecuteMsg::ReviewCounterTrade {\n            trade_id,\n            counter_id,\n            comment,\n        } =\u003e review_counter_trade(deps, env, info, trade_id, counter_id, comment),\n\n        ExecuteMsg::WithdrawPendingAssets { trader, trade_id } =\u003e {\n            withdraw_accepted_funds(deps, env, info, trader, trade_id)\n        }\n\n        ExecuteMsg::WithdrawAllFromTrade { trade_id } =\u003e {\n            withdraw_all_from_trade(deps, env, info, trade_id)\n        }\n\n        ExecuteMsg::WithdrawAllFromCounter {\n            trade_id,\n            counter_id,\n        } =\u003e withdraw_all_from_counter(deps, env, info, trade_id, counter_id),\n\n        // Contract Variable\n        ExecuteMsg::SetNewOwner { owner } =\u003e set_new_owner(deps, env, info, owner),\n\n        // Contract Variable\n        ExecuteMsg::SetNewFeeContract { fee_contract } =\u003e {\n            set_new_fee_contract(deps, env, info, fee_contract)\n        }\n    }\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn migrate(_deps: DepsMut, _env: Env, _msg: MigrateMsg) -\u003e Result\u003cResponse, ContractError\u003e {\n    // No state migrations performed, just returned a Response\n    Ok(Response::default())\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::ContractInfo {} =\u003e to_binary(\u0026query_contract_info(deps)?),\n        QueryMsg::TradeInfo { trade_id } =\u003e to_binary(\n            \u0026load_trade(deps.storage, trade_id)\n                .map_err(|e| StdError::generic_err(e.to_string()))?,\n        ),\n        QueryMsg::CounterTradeInfo {\n            trade_id,\n            counter_id,\n        } =\u003e to_binary(\n            \u0026load_counter_trade(deps.storage, trade_id, counter_id)\n                .map_err(|e| StdError::generic_err(e.to_string()))?,\n        ),\n        QueryMsg::GetAllCounterTrades {\n            start_after,\n            limit,\n            filters,\n        } =\u003e to_binary(\u0026query_all_counter_trades(\n            deps,\n            start_after,\n            limit,\n            filters,\n        )?),\n        QueryMsg::GetCounterTrades {\n            trade_id,\n            start_after,\n            limit,\n            filters,\n        } =\u003e to_binary(\u0026query_counter_trades(\n            deps,\n            trade_id,\n            start_after,\n            limit,\n            filters,\n        )?),\n        QueryMsg::GetAllTrades {\n            start_after,\n            limit,\n            filters,\n        } =\u003e to_binary(\u0026query_all_trades(deps, start_after, limit, filters)?),\n    }\n}\n\n/// Replace the current contract owner with the provided owner address\n/// * `owner` must be a valid Terra address\n/// The owner has limited power on this contract :\n/// 1. Change the contract owner\n/// 2. Change the fee contract\npub fn set_new_owner(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    new_owner: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut contract_info = is_owner(deps.storage, info.sender)?;\n\n    let new_owner = deps.api.addr_validate(\u0026new_owner)?;\n    contract_info.owner = new_owner.clone();\n    CONTRACT_INFO.save(deps.storage, \u0026contract_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"modify_parameter\")\n        .add_attribute(\"parameter\", \"owner\")\n        .add_attribute(\"value\", new_owner))\n}\n\n/// Replace the current fee_contract with the provided fee_contract address\n/// * `fee_contract` must be a valid Terra address\npub fn set_new_fee_contract(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    fee_contract: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut contract_info = is_owner(deps.storage, info.sender)?;\n\n    let fee_contract = deps.api.addr_validate(\u0026fee_contract)?;\n    contract_info.fee_contract = Some(fee_contract.clone());\n    CONTRACT_INFO.save(deps.storage, \u0026contract_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"modify_parameter\")\n        .add_attribute(\"parameter\", \"fee_contract\")\n        .add_attribute(\"value\", fee_contract))\n}\n\n/// General handler to add an asset to a trade or a counter trade\n#[allow(clippy::too_many_arguments)]\npub fn add_asset(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    trade_id: Option\u003cu64\u003e,\n    counter_id: Option\u003cu64\u003e,\n    to_last_trade: Option\u003cbool\u003e,\n    to_last_counter: Option\u003cbool\u003e,\n    asset: AssetInfo,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // We implement 4 different cases here.\n    if to_last_trade.unwrap_or_default() {\n        // 1. We want to add the asset to the last trade created by the user\n        add_asset_to_trade(deps, env, info, None, asset)\n    } else if to_last_counter.unwrap_or_default() {\n        // 2. We want to add the asset to the last counter_trade created by the user\n        add_asset_to_counter_trade(\n            deps,\n            env,\n            info,\n            trade_id.ok_or(ContractError::TradeIdMissing {})?,\n            None,\n            asset,\n        )\n    } else if counter_id.is_some() {\n        // 3. We want to add the asset to a designated counter_trade (trade_id + counter_id)\n        add_asset_to_counter_trade(deps, env, info, trade_id.unwrap(), counter_id, asset)\n    } else {\n        // 4. We want to add the asset to a designated trade_id\n        add_asset_to_trade(deps, env, info, trade_id, asset)\n    }\n}\n\n/// Remove some assets from a trade when creating it.\npub fn withdraw_assets_while_creating(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    trade_id: u64,\n    counter_id: Option\u003cu64\u003e,\n    assets: Vec\u003c(u16, AssetInfo)\u003e, // We chose to number the withdrawn assets to prevent looping over all deposited assets\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    match counter_id {\n        Some(counter_id) =\u003e withdraw_counter_trade_assets_while_creating(\n            deps, env, info, trade_id, counter_id, assets,\n        ),\n        None =\u003e withdraw_trade_assets_while_creating(deps, env, info, trade_id, assets),\n    }\n}\n\n/// Withdraw assets from an accepted trade.\n/// The trader will withdraw assets from the counter_trade\n/// The counter_trader will withdraw assets from the trade\npub fn withdraw_accepted_funds(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    trader: String,\n    trade_id: u64,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // The fee contract is the only one responsible for withdrawing assets\n    is_fee_contract(deps.storage, info.sender)?;\n\n    // We load the trade and verify it has been accepted\n    let mut trade_info = load_trade(deps.storage, trade_id)?;\n    if trade_info.state != TradeState::Accepted {\n        return Err(ContractError::TradeNotAccepted {});\n    }\n\n    // We load the corresponding counter_trade\n    let counter_id = trade_info\n        .accepted_info\n        .clone()\n        .ok_or(ContractError::ContractBug {})?\n        .counter_id;\n    let mut counter_info = load_counter_trade(deps.storage, trade_id, counter_id)?;\n\n    let trader = deps.api.addr_validate(\u0026trader)?;\n    let (res, trade_type);\n\n    // We indentify who the transaction sender is (trader or counter-trader)\n    if trade_info.owner == trader {\n        // In case the trader wants to withdraw the exchanged funds (from the counter_info object)\n        res = check_and_create_withdraw_messages(env, \u0026trader, \u0026counter_info)?;\n\n        trade_type = \"counter\";\n        counter_info.assets_withdrawn = true;\n        COUNTER_TRADE_INFO.save(deps.storage, (trade_id, counter_id), \u0026counter_info)?;\n    } else if counter_info.owner == trader {\n        // In case the counter_trader wants to withdraw the exchanged funds (from the trade_info object)\n        res = check_and_create_withdraw_messages(env, \u0026trader, \u0026trade_info)?;\n\n        trade_type = \"trade\";\n        trade_info.assets_withdrawn = true;\n        TRADE_INFO.save(deps.storage, trade_id, \u0026trade_info)?;\n    } else {\n        return Err(ContractError::NotWithdrawableByYou {});\n    }\n\n    Ok(res\n        .add_attribute(\"action\", \"withdraw_funds\")\n        .add_attribute(\"type\", trade_type)\n        .add_attribute(\"trade\", trade_id.to_string())\n        .add_attribute(\"counter\", counter_id.to_string())\n        .add_attribute(\"trader\", trade_info.owner)\n        .add_attribute(\"counter_trader\", counter_info.owner))\n}\n\n#[cfg(test)]\npub mod tests {\n    use super::*;\n    use crate::state::load_trade;\n    use cosmwasm_std::testing::{mock_dependencies, mock_env, mock_info};\n    use cosmwasm_std::{coins, Addr, Attribute, BankMsg, Coin, Uint128};\n    use cw1155::Cw1155ExecuteMsg;\n    use cw20::Cw20ExecuteMsg;\n    use cw721::Cw721ExecuteMsg;\n    use p2p_trading_export::msg::into_cosmos_msg;\n    use p2p_trading_export::state::{AssetInfo, Cw1155Coin, Cw20Coin, Cw721Coin, TradeInfo};\n\n    fn init_helper(deps: DepsMut) {\n        let instantiate_msg = InstantiateMsg {\n            name: \"p2p-trading\".to_string(),\n            owner: None,\n        };\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n\n        instantiate(deps, env, info, instantiate_msg).unwrap();\n    }\n\n    fn set_fee_contract_helper(deps: DepsMut) {\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::SetNewFeeContract {\n                fee_contract: \"fee_contract\".to_string(),\n            },\n        )\n        .unwrap();\n    }\n\n    #[test]\n    fn test_init_sanity() {\n        let mut deps = mock_dependencies();\n        let instantiate_msg = InstantiateMsg {\n            name: \"p2p-trading\".to_string(),\n            owner: Some(\"this_address\".to_string()),\n        };\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n\n        let res_init = instantiate(deps.as_mut(), env, info, instantiate_msg).unwrap();\n        assert_eq!(0, res_init.messages.len());\n    }\n\n    #[test]\n    fn test_change_owner() {\n        let mut deps = mock_dependencies();\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n        init_helper(deps.as_mut());\n\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            ExecuteMsg::SetNewOwner {\n                owner: \"new_owner\".to_string(),\n            },\n        )\n        .unwrap();\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            ExecuteMsg::SetNewOwner {\n                owner: \"new_owner\".to_string(),\n            },\n        )\n        .unwrap_err();\n        let info = mock_info(\"new_owner\", \u0026[]);\n        execute(\n            deps.as_mut(),\n            env,\n            info,\n            ExecuteMsg::SetNewOwner {\n                owner: \"other_owner\".to_string(),\n            },\n        )\n        .unwrap();\n    }\n\n    fn create_trade_helper(deps: DepsMut, creator: \u0026str) -\u003e Response {\n        let info = mock_info(creator, \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::CreateTrade {\n                whitelisted_users: Some(vec![]),\n                comment: Some(\"Q\".to_string()),\n            },\n        )\n        .unwrap()\n    }\n\n    fn create_private_trade_helper(deps: DepsMut, users: Vec\u003cString\u003e) -\u003e Response {\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::CreateTrade {\n                whitelisted_users: Some(users),\n                comment: None,\n            },\n        )\n        .unwrap()\n    }\n\n    fn add_whitelisted_users(\n        deps: DepsMut,\n        trade_id: u64,\n        users: Vec\u003cString\u003e,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::AddWhitelistedUsers {\n                trade_id,\n                whitelisted_users: users,\n            },\n        )\n    }\n\n    fn remove_whitelisted_users(\n        deps: DepsMut,\n        trade_id: u64,\n        users: Vec\u003cString\u003e,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::RemoveWhitelistedUsers {\n                trade_id,\n                whitelisted_users: users,\n            },\n        )\n    }\n\n    fn add_nfts_wanted_helper(\n        deps: DepsMut,\n        trader: \u0026str,\n        trade_id: u64,\n        confirm: Vec\u003cString\u003e,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(trader, \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::AddNFTsWanted {\n                trade_id: Some(trade_id),\n                nfts_wanted: confirm,\n            },\n        )\n    }\n\n    fn remove_nfts_wanted_helper(\n        deps: DepsMut,\n        trader: \u0026str,\n        trade_id: u64,\n        confirm: Vec\u003cString\u003e,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(trader, \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::RemoveNFTsWanted {\n                trade_id,\n                nfts_wanted: confirm,\n            },\n        )\n    }\n\n    fn add_asset_to_trade_helper(\n        deps: DepsMut,\n        trader: \u0026str,\n        trade_id: u64,\n        asset: AssetInfo,\n        coins_to_send: \u0026[Coin],\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(trader, coins_to_send);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::AddAsset {\n                to_last_trade: None,\n                to_last_counter: None,\n                trade_id: Some(trade_id),\n                counter_id: None,\n                asset,\n            },\n        )\n    }\n\n    fn remove_assets_helper(\n        deps: DepsMut,\n        sender: \u0026str,\n        trade_id: u64,\n        counter_id: Option\u003cu64\u003e,\n        assets: Vec\u003c(u16, AssetInfo)\u003e,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(sender, \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::RemoveAssets {\n                trade_id,\n                counter_id,\n                assets,\n            },\n        )\n    }\n\n    fn confirm_trade_helper(\n        deps: DepsMut,\n        sender: \u0026str,\n        trade_id: u64,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(sender, \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::ConfirmTrade {\n                trade_id: Some(trade_id),\n            },\n        )\n    }\n\n    fn withdraw_helper(\n        deps: DepsMut,\n        trader: \u0026str,\n        sender: \u0026str,\n        trade_id: u64,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(sender, \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::WithdrawPendingAssets {\n                trader: trader.to_string(),\n                trade_id,\n            },\n        )\n    }\n\n    fn withdraw_cancelled_trade_helper(\n        deps: DepsMut,\n        sender: \u0026str,\n        trade_id: u64,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(sender, \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::WithdrawAllFromTrade { trade_id },\n        )\n    }\n\n    fn withdraw_aborted_counter_helper(\n        deps: DepsMut,\n        sender: \u0026str,\n        trade_id: u64,\n        counter_id: u64,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(sender, \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::WithdrawAllFromCounter {\n                trade_id,\n                counter_id,\n            },\n        )\n    }\n\n    pub mod trade_tests {\n        use super::*;\n        use crate::query::{query_counter_trades, TradeResponse};\n        use crate::trade::validate_addresses;\n        use cosmwasm_std::{coin, Api, SubMsg};\n        use p2p_trading_export::msg::QueryFilters;\n        use p2p_trading_export::state::{AdditionnalTradeInfo, Comment, CounterTradeInfo};\n        use std::collections::HashSet;\n        use std::iter::FromIterator;\n\n        #[test]\n        fn create_trade() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            let res = create_trade_helper(deps.as_mut(), \"creator\");\n\n            assert_eq!(res.messages, vec![]);\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"create_trade\"),\n                    Attribute::new(\"trade_id\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                ]\n            );\n\n            let res = create_trade_helper(deps.as_mut(), \"creator\");\n\n            assert_eq!(res.messages, vec![]);\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"create_trade\"),\n                    Attribute::new(\"trade_id\", \"1\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                ]\n            );\n\n            let new_trade_info = load_trade(\u0026deps.storage, 0).unwrap();\n\n            assert_eq!(new_trade_info.state, TradeState::Created {});\n\n            // Query all and check that trades exist, without filters specified\n            let res = query_all_trades(deps.as_ref(), None, None, None).unwrap();\n\n            assert_eq!(\n                res.trades,\n                vec![\n                    {\n                        TradeResponse {\n                            trade_id: 1,\n                            counter_id: None,\n                            trade_info: Some(TradeInfo {\n                                owner: deps.api.addr_validate(\"creator\").unwrap(),\n                                additionnal_info: AdditionnalTradeInfo {\n                                    owner_comment: Some(Comment {\n                                        comment: \"Q\".to_string(),\n                                        time: mock_env().block.time,\n                                    }),\n                                    time: mock_env().block.time,\n                                    ..Default::default()\n                                },\n                                ..Default::default()\n                            }),\n                        }\n                    },\n                    {\n                        TradeResponse {\n                            trade_id: 0,\n                            counter_id: None,\n                            trade_info: Some(TradeInfo {\n                                owner: deps.api.addr_validate(\"creator\").unwrap(),\n                                additionnal_info: AdditionnalTradeInfo {\n                                    owner_comment: Some(Comment {\n                                        comment: \"Q\".to_string(),\n                                        time: mock_env().block.time,\n                                    }),\n                                    time: mock_env().block.time,\n                                    ..Default::default()\n                                },\n                                ..Default::default()\n                            }),\n                        }\n                    }\n                ]\n            );\n        }\n\n        #[test]\n        fn create_trade_and_nfts_wanted() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            let res = add_nfts_wanted_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                vec![\"nft1\".to_string(), \"nft2\".to_string()],\n            )\n            .unwrap();\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"modify_parameter\"),\n                    Attribute::new(\"name\", \"nfts_wanted\"),\n                    Attribute::new(\"operation_type\", \"add\"),\n                    Attribute::new(\"value\", \"nft1,nft2\"),\n                    Attribute::new(\"trade_id\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\")\n                ]\n            );\n\n            let trade = load_trade(\u0026deps.storage, 0).unwrap();\n            assert_eq!(\n                trade.additionnal_info.nfts_wanted,\n                HashSet::from_iter(vec![Addr::unchecked(\"nft1\"), Addr::unchecked(\"nft2\")])\n            );\n\n            add_nfts_wanted_helper(deps.as_mut(), \"creator\", 0, vec![\"nft1\".to_string()]).unwrap();\n            remove_nfts_wanted_helper(deps.as_mut(), \"creator\", 0, vec![\"nft1\".to_string()])\n                .unwrap();\n\n            let trade = load_trade(\u0026deps.storage, 0).unwrap();\n            assert_eq!(\n                trade.additionnal_info.nfts_wanted,\n                HashSet::from_iter(vec![Addr::unchecked(\"nft2\")])\n            );\n        }\n\n        #[test]\n        fn create_multiple_trades_and_query() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            let res = create_trade_helper(deps.as_mut(), \"creator\");\n\n            assert_eq!(res.messages, vec![]);\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"create_trade\"),\n                    Attribute::new(\"trade_id\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                ]\n            );\n\n            let res = create_trade_helper(deps.as_mut(), \"creator2\");\n\n            assert_eq!(res.messages, vec![]);\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"create_trade\"),\n                    Attribute::new(\"trade_id\", \"1\"),\n                    Attribute::new(\"trader\", \"creator2\"),\n                ]\n            );\n\n            let new_trade_info = load_trade(\u0026deps.storage, 0).unwrap();\n\n            assert_eq!(new_trade_info.state, TradeState::Created {});\n\n            let new_trade_info = load_trade(\u0026deps.storage, 1).unwrap();\n            assert_eq!(new_trade_info.state, TradeState::Created {});\n\n            create_trade_helper(deps.as_mut(), \"creator2\");\n            confirm_trade_helper(deps.as_mut(), \"creator2\", 2).unwrap();\n\n            // Query all created trades check that creators are different\n            let res = query_all_trades(\n                deps.as_ref(),\n                None,\n                None,\n                Some(QueryFilters {\n                    states: Some(vec![TradeState::Created.to_string()]),\n                    ..Default::default()\n                }),\n            )\n            .unwrap();\n\n            assert_eq!(\n                res.trades,\n                vec![\n                    {\n                        TradeResponse {\n                            trade_id: 1,\n                            counter_id: None,\n                            trade_info: Some(TradeInfo {\n                                owner: deps.api.addr_validate(\"creator2\").unwrap(),\n                                additionnal_info: AdditionnalTradeInfo {\n                                    owner_comment: Some(Comment {\n                                        comment: \"Q\".to_string(),\n                                        time: mock_env().block.time,\n                                    }),\n                                    time: mock_env().block.time,\n                                    ..Default::default()\n                                },\n                                ..Default::default()\n                            }),\n                        }\n                    },\n                    {\n                        TradeResponse {\n                            trade_id: 0,\n                            counter_id: None,\n                            trade_info: Some(TradeInfo {\n                                owner: deps.api.addr_validate(\"creator\").unwrap(),\n                                additionnal_info: AdditionnalTradeInfo {\n                                    owner_comment: Some(Comment {\n                                        comment: \"Q\".to_string(),\n                                        time: mock_env().block.time,\n                                    }),\n                                    time: mock_env().block.time,\n                                    ..Default::default()\n                                },\n                                ..Default::default()\n                            }),\n                        }\n                    }\n                ]\n            );\n\n            // Verify that pagination by trade_id works\n            let res = query_all_trades(\n                deps.as_ref(),\n                Some(1),\n                None,\n                Some(QueryFilters {\n                    states: Some(vec![TradeState::Created.to_string()]),\n                    ..Default::default()\n                }),\n            )\n            .unwrap();\n\n            assert_eq!(\n                res.trades,\n                vec![{\n                    TradeResponse {\n                        trade_id: 0,\n                        counter_id: None,\n                        trade_info: Some(TradeInfo {\n                            owner: deps.api.addr_validate(\"creator\").unwrap(),\n                            additionnal_info: AdditionnalTradeInfo {\n                                owner_comment: Some(Comment {\n                                    comment: \"Q\".to_string(),\n                                    time: mock_env().block.time,\n                                }),\n                                time: mock_env().block.time,\n                                ..Default::default()\n                            },\n                            ..Default::default()\n                        }),\n                    }\n                }]\n            );\n\n            // Query that query returned only queries that are in created state and belong to creator2\n            let res = query_all_trades(\n                deps.as_ref(),\n                None,\n                None,\n                Some(QueryFilters {\n                    states: Some(vec![TradeState::Created.to_string()]),\n                    owner: Some(\"creator2\".to_string()),\n                    ..Default::default()\n                }),\n            )\n            .unwrap();\n\n            assert_eq!(\n                res.trades,\n                vec![TradeResponse {\n                    trade_id: 1,\n                    counter_id: None,\n                    trade_info: Some(TradeInfo {\n                        owner: deps.api.addr_validate(\"creator2\").unwrap(),\n                        additionnal_info: AdditionnalTradeInfo {\n                            owner_comment: Some(Comment {\n                                comment: \"Q\".to_string(),\n                                time: mock_env().block.time\n                            }),\n                            time: mock_env().block.time,\n                            ..Default::default()\n                        },\n                        ..Default::default()\n                    })\n                }]\n            );\n\n            // Check that if states are None that owner query still works\n            let res = query_all_trades(\n                deps.as_ref(),\n                None,\n                None,\n                Some(QueryFilters {\n                    owner: Some(\"creator2\".to_string()),\n                    ..Default::default()\n                }),\n            )\n            .unwrap();\n\n            assert_eq!(\n                res.trades,\n                vec![\n                    TradeResponse {\n                        trade_id: 2,\n                        counter_id: None,\n                        trade_info: Some(TradeInfo {\n                            owner: deps.api.addr_validate(\"creator2\").unwrap(),\n                            state: TradeState::Published,\n                            additionnal_info: AdditionnalTradeInfo {\n                                owner_comment: Some(Comment {\n                                    comment: \"Q\".to_string(),\n                                    time: mock_env().block.time\n                                }),\n                                time: mock_env().block.time,\n                                ..Default::default()\n                            },\n                            ..Default::default()\n                        })\n                    },\n                    TradeResponse {\n                        trade_id: 1,\n                        counter_id: None,\n                        trade_info: Some(TradeInfo {\n                            owner: deps.api.addr_validate(\"creator2\").unwrap(),\n                            additionnal_info: AdditionnalTradeInfo {\n                                owner_comment: Some(Comment {\n                                    comment: \"Q\".to_string(),\n                                    time: mock_env().block.time\n                                }),\n                                time: mock_env().block.time,\n                                ..Default::default()\n                            },\n                            ..Default::default()\n                        })\n                    }\n                ]\n            );\n\n            // Check that queries with published state do not return anything. Because none exists.\n            let res = query_all_trades(\n                deps.as_ref(),\n                None,\n                None,\n                Some(QueryFilters {\n                    states: Some(vec![TradeState::Accepted.to_string()]),\n                    ..Default::default()\n                }),\n            )\n            .unwrap();\n\n            assert_eq!(res.trades, vec![]);\n\n            // Check that queries with published state do not return anything when owner is specified. Because none exists.\n            let res = query_all_trades(\n                deps.as_ref(),\n                None,\n                None,\n                Some(QueryFilters {\n                    states: Some(vec![TradeState::Accepted.to_string()]),\n                    owner: Some(\"creator2\".to_string()),\n                    ..Default::default()\n                }),\n            )\n            .unwrap();\n            assert_eq!(res.trades, vec![]);\n        }\n\n        #[test]\n        fn create_trade_and_add_funds() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            let res = add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Coin(coin(2, \"token\")),\n                \u0026coins(2, \"token\"),\n            )\n            .unwrap();\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"add_asset\"),\n                    Attribute::new(\"asset_type\", \"fund\"),\n                    Attribute::new(\"denom\", \"token\"),\n                    Attribute::new(\"amount\", \"2\"),\n                    Attribute::new(\"trade_id\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                ]\n            );\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Coin(coin(2, \"token\")),\n                \u0026coins(2, \"token\"),\n            )\n            .unwrap();\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Coin(coin(2, \"other_token\")),\n                \u0026coins(2, \"other_token\"),\n            )\n            .unwrap();\n\n            let new_trade_info = load_trade(\u0026deps.storage, 0).unwrap();\n            assert_eq!(\n                new_trade_info.associated_assets,\n                vec![\n                    AssetInfo::Coin(Coin {\n                        amount: Uint128::from(4u64),\n                        denom: \"token\".to_string()\n                    }),\n                    AssetInfo::Coin(Coin {\n                        amount: Uint128::from(2u64),\n                        denom: \"other_token\".to_string()\n                    })\n                ]\n            );\n        }\n\n        #[test]\n        fn create_trade_and_add_cw20_tokens() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n\n            let res = add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    address: \"token\".to_string(),\n                    amount: Uint128::new(100u128),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"add_asset\"),\n                    Attribute::new(\"asset_type\", \"token\"),\n                    Attribute::new(\"token\", \"token\"),\n                    Attribute::new(\"amount\", \"100\"),\n                    Attribute::new(\"trade_id\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                ]\n            );\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    address: \"token\".to_string(),\n                    amount: Uint128::new(100u128),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    address: \"other_token\".to_string(),\n                    amount: Uint128::new(100u128),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            let new_trade_info = load_trade(\u0026deps.storage, 0).unwrap();\n            assert_eq!(\n                new_trade_info.associated_assets,\n                vec![\n                    AssetInfo::Cw20Coin(Cw20Coin {\n                        amount: Uint128::from(200u64),\n                        address: \"token\".to_string()\n                    }),\n                    AssetInfo::Cw20Coin(Cw20Coin {\n                        amount: Uint128::from(100u64),\n                        address: \"other_token\".to_string()\n                    })\n                ]\n            );\n\n            // Verify the token contain query\n            let res = query_all_trades(\n                deps.as_ref(),\n                None,\n                None,\n                Some(QueryFilters {\n                    contains_token: Some(\"other_token\".to_string()),\n                    ..Default::default()\n                }),\n            )\n            .unwrap();\n\n            let env = mock_env();\n            assert_eq!(\n                res.trades,\n                vec![{\n                    TradeResponse {\n                        trade_id: 0,\n                        counter_id: None,\n                        trade_info: Some(TradeInfo {\n                            owner: deps.api.addr_validate(\"creator\").unwrap(),\n                            state: TradeState::Created,\n                            associated_assets: vec![\n                                AssetInfo::Cw20Coin(Cw20Coin {\n                                    amount: Uint128::from(200u64),\n                                    address: \"token\".to_string(),\n                                }),\n                                AssetInfo::Cw20Coin(Cw20Coin {\n                                    amount: Uint128::from(100u64),\n                                    address: \"other_token\".to_string(),\n                                }),\n                            ],\n                            additionnal_info: AdditionnalTradeInfo {\n                                owner_comment: Some(Comment {\n                                    comment: \"Q\".to_string(),\n                                    time: env.block.time,\n                                }),\n                                time: env.block.time,\n                                ..Default::default()\n                            },\n                            ..Default::default()\n                        }),\n                    }\n                }]\n            );\n\n            // Verify it works when querying another token\n            let res = query_all_trades(\n                deps.as_ref(),\n                None,\n                None,\n                Some(QueryFilters {\n                    contains_token: Some(\"bad_token\".to_string()),\n                    ..Default::default()\n                }),\n            )\n            .unwrap();\n            assert_eq!(res.trades, vec![]);\n\n            // This triggers an error, the creator is not the same as the sender\n\n            let err = add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"bad_person\",\n                0,\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    address: \"other_token\".to_string(),\n                    amount: Uint128::new(100u128),\n                }),\n                \u0026[],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::TraderNotCreator {});\n        }\n\n        #[test]\n        fn create_trade_and_add_cw721_tokens() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n\n            let res = add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft\".to_string(),\n                    token_id: \"58\".to_string(),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"add_asset\"),\n                    Attribute::new(\"asset_type\", \"NFT\"),\n                    Attribute::new(\"nft\", \"nft\"),\n                    Attribute::new(\"token_id\", \"58\"),\n                    Attribute::new(\"trade_id\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                ]\n            );\n\n            let new_trade_info = load_trade(\u0026deps.storage, 0).unwrap();\n            assert_eq!(\n                new_trade_info.associated_assets,\n                vec![AssetInfo::Cw721Coin(Cw721Coin {\n                    token_id: \"58\".to_string(),\n                    address: \"nft\".to_string()\n                })]\n            );\n\n            // This triggers an error, the creator is not the same as the sender\n            let err = add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"bad_person\",\n                0,\n                AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"other_token\".to_string(),\n                    token_id: \"58\".to_string(),\n                }),\n                \u0026[],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::TraderNotCreator {});\n        }\n\n        #[test]\n        fn create_trade_and_add_cw1155_tokens() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n\n            let res = add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw1155Coin(Cw1155Coin {\n                    address: \"1155\".to_string(),\n                    token_id: \"58\".to_string(),\n                    value: Uint128::new(50u128),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"add_asset\"),\n                    Attribute::new(\"asset_type\", \"cw1155\"),\n                    Attribute::new(\"token\", \"1155\"),\n                    Attribute::new(\"token_id\", \"58\"),\n                    Attribute::new(\"amount\", \"50\"),\n                    Attribute::new(\"trade_id\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                ]\n            );\n\n            let new_trade_info = load_trade(\u0026deps.storage, 0).unwrap();\n            assert_eq!(\n                new_trade_info.associated_assets,\n                vec![AssetInfo::Cw1155Coin(Cw1155Coin {\n                    token_id: \"58\".to_string(),\n                    address: \"1155\".to_string(),\n                    value: Uint128::from(50u128)\n                })]\n            );\n\n            // This triggers an error, the creator is not the same as the sender\n            let err = add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"bad_person\",\n                0,\n                AssetInfo::Cw1155Coin(Cw1155Coin {\n                    address: \"1155\".to_string(),\n                    token_id: \"58\".to_string(),\n                    value: Uint128::new(50u128),\n                }),\n                \u0026[],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::TraderNotCreator {});\n        }\n        #[test]\n        fn create_trade_and_withdraw() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            create_trade_helper(deps.as_mut(), \"creator\");\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw1155Coin(Cw1155Coin {\n                    address: \"1155\".to_string(),\n                    token_id: \"58\".to_string(),\n                    value: Uint128::new(50u128),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"other_token\".to_string(),\n                    token_id: \"58\".to_string(),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            withdraw_cancelled_trade_helper(deps.as_mut(), \"bas_person\", 0).unwrap_err();\n            withdraw_cancelled_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n\n            let new_trade_info = load_trade(\u0026deps.storage, 0).unwrap();\n            assert_eq!(new_trade_info.state, TradeState::Cancelled);\n\n            withdraw_cancelled_trade_helper(deps.as_mut(), \"creator\", 0).unwrap_err();\n        }\n        #[test]\n        fn create_trade_automatic_trade_id() {\n            let mut deps = mock_dependencies();\n            let info = mock_info(\"creator\", \u0026[]);\n            let env = mock_env();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            create_trade_helper(deps.as_mut(), \"creator\");\n\n            execute(\n                deps.as_mut(),\n                env.clone(),\n                info,\n                ExecuteMsg::AddAsset {\n                    trade_id: None,\n                    counter_id: None,\n                    to_last_trade: Some(true),\n                    to_last_counter: None,\n                    asset: AssetInfo::Cw20Coin(Cw20Coin {\n                        address: \"cw20\".to_string(),\n                        amount: Uint128::from(100u64),\n                    }),\n                },\n            )\n            .unwrap();\n\n            let info = mock_info(\"creator\", \u0026coins(97u128, \"uluna\"));\n            execute(\n                deps.as_mut(),\n                env,\n                info,\n                ExecuteMsg::AddAsset {\n                    trade_id: None,\n                    counter_id: None,\n                    to_last_trade: Some(true),\n                    to_last_counter: None,\n                    asset: AssetInfo::Coin(coin(97u128, \"uluna\")),\n                },\n            )\n            .unwrap();\n\n            let trade_info = TRADE_INFO.load(\u0026deps.storage, 1u64).unwrap();\n            assert_eq!(\n                trade_info.associated_assets,\n                vec![\n                    AssetInfo::Cw20Coin(Cw20Coin {\n                        address: \"cw20\".to_string(),\n                        amount: Uint128::from(100u128)\n                    }),\n                    AssetInfo::Coin(coin(97u128, \"uluna\")),\n                ]\n            );\n        }\n\n        #[test]\n        fn create_trade_add_remove_tokens() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft\".to_string(),\n                    token_id: \"58\".to_string(),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft-2\".to_string(),\n                    token_id: \"58\".to_string(),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw1155Coin(Cw1155Coin {\n                    address: \"cw1155token\".to_string(),\n                    token_id: \"58\".to_string(),\n                    value: Uint128::new(100u128),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    address: \"token\".to_string(),\n                    amount: Uint128::new(100u128),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Coin(coin(100, \"luna\")),\n                \u0026coins(100, \"luna\"),\n            )\n            .unwrap();\n\n            let res = remove_assets_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                None,\n                vec![\n                    (\n                        0,\n                        AssetInfo::Cw721Coin(Cw721Coin {\n                            address: \"nft\".to_string(),\n                            token_id: \"58\".to_string(),\n                        }),\n                    ),\n                    (\n                        2,\n                        AssetInfo::Cw1155Coin(Cw1155Coin {\n                            address: \"cw1155token\".to_string(),\n                            token_id: \"58\".to_string(),\n                            value: Uint128::from(58u128),\n                        }),\n                    ),\n                    (\n                        3,\n                        AssetInfo::Cw20Coin(Cw20Coin {\n                            address: \"token\".to_string(),\n                            amount: Uint128::from(58u64),\n                        }),\n                    ),\n                    (4, AssetInfo::Coin(coin(58, \"luna\"))),\n                ],\n            )\n            .unwrap();\n\n            assert_eq!(\n                res.messages,\n                vec![\n                    SubMsg::new(\n                        into_cosmos_msg(\n                            Cw721ExecuteMsg::TransferNft {\n                                recipient: \"creator\".to_string(),\n                                token_id: \"58\".to_string()\n                            },\n                            \"nft\"\n                        )\n                        .unwrap()\n                    ),\n                    SubMsg::new(\n                        into_cosmos_msg(\n                            Cw1155ExecuteMsg::SendFrom {\n                                from: mock_env().contract.address.to_string(),\n                                to: \"creator\".to_string(),\n                                token_id: \"58\".to_string(),\n                                value: Uint128::from(58u128),\n                                msg: None\n                            },\n                            \"cw1155token\"\n                        )\n                        .unwrap()\n                    ),\n                    SubMsg::new(\n                        into_cosmos_msg(\n                            Cw20ExecuteMsg::Transfer {\n                                recipient: \"creator\".to_string(),\n                                amount: Uint128::from(58u64)\n                            },\n                            \"token\"\n                        )\n                        .unwrap()\n                    ),\n                    SubMsg::new(BankMsg::Send {\n                        to_address: \"creator\".to_string(),\n                        amount: coins(58, \"luna\"),\n                    })\n                ]\n            );\n\n            let new_trade_info = load_trade(\u0026deps.storage, 0).unwrap();\n            assert_eq!(\n                new_trade_info.associated_assets,\n                vec![\n                    AssetInfo::Cw721Coin(Cw721Coin {\n                        token_id: \"58\".to_string(),\n                        address: \"nft-2\".to_string()\n                    }),\n                    AssetInfo::Cw1155Coin(Cw1155Coin {\n                        value: Uint128::from(42u64),\n                        address: \"cw1155token\".to_string(),\n                        token_id: \"58\".to_string()\n                    }),\n                    AssetInfo::Cw20Coin(Cw20Coin {\n                        amount: Uint128::from(42u64),\n                        address: \"token\".to_string()\n                    }),\n                    AssetInfo::Coin(coin(42, \"luna\"))\n                ],\n            );\n\n            remove_assets_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                None,\n                vec![\n                    (\n                        1,\n                        AssetInfo::Cw1155Coin(Cw1155Coin {\n                            address: \"cw1155token\".to_string(),\n                            token_id: \"58\".to_string(),\n                            value: Uint128::from(42u64),\n                        }),\n                    ),\n                    (\n                        2,\n                        AssetInfo::Cw20Coin(Cw20Coin {\n                            address: \"token\".to_string(),\n                            amount: Uint128::from(42u64),\n                        }),\n                    ),\n                    (3, AssetInfo::Coin(coin(42, \"luna\"))),\n                ],\n            )\n            .unwrap();\n\n            let new_trade_info = load_trade(\u0026deps.storage, 0).unwrap();\n            assert_eq!(\n                new_trade_info.associated_assets,\n                vec![AssetInfo::Cw721Coin(Cw721Coin {\n                    token_id: \"58\".to_string(),\n                    address: \"nft-2\".to_string()\n                }),],\n            );\n\n            // This triggers an error, the creator is not the same as the sender\n            let err = remove_assets_helper(\n                deps.as_mut(),\n                \"bad_person\",\n                0,\n                None,\n                vec![(\n                    0,\n                    AssetInfo::Cw721Coin(Cw721Coin {\n                        address: \"nft-2\".to_string(),\n                        token_id: \"58\".to_string(),\n                    }),\n                )],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::TraderNotCreator {});\n\n            // This triggers an error, no matching funds were found\n            let err = remove_assets_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                None,\n                vec![(\n                    1,\n                    AssetInfo::Cw721Coin(Cw721Coin {\n                        address: \"nft-2\".to_string(),\n                        token_id: \"58\".to_string(),\n                    }),\n                )],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::AssetNotFound { position: 1 });\n\n            // This triggers an error, no matching funds were found\n            let err = remove_assets_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                None,\n                vec![(\n                    0,\n                    AssetInfo::Cw721Coin(Cw721Coin {\n                        address: \"nft-1\".to_string(),\n                        token_id: \"58\".to_string(),\n                    }),\n                )],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::AssetNotFound { position: 0 });\n\n            // This triggers an error, no matching funds were found\n            let err = remove_assets_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                None,\n                vec![(\n                    0,\n                    AssetInfo::Cw721Coin(Cw721Coin {\n                        address: \"nft-2\".to_string(),\n                        token_id: \"42\".to_string(),\n                    }),\n                )],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::AssetNotFound { position: 0 });\n        }\n\n        #[test]\n        fn create_trade_add_remove_tokens_errors() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft\".to_string(),\n                    token_id: \"58\".to_string(),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft-2\".to_string(),\n                    token_id: \"58\".to_string(),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    address: \"token\".to_string(),\n                    amount: Uint128::new(100u128),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Coin(coin(100, \"luna\")),\n                \u0026coins(100, \"luna\"),\n            )\n            .unwrap();\n\n            let err = remove_assets_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                None,\n                vec![(\n                    2,\n                    AssetInfo::Cw20Coin(Cw20Coin {\n                        address: \"token\".to_string(),\n                        amount: Uint128::from(101u64),\n                    }),\n                )],\n            )\n            .unwrap_err();\n\n            assert_eq!(\n                err,\n                ContractError::TooMuchWithdrawn {\n                    address: \"token\".to_string(),\n                    wanted: 101,\n                    available: 100\n                }\n            );\n\n            let err = remove_assets_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                None,\n                vec![(\n                    0,\n                    AssetInfo::Cw20Coin(Cw20Coin {\n                        address: \"token\".to_string(),\n                        amount: Uint128::from(101u64),\n                    }),\n                )],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::AssetNotFound { position: 0 });\n\n            let err = remove_assets_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                None,\n                vec![(\n                    2,\n                    AssetInfo::Cw20Coin(Cw20Coin {\n                        address: \"wrong-token\".to_string(),\n                        amount: Uint128::from(101u64),\n                    }),\n                )],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::AssetNotFound { position: 2 });\n\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n\n            let err = remove_assets_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                None,\n                vec![(\n                    2,\n                    AssetInfo::Cw20Coin(Cw20Coin {\n                        address: \"token\".to_string(),\n                        amount: Uint128::from(58u64),\n                    }),\n                )],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::TradeAlreadyPublished {});\n        }\n\n        #[test]\n        fn confirm_trade() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n\n            //Wrong trade id\n            let err = confirm_trade_helper(deps.as_mut(), \"creator\", 1).unwrap_err();\n            assert_eq!(err, ContractError::NotFoundInTradeInfo {});\n\n            //Wrong trader\n            let err = confirm_trade_helper(deps.as_mut(), \"bad_person\", 0).unwrap_err();\n            assert_eq!(err, ContractError::TraderNotCreator {});\n\n            let res = confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"confirm_trade\"),\n                    Attribute::new(\"trade_id\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                ]\n            );\n\n            // Check with query that trade is confirmed, in published state\n            let res = query_all_trades(\n                deps.as_ref(),\n                None,\n                None,\n                Some(QueryFilters {\n                    states: Some(vec![TradeState::Published.to_string()]),\n                    owner: Some(\"creator\".to_string()),\n                    ..Default::default()\n                }),\n            )\n            .unwrap();\n\n            assert_eq!(\n                res.trades,\n                vec![{\n                    TradeResponse {\n                        trade_id: 0,\n                        counter_id: None,\n                        trade_info: Some(TradeInfo {\n                            owner: deps.api.addr_validate(\"creator\").unwrap(),\n                            state: TradeState::Published,\n                            additionnal_info: AdditionnalTradeInfo {\n                                owner_comment: Some(Comment {\n                                    comment: \"Q\".to_string(),\n                                    time: mock_env().block.time,\n                                }),\n                                time: mock_env().block.time,\n                                ..Default::default()\n                            },\n                            ..Default::default()\n                        }),\n                    }\n                }]\n            );\n\n            let new_trade_info = load_trade(\u0026deps.storage, 0).unwrap();\n            assert_eq!(new_trade_info.state, TradeState::Published {});\n\n            //Already confirmed\n            let err = confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap_err();\n            assert_eq!(\n                err,\n                ContractError::CantChangeTradeState {\n                    from: TradeState::Published,\n                    to: TradeState::Published\n                }\n            );\n        }\n\n        #[test]\n        fn confirm_trade_and_try_add_assets() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n\n            // This triggers an error, we can't send funds to confirmed trade\n\n            let err = add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Coin(coin(2, \"token\")),\n                \u0026coins(2, \"token\"),\n            )\n            .unwrap_err();\n\n            assert_eq!(\n                err,\n                ContractError::WrongTradeState {\n                    state: TradeState::Published\n                }\n            );\n        }\n\n        #[test]\n        fn accept_trade() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n\n            let err = accept_trade_helper(deps.as_mut(), \"creator\", 0, 5).unwrap_err();\n            assert_eq!(err, ContractError::NotFoundInCounterTradeInfo {});\n\n            let err = accept_trade_helper(deps.as_mut(), \"creator\", 1, 0).unwrap_err();\n            assert_eq!(err, ContractError::NotFoundInTradeInfo {});\n\n            let err = accept_trade_helper(deps.as_mut(), \"bad_person\", 0, 0).unwrap_err();\n            assert_eq!(err, ContractError::TraderNotCreator {});\n\n            let err = accept_trade_helper(deps.as_mut(), \"creator\", 0, 0).unwrap_err();\n            assert_eq!(err, ContractError::CantAcceptNotPublishedCounter {});\n\n            confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap();\n\n            let res = accept_trade_helper(deps.as_mut(), \"creator\", 0, 0).unwrap();\n\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"accept_counter_trade\"),\n                    Attribute::new(\"trade_id\", \"0\"),\n                    Attribute::new(\"counter_id\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                    Attribute::new(\"counter_trader\", \"counterer\"),\n                ]\n            );\n\n            let trade_info = load_trade(\u0026deps.storage, 0).unwrap();\n            assert_eq!(trade_info.state, TradeState::Accepted {});\n            assert_eq!(\n                trade_info.accepted_info.unwrap(),\n                CounterTradeInfo {\n                    trade_id: 0,\n                    counter_id: 0\n                }\n            );\n\n            let counter_trade_info = load_counter_trade(\u0026deps.storage, 0, 0).unwrap();\n            assert_eq!(counter_trade_info.state, TradeState::Accepted {});\n\n            // Check with query that trade is confirmed, in ack state\n            let res = query_all_trades(\n                deps.as_ref(),\n                None,\n                None,\n                Some(QueryFilters {\n                    states: Some(vec![TradeState::Accepted.to_string()]),\n                    owner: Some(\"creator\".to_string()),\n                    ..Default::default()\n                }),\n            )\n            .unwrap();\n\n            assert_eq!(\n                res.trades,\n                vec![{\n                    TradeResponse {\n                        trade_id: 0,\n                        counter_id: None,\n                        trade_info: Some(TradeInfo {\n                            owner: deps.api.addr_validate(\"creator\").unwrap(),\n                            state: TradeState::Accepted,\n                            last_counter_id: Some(0),\n                            accepted_info: Some(CounterTradeInfo {\n                                trade_id: 0,\n                                counter_id: 0,\n                            }),\n                            additionnal_info: AdditionnalTradeInfo {\n                                owner_comment: Some(Comment {\n                                    comment: \"Q\".to_string(),\n                                    time: mock_env().block.time,\n                                }),\n                                time: mock_env().block.time,\n                                ..Default::default()\n                            },\n                            ..Default::default()\n                        }),\n                    }\n                }]\n            );\n\n            // Check with query by trade id that one counter is returned\n            let res = query_counter_trades(deps.as_ref(), 0, None, None, None).unwrap();\n\n            assert_eq!(\n                res.counter_trades,\n                vec![{\n                    TradeResponse {\n                        counter_id: Some(0),\n                        trade_id: 0,\n                        trade_info: Some(TradeInfo {\n                            owner: deps.api.addr_validate(\"counterer\").unwrap(),\n                            state: TradeState::Accepted,\n                            additionnal_info: AdditionnalTradeInfo {\n                                owner_comment: Some(Comment {\n                                    comment: \"Q\".to_string(),\n                                    time: mock_env().block.time,\n                                }),\n                                trader_comment: Some(Comment {\n                                    comment: \"You're very kind madam\".to_string(),\n                                    time: mock_env().block.time,\n                                }),\n                                time: mock_env().block.time,\n                                ..Default::default()\n                            },\n                            ..Default::default()\n                        }),\n                    }\n                }]\n            );\n\n            let res = query_counter_trades(deps.as_ref(), 0, Some(0), None, None).unwrap();\n            assert_eq!(res.counter_trades, vec![]);\n\n            // Check with queries that only one counter is returned by query and in accepted state\n            let res = query_all_counter_trades(deps.as_ref(), None, None, None).unwrap();\n\n            assert_eq!(\n                res.counter_trades,\n                vec![{\n                    TradeResponse {\n                        counter_id: Some(0),\n                        trade_id: 0,\n                        trade_info: Some(TradeInfo {\n                            owner: deps.api.addr_validate(\"counterer\").unwrap(),\n                            state: TradeState::Accepted,\n                            additionnal_info: AdditionnalTradeInfo {\n                                owner_comment: Some(Comment {\n                                    comment: \"Q\".to_string(),\n                                    time: mock_env().block.time,\n                                }),\n                                trader_comment: Some(Comment {\n                                    comment: \"You're very kind madam\".to_string(),\n                                    time: mock_env().block.time,\n                                }),\n                                time: mock_env().block.time,\n                                ..Default::default()\n                            },\n                            ..Default::default()\n                        }),\n                    }\n                }]\n            );\n        }\n\n        #[test]\n        fn accept_trade_with_multiple_counter() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n\n            confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap();\n            confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 1).unwrap();\n\n            let res = accept_trade_helper(deps.as_mut(), \"creator\", 0, 0).unwrap();\n\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"accept_counter_trade\"),\n                    Attribute::new(\"trade_id\", \"0\"),\n                    Attribute::new(\"counter_id\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                    Attribute::new(\"counter_trader\", \"counterer\"),\n                ]\n            );\n\n            let trade_info = load_trade(\u0026deps.storage, 0).unwrap();\n            assert_eq!(trade_info.state, TradeState::Accepted {});\n\n            let counter_trade_info = load_counter_trade(\u0026deps.storage, 0, 0).unwrap();\n            assert_eq!(counter_trade_info.state, TradeState::Accepted {});\n\n            let counter_trade_info = load_counter_trade(\u0026deps.storage, 0, 1).unwrap();\n            assert_eq!(counter_trade_info.state, TradeState::Refused {});\n\n            // Check that the only Accepted and Published counters are the accepted counter\n            let res = query_all_counter_trades(\n                deps.as_ref(),\n                None,\n                None,\n                Some(QueryFilters {\n                    states: Some(vec![\n                        TradeState::Accepted.to_string(),\n                        TradeState::Published.to_string(),\n                    ]),\n                    ..Default::default()\n                }),\n            )\n            .unwrap();\n\n            assert_eq!(\n                res.counter_trades,\n                vec![{\n                    TradeResponse {\n                        counter_id: Some(0),\n                        trade_id: 0,\n                        trade_info: Some(TradeInfo {\n                            owner: deps.api.addr_validate(\"counterer\").unwrap(),\n                            state: TradeState::Accepted,\n\n                            additionnal_info: AdditionnalTradeInfo {\n                                owner_comment: Some(Comment {\n                                    comment: \"Q\".to_string(),\n                                    time: mock_env().block.time,\n                                }),\n                                trader_comment: Some(Comment {\n                                    comment: \"You're very kind madam\".to_string(),\n                                    time: mock_env().block.time,\n                                }),\n                                time: mock_env().block.time,\n                                ..Default::default()\n                            },\n                            ..Default::default()\n                        }),\n                    }\n                }]\n            );\n            // Check that the other counters is cancelled\n            let res = query_all_counter_trades(\n                deps.as_ref(),\n                None,\n                None,\n                Some(QueryFilters {\n                    states: Some(vec![TradeState::Refused.to_string()]),\n                    ..Default::default()\n                }),\n            )\n            .unwrap();\n\n            assert_eq!(\n                res.counter_trades,\n                vec![\n                    {\n                        TradeResponse {\n                            counter_id: Some(2),\n                            trade_id: 0,\n                            trade_info: Some(TradeInfo {\n                                owner: deps.api.addr_validate(\"counterer\").unwrap(),\n                                state: TradeState::Refused,\n                                additionnal_info: AdditionnalTradeInfo {\n                                    owner_comment: Some(Comment {\n                                        comment: \"Q\".to_string(),\n                                        time: mock_env().block.time,\n                                    }),\n                                    time: mock_env().block.time,\n                                    ..Default::default()\n                                },\n                                ..Default::default()\n                            }),\n                        }\n                    },\n                    {\n                        TradeResponse {\n                            counter_id: Some(1),\n                            trade_id: 0,\n                            trade_info: Some(TradeInfo {\n                                owner: deps.api.addr_validate(\"counterer\").unwrap(),\n                                state: TradeState::Refused,\n                                additionnal_info: AdditionnalTradeInfo {\n                                    owner_comment: Some(Comment {\n                                        comment: \"Q\".to_string(),\n                                        time: mock_env().block.time,\n                                    }),\n                                    time: mock_env().block.time,\n                                    ..Default::default()\n                                },\n                                ..Default::default()\n                            }),\n                        }\n                    },\n                ]\n            );\n\n            // Check that both Accepted and Published counter queries exist, paginate to skip last counter trade\n            let res = query_all_counter_trades(\n                deps.as_ref(),\n                Some(CounterTradeInfo {\n                    trade_id: 0,\n                    counter_id: 1,\n                }),\n                None,\n                Some(QueryFilters {\n                    states: Some(vec![\n                        TradeState::Accepted.to_string(),\n                        TradeState::Published.to_string(),\n                    ]),\n                    ..Default::default()\n                }),\n            )\n            .unwrap();\n\n            assert_eq!(\n                res.counter_trades,\n                vec![{\n                    TradeResponse {\n                        counter_id: Some(0),\n                        trade_id: 0,\n                        trade_info: Some(TradeInfo {\n                            owner: deps.api.addr_validate(\"counterer\").unwrap(),\n                            state: TradeState::Accepted,\n                            additionnal_info: AdditionnalTradeInfo {\n                                owner_comment: Some(Comment {\n                                    comment: \"Q\".to_string(),\n                                    time: mock_env().block.time,\n                                }),\n                                trader_comment: Some(Comment {\n                                    comment: \"You're very kind madam\".to_string(),\n                                    time: mock_env().block.time,\n                                }),\n                                time: mock_env().block.time,\n                                ..Default::default()\n                            },\n                            ..Default::default()\n                        }),\n                    }\n                }]\n            );\n        }\n\n        #[test]\n        fn cancel_trade() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n\n            let err = cancel_trade_helper(deps.as_mut(), \"creator\", 1).unwrap_err();\n            assert_eq!(err, ContractError::NotFoundInTradeInfo {});\n\n            let err = cancel_trade_helper(deps.as_mut(), \"bad_person\", 0).unwrap_err();\n            assert_eq!(err, ContractError::TraderNotCreator {});\n\n            confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap();\n\n            let res = cancel_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"cancel_trade\"),\n                    Attribute::new(\"trade_id\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                ]\n            );\n\n            // Query all counter trades make sure counter trade is cancelled with the trade\n            let res = query_all_counter_trades(deps.as_ref(), None, None, None).unwrap();\n\n            assert_eq!(\n                res.counter_trades,\n                vec![{\n                    TradeResponse {\n                        counter_id: Some(0),\n                        trade_id: 0,\n                        trade_info: Some(TradeInfo {\n                            owner: deps.api.addr_validate(\"counterer\").unwrap(),\n                            state: TradeState::Cancelled,\n                            additionnal_info: AdditionnalTradeInfo {\n                                owner_comment: Some(Comment {\n                                    comment: \"Q\".to_string(),\n                                    time: mock_env().block.time,\n                                }),\n                                time: mock_env().block.time,\n                                ..Default::default()\n                            },\n                            ..Default::default()\n                        }),\n                    }\n                }]\n            );\n        }\n\n        #[test]\n        fn queries_with_multiple_trades_and_counter_trades() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 1).unwrap();\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 2).unwrap();\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 3).unwrap();\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 4).unwrap();\n\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer2\", 0).unwrap();\n\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 1).unwrap();\n\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 2).unwrap();\n\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 3).unwrap();\n\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 4).unwrap();\n\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer2\", 4).unwrap();\n\n            // Query all before second one, should return the first one\n            let res = query_all_counter_trades(\n                deps.as_ref(),\n                Some(CounterTradeInfo {\n                    trade_id: 0,\n                    counter_id: 1,\n                }),\n                None,\n                Some(QueryFilters {\n                    owner: Some(\"counterer2\".to_string()),\n                    ..Default::default()\n                }),\n            )\n            .unwrap();\n\n            assert_eq!(\n                res.counter_trades,\n                vec![TradeResponse {\n                    trade_id: 0,\n                    counter_id: Some(0),\n                    trade_info: Some(TradeInfo {\n                        owner: deps.api.addr_validate(\"counterer2\").unwrap(),\n                        state: TradeState::Created,\n                        additionnal_info: AdditionnalTradeInfo {\n                            owner_comment: Some(Comment {\n                                comment: \"Q\".to_string(),\n                                time: mock_env().block.time\n                            }),\n                            time: mock_env().block.time,\n                            ..Default::default()\n                        },\n                        ..Default::default()\n                    })\n                }]\n            );\n\n            // Query all before first one, should return empty array\n            let res = query_all_counter_trades(\n                deps.as_ref(),\n                Some(CounterTradeInfo {\n                    trade_id: 0,\n                    counter_id: 0,\n                }),\n                None,\n                None,\n            )\n            .unwrap();\n\n            assert_eq!(res.counter_trades, vec![]);\n\n            // Query for non existing user should return empty []\n            let res = query_all_counter_trades(\n                deps.as_ref(),\n                None,\n                None,\n                Some(QueryFilters {\n                    owner: Some(\"counterer5\".to_string()),\n                    ..Default::default()\n                }),\n            )\n            .unwrap();\n\n            assert_eq!(res.counter_trades, vec![]);\n\n            // Query by trade_id should return counter queries for trade id 4\n            let res = query_counter_trades(deps.as_ref(), 4, None, None, None).unwrap();\n\n            assert_eq!(\n                res.counter_trades,\n                vec![\n                    TradeResponse {\n                        trade_id: 4,\n                        counter_id: Some(1),\n                        trade_info: Some(TradeInfo {\n                            owner: deps.api.addr_validate(\"counterer2\").unwrap(),\n                            state: TradeState::Created,\n                            additionnal_info: AdditionnalTradeInfo {\n                                owner_comment: Some(Comment {\n                                    comment: \"Q\".to_string(),\n                                    time: mock_env().block.time\n                                }),\n                                time: mock_env().block.time,\n                                ..Default::default()\n                            },\n                            ..Default::default()\n                        })\n                    },\n                    TradeResponse {\n                        trade_id: 4,\n                        counter_id: Some(0),\n                        trade_info: Some(TradeInfo {\n                            owner: deps.api.addr_validate(\"counterer\").unwrap(),\n                            additionnal_info: AdditionnalTradeInfo {\n                                owner_comment: Some(Comment {\n                                    comment: \"Q\".to_string(),\n                                    time: mock_env().block.time\n                                }),\n                                time: mock_env().block.time,\n                                ..Default::default()\n                            },\n                            ..Default::default()\n                        })\n                    }\n                ]\n            );\n        }\n\n        #[test]\n        fn withdraw_accepted_assets() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n            set_fee_contract_helper(deps.as_mut());\n            create_trade_helper(deps.as_mut(), \"creator\");\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft\".to_string(),\n                    token_id: \"58\".to_string(),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw1155Coin(Cw1155Coin {\n                    address: \"cw1155\".to_string(),\n                    token_id: \"58\".to_string(),\n                    value: Uint128::new(100u128),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    address: \"token\".to_string(),\n                    amount: Uint128::new(100u128),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Coin(coin(9, \"other_token\")),\n                \u0026coins(9, \"other_token\"),\n            )\n            .unwrap();\n\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"other_counterer\", 0).unwrap();\n\n            add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"other_counterer\",\n                0,\n                0,\n                AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"other_counter-nft\".to_string(),\n                    token_id: \"58\".to_string(),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"other_counterer\",\n                0,\n                0,\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    address: \"other_counter-token\".to_string(),\n                    amount: Uint128::new(100u128),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"other_counterer\",\n                0,\n                0,\n                AssetInfo::Coin(coin(5, \"lunas\")),\n                \u0026coins(5, \"lunas\"),\n            )\n            .unwrap();\n\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n\n            add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                1,\n                AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"counter-nft\".to_string(),\n                    token_id: \"58\".to_string(),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                1,\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    address: \"counter-token\".to_string(),\n                    amount: Uint128::new(100u128),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                1,\n                AssetInfo::Coin(coin(2, \"token\")),\n                \u0026coins(2, \"token\"),\n            )\n            .unwrap();\n\n            confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 1).unwrap();\n\n            // Little test to start with (can't withdraw if the trade is not accepted)\n            let err = withdraw_helper(deps.as_mut(), \"anyone\", \"fee_contract\", 0).unwrap_err();\n            assert_eq!(err, ContractError::TradeNotAccepted {});\n\n            accept_trade_helper(deps.as_mut(), \"creator\", 0, 1).unwrap();\n\n            // Withdraw tests\n            let err = withdraw_helper(deps.as_mut(), \"bad_person\", \"fee_contract\", 0).unwrap_err();\n            assert_eq!(err, ContractError::NotWithdrawableByYou {});\n\n            let err = withdraw_helper(deps.as_mut(), \"creator\", \"bad_person\", 0).unwrap_err();\n            assert_eq!(err, ContractError::Unauthorized {});\n\n            let res = withdraw_helper(deps.as_mut(), \"creator\", \"fee_contract\", 0).unwrap();\n            assert_eq!(\n                res.messages,\n                vec![\n                    SubMsg::new(\n                        into_cosmos_msg(\n                            Cw721ExecuteMsg::TransferNft {\n                                recipient: \"creator\".to_string(),\n                                token_id: \"58\".to_string()\n                            },\n                            \"counter-nft\"\n                        )\n                        .unwrap()\n                    ),\n                    SubMsg::new(\n                        into_cosmos_msg(\n                            Cw20ExecuteMsg::Transfer {\n                                recipient: \"creator\".to_string(),\n                                amount: Uint128::from(100u64)\n                            },\n                            \"counter-token\"\n                        )\n                        .unwrap()\n                    ),\n                    SubMsg::new(BankMsg::Send {\n                        to_address: \"creator\".to_string(),\n                        amount: coins(2, \"token\"),\n                    })\n                ]\n            );\n\n            let err = withdraw_helper(deps.as_mut(), \"creator\", \"fee_contract\", 0).unwrap_err();\n            assert_eq!(err, ContractError::TradeAlreadyWithdrawn {});\n\n            let res = withdraw_helper(deps.as_mut(), \"counterer\", \"fee_contract\", 0).unwrap();\n            assert_eq!(\n                res.messages,\n                vec![\n                    SubMsg::new(\n                        into_cosmos_msg(\n                            Cw721ExecuteMsg::TransferNft {\n                                recipient: \"counterer\".to_string(),\n                                token_id: \"58\".to_string()\n                            },\n                            \"nft\"\n                        )\n                        .unwrap()\n                    ),\n                    SubMsg::new(\n                        into_cosmos_msg(\n                            Cw1155ExecuteMsg::SendFrom {\n                                to: \"counterer\".to_string(),\n                                from: mock_env().contract.address.to_string(),\n                                token_id: \"58\".to_string(),\n                                value: Uint128::from(100u128),\n                                msg: None\n                            },\n                            \"cw1155\"\n                        )\n                        .unwrap()\n                    ),\n                    SubMsg::new(\n                        into_cosmos_msg(\n                            Cw20ExecuteMsg::Transfer {\n                                recipient: \"counterer\".to_string(),\n                                amount: Uint128::from(100u64)\n                            },\n                            \"token\"\n                        )\n                        .unwrap()\n                    ),\n                    SubMsg::new(BankMsg::Send {\n                        to_address: \"counterer\".to_string(),\n                        amount: coins(9, \"other_token\"),\n                    }),\n                ]\n            );\n\n            let err = withdraw_helper(deps.as_mut(), \"counterer\", \"fee_contract\", 0).unwrap_err();\n            assert_eq!(err, ContractError::TradeAlreadyWithdrawn {});\n\n            let res =\n                withdraw_aborted_counter_helper(deps.as_mut(), \"other_counterer\", 0, 0).unwrap();\n            assert_eq!(\n                res.messages,\n                vec![\n                    SubMsg::new(\n                        into_cosmos_msg(\n                            Cw721ExecuteMsg::TransferNft {\n                                recipient: \"other_counterer\".to_string(),\n                                token_id: \"58\".to_string()\n                            },\n                            \"other_counter-nft\"\n                        )\n                        .unwrap()\n                    ),\n                    SubMsg::new(\n                        into_cosmos_msg(\n                            Cw20ExecuteMsg::Transfer {\n                                recipient: \"other_counterer\".to_string(),\n                                amount: Uint128::from(100u64)\n                            },\n                            \"other_counter-token\"\n                        )\n                        .unwrap()\n                    ),\n                    SubMsg::new(BankMsg::Send {\n                        to_address: \"other_counterer\".to_string(),\n                        amount: coins(5, \"lunas\"),\n                    }),\n                ]\n            );\n\n            let err = withdraw_aborted_counter_helper(deps.as_mut(), \"other_counterer\", 0, 0)\n                .unwrap_err();\n            assert_eq!(err, ContractError::TradeAlreadyWithdrawn {});\n        }\n\n        #[test]\n        fn withdraw_cancelled_trade() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n            create_trade_helper(deps.as_mut(), \"creator\");\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft\".to_string(),\n                    token_id: \"58\".to_string(),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    address: \"token\".to_string(),\n                    amount: Uint128::new(100u128),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Coin(coin(5, \"lunas\")),\n                \u0026coins(5, \"lunas\"),\n            )\n            .unwrap();\n\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n\n            add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                0,\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    address: \"other_counter-token\".to_string(),\n                    amount: Uint128::new(100u128),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            cancel_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            let res = withdraw_cancelled_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n\n            assert_eq!(\n                res.messages,\n                vec![\n                    SubMsg::new(\n                        into_cosmos_msg(\n                            Cw721ExecuteMsg::TransferNft {\n                                recipient: \"creator\".to_string(),\n                                token_id: \"58\".to_string()\n                            },\n                            \"nft\"\n                        )\n                        .unwrap()\n                    ),\n                    SubMsg::new(\n                        into_cosmos_msg(\n                            Cw20ExecuteMsg::Transfer {\n                                recipient: \"creator\".to_string(),\n                                amount: Uint128::from(100u64)\n                            },\n                            \"token\"\n                        )\n                        .unwrap()\n                    ),\n                    SubMsg::new(BankMsg::Send {\n                        to_address: \"creator\".to_string(),\n                        amount: coins(5, \"lunas\"),\n                    }),\n                ]\n            );\n\n            let err = withdraw_cancelled_trade_helper(deps.as_mut(), \"creator\", 0).unwrap_err();\n            assert_eq!(err, ContractError::TradeAlreadyWithdrawn {});\n\n            let res = withdraw_aborted_counter_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap();\n            assert_eq!(\n                res.messages,\n                vec![SubMsg::new(\n                    into_cosmos_msg(\n                        Cw20ExecuteMsg::Transfer {\n                            recipient: \"counterer\".to_string(),\n                            amount: Uint128::from(100u64)\n                        },\n                        \"other_counter-token\"\n                    )\n                    .unwrap()\n                ),]\n            );\n\n            let err =\n                withdraw_aborted_counter_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap_err();\n            assert_eq!(err, ContractError::TradeAlreadyWithdrawn {});\n        }\n\n        #[test]\n        fn private() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n            create_private_trade_helper(deps.as_mut(), vec![\"whitelist\".to_string()]);\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft\".to_string(),\n                    token_id: \"58\".to_string(),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    address: \"token\".to_string(),\n                    amount: Uint128::new(100u128),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Coin(coin(5, \"lunas\")),\n                \u0026coins(5, \"lunas\"),\n            )\n            .unwrap();\n\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n\n            let err = suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap_err();\n            assert_eq!(err, ContractError::AddressNotWhitelisted {});\n\n            suggest_counter_trade_helper(deps.as_mut(), \"whitelist\", 0).unwrap();\n\n            let err = remove_whitelisted_users(deps.as_mut(), 0, vec![\"whitelist\".to_string()])\n                .unwrap_err();\n            assert_eq!(\n                err,\n                ContractError::WrongTradeState {\n                    state: TradeState::Countered\n                }\n            );\n\n            let err =\n                add_whitelisted_users(deps.as_mut(), 0, vec![\"whitelist\".to_string()]).unwrap_err();\n            assert_eq!(\n                err,\n                ContractError::WrongTradeState {\n                    state: TradeState::Countered\n                }\n            );\n\n            create_private_trade_helper(deps.as_mut(), vec![\"whitelist\".to_string()]);\n\n            remove_whitelisted_users(deps.as_mut(), 1, vec![\"whitelist\".to_string()]).unwrap();\n            let info = TRADE_INFO.load(\u0026deps.storage, 1_u64).unwrap();\n            let hash_set = HashSet::new();\n            assert_eq!(info.whitelisted_users, hash_set);\n\n            add_whitelisted_users(\n                deps.as_mut(),\n                1,\n                vec![\"whitelist-1\".to_string(), \"whitelist\".to_string()],\n            )\n            .unwrap();\n            add_whitelisted_users(\n                deps.as_mut(),\n                1,\n                vec![\"whitelist-2\".to_string(), \"whitelist\".to_string()],\n            )\n            .unwrap();\n            let info = TRADE_INFO.load(\u0026deps.storage, 1_u64).unwrap();\n\n            let whitelisted_users = vec![\n                \"whitelist\".to_string(),\n                \"whitelist-1\".to_string(),\n                \"whitelist-2\".to_string(),\n            ];\n            let hash_set =\n                HashSet::from_iter(validate_addresses(\u0026deps.api, \u0026whitelisted_users).unwrap());\n            assert_eq!(info.whitelisted_users, hash_set);\n        }\n    }\n\n    fn suggest_counter_trade_helper(\n        deps: DepsMut,\n        counterer: \u0026str,\n        trade_id: u64,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(counterer, \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::SuggestCounterTrade {\n                trade_id,\n                comment: Some(\"Q\".to_string()),\n            },\n        )\n    }\n\n    fn add_asset_to_counter_trade_helper(\n        deps: DepsMut,\n        counterer: \u0026str,\n        trade_id: u64,\n        counter_id: u64,\n        asset: AssetInfo,\n        coins_to_send: \u0026[Coin],\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(counterer, coins_to_send);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::AddAsset {\n                to_last_trade: None,\n                to_last_counter: None,\n                trade_id: Some(trade_id),\n                counter_id: Some(counter_id),\n                asset,\n            },\n        )\n    }\n\n    fn confirm_counter_trade_helper(\n        deps: DepsMut,\n        sender: \u0026str,\n        trade_id: u64,\n        counter_id: u64,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(sender, \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::ConfirmCounterTrade {\n                trade_id,\n                counter_id: Some(counter_id),\n            },\n        )\n    }\n\n    fn review_counter_trade_helper(\n        deps: DepsMut,\n        sender: \u0026str,\n        trade_id: u64,\n        counter_id: u64,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(sender, \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::ReviewCounterTrade {\n                trade_id,\n                counter_id,\n                comment: Some(\"Shit NFT my girl\".to_string()),\n            },\n        )\n    }\n\n    fn accept_trade_helper(\n        deps: DepsMut,\n        sender: \u0026str,\n        trade_id: u64,\n        counter_id: u64,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(sender, \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::AcceptTrade {\n                trade_id,\n                counter_id,\n                comment: Some(\"You're very kind madam\".to_string()),\n            },\n        )\n    }\n\n    fn cancel_trade_helper(\n        deps: DepsMut,\n        sender: \u0026str,\n        trade_id: u64,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(sender, \u0026[]);\n        let env = mock_env();\n\n        execute(deps, env, info, ExecuteMsg::CancelTrade { trade_id })\n    }\n\n    fn cancel_counter_trade_helper(\n        deps: DepsMut,\n        sender: \u0026str,\n        trade_id: u64,\n        counter_id: u64,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(sender, \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::CancelCounterTrade {\n                trade_id,\n                counter_id,\n            },\n        )\n    }\n\n    fn refuse_counter_trade_helper(\n        deps: DepsMut,\n        trader: \u0026str,\n        trade_id: u64,\n        counter_id: u64,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(trader, \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::RefuseCounterTrade {\n                trade_id,\n                counter_id,\n            },\n        )\n    }\n\n    pub mod counter_trade_tests {\n        use super::*;\n        use crate::query::{AllTradesResponse, TradeResponse};\n        use cosmwasm_std::{coin, from_binary, Api, SubMsg};\n        use p2p_trading_export::msg::QueryFilters;\n        use p2p_trading_export::state::{AdditionnalTradeInfo, Comment, CounterTradeInfo};\n\n        #[test]\n        fn create_counter_trade() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n\n            let err = suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap_err();\n\n            assert_eq!(err, ContractError::NotCounterable {});\n\n            let err = suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 1).unwrap_err();\n\n            assert_eq!(err, ContractError::NotFoundInTradeInfo {});\n\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n\n            let res = suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"create_counter_trade\"),\n                    Attribute::new(\"trade_id\", \"0\"),\n                    Attribute::new(\"counter_id\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                    Attribute::new(\"counter_trader\", \"counterer\"),\n                ]\n            );\n            // We need to make sure it is not couterable in case the counter is accepted\n        }\n        #[test]\n        fn create_counter_trade_and_add_funds() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n\n            let res = add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                0,\n                AssetInfo::Coin(coin(2, \"token\")),\n                \u0026coins(2, \"token\"),\n            )\n            .unwrap();\n\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"add_asset\"),\n                    Attribute::new(\"asset_type\", \"fund\"),\n                    Attribute::new(\"denom\", \"token\"),\n                    Attribute::new(\"amount\", \"2\"),\n                    Attribute::new(\"trade_id\", \"0\"),\n                    Attribute::new(\"counter_id\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                    Attribute::new(\"counter_trader\", \"counterer\"),\n                ]\n            );\n\n            let counter_trade_info = load_counter_trade(\u0026deps.storage, 0, 0).unwrap();\n            assert_eq!(counter_trade_info.state, TradeState::Created);\n            assert_eq!(\n                counter_trade_info.associated_assets,\n                vec![AssetInfo::Coin(coin(2, \"token\"))]\n            );\n        }\n\n        #[test]\n        fn create_counter_trade_and_add_cw20_tokens() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n\n            let res = add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                0,\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    address: \"token\".to_string(),\n                    amount: Uint128::new(100u128),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"add_asset\"),\n                    Attribute::new(\"asset_type\", \"token\"),\n                    Attribute::new(\"token\", \"token\"),\n                    Attribute::new(\"amount\", \"100\"),\n                    Attribute::new(\"trade_id\", \"0\"),\n                    Attribute::new(\"counter_id\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                    Attribute::new(\"counter_trader\", \"counterer\"),\n                ]\n            );\n\n            let err = add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                1,\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    address: \"token\".to_string(),\n                    amount: Uint128::new(100u128),\n                }),\n                \u0026[],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::NotFoundInCounterTradeInfo {});\n\n            // Verifying the state has been changed\n            let trade_info = load_trade(\u0026deps.storage, 0).unwrap();\n            assert_eq!(trade_info.state, TradeState::Countered);\n            assert_eq!(trade_info.associated_assets, vec![]);\n\n            let counter_trade_info = load_counter_trade(\u0026deps.storage, 0, 0).unwrap();\n            assert_eq!(counter_trade_info.state, TradeState::Created);\n            assert_eq!(\n                counter_trade_info.associated_assets,\n                vec![AssetInfo::Cw20Coin(Cw20Coin {\n                    address: \"token\".to_string(),\n                    amount: Uint128::from(100u64)\n                }),]\n            );\n\n            // This triggers an error, the creator is not the same as the sender\n            let err = add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"bad_person\",\n                0,\n                0,\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    address: \"token\".to_string(),\n                    amount: Uint128::new(100u128),\n                }),\n                \u0026[],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::CounterTraderNotCreator {});\n        }\n\n        #[test]\n        fn create_trade_and_add_cw721_tokens() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n\n            let res = add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                0,\n                AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft\".to_string(),\n                    token_id: \"58\".to_string(),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"add_asset\"),\n                    Attribute::new(\"asset_type\", \"NFT\"),\n                    Attribute::new(\"nft\", \"nft\"),\n                    Attribute::new(\"token_id\", \"58\"),\n                    Attribute::new(\"trade_id\", \"0\"),\n                    Attribute::new(\"counter_id\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                    Attribute::new(\"counter_trader\", \"counterer\"),\n                ]\n            );\n\n            // Verifying the state has been changed\n            let trade_info = load_trade(\u0026deps.storage, 0).unwrap();\n            assert_eq!(trade_info.state, TradeState::Countered);\n            assert_eq!(trade_info.associated_assets, vec![]);\n\n            let counter_trade_info = load_counter_trade(\u0026deps.storage, 0, 0).unwrap();\n            assert_eq!(counter_trade_info.state, TradeState::Created);\n            assert_eq!(\n                counter_trade_info.associated_assets,\n                vec![AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft\".to_string(),\n                    token_id: \"58\".to_string()\n                }),]\n            );\n\n            // This triggers an error, the counter-trade creator is not the same as the sender\n            let err = add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"bad_person\",\n                0,\n                0,\n                AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"token\".to_string(),\n                    token_id: \"58\".to_string(),\n                }),\n                \u0026[],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::CounterTraderNotCreator {});\n        }\n\n        #[test]\n        fn create_counter_trade_automatic_trade_id() {\n            let mut deps = mock_dependencies();\n            let info = mock_info(\"creator\", \u0026[]);\n            let env = mock_env();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 1).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"creator\", 1).unwrap();\n\n            suggest_counter_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n\n            execute(\n                deps.as_mut(),\n                env.clone(),\n                info,\n                ExecuteMsg::AddAsset {\n                    trade_id: Some(0),\n                    counter_id: None,\n                    to_last_trade: None,\n                    to_last_counter: Some(true),\n                    asset: AssetInfo::Cw20Coin(Cw20Coin {\n                        address: \"cw20\".to_string(),\n                        amount: Uint128::from(100u64),\n                    }),\n                },\n            )\n            .unwrap();\n\n            let info = mock_info(\"creator\", \u0026coins(97u128, \"uluna\"));\n            execute(\n                deps.as_mut(),\n                env,\n                info,\n                ExecuteMsg::AddAsset {\n                    trade_id: Some(0),\n                    counter_id: None,\n                    to_last_trade: None,\n                    to_last_counter: Some(true),\n                    asset: AssetInfo::Coin(coin(97u128, \"uluna\")),\n                },\n            )\n            .unwrap();\n\n            let info = mock_info(\"creator\", \u0026[]);\n            let env = mock_env();\n\n            execute(\n                deps.as_mut(),\n                env,\n                info,\n                ExecuteMsg::ConfirmCounterTrade {\n                    trade_id: 0,\n                    counter_id: None,\n                },\n            )\n            .unwrap();\n\n            let trade_info = COUNTER_TRADE_INFO\n                .load(\u0026deps.storage, (0u64, 0u64))\n                .unwrap();\n            assert_eq!(\n                trade_info.associated_assets,\n                vec![\n                    AssetInfo::Cw20Coin(Cw20Coin {\n                        address: \"cw20\".to_string(),\n                        amount: Uint128::from(100u128)\n                    }),\n                    AssetInfo::Coin(coin(97, \"uluna\"))\n                ]\n            );\n            assert_eq!(trade_info.state, TradeState::Published);\n        }\n\n        #[test]\n        fn create_counter_trade_add_remove_tokens() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n\n            add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                0,\n                AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft\".to_string(),\n                    token_id: \"58\".to_string(),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                0,\n                AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft-2\".to_string(),\n                    token_id: \"58\".to_string(),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                0,\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    address: \"token\".to_string(),\n                    amount: Uint128::new(100u128),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                0,\n                AssetInfo::Coin(coin(100, \"luna\")),\n                \u0026coins(100, \"luna\"),\n            )\n            .unwrap();\n\n            let res = remove_assets_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                Some(0),\n                vec![\n                    (\n                        0,\n                        AssetInfo::Cw721Coin(Cw721Coin {\n                            address: \"nft\".to_string(),\n                            token_id: \"58\".to_string(),\n                        }),\n                    ),\n                    (\n                        2,\n                        AssetInfo::Cw20Coin(Cw20Coin {\n                            address: \"token\".to_string(),\n                            amount: Uint128::from(58u64),\n                        }),\n                    ),\n                    (3, AssetInfo::Coin(coin(58, \"luna\"))),\n                ],\n            )\n            .unwrap();\n\n            assert_eq!(res.attributes.len(), 14);\n            assert_eq!(\n                res.messages,\n                vec![\n                    SubMsg::new(\n                        into_cosmos_msg(\n                            Cw721ExecuteMsg::TransferNft {\n                                recipient: \"counterer\".to_string(),\n                                token_id: \"58\".to_string()\n                            },\n                            \"nft\"\n                        )\n                        .unwrap()\n                    ),\n                    SubMsg::new(\n                        into_cosmos_msg(\n                            Cw20ExecuteMsg::Transfer {\n                                recipient: \"counterer\".to_string(),\n                                amount: Uint128::from(58u64)\n                            },\n                            \"token\"\n                        )\n                        .unwrap()\n                    ),\n                    SubMsg::new(BankMsg::Send {\n                        to_address: \"counterer\".to_string(),\n                        amount: coins(58, \"luna\"),\n                    })\n                ]\n            );\n\n            let new_trade_info = load_counter_trade(\u0026deps.storage, 0, 0).unwrap();\n            assert_eq!(\n                new_trade_info.associated_assets,\n                vec![\n                    AssetInfo::Cw721Coin(Cw721Coin {\n                        token_id: \"58\".to_string(),\n                        address: \"nft-2\".to_string()\n                    }),\n                    AssetInfo::Cw20Coin(Cw20Coin {\n                        amount: Uint128::from(42u64),\n                        address: \"token\".to_string()\n                    }),\n                    AssetInfo::Coin(coin(42, \"luna\"))\n                ],\n            );\n\n            remove_assets_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                Some(0),\n                vec![\n                    (\n                        1,\n                        AssetInfo::Cw20Coin(Cw20Coin {\n                            address: \"token\".to_string(),\n                            amount: Uint128::from(42u64),\n                        }),\n                    ),\n                    (2, AssetInfo::Coin(coin(42, \"luna\"))),\n                ],\n            )\n            .unwrap();\n\n            let new_trade_info = load_counter_trade(\u0026deps.storage, 0, 0).unwrap();\n            assert_eq!(\n                new_trade_info.associated_assets,\n                vec![AssetInfo::Cw721Coin(Cw721Coin {\n                    token_id: \"58\".to_string(),\n                    address: \"nft-2\".to_string()\n                }),],\n            );\n\n            // This triggers an error, the counterer is not the same as the sender\n            let err = remove_assets_helper(\n                deps.as_mut(),\n                \"bad_person\",\n                0,\n                Some(0),\n                vec![(\n                    0,\n                    AssetInfo::Cw721Coin(Cw721Coin {\n                        address: \"nft-2\".to_string(),\n                        token_id: \"58\".to_string(),\n                    }),\n                )],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::CounterTraderNotCreator {});\n\n            // This triggers an error, no matching funds were found\n            let err = remove_assets_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                Some(0),\n                vec![(\n                    1,\n                    AssetInfo::Cw721Coin(Cw721Coin {\n                        address: \"nft-2\".to_string(),\n                        token_id: \"58\".to_string(),\n                    }),\n                )],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::AssetNotFound { position: 1 });\n\n            // This triggers an error, no matching funds were found\n            let err = remove_assets_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                Some(0),\n                vec![(\n                    0,\n                    AssetInfo::Cw721Coin(Cw721Coin {\n                        address: \"nft-1\".to_string(),\n                        token_id: \"58\".to_string(),\n                    }),\n                )],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::AssetNotFound { position: 0 });\n\n            // This triggers an error, no matching funds were found\n            let err = remove_assets_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                Some(0),\n                vec![(\n                    0,\n                    AssetInfo::Cw721Coin(Cw721Coin {\n                        address: \"nft-2\".to_string(),\n                        token_id: \"42\".to_string(),\n                    }),\n                )],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::AssetNotFound { position: 0 });\n        }\n\n        #[test]\n        fn create_trade_add_remove_tokens_errors() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n\n            add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                0,\n                AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft\".to_string(),\n                    token_id: \"58\".to_string(),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                0,\n                AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft-2\".to_string(),\n                    token_id: \"58\".to_string(),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                0,\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    address: \"token\".to_string(),\n                    amount: Uint128::new(100u128),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                0,\n                AssetInfo::Coin(coin(100, \"luna\")),\n                \u0026coins(100, \"luna\"),\n            )\n            .unwrap();\n\n            let err = remove_assets_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                Some(0),\n                vec![(\n                    2,\n                    AssetInfo::Cw20Coin(Cw20Coin {\n                        address: \"token\".to_string(),\n                        amount: Uint128::from(101u64),\n                    }),\n                )],\n            )\n            .unwrap_err();\n\n            assert_eq!(\n                err,\n                ContractError::TooMuchWithdrawn {\n                    address: \"token\".to_string(),\n                    wanted: 101,\n                    available: 100\n                }\n            );\n\n            let err = remove_assets_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                Some(0),\n                vec![(\n                    0,\n                    AssetInfo::Cw20Coin(Cw20Coin {\n                        address: \"token\".to_string(),\n                        amount: Uint128::from(101u64),\n                    }),\n                )],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::AssetNotFound { position: 0 });\n\n            let err = remove_assets_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                Some(0),\n                vec![(\n                    2,\n                    AssetInfo::Cw20Coin(Cw20Coin {\n                        address: \"wrong-token\".to_string(),\n                        amount: Uint128::from(101u64),\n                    }),\n                )],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::AssetNotFound { position: 2 });\n\n            confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap();\n\n            let err = remove_assets_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                Some(0),\n                vec![(\n                    2,\n                    AssetInfo::Cw20Coin(Cw20Coin {\n                        address: \"token\".to_string(),\n                        amount: Uint128::from(58u64),\n                    }),\n                )],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::CounterTradeAlreadyPublished {});\n        }\n\n        #[test]\n        fn confirm_counter_trade() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n\n            //Wrong trade id\n            let err = confirm_counter_trade_helper(deps.as_mut(), \"creator\", 1, 0).unwrap_err();\n            assert_eq!(err, ContractError::NotFoundInCounterTradeInfo {});\n\n            //Wrong counter id\n            let err = confirm_counter_trade_helper(deps.as_mut(), \"creator\", 0, 1).unwrap_err();\n            assert_eq!(err, ContractError::NotFoundInCounterTradeInfo {});\n\n            //Wrong trader\n            let err = confirm_counter_trade_helper(deps.as_mut(), \"bad_person\", 0, 0).unwrap_err();\n            assert_eq!(err, ContractError::CounterTraderNotCreator {});\n\n            // This time, it has to work fine\n            let res = confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap();\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"confirm_counter_trade\"),\n                    Attribute::new(\"trade\", \"0\"),\n                    Attribute::new(\"counter\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                    Attribute::new(\"counter_trader\", \"counterer\"),\n                ]\n            );\n\n            //Already confirmed\n            let err = confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap_err();\n            assert_eq!(\n                err,\n                ContractError::CantChangeCounterTradeState {\n                    from: TradeState::Published,\n                    to: TradeState::Published\n                }\n            );\n        }\n\n        #[test]\n        fn review_counter_trade() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n\n            //Wrong trade id\n            let err = review_counter_trade_helper(deps.as_mut(), \"creator\", 1, 0).unwrap_err();\n            assert_eq!(err, ContractError::NotFoundInTradeInfo {});\n\n            //Wrong counter id\n            let err = review_counter_trade_helper(deps.as_mut(), \"creator\", 0, 1).unwrap_err();\n            assert_eq!(err, ContractError::NotFoundInCounterTradeInfo {});\n\n            //Wrong trader\n            let err = review_counter_trade_helper(deps.as_mut(), \"bad_person\", 0, 0).unwrap_err();\n            assert_eq!(err, ContractError::TraderNotCreator {});\n\n            let err = review_counter_trade_helper(deps.as_mut(), \"creator\", 0, 0).unwrap_err();\n            assert_eq!(\n                err,\n                ContractError::CantChangeCounterTradeState {\n                    from: TradeState::Created,\n                    to: TradeState::Created\n                }\n            );\n\n            confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap();\n\n            // This time, it has to work fine\n            let res = review_counter_trade_helper(deps.as_mut(), \"creator\", 0, 0).unwrap();\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"review_counter_trade\"),\n                    Attribute::new(\"trade_id\", \"0\"),\n                    Attribute::new(\"counter_id\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                    Attribute::new(\"counter_trader\", \"counterer\"),\n                ]\n            );\n\n            // Because this was the only counter\n            let new_trade_info = load_trade(\u0026deps.storage, 0).unwrap();\n            assert_eq!(new_trade_info.state, TradeState::Countered {});\n        }\n\n        #[test]\n        fn review_counter_trade_when_accepted() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n            confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap();\n            accept_trade_helper(deps.as_mut(), \"creator\", 0, 0).unwrap();\n\n            let err = review_counter_trade_helper(deps.as_mut(), \"creator\", 0, 0).unwrap_err();\n            assert_eq!(err, ContractError::TradeAlreadyAccepted {});\n        }\n\n        #[test]\n        fn review_counter_trade_when_cancelled() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n            confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap();\n            cancel_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n\n            let err = review_counter_trade_helper(deps.as_mut(), \"creator\", 0, 0).unwrap_err();\n            assert_eq!(err, ContractError::TradeCancelled {});\n        }\n\n        #[test]\n        fn review_counter_with_multiple() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n            confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap();\n            // We suggest and confirm one more counter\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n            confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 1).unwrap();\n\n            // This time, it has to work fine\n            let res = review_counter_trade_helper(deps.as_mut(), \"creator\", 0, 0).unwrap();\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"review_counter_trade\"),\n                    Attribute::new(\"trade_id\", \"0\"),\n                    Attribute::new(\"counter_id\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                    Attribute::new(\"counter_trader\", \"counterer\"),\n                ]\n            );\n\n            let new_trade_info = load_trade(\u0026deps.storage, 0).unwrap();\n            assert_eq!(new_trade_info.state, TradeState::Countered {});\n        }\n\n        #[test]\n        fn refuse_counter_trade() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n            let res = refuse_counter_trade_helper(deps.as_mut(), \"creator\", 0, 0).unwrap();\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"refuse_counter_trade\"),\n                    Attribute::new(\"trade_id\", \"0\"),\n                    Attribute::new(\"counter_id\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                    Attribute::new(\"counter_trader\", \"counterer\"),\n                ]\n            );\n        }\n\n        #[test]\n        fn cancel_counter_trade() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n            confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap();\n            cancel_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap();\n\n            let err = accept_trade_helper(deps.as_mut(), \"creator\", 0, 0).unwrap_err();\n\n            assert_eq!(err, ContractError::CantAcceptNotPublishedCounter {});\n        }\n\n        #[test]\n        fn refuse_counter_trade_with_multiple() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n            // We suggest and confirm one more counter\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n            confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap();\n            // We suggest one more counter\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n\n            let res = refuse_counter_trade_helper(deps.as_mut(), \"creator\", 0, 0).unwrap();\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"refuse_counter_trade\"),\n                    Attribute::new(\"trade_id\", \"0\"),\n                    Attribute::new(\"counter_id\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                    Attribute::new(\"counter_trader\", \"counterer\"),\n                ]\n            );\n        }\n\n        #[test]\n        fn refuse_accepted_counter_trade() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n\n            confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap();\n            accept_trade_helper(deps.as_mut(), \"creator\", 0, 0).unwrap();\n            let err = refuse_counter_trade_helper(deps.as_mut(), \"creator\", 0, 0).unwrap_err();\n            assert_eq!(err, ContractError::TradeAlreadyAccepted {});\n        }\n\n        #[test]\n        fn cancel_accepted_counter_trade() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n\n            confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap();\n            accept_trade_helper(deps.as_mut(), \"creator\", 0, 0).unwrap();\n            let err = cancel_trade_helper(deps.as_mut(), \"creator\", 0).unwrap_err();\n            assert_eq!(\n                err,\n                ContractError::CantChangeTradeState {\n                    from: TradeState::Accepted,\n                    to: TradeState::Cancelled\n                }\n            );\n        }\n\n        #[test]\n        fn confirm_counter_trade_after_accepted() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n            confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap();\n            accept_trade_helper(deps.as_mut(), \"creator\", 0, 0).unwrap();\n\n            //Already confirmed\n            let err = confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap_err();\n            assert_eq!(\n                err,\n                ContractError::CantChangeCounterTradeState {\n                    from: TradeState::Accepted,\n                    to: TradeState::Published\n                }\n            );\n        }\n\n        #[test]\n        fn query_trades_by_counterer() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n\n            // When no counter_trades\n            let env = mock_env();\n            let res: AllTradesResponse = from_binary(\n                \u0026query(\n                    deps.as_ref(),\n                    env,\n                    QueryMsg::GetAllTrades {\n                        start_after: None,\n                        limit: None,\n                        filters: Some(QueryFilters {\n                            counterer: Some(\"counterer\".to_string()),\n                            ..QueryFilters::default()\n                        }),\n                    },\n                )\n                .unwrap(),\n            )\n            .unwrap();\n\n            assert_eq!(res.trades, vec![]);\n\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n            confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap();\n            accept_trade_helper(deps.as_mut(), \"creator\", 0, 0).unwrap();\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 1).unwrap();\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 2).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"bad_person\", 1).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"bad_person\", 1).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"bad_person\", 1).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"bad_person\", 1).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"bad_person\", 1).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"bad_person\", 1).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"bad_person\", 1).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"bad_person\", 1).unwrap();\n\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 2).unwrap();\n\n            let env = mock_env();\n            let res: AllTradesResponse = from_binary(\n                \u0026query(\n                    deps.as_ref(),\n                    env,\n                    QueryMsg::GetAllTrades {\n                        start_after: None,\n                        limit: None,\n                        filters: Some(QueryFilters {\n                            counterer: Some(\"counterer\".to_string()),\n                            ..QueryFilters::default()\n                        }),\n                    },\n                )\n                .unwrap(),\n            )\n            .unwrap();\n\n            let env = mock_env();\n            assert_eq!(\n                res.trades,\n                vec![\n                    {\n                        TradeResponse {\n                            trade_id: 2,\n                            counter_id: None,\n                            trade_info: Some(TradeInfo {\n                                owner: deps.api.addr_validate(\"creator\").unwrap(),\n                                last_counter_id: Some(0),\n                                state: TradeState::Countered,\n                                additionnal_info: AdditionnalTradeInfo {\n                                    owner_comment: Some(Comment {\n                                        comment: \"Q\".to_string(),\n                                        time: env.block.time,\n                                    }),\n                                    time: env.block.time,\n                                    ..Default::default()\n                                },\n                                ..Default::default()\n                            }),\n                        }\n                    },\n                    {\n                        TradeResponse {\n                            trade_id: 0,\n                            counter_id: None,\n                            trade_info: Some(TradeInfo {\n                                owner: deps.api.addr_validate(\"creator\").unwrap(),\n                                last_counter_id: Some(3),\n                                state: TradeState::Accepted,\n                                accepted_info: Some(CounterTradeInfo {\n                                    trade_id: 0,\n                                    counter_id: 0,\n                                }),\n                                additionnal_info: AdditionnalTradeInfo {\n                                    owner_comment: Some(Comment {\n                                        comment: \"Q\".to_string(),\n                                        time: env.block.time,\n                                    }),\n                                    time: env.block.time,\n                                    ..Default::default()\n                                },\n                                ..Default::default()\n                            }),\n                        }\n                    }\n                ]\n            );\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","p2p-trading","src","counter_trade.rs"],"content":"use cosmwasm_std::{Addr, Deps, DepsMut, Env, MessageInfo, Response};\n\nuse p2p_trading_export::msg::QueryFilters;\nuse p2p_trading_export::state::{AdditionnalTradeInfo, AssetInfo, TradeInfo, TradeState};\n\nuse crate::error::ContractError;\nuse crate::messages::set_comment;\nuse crate::query::query_counter_trades;\nuse crate::state::{\n    add_cw1155_coin, add_cw20_coin, add_cw721_coin, add_funds, can_suggest_counter_trade,\n    is_counter_trader, load_trade, COUNTER_TRADE_INFO, TRADE_INFO,\n};\nuse crate::trade::{\n    _are_assets_in_trade, _create_receive_asset_messages, _create_withdraw_messages_unsafe,\n    _try_withdraw_assets_unsafe, check_and_create_withdraw_messages,\n};\n\n/// Query the last counter_trade created by the owner for the `trade_id`\n/// This should only be used in the same transaction as the counter_trade creation.\n/// Otherwise, specify the counter_id directly in the transaction and this is not needed\npub fn get_last_counter_id_created(\n    deps: Deps,\n    by: String,\n    trade_id: u64,\n) -\u003e Result\u003cu64, ContractError\u003e {\n    let counter_trade = \u0026query_counter_trades(\n        deps,\n        trade_id,\n        None,\n        Some(1),\n        Some(QueryFilters {\n            owner: Some(by),\n            ..QueryFilters::default()\n        }),\n    )?\n    .counter_trades[0];\n    Ok(counter_trade.counter_id.unwrap())\n}\n\n/// Create a new counter_trade and assign it a unique id for the specified `trade_id`\npub fn suggest_counter_trade(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    trade_id: u64,\n    comment: Option\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // We start by verifying it is possible to suggest a counter trade to that trade\n    // It also checks if the trade exists\n    // And that the sender is whitelisted (in case the trade is private)\n    let mut trade_info = can_suggest_counter_trade(deps.storage, trade_id, \u0026info.sender)?;\n\n    // We start by creating a new trade_id (simply incremented from the last id)\n    trade_info.last_counter_id = trade_info\n        .last_counter_id\n        .map_or(Some(0), |id| Some(id + 1));\n    if trade_info.state == TradeState::Published {\n        trade_info.state = TradeState::Countered;\n    }\n    TRADE_INFO.save(deps.storage, trade_id, \u0026trade_info)?;\n\n    let counter_id = trade_info.last_counter_id.unwrap(); // This is safe, as we just created a ast_counter_id` if it didn't exist.\n\n    COUNTER_TRADE_INFO.update(\n        deps.storage,\n        (trade_id, counter_id),\n        |counter| match counter {\n            // If the trade id already exists, the contract is faulty\n            // Or an external error happened, or whatever...\n            // In that case, we emit an error\n            // The priority is : We do not want to overwrite existing data\n            Some(_) =\u003e Err(ContractError::ExistsInCounterTradeInfo {}),\n            None =\u003e Ok(TradeInfo {\n                owner: info.sender.clone(),\n                additionnal_info: AdditionnalTradeInfo {\n                    time: env.block.time,\n                    ..Default::default()\n                },\n                ..Default::default()\n            }),\n        },\n    )?;\n    if let Some(comment) = comment {\n        set_comment(deps, env, info.clone(), trade_id, Some(counter_id), comment)?;\n    }\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"create_counter_trade\")\n        .add_attribute(\"trade_id\", trade_id.to_string())\n        .add_attribute(\"counter_id\", counter_id.to_string())\n        .add_attribute(\"trader\", trade_info.owner)\n        .add_attribute(\"counter_trader\", info.sender))\n}\n\npub fn counter_id_or_last(\n    deps: Deps,\n    trader: Addr,\n    trade_id: u64,\n    counter_id: Option\u003cu64\u003e,\n) -\u003e Result\u003cu64, ContractError\u003e {\n    match counter_id {\n        Some(counter_id) =\u003e Ok(counter_id),\n        None =\u003e get_last_counter_id_created(deps, trader.to_string(), trade_id),\n    }\n}\n\n/// We prepare the info before asset addition\n/// 1. If the trade_id is not specified, we get the last trade_id created by the sender\n/// 2. We verify the trade can be modified\npub fn prepare_counter_modification(\n    deps: Deps,\n    trader: Addr,\n    trade_id: u64,\n    counter_id: Option\u003cu64\u003e,\n) -\u003e Result\u003cu64, ContractError\u003e {\n    let counter_id = counter_id_or_last(deps, trader.clone(), trade_id, counter_id)?;\n\n    let counter_info = is_counter_trader(deps.storage, \u0026trader, trade_id, counter_id)?;\n\n    if counter_info.state != TradeState::Created {\n        return Err(ContractError::WrongTradeState {\n            state: counter_info.state,\n        });\n    }\n    Ok(counter_id)\n}\n\npub fn add_asset_to_counter_trade(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    trade_id: u64,\n    counter_id: Option\u003cu64\u003e,\n    asset: AssetInfo,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let counter_id =\n        prepare_counter_modification(deps.as_ref(), info.sender.clone(), trade_id, counter_id)?;\n\n    match asset.clone() {\n        AssetInfo::Coin(coin) =\u003e COUNTER_TRADE_INFO.update(\n            deps.storage,\n            (trade_id, counter_id),\n            add_funds(coin, info.funds.clone()),\n        ),\n        AssetInfo::Cw20Coin(token) =\u003e COUNTER_TRADE_INFO.update(\n            deps.storage,\n            (trade_id, counter_id),\n            add_cw20_coin(token.address.clone(), token.amount),\n        ),\n        AssetInfo::Cw721Coin(token) =\u003e COUNTER_TRADE_INFO.update(\n            deps.storage,\n            (trade_id, counter_id),\n            add_cw721_coin(token.address.clone(), token.token_id),\n        ),\n        AssetInfo::Cw1155Coin(token) =\u003e COUNTER_TRADE_INFO.update(\n            deps.storage,\n            (trade_id, counter_id),\n            add_cw1155_coin(token.address.clone(), token.token_id.clone(), token.value),\n        ),\n    }?;\n\n    // We load the trade_info for events\n    let trade_info = load_trade(deps.storage, trade_id)?;\n\n    // Now we need to transfer the token\n    Ok(_create_receive_asset_messages(env, info.clone(), asset)?\n        .add_attribute(\"trade_id\", trade_id.to_string())\n        .add_attribute(\"counter_id\", counter_id.to_string())\n        .add_attribute(\"trader\", trade_info.owner)\n        .add_attribute(\"counter_trader\", info.sender))\n}\n\n/// Allows to withdraw assets while creating a counter_trade, Refer to the `trade.rs`file for more information (similar mecanism)\npub fn withdraw_counter_trade_assets_while_creating(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    trade_id: u64,\n    counter_id: u64,\n    assets: Vec\u003c(u16, AssetInfo)\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut counter_info = is_counter_trader(deps.storage, \u0026info.sender, trade_id, counter_id)?;\n    if counter_info.state != TradeState::Created {\n        return Err(ContractError::CounterTradeAlreadyPublished {});\n    }\n    _are_assets_in_trade(\u0026counter_info, \u0026assets)?;\n\n    _try_withdraw_assets_unsafe(\u0026mut counter_info, \u0026assets)?;\n    COUNTER_TRADE_INFO.save(deps.storage, (trade_id, counter_id), \u0026counter_info)?;\n\n    let res = _create_withdraw_messages_unsafe(\n        \u0026env.contract.address,\n        \u0026info.sender,\n        \u0026assets.iter().map(|x| x.1.clone()).collect(),\n    )?;\n    // We load the trade_info for events\n    let trade_info = load_trade(deps.storage, trade_id)?;\n    Ok(res\n        .add_attribute(\"action\", \"remove_from_counter_trade\")\n        .add_attribute(\"trade\", trade_id.to_string())\n        .add_attribute(\"counter\", counter_id.to_string())\n        .add_attribute(\"trader\", trade_info.owner)\n        .add_attribute(\"counter_trader\", info.sender))\n}\n\n/// Confirm (and publish) a counter_trade when creation is finished\npub fn confirm_counter_trade(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    trade_id: u64,\n    counter_id: Option\u003cu64\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // We check the counter exists and belongs to the sender\n    let counter_id = counter_id_or_last(deps.as_ref(), info.sender.clone(), trade_id, counter_id)?;\n    let mut counter_info = is_counter_trader(deps.storage, \u0026info.sender, trade_id, counter_id)?;\n\n    // We check the counter can be confirmed\n    if counter_info.state != TradeState::Created {\n        return Err(ContractError::CantChangeCounterTradeState {\n            from: counter_info.state,\n            to: TradeState::Published,\n        });\n    }\n    // We confirm the counter_trade\n    counter_info.state = TradeState::Published;\n    COUNTER_TRADE_INFO.save(deps.storage, (trade_id, counter_id), \u0026counter_info)?;\n\n    // We load the trade_info for events\n    let trade_info = load_trade(deps.storage, trade_id)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"confirm_counter_trade\")\n        .add_attribute(\"trade\", trade_id.to_string())\n        .add_attribute(\"counter\", counter_id.to_string())\n        .add_attribute(\"trader\", trade_info.owner)\n        .add_attribute(\"counter_trader\", info.sender))\n}\n\n/// Cancel a counter_trade\n/// The counter_trade isn't modifiable, but the funds are withdrawnable after this call.\npub fn cancel_counter_trade(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    trade_id: u64,\n    counter_id: u64,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // Only the initial trader can cancel the trade\n    let mut counter_info = is_counter_trader(deps.storage, \u0026info.sender, trade_id, counter_id)?;\n\n    // We can't cancel an accepted counter_trade\n    if counter_info.state == TradeState::Accepted {\n        return Err(ContractError::CantChangeCounterTradeState {\n            from: counter_info.state,\n            to: TradeState::Cancelled,\n        });\n    }\n    counter_info.state = TradeState::Cancelled;\n\n    // We store the new trade status\n    COUNTER_TRADE_INFO.save(deps.storage, (trade_id, counter_id), \u0026counter_info)?;\n\n    // We load the trade_info for events\n    let trade_info = load_trade(deps.storage, trade_id)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"cancel_counter_trade\")\n        .add_attribute(\"trade\", trade_id.to_string())\n        .add_attribute(\"counter\", counter_id.to_string())\n        .add_attribute(\"trader\", trade_info.owner)\n        .add_attribute(\"counter_trader\", info.sender))\n}\n\n/// Withdraw all assets from a created (not published yet), refused or cancelled counter_trade\n/// If the counter_trade is only in the created state, it is automatically cancelled before withdrawing assets\npub fn withdraw_all_from_counter(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    trade_id: u64,\n    counter_id: u64,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut counter_info = is_counter_trader(deps.storage, \u0026info.sender, trade_id, counter_id)?;\n\n    // If the counter is still in the created state, we cancel it\n    if counter_info.state == TradeState::Created {\n        counter_info.state = TradeState::Cancelled;\n    }\n\n    // This fuction call is possible only if the counter was refused or if this counter was cancelled\n    if !(counter_info.state == TradeState::Refused || counter_info.state == TradeState::Cancelled) {\n        return Err(ContractError::CounterTradeNotAborted {});\n    }\n\n    // We create withdraw messages to send the funds back to the counter trader\n    let res = check_and_create_withdraw_messages(env, \u0026info.sender, \u0026counter_info)?;\n    counter_info.assets_withdrawn = true;\n    COUNTER_TRADE_INFO.save(deps.storage, (trade_id, counter_id), \u0026counter_info)?;\n\n    // We load the trade_info for events\n    let trade_info = load_trade(deps.storage, trade_id)?;\n\n    Ok(res\n        .add_attribute(\"action\", \"withdraw_all_funds\")\n        .add_attribute(\"type\", \"counter_trade\")\n        .add_attribute(\"trade\", trade_id.to_string())\n        .add_attribute(\"counter\", counter_id.to_string())\n        .add_attribute(\"trader\", trade_info.owner)\n        .add_attribute(\"counter_trader\", counter_info.owner))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","p2p-trading","src","error.rs"],"content":"use cosmwasm_std::StdError;\nuse p2p_trading_export::state::TradeState;\nuse thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized {},\n\n    #[error(\"An unplanned bug just happened :/\")]\n    ContractBug {},\n\n    #[error(\"Key already exists in TradeInfo\")]\n    ExistsInTradeInfo {},\n\n    #[error(\"Key does not exist in TradeInfo\")]\n    NotFoundInTradeInfo {},\n\n    #[error(\n        \"The trade_id field should be present when modifying the last counter_trade submitted\"\n    )]\n    TradeIdMissing {},\n\n    #[error(\"Trader not creator of the trade\")]\n    TraderNotCreator {},\n\n    #[error(\"Key already exists in CounterTradeInfo\")]\n    ExistsInCounterTradeInfo {},\n\n    #[error(\"Key does not exist in CounterTradeInfo\")]\n    NotFoundInCounterTradeInfo {},\n\n    #[error(\"Trader not creator of the CounterTrade\")]\n    CounterTraderNotCreator {},\n\n    #[error(\"Trade cannot be countered, it is not ready or is already cancelled/terminated\")]\n    NotCounterable {},\n\n    #[error(\"Wrong state of the trade for the current operation : {state:?}\")]\n    WrongTradeState { state: TradeState },\n\n    #[error(\"Can change the state of the trade from {from:?} to {to:?}\")]\n    CantChangeTradeState { from: TradeState, to: TradeState },\n\n    #[error(\"Sorry, you can't accept a counter trade that is not published yet\")]\n    TradeAlreadyAccepted {},\n\n    #[error(\"Sorry, the trade is published, you can't modify it. You can cancel it if you're not satisfied\")]\n    TradeAlreadyPublished {},\n\n    #[error(\"Sorry, this trade is not accepted yet\")]\n    TradeNotAccepted {},\n\n    #[error(\"Sorry, this trade is cancelled\")]\n    TradeCancelled {},\n\n    #[error(\"Sorry, this trade is not cancelled\")]\n    TradeNotCancelled {},\n\n    #[error(\"Assets were already withdrawn, don't try to scam the platform please\")]\n    TradeAlreadyWithdrawn {},\n\n    #[error(\"Can change the state of the counter-trade from {from:?} to {to:?}\")]\n    CantChangeCounterTradeState { from: TradeState, to: TradeState },\n\n    #[error(\"Sorry, you can't accept a counter trade that is not published yet\")]\n    CantAcceptNotPublishedCounter {},\n\n    #[error(\"Sorry, the counter trade is published, you can't modify it. You can cancel it if you're not satisfied\")]\n    CounterTradeAlreadyPublished {},\n\n    #[error(\"Sorry, the trade has to be refused or cancelled to withdraw your funds\")]\n    CounterTradeNotAborted {},\n\n    #[error(\"Only the trader or the counter-trader can withdraw assets, don't try to scam the platform please\")]\n    NotWithdrawableByYou {},\n\n    #[error(\"This trade is only allowed to a selected few, sorry :/\")]\n    AddressNotWhitelisted {},\n\n    #[error(\n        \"Asset not found in your trade (wrong position or wrong asset specified or wrong token_id)\"\n    )]\n    AssetNotFound { position: usize },\n\n    #[error(\"Asset found in your trade but you are trying to withdraw too much. address: {address:?}, wanted: {wanted:?}, available {available:?}\")]\n    TooMuchWithdrawn {\n        address: String,\n        wanted: u128,\n        available: u128,\n    },\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","p2p-trading","src","lib.rs"],"content":"pub mod contract;\npub mod counter_trade;\nmod error;\npub mod messages;\npub mod query;\npub mod state;\npub mod trade;\n\npub use crate::error::ContractError;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","p2p-trading","src","messages.rs"],"content":"use crate::error::ContractError;\nuse crate::state::{\n    is_counter_trader, is_trader, load_counter_trade, COUNTER_TRADE_INFO, TRADE_INFO,\n};\nuse cosmwasm_std::{DepsMut, Env, MessageInfo, Response};\nuse p2p_trading_export::state::{Comment, TradeState};\n\npub fn review_counter_trade(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    trade_id: u64,\n    counter_id: u64,\n    comment: Option\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // Only the initial trader can cancel the trade !\n    let trade_info = is_trader(deps.storage, \u0026info.sender, trade_id)?;\n\n    // We check the counter trade exists !\n    let mut counter_info = load_counter_trade(deps.storage, trade_id, counter_id)?;\n\n    if trade_info.state == TradeState::Accepted {\n        return Err(ContractError::TradeAlreadyAccepted {});\n    }\n    if trade_info.state == TradeState::Cancelled {\n        return Err(ContractError::TradeCancelled {});\n    }\n\n    // Only a published counter trade can be reviewed\n    if counter_info.state != TradeState::Published {\n        return Err(ContractError::CantChangeCounterTradeState {\n            from: counter_info.state,\n            to: TradeState::Created,\n        });\n    }\n\n    counter_info.state = TradeState::Created;\n    counter_info.additionnal_info.trader_comment = comment.map(|comment| Comment {\n        time: env.block.time,\n        comment,\n    });\n\n    // Then we need to change the trade status that we may have changed\n    TRADE_INFO.save(deps.storage, trade_id, \u0026trade_info)?;\n    COUNTER_TRADE_INFO.save(deps.storage, (trade_id, counter_id), \u0026counter_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"review_counter_trade\")\n        .add_attribute(\"trade_id\", trade_id.to_string())\n        .add_attribute(\"counter_id\", counter_id.to_string())\n        .add_attribute(\"trader\", trade_info.owner)\n        .add_attribute(\"counter_trader\", counter_info.owner))\n}\n\npub fn set_comment(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    trade_id: u64,\n    counter_id: Option\u003cu64\u003e,\n    comment: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let comment = Comment {\n        time: env.block.time,\n        comment,\n    };\n\n    if let Some(counter_id) = counter_id {\n        let mut counter_info = is_counter_trader(deps.storage, \u0026info.sender, trade_id, counter_id)?;\n        counter_info.additionnal_info.owner_comment = Some(comment);\n        COUNTER_TRADE_INFO.save(deps.storage, (trade_id, counter_id), \u0026counter_info)?;\n    } else {\n        let mut trade_info = is_trader(deps.storage, \u0026info.sender, trade_id)?;\n        trade_info.additionnal_info.owner_comment = Some(comment);\n        TRADE_INFO.save(deps.storage, trade_id, \u0026trade_info)?;\n    }\n    let partial_res = Response::new()\n        .add_attribute(\"action\", \"set_comment\")\n        .add_attribute(\"trade\", trade_id.to_string());\n\n    if let Some(counter_id) = counter_id {\n        Ok(partial_res.add_attribute(\"counter\", counter_id.to_string()))\n    } else {\n        Ok(partial_res)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","p2p-trading","src","query.rs"],"content":"use cosmwasm_std::Api;\n#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::{Deps, Order, StdResult, Storage};\n\nuse cw_storage_plus::Bound;\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse crate::state::{get_actual_counter_state, CONTRACT_INFO, COUNTER_TRADE_INFO, TRADE_INFO};\nuse p2p_trading_export::msg::QueryFilters;\nuse p2p_trading_export::state::{AssetInfo, ContractInfo, CounterTradeInfo, TradeInfo};\n\nuse itertools::Itertools;\n// settings for pagination\nconst MAX_LIMIT: u32 = 30;\nconst DEFAULT_LIMIT: u32 = 10;\nconst BASE_LIMIT: usize = 100;\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug, Default)]\npub struct TradeResponse {\n    pub trade_id: u64,\n    pub counter_id: Option\u003cu64\u003e,\n    pub trade_info: Option\u003cTradeInfo\u003e,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug, Default)]\npub struct AllTradesResponse {\n    pub trades: Vec\u003cTradeResponse\u003e,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug, Default)]\npub struct AllCounterTradesResponse {\n    pub counter_trades: Vec\u003cTradeResponse\u003e,\n}\n\npub fn query_contract_info(deps: Deps) -\u003e StdResult\u003cContractInfo\u003e {\n    CONTRACT_INFO.load(deps.storage)\n}\n\n// parse trades to human readable format\nfn parse_trades(_: \u0026dyn Api, item: StdResult\u003c(u64, TradeInfo)\u003e) -\u003e StdResult\u003cTradeResponse\u003e {\n    item.map(|(trade_id, trade)| TradeResponse {\n        trade_id,\n        counter_id: None,\n        trade_info: Some(trade),\n    })\n}\n\n// parse counter trades to human readable format\nfn parse_all_counter_trades(\n    _: \u0026dyn Api,\n    storage: \u0026dyn Storage,\n    item: StdResult\u003c((u64, u64), TradeInfo)\u003e,\n) -\u003e StdResult\u003cTradeResponse\u003e {\n    item.map(|((trade_id, counter_id), mut counter)| {\n        // First two bytes define size [0,8] since we know it's u64 skip it.\n        get_actual_counter_state(storage, trade_id, \u0026mut counter)?;\n        Ok(TradeResponse {\n            trade_id,\n            counter_id: Some(counter_id),\n            trade_info: Some(counter),\n        })\n    })?\n}\n\n// parse counter trades to human readable format\nfn parse_counter_trades(\n    _: \u0026dyn Api,\n    storage: \u0026dyn Storage,\n    item: StdResult\u003c(u64, TradeInfo)\u003e,\n    trade_id: u64,\n) -\u003e StdResult\u003cTradeResponse\u003e {\n    item.map(|(counter_id, mut counter)| {\n        get_actual_counter_state(storage, trade_id, \u0026mut counter)?;\n        Ok(TradeResponse {\n            trade_id,\n            counter_id: Some(counter_id),\n            trade_info: Some(counter),\n        })\n    })?\n}\n\npub fn trade_filter(\n    api: \u0026dyn Api,\n    trade_info: \u0026StdResult\u003cTradeResponse\u003e,\n    filters: \u0026Option\u003cQueryFilters\u003e,\n) -\u003e bool {\n    if let Some(filters) = filters {\n        let trade = trade_info.as_ref().unwrap();\n\n        (match \u0026filters.states {\n            Some(state) =\u003e state.contains(\u0026trade.trade_info.as_ref().unwrap().state.to_string()),\n            None =\u003e true,\n        } \u0026\u0026 match \u0026filters.owner {\n            Some(owner) =\u003e trade.trade_info.as_ref().unwrap().owner == owner.clone(),\n            None =\u003e true,\n        } \u0026\u0026 match \u0026filters.has_whitelist {\n            Some(has_whitelist) =\u003e {\n                \u0026trade\n                    .trade_info\n                    .as_ref()\n                    .unwrap()\n                    .whitelisted_users\n                    .is_empty()\n                    != has_whitelist\n            }\n            None =\u003e true,\n        } \u0026\u0026 match \u0026filters.whitelisted_user {\n            Some(whitelisted_user) =\u003e trade\n                .trade_info\n                .as_ref()\n                .unwrap()\n                .whitelisted_users\n                .contains(\u0026api.addr_validate(whitelisted_user).unwrap()),\n            None =\u003e true,\n        } \u0026\u0026 match \u0026filters.wanted_nft {\n            Some(wanted_nft) =\u003e trade\n                .trade_info\n                .as_ref()\n                .unwrap()\n                .additionnal_info\n                .nfts_wanted\n                .contains(\u0026api.addr_validate(wanted_nft).unwrap()),\n            None =\u003e true,\n        } \u0026\u0026 match \u0026filters.contains_token {\n            Some(token) =\u003e trade\n                .trade_info\n                .as_ref()\n                .unwrap()\n                .associated_assets\n                .iter()\n                .any(|asset| match asset {\n                    AssetInfo::Coin(x) =\u003e x.denom == token.as_ref(),\n                    AssetInfo::Cw20Coin(x) =\u003e x.address == token.as_ref(),\n                    AssetInfo::Cw721Coin(x) =\u003e x.address == token.as_ref(),\n                    AssetInfo::Cw1155Coin(x) =\u003e x.address == token.as_ref(),\n                }),\n            None =\u003e true,\n        } \u0026\u0026 match \u0026filters.assets_withdrawn {\n            Some(assets_withdrawn) =\u003e {\n                trade.trade_info.clone().unwrap().assets_withdrawn == *assets_withdrawn\n            }\n            None =\u003e true,\n        })\n    } else {\n        true\n    }\n}\n\npub fn query_all_trades(\n    deps: Deps,\n    start_after: Option\u003cu64\u003e,\n    limit: Option\u003cu32\u003e,\n    filters: Option\u003cQueryFilters\u003e,\n) -\u003e StdResult\u003cAllTradesResponse\u003e {\n    if let Some(f) = filters.clone() {\n        if let Some(counterer) = f.counterer {\n            query_all_trades_by_counterer(deps, start_after, limit, counterer, filters)\n        } else {\n            query_all_trades_raw(deps, start_after, limit, filters)\n        }\n    } else {\n        query_all_trades_raw(deps, start_after, limit, filters)\n    }\n}\n\npub fn query_all_trades_raw(\n    deps: Deps,\n    start_after: Option\u003cu64\u003e,\n    limit: Option\u003cu32\u003e,\n    filters: Option\u003cQueryFilters\u003e,\n) -\u003e StdResult\u003cAllTradesResponse\u003e {\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n    let start = start_after.map(Bound::exclusive);\n\n    let mut trades: Vec\u003cTradeResponse\u003e = TRADE_INFO\n        .range(deps.storage, None, start.clone(), Order::Descending)\n        .take(BASE_LIMIT)\n        .map(|kv_item| parse_trades(deps.api, kv_item))\n        .filter(|response| trade_filter(deps.api, response, \u0026filters))\n        .take(limit)\n        .collect::\u003cStdResult\u003cVec\u003cTradeResponse\u003e\u003e\u003e()?;\n\n    if trades.is_empty() {\n        let trade_id = TRADE_INFO\n            .keys(deps.storage, None, start, Order::Descending)\n            .take(BASE_LIMIT)\n            .last();\n\n        if let Some(Ok(trade_id)) = trade_id {\n            if trade_id != 0 {\n                trades = vec![TradeResponse {\n                    trade_id,\n                    counter_id: None,\n                    trade_info: None,\n                }]\n            }\n        }\n    }\n    Ok(AllTradesResponse { trades })\n}\n\npub fn query_all_trades_by_counterer(\n    deps: Deps,\n    start_after: Option\u003cu64\u003e,\n    limit: Option\u003cu32\u003e,\n    counterer: String,\n    filters: Option\u003cQueryFilters\u003e,\n) -\u003e StdResult\u003cAllTradesResponse\u003e {\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n\n    let start = start_after.map(|s| Bound::exclusive((s, 0)));\n\n    let counter_filters = Some(QueryFilters {\n        owner: Some(counterer),\n        ..QueryFilters::default()\n    });\n\n    let mut trades: Vec\u003cTradeResponse\u003e = COUNTER_TRADE_INFO\n        .range(deps.storage, None, start.clone(), Order::Descending)\n        .take(BASE_LIMIT)\n        .map(|kv_item| parse_all_counter_trades(deps.api, deps.storage, kv_item))\n        .filter(|response| trade_filter(deps.api, response, \u0026counter_filters))\n        .filter_map(|response| response.ok())\n        // Now we get back the trade_id and query the trade_info\n        .map(|response| response.trade_id)\n        .unique()\n        .map(|trade_id| Ok((trade_id, TRADE_INFO.load(deps.storage, trade_id)?)))\n        .map(|kv_item| parse_trades(deps.api, kv_item))\n        .filter(|response| trade_filter(deps.api, response, \u0026filters))\n        .take(limit)\n        .collect::\u003cStdResult\u003cVec\u003cTradeResponse\u003e\u003e\u003e()?;\n\n    if trades.is_empty() {\n        let trade_info: Option\u003cTradeResponse\u003e = COUNTER_TRADE_INFO\n            .range(deps.storage, None, start, Order::Descending)\n            .take(BASE_LIMIT)\n            .map(|kv_item| parse_all_counter_trades(deps.api, deps.storage, kv_item))\n            .filter_map(|response| response.ok())\n            .map(|response| response.trade_id)\n            .unique()\n            .map(|trade_id| Ok((trade_id, TRADE_INFO.load(deps.storage, trade_id)?)))\n            .filter_map(|kv_item| parse_trades(deps.api, kv_item).ok())\n            .last();\n\n        if let Some(trade_info) = trade_info {\n            if trade_info.trade_id != 0 || trade_info.counter_id.unwrap() != 0 {\n                trades = vec![TradeResponse {\n                    trade_id: trade_info.trade_id,\n                    counter_id: trade_info.counter_id,\n                    trade_info: None,\n                }]\n            }\n        }\n    }\n\n    Ok(AllTradesResponse { trades })\n}\n\npub fn query_all_counter_trades(\n    deps: Deps,\n    start_after: Option\u003cCounterTradeInfo\u003e,\n    limit: Option\u003cu32\u003e,\n    filters: Option\u003cQueryFilters\u003e,\n) -\u003e StdResult\u003cAllCounterTradesResponse\u003e {\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n\n    let start = start_after.map(|s| Bound::exclusive((s.trade_id, s.counter_id)));\n\n    let mut counter_trades: Vec\u003cTradeResponse\u003e = COUNTER_TRADE_INFO\n        .range(deps.storage, None, start.clone(), Order::Descending)\n        .take(BASE_LIMIT)\n        .map(|kv_item| parse_all_counter_trades(deps.api, deps.storage, kv_item))\n        .filter(|response| trade_filter(deps.api, response, \u0026filters))\n        .take(limit)\n        .collect::\u003cStdResult\u003cVec\u003cTradeResponse\u003e\u003e\u003e()?;\n\n    if counter_trades.is_empty() {\n        let id = COUNTER_TRADE_INFO\n            .keys(deps.storage, None, start, Order::Descending)\n            .take(BASE_LIMIT)\n            .last();\n\n        if let Some(Ok((trade_id, counter_id))) = id {\n            if trade_id != 0 || counter_id != 0 {\n                counter_trades = vec![TradeResponse {\n                    trade_id,\n                    counter_id: Some(counter_id),\n                    trade_info: None,\n                }]\n            }\n        }\n    }\n\n    Ok(AllCounterTradesResponse { counter_trades })\n}\n\npub fn query_counter_trades(\n    deps: Deps,\n    trade_id: u64,\n    start_after: Option\u003cu64\u003e,\n    limit: Option\u003cu32\u003e,\n    filters: Option\u003cQueryFilters\u003e,\n) -\u003e StdResult\u003cAllCounterTradesResponse\u003e {\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n\n    let start = start_after.map(Bound::exclusive);\n\n    let mut counter_trades: Vec\u003cTradeResponse\u003e = COUNTER_TRADE_INFO\n        .prefix(trade_id)\n        .range(deps.storage, None, start.clone(), Order::Descending)\n        .take(BASE_LIMIT)\n        .map(|kv_item| parse_counter_trades(deps.api, deps.storage, kv_item, trade_id))\n        .filter(|response| trade_filter(deps.api, response, \u0026filters))\n        .take(limit)\n        .collect::\u003cStdResult\u003cVec\u003cTradeResponse\u003e\u003e\u003e()?;\n\n    if counter_trades.is_empty() {\n        let counter_id = COUNTER_TRADE_INFO\n            .prefix(trade_id)\n            .keys(deps.storage, None, start, Order::Descending)\n            .take(BASE_LIMIT)\n            .last();\n\n        if let Some(Ok(counter_id)) = counter_id {\n            if trade_id != 0 || counter_id != 0 {\n                counter_trades = vec![TradeResponse {\n                    trade_id,\n                    counter_id: Some(counter_id),\n                    trade_info: None,\n                }]\n            }\n        }\n    }\n\n    Ok(AllCounterTradesResponse { counter_trades })\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","p2p-trading","src","state.rs"],"content":"use cw_storage_plus::{Item, Map};\n\nuse cosmwasm_std::{Addr, Coin, StdError, StdResult, Storage, Uint128};\n\nuse crate::error::ContractError;\nuse p2p_trading_export::state::{\n    AssetInfo, ContractInfo, Cw1155Coin, Cw20Coin, Cw721Coin, TradeInfo, TradeState,\n};\n\npub const CONTRACT_INFO: Item\u003cContractInfo\u003e = Item::new(\"contract_info\");\n\npub const TRADE_INFO: Map\u003cu64, TradeInfo\u003e = Map::new(\"trade_info\");\n\npub const COUNTER_TRADE_INFO: Map\u003c(u64, u64), TradeInfo\u003e = Map::new(\"counter_trade_info\");\n\npub fn add_funds(\n    fund: Coin,\n    info_funds: Vec\u003cCoin\u003e,\n) -\u003e impl FnOnce(Option\u003cTradeInfo\u003e) -\u003e Result\u003cTradeInfo, ContractError\u003e {\n    move |d: Option\u003cTradeInfo\u003e| -\u003e Result\u003cTradeInfo, ContractError\u003e {\n        match d {\n            Some(mut trade) =\u003e {\n                // We check the sent funds are with the right format\n                if info_funds.len() != 1 || fund != info_funds[0] {\n                    return Err(ContractError::Std(StdError::generic_err(\n                        \"Funds sent do not match message AssetInfo\",\n                    )));\n                }\n                let existing_denom = trade.associated_assets.iter_mut().find(|c| match c {\n                    AssetInfo::Coin(x) =\u003e x.denom == fund.denom,\n                    _ =\u003e false,\n                });\n\n                if let Some(existing_fund) = existing_denom {\n                    let current_amount = match existing_fund {\n                        AssetInfo::Coin(x) =\u003e x.amount,\n                        _ =\u003e Uint128::zero(),\n                    };\n                    *existing_fund = AssetInfo::Coin(Coin {\n                        denom: fund.denom,\n                        amount: current_amount + fund.amount,\n                    });\n                } else {\n                    trade.associated_assets.push(AssetInfo::Coin(fund));\n                }\n                Ok(trade)\n            }\n            //TARPAULIN : Unreachable in current code state\n            None =\u003e Err(ContractError::NotFoundInTradeInfo {}),\n        }\n    }\n}\n\npub fn add_cw20_coin(\n    address: String,\n    sent_amount: Uint128,\n) -\u003e impl FnOnce(Option\u003cTradeInfo\u003e) -\u003e Result\u003cTradeInfo, ContractError\u003e {\n    move |d: Option\u003cTradeInfo\u003e| -\u003e Result\u003cTradeInfo, ContractError\u003e {\n        match d {\n            Some(mut trade) =\u003e {\n                let existing_token = trade.associated_assets.iter_mut().find(|c| match c {\n                    AssetInfo::Cw20Coin(x) =\u003e x.address == address,\n                    _ =\u003e false,\n                });\n                if let Some(existing_token) = existing_token {\n                    let current_amount = match existing_token {\n                        AssetInfo::Cw20Coin(x) =\u003e x.amount,\n                        _ =\u003e Uint128::zero(),\n                    };\n                    *existing_token = AssetInfo::Cw20Coin(Cw20Coin {\n                        address,\n                        amount: current_amount + sent_amount,\n                    })\n                } else {\n                    trade.associated_assets.push(AssetInfo::Cw20Coin(Cw20Coin {\n                        address,\n                        amount: sent_amount,\n                    }))\n                }\n\n                Ok(trade)\n            }\n            //TARPAULIN : Unreachable in current code state\n            None =\u003e Err(ContractError::NotFoundInTradeInfo {}),\n        }\n    }\n}\n\npub fn add_cw721_coin(\n    address: String,\n    token_id: String,\n) -\u003e impl FnOnce(Option\u003cTradeInfo\u003e) -\u003e Result\u003cTradeInfo, ContractError\u003e {\n    move |d: Option\u003cTradeInfo\u003e| -\u003e Result\u003cTradeInfo, ContractError\u003e {\n        match d {\n            Some(mut one) =\u003e {\n                one.associated_assets\n                    .push(AssetInfo::Cw721Coin(Cw721Coin { address, token_id }));\n                Ok(one)\n            }\n            //TARPAULIN : Unreachable in current code state\n            None =\u003e Err(ContractError::NotFoundInTradeInfo {}),\n        }\n    }\n}\n\npub fn add_cw1155_coin(\n    address: String,\n    token_id: String,\n    value: Uint128,\n) -\u003e impl FnOnce(Option\u003cTradeInfo\u003e) -\u003e Result\u003cTradeInfo, ContractError\u003e {\n    move |d: Option\u003cTradeInfo\u003e| -\u003e Result\u003cTradeInfo, ContractError\u003e {\n        match d {\n            Some(mut trade) =\u003e {\n                let existing_token = trade.associated_assets.iter_mut().find(|c| match c {\n                    AssetInfo::Cw1155Coin(x) =\u003e x.address == address \u0026\u0026 x.token_id == token_id,\n                    _ =\u003e false,\n                });\n                if let Some(existing_token) = existing_token {\n                    let current_value = match existing_token {\n                        AssetInfo::Cw1155Coin(x) =\u003e x.value,\n                        _ =\u003e Uint128::zero(),\n                    };\n                    *existing_token = AssetInfo::Cw1155Coin(Cw1155Coin {\n                        address,\n                        token_id,\n                        value: current_value + value,\n                    })\n                } else {\n                    trade\n                        .associated_assets\n                        .push(AssetInfo::Cw1155Coin(Cw1155Coin {\n                            address,\n                            token_id,\n                            value,\n                        }))\n                }\n\n                Ok(trade)\n            }\n            //TARPAULIN : Unreachable in current code state\n            None =\u003e Err(ContractError::NotFoundInTradeInfo {}),\n        }\n    }\n}\n\npub fn is_owner(storage: \u0026dyn Storage, sender: Addr) -\u003e Result\u003cContractInfo, ContractError\u003e {\n    let contract_info = CONTRACT_INFO.load(storage)?;\n    if sender == contract_info.owner {\n        Ok(contract_info)\n    } else {\n        Err(ContractError::Unauthorized {})\n    }\n}\n\npub fn is_fee_contract(storage: \u0026dyn Storage, sender: Addr) -\u003e Result\u003c(), ContractError\u003e {\n    let contract_info = CONTRACT_INFO.load(storage)?;\n    if let Some(fee_contract) = contract_info.fee_contract {\n        if sender == fee_contract {\n            Ok(())\n        } else {\n            Err(ContractError::Unauthorized {})\n        }\n    } else {\n        Err(ContractError::Unauthorized {})\n    }\n}\n\npub fn is_trader(\n    storage: \u0026dyn Storage,\n    sender: \u0026Addr,\n    trade_id: u64,\n) -\u003e Result\u003cTradeInfo, ContractError\u003e {\n    let trade = load_trade(storage, trade_id)?;\n\n    if trade.owner == sender.clone() {\n        Ok(trade)\n    } else {\n        Err(ContractError::TraderNotCreator {})\n    }\n}\n\npub fn is_counter_trader(\n    storage: \u0026dyn Storage,\n    sender: \u0026Addr,\n    trade_id: u64,\n    counter_id: u64,\n) -\u003e Result\u003cTradeInfo, ContractError\u003e {\n    let trade = load_counter_trade(storage, trade_id, counter_id)?;\n\n    if trade.owner == sender.clone() {\n        Ok(trade)\n    } else {\n        Err(ContractError::CounterTraderNotCreator {})\n    }\n}\n\npub fn get_actual_counter_state(\n    storage: \u0026dyn Storage,\n    trade_id: u64,\n    counter_info: \u0026mut TradeInfo,\n) -\u003e StdResult\u003c()\u003e {\n    let trade_info = TRADE_INFO.load(storage, trade_id)?;\n\n    match trade_info.state {\n        TradeState::Refused =\u003e counter_info.state = TradeState::Cancelled,\n        TradeState::Cancelled =\u003e counter_info.state = TradeState::Cancelled,\n        TradeState::Accepted =\u003e match counter_info.state {\n            TradeState::Accepted =\u003e {}\n            _ =\u003e counter_info.state = TradeState::Refused,\n        },\n        _ =\u003e {}\n    }\n    Ok(())\n}\n\npub fn load_counter_trade(\n    storage: \u0026dyn Storage,\n    trade_id: u64,\n    counter_id: u64,\n) -\u003e Result\u003cTradeInfo, ContractError\u003e {\n    let mut counter = COUNTER_TRADE_INFO\n        .load(storage, (trade_id, counter_id))\n        .map_err(|_| ContractError::NotFoundInCounterTradeInfo {})?;\n\n    get_actual_counter_state(storage, trade_id, \u0026mut counter)?;\n\n    Ok(counter)\n}\n\npub fn load_trade(storage: \u0026dyn Storage, trade_id: u64) -\u003e Result\u003cTradeInfo, ContractError\u003e {\n    TRADE_INFO\n        .load(storage, trade_id)\n        .map_err(|_| ContractError::NotFoundInTradeInfo {})\n}\n\npub fn can_suggest_counter_trade(\n    storage: \u0026dyn Storage,\n    trade_id: u64,\n    sender: \u0026Addr,\n) -\u003e Result\u003cTradeInfo, ContractError\u003e {\n    if let Ok(Some(trade)) = TRADE_INFO.may_load(storage, trade_id) {\n        if (trade.state == TradeState::Published) | (trade.state == TradeState::Countered) {\n            if !trade.whitelisted_users.is_empty() {\n                if !trade.whitelisted_users.contains(sender) {\n                    Err(ContractError::AddressNotWhitelisted {})\n                } else {\n                    Ok(trade)\n                }\n            } else {\n                Ok(trade)\n            }\n        } else {\n            Err(ContractError::NotCounterable {})\n        }\n    } else {\n        Err(ContractError::NotFoundInTradeInfo {})\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","p2p-trading","src","trade.rs"],"content":"use cosmwasm_std::{\n    Addr, Api, BankMsg, Deps, DepsMut, Env, MessageInfo, Response, StdResult, Storage, Uint128,\n};\n\nuse std::collections::HashSet;\nuse std::iter::FromIterator;\n\nuse cw1155::Cw1155ExecuteMsg;\nuse cw20::Cw20ExecuteMsg;\nuse cw721::Cw721ExecuteMsg;\n\nuse p2p_trading_export::msg::{into_cosmos_msg, QueryFilters};\nuse p2p_trading_export::state::{\n    AdditionnalTradeInfo, AssetInfo, Comment, CounterTradeInfo, TradeInfo, TradeState,\n};\n\nuse crate::error::ContractError;\nuse crate::messages::set_comment;\nuse crate::query::query_all_trades;\nuse crate::state::{\n    add_cw1155_coin, add_cw20_coin, add_cw721_coin, add_funds, is_trader, load_counter_trade,\n    CONTRACT_INFO, COUNTER_TRADE_INFO, TRADE_INFO,\n};\n\n/// Query the last trade created by the owner.\n/// This should only be used in the same transaction as the trade creation.\n/// Otherwise, specify the trade_id directly in the transaction\npub fn get_last_trade_id_created(deps: Deps, by: String) -\u003e Result\u003cu64, ContractError\u003e {\n    Ok(query_all_trades(\n        deps,\n        None,\n        Some(1),\n        Some(QueryFilters {\n            owner: Some(by),\n            ..QueryFilters::default()\n        }),\n    )?\n    .trades[0]\n        .trade_id)\n}\n\n/// Create a new trade and assign it a unique id\npub fn create_trade(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    whitelisted_users: Option\u003cVec\u003cString\u003e\u003e,\n    comment: Option\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // We start by creating a new trade_id (simply incremented from the last id)\n    let trade_id: u64 = CONTRACT_INFO\n        .update(deps.storage, |mut c| -\u003e StdResult\u003c_\u003e {\n            c.last_trade_id = c.last_trade_id.map_or(Some(0), |id| Some(id + 1));\n            Ok(c)\n        })?\n        .last_trade_id\n        .unwrap(); // This is safe because of the function architecture just there\n\n    TRADE_INFO.update(deps.storage, trade_id, |trade| match trade {\n        // If the trade id already exists, the contract is faulty\n        // Or an external error happened, or whatever...\n        // In that case, we emit an error\n        // The priority is : We do not want to overwrite existing data\n        Some(_) =\u003e Err(ContractError::ExistsInTradeInfo {}),\n        None =\u003e Ok(TradeInfo {\n            owner: info.sender.clone(),\n            additionnal_info: AdditionnalTradeInfo {\n                time: env.block.time,\n                ..Default::default()\n            },\n            ..Default::default()\n        }),\n    })?;\n\n    // We add withlisted addresses\n    if let Some(whitelist) = whitelisted_users {\n        add_whitelisted_users(\n            deps.storage,\n            deps.api,\n            env.clone(),\n            info.clone(),\n            trade_id,\n            whitelist,\n        )?;\n    }\n\n    // And the eventual comment sent along with the transaction\n    if let Some(comment) = comment {\n        set_comment(deps, env, info.clone(), trade_id, None, comment)?;\n    }\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"create_trade\")\n        .add_attribute(\"trade_id\", trade_id.to_string())\n        .add_attribute(\"trader\", info.sender))\n}\n\n/// We verify the trader is indeed the sender and the trade can be modified\npub fn can_modify_trade(\n    storage: \u0026dyn Storage,\n    trader: Addr,\n    trade_id: u64,\n) -\u003e Result\u003cTradeInfo, ContractError\u003e {\n    let trade_info = is_trader(storage, \u0026trader, trade_id)?;\n    // 3.\n    if trade_info.state != TradeState::Created {\n        return Err(ContractError::WrongTradeState {\n            state: trade_info.state,\n        });\n    }\n    Ok(trade_info)\n}\n\npub fn trade_id_or_last(\n    deps: Deps,\n    trader: Addr,\n    trade_id: Option\u003cu64\u003e,\n) -\u003e Result\u003cu64, ContractError\u003e {\n    match trade_id {\n        Some(trade_id) =\u003e Ok(trade_id),\n        None =\u003e get_last_trade_id_created(deps, trader.to_string()),\n    }\n}\n\n/// We prepare the info before asset addition\n/// 1. If the trade_id is not specified, we get the last trade_id created by the sender\n/// 2. We verify the trade can be modified\npub fn prepare_trade_modification(\n    deps: Deps,\n    trader: Addr,\n    trade_id: Option\u003cu64\u003e,\n) -\u003e Result\u003c(u64, TradeInfo), ContractError\u003e {\n    let trade_id = trade_id_or_last(deps, trader.clone(), trade_id)?;\n    let trade_info = can_modify_trade(deps.storage, trader, trade_id)?;\n    Ok((trade_id, trade_info))\n}\n\npub fn _create_receive_asset_messages(\n    env: Env,\n    info: MessageInfo,\n    asset: AssetInfo,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    Ok(match asset {\n        AssetInfo::Coin(coin) =\u003e Response::new()\n            .add_attribute(\"action\", \"add_asset\")\n            .add_attribute(\"asset_type\", \"fund\")\n            .add_attribute(\"denom\", coin.denom)\n            .add_attribute(\"amount\", coin.amount),\n        AssetInfo::Cw20Coin(token) =\u003e {\n            let message = Cw20ExecuteMsg::TransferFrom {\n                owner: info.sender.to_string(),\n                recipient: env.contract.address.into(),\n                amount: token.amount,\n            };\n            Response::new()\n                .add_message(into_cosmos_msg(message, token.address.clone())?)\n                .add_attribute(\"action\", \"add_asset\")\n                .add_attribute(\"asset_type\", \"token\")\n                .add_attribute(\"token\", token.address)\n                .add_attribute(\"amount\", token.amount)\n        }\n        AssetInfo::Cw721Coin(token) =\u003e {\n            let message = Cw721ExecuteMsg::TransferNft {\n                recipient: env.contract.address.into(),\n                token_id: token.token_id.clone(),\n            };\n\n            Response::new()\n                .add_message(into_cosmos_msg(message, token.address.clone())?)\n                .add_attribute(\"action\", \"add_asset\")\n                .add_attribute(\"asset_type\", \"NFT\")\n                .add_attribute(\"nft\", token.address)\n                .add_attribute(\"token_id\", token.token_id)\n        }\n        AssetInfo::Cw1155Coin(token) =\u003e {\n            let message = Cw1155ExecuteMsg::SendFrom {\n                from: info.sender.to_string(),\n                to: env.contract.address.into(),\n                token_id: token.token_id.clone(),\n                value: token.value,\n                msg: None,\n            };\n\n            Response::new()\n                .add_message(into_cosmos_msg(message, token.address.clone())?)\n                .add_attribute(\"action\", \"add_asset\")\n                .add_attribute(\"asset_type\", \"cw1155\")\n                .add_attribute(\"token\", token.address)\n                .add_attribute(\"token_id\", token.token_id)\n                .add_attribute(\"amount\", token.value)\n        }\n    })\n}\n\n/// Adding a new asset to a trade.\n/// This function handles 4 different types of assets\npub fn add_asset_to_trade(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    trade_id: Option\u003cu64\u003e,\n    asset: AssetInfo,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let (trade_id, _trade_info) =\n        prepare_trade_modification(deps.as_ref(), info.sender.clone(), trade_id)?;\n\n    match asset.clone() {\n        AssetInfo::Coin(coin) =\u003e {\n            TRADE_INFO.update(deps.storage, trade_id, add_funds(coin, info.funds.clone()))\n        }\n        AssetInfo::Cw20Coin(token) =\u003e TRADE_INFO.update(\n            deps.storage,\n            trade_id,\n            add_cw20_coin(token.address.clone(), token.amount),\n        ),\n        AssetInfo::Cw721Coin(token) =\u003e TRADE_INFO.update(\n            deps.storage,\n            trade_id,\n            add_cw721_coin(token.address.clone(), token.token_id),\n        ),\n        AssetInfo::Cw1155Coin(token) =\u003e TRADE_INFO.update(\n            deps.storage,\n            trade_id,\n            add_cw1155_coin(token.address.clone(), token.token_id.clone(), token.value),\n        ),\n    }?;\n\n    // Now we need to transfer the token\n    Ok(_create_receive_asset_messages(env, info.clone(), asset)?\n        .add_attribute(\"trade_id\", trade_id.to_string())\n        .add_attribute(\"trader\", info.sender))\n}\n\n/// Allows to withdraw assets while creating a trade\n/// The assets vector specifies a position (u16) and an asset Info (AssetInfo)\n/// The u16 is simply the position of the asset in the associated_assets vector of the TradeInfo struct\n/// This position is accessible when querying the TradeInfo.\n/// We made this choice to avoid looping over assets when withdrawing unique assets.\n/// This allows users to withdraw single assets without a risk of running out of gas.\npub fn withdraw_trade_assets_while_creating(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    trade_id: u64,\n    assets: Vec\u003c(u16, AssetInfo)\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // We verify the sender is allowed to withdraw funds\n    let mut trade_info = is_trader(deps.storage, \u0026info.sender, trade_id)?;\n    if trade_info.state != TradeState::Created {\n        return Err(ContractError::TradeAlreadyPublished {});\n    }\n    _are_assets_in_trade(\u0026trade_info, \u0026assets)?;\n\n    // We withdraw the assets\n    _try_withdraw_assets_unsafe(\u0026mut trade_info, \u0026assets)?;\n    TRADE_INFO.save(deps.storage, trade_id, \u0026trade_info)?;\n\n    // We send the assets back to the sender\n    let res = _create_withdraw_messages_unsafe(\n        \u0026env.contract.address,\n        \u0026info.sender,\n        \u0026assets.iter().map(|x| x.1.clone()).collect(),\n    )?;\n    Ok(res\n        .add_attribute(\"action\", \"remove_from_trade\")\n        .add_attribute(\"trade_id\", trade_id.to_string())\n        .add_attribute(\"trader\", trade_info.owner))\n}\n\n/// Helper function to verify the specified `assets` indeed exist in the trade and have the right position specified\npub fn _are_assets_in_trade(\n    trade_info: \u0026TradeInfo,\n    assets: \u0026[(u16, AssetInfo)],\n) -\u003e Result\u003c(), ContractError\u003e {\n    // We first treat the assets\n    for (position, asset) in assets {\n        let position: usize = (*position).into();\n\n        if position \u003e= trade_info.associated_assets.len() {\n            return Err(ContractError::AssetNotFound { position });\n        }\n        let asset_info: AssetInfo = trade_info.associated_assets[position].clone();\n        match asset_info {\n            AssetInfo::Coin(fund_info) =\u003e {\n                // We check the fund is the one we want\n                if let AssetInfo::Coin(fund) = asset {\n                    // We verify the sent information matches the saved fund\n                    if fund_info.denom != fund.denom {\n                        return Err(ContractError::AssetNotFound { position });\n                    }\n                    if fund_info.amount \u003c fund.amount {\n                        return Err(ContractError::TooMuchWithdrawn {\n                            address: fund_info.denom,\n                            wanted: fund.amount.u128(),\n                            available: fund_info.amount.u128(),\n                        });\n                    }\n                }\n            }\n\n            AssetInfo::Cw20Coin(token_info) =\u003e {\n                // We check the token is the one we want\n                if let AssetInfo::Cw20Coin(token) = asset {\n                    // We verify the sent information matches the saved token\n                    if token_info.address != token.address {\n                        return Err(ContractError::AssetNotFound { position });\n                    }\n                    if token_info.amount \u003c token.amount {\n                        return Err(ContractError::TooMuchWithdrawn {\n                            address: token_info.address,\n                            wanted: token.amount.u128(),\n                            available: token_info.amount.u128(),\n                        });\n                    }\n                } else {\n                    return Err(ContractError::AssetNotFound { position });\n                }\n            }\n            AssetInfo::Cw721Coin(nft_info) =\u003e {\n                // We check the token is the one we want\n                if let AssetInfo::Cw721Coin(nft) = asset {\n                    // We verify the sent information matches the saved nft\n                    if nft_info.address != nft.address {\n                        return Err(ContractError::AssetNotFound { position });\n                    }\n                    if nft_info.token_id != nft.token_id {\n                        return Err(ContractError::AssetNotFound { position });\n                    }\n                } else {\n                    return Err(ContractError::AssetNotFound { position });\n                }\n            }\n            AssetInfo::Cw1155Coin(cw1155_info) =\u003e {\n                // We check the token is the one we want\n                if let AssetInfo::Cw1155Coin(cw1155) = asset {\n                    // We verify the sent information matches the saved nft\n                    if cw1155_info.address != cw1155.address {\n                        return Err(ContractError::AssetNotFound { position });\n                    }\n                    if cw1155_info.token_id != cw1155.token_id {\n                        return Err(ContractError::AssetNotFound { position });\n                    }\n                    if cw1155_info.value \u003c cw1155.value {\n                        return Err(ContractError::TooMuchWithdrawn {\n                            address: cw1155_info.address.to_string(),\n                            wanted: cw1155.value.u128(),\n                            available: cw1155_info.value.u128(),\n                        });\n                    }\n                } else {\n                    return Err(ContractError::AssetNotFound { position });\n                }\n            }\n        }\n    }\n\n    Ok(())\n}\n\n/// Helper function to remove withdrawn assets from the trade in the internal data_structure\npub fn _try_withdraw_assets_unsafe(\n    trade_info: \u0026mut TradeInfo,\n    assets: \u0026[(u16, AssetInfo)],\n) -\u003e Result\u003c(), ContractError\u003e {\n    for (position, asset) in assets {\n        let position: usize = (*position).into();\n        let asset_info = trade_info.associated_assets[position].clone();\n        match asset_info {\n            AssetInfo::Coin(mut fund_info) =\u003e {\n                if let AssetInfo::Coin(fund) = asset {\n                    // If everything is in order, we remove the coin from the trade\n                    fund_info.amount -= fund.amount;\n                    trade_info.associated_assets[position] = AssetInfo::Coin(fund_info);\n                }\n            }\n            AssetInfo::Cw20Coin(mut token_info) =\u003e {\n                if let AssetInfo::Cw20Coin(token) = asset {\n                    token_info.amount -= token.amount;\n                    trade_info.associated_assets[position] = AssetInfo::Cw20Coin(token_info);\n                }\n            }\n            AssetInfo::Cw721Coin(mut nft_info) =\u003e {\n                if let AssetInfo::Cw721Coin(_) = asset {\n                    nft_info.address = \"\".to_string();\n                    trade_info.associated_assets[position] = AssetInfo::Cw721Coin(nft_info);\n                }\n            }\n            AssetInfo::Cw1155Coin(mut cw1155_info) =\u003e {\n                if let AssetInfo::Cw1155Coin(cw1155) = asset {\n                    cw1155_info.value -= cw1155.value;\n                    trade_info.associated_assets[position] = AssetInfo::Cw1155Coin(cw1155_info);\n                }\n            }\n        }\n    }\n\n    // Then we remove empty assets from the trade\n    trade_info.associated_assets.retain(|asset| match asset {\n        AssetInfo::Coin(fund) =\u003e fund.amount != Uint128::zero(),\n        AssetInfo::Cw20Coin(token) =\u003e token.amount != Uint128::zero(),\n        AssetInfo::Cw721Coin(nft) =\u003e !nft.address.is_empty(),\n        AssetInfo::Cw1155Coin(cw1155) =\u003e cw1155.value != Uint128::zero(),\n    });\n\n    Ok(())\n}\n\n/// Helper function to create withdraw messages based on a slice of assets.\n/// This function doesn't do any checks and mus be used with caution\n/// We must always verify the sender has the right to withdraw before calling this function\n#[allow(clippy::ptr_arg)]\npub fn _create_withdraw_messages_unsafe(\n    contract_address: \u0026Addr,\n    recipient: \u0026Addr,\n    assets: \u0026Vec\u003cAssetInfo\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut res = Response::new();\n\n    // First the assets\n    for asset in assets {\n        match asset {\n            AssetInfo::Coin(fund) =\u003e {\n                let message = BankMsg::Send {\n                    to_address: recipient.to_string(),\n                    amount: vec![fund.clone()],\n                };\n                res = res\n                    .add_message(message)\n                    .add_attribute(\"asset_type\", \"fund\")\n                    .add_attribute(\"denom\", fund.denom.clone())\n                    .add_attribute(\"amount\", fund.amount);\n            }\n            AssetInfo::Cw20Coin(token) =\u003e {\n                let message = Cw20ExecuteMsg::Transfer {\n                    recipient: recipient.to_string(),\n                    amount: token.amount,\n                };\n                res = res\n                    .add_message(into_cosmos_msg(message, token.address.clone())?)\n                    .add_attribute(\"asset_type\", \"token\")\n                    .add_attribute(\"token\", token.address.clone())\n                    .add_attribute(\"amount\", token.amount);\n            }\n            AssetInfo::Cw721Coin(nft) =\u003e {\n                let message = Cw721ExecuteMsg::TransferNft {\n                    recipient: recipient.to_string(),\n                    token_id: nft.token_id.clone(),\n                };\n                res = res\n                    .add_message(into_cosmos_msg(message, nft.address.clone())?)\n                    .add_attribute(\"asset_type\", \"NFT\")\n                    .add_attribute(\"nft\", nft.address.clone())\n                    .add_attribute(\"token_id\", nft.token_id.clone());\n            }\n            AssetInfo::Cw1155Coin(cw1155) =\u003e {\n                let message = Cw1155ExecuteMsg::SendFrom {\n                    from: contract_address.to_string(),\n                    to: recipient.to_string(),\n                    token_id: cw1155.token_id.clone(),\n                    value: cw1155.value,\n                    msg: None,\n                };\n                res = res\n                    .add_message(into_cosmos_msg(message, cw1155.address.clone())?)\n                    .add_attribute(\"asset_type\", \"Cw1155\")\n                    .add_attribute(\"token\", cw1155.address.clone())\n                    .add_attribute(\"token_id\", cw1155.token_id.clone())\n                    .add_attribute(\"amount\", cw1155.value);\n            }\n        }\n    }\n\n    Ok(res)\n}\n\n/// Check the assets are not already withdrawn and then creates the withdraw messages\npub fn check_and_create_withdraw_messages(\n    env: Env,\n    recipient: \u0026Addr,\n    trade_info: \u0026TradeInfo,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    if trade_info.assets_withdrawn {\n        return Err(ContractError::TradeAlreadyWithdrawn {});\n    }\n    _create_withdraw_messages_unsafe(\n        \u0026env.contract.address,\n        recipient,\n        \u0026trade_info.associated_assets,\n    )\n}\n\n/// Helper to validate a slice of addresses\npub fn validate_addresses(api: \u0026dyn Api, whitelisted_users: \u0026[String]) -\u003e StdResult\u003cVec\u003cAddr\u003e\u003e {\n    whitelisted_users\n        .iter()\n        .map(|x| api.addr_validate(x))\n        .collect()\n}\n\n/// Add new whitelisted users to a trade\npub fn add_whitelisted_users(\n    storage: \u0026mut dyn Storage,\n    api: \u0026dyn Api,\n    _env: Env,\n    info: MessageInfo,\n    trade_id: u64,\n    whitelisted_users: Vec\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // We verify the trade can be modified\n    let mut trade_info = can_modify_trade(storage, info.sender.clone(), trade_id)?;\n    // We modify the whitelist\n    let hash_set: HashSet\u003cAddr\u003e = HashSet::from_iter(validate_addresses(api, \u0026whitelisted_users)?);\n    trade_info.whitelisted_users = trade_info\n        .whitelisted_users\n        .union(\u0026hash_set)\n        .cloned()\n        .collect();\n    TRADE_INFO.save(storage, trade_id, \u0026trade_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"modify_parameter\")\n        .add_attribute(\"name\", \"whitelisted_users\")\n        .add_attribute(\"operation_type\", \"add\")\n        .add_attribute(\"value\", whitelisted_users.join(\",\"))\n        .add_attribute(\"trade_id\", trade_id.to_string())\n        .add_attribute(\"trader\", info.sender))\n}\n\n/// Remove whitelisted users from a trade\npub fn remove_whitelisted_users(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    trade_id: u64,\n    whitelisted_users: Vec\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // We verify the trade can be modified\n    let mut trade_info = can_modify_trade(deps.storage, info.sender.clone(), trade_id)?;\n    // We modify the whitelist\n    let valid_whitelisted_users = validate_addresses(deps.api, \u0026whitelisted_users)?;\n    for user in \u0026valid_whitelisted_users {\n        trade_info.whitelisted_users.remove(user);\n    }\n    TRADE_INFO.save(deps.storage, trade_id, \u0026trade_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"modify_parameter\")\n        .add_attribute(\"name\", \"whitelisted_users\")\n        .add_attribute(\"operation_type\", \"remove\")\n        .add_attribute(\"value\", whitelisted_users.join(\",\"))\n        .add_attribute(\"trade_id\", trade_id.to_string())\n        .add_attribute(\"trader\", info.sender))\n}\n\n/// Add wanted nfts (only informational) to a trade\npub fn add_nfts_wanted(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    trade_id: Option\u003cu64\u003e,\n    nfts_wanted: Vec\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // We verify the trade can be modified\n    let (trade_id, mut trade_info) =\n        prepare_trade_modification(deps.as_ref(), info.sender.clone(), trade_id)?;\n    // We modify the nfts wanted\n    let hash_set: HashSet\u003cAddr\u003e = HashSet::from_iter(validate_addresses(deps.api, \u0026nfts_wanted)?);\n    trade_info.additionnal_info.nfts_wanted = trade_info\n        .additionnal_info\n        .nfts_wanted\n        .union(\u0026hash_set)\n        .cloned()\n        .collect();\n\n    TRADE_INFO.save(deps.storage, trade_id, \u0026trade_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"modify_parameter\")\n        .add_attribute(\"name\", \"nfts_wanted\")\n        .add_attribute(\"operation_type\", \"add\")\n        .add_attribute(\"value\", nfts_wanted.join(\",\"))\n        .add_attribute(\"trade_id\", trade_id.to_string())\n        .add_attribute(\"trader\", info.sender))\n}\n\n/// Remove wanted nfts (only informational) from a trade\npub fn remove_nfts_wanted(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    trade_id: u64,\n    nfts_wanted: Vec\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // We verify the trade can be modified\n    let mut trade_info = can_modify_trade(deps.storage, info.sender.clone(), trade_id)?;\n    // We modify the whitelist\n    let valid_nfts_wanted = validate_addresses(deps.api, \u0026nfts_wanted)?;\n    for nft in \u0026valid_nfts_wanted {\n        trade_info.additionnal_info.nfts_wanted.remove(nft);\n    }\n    TRADE_INFO.save(deps.storage, trade_id, \u0026trade_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"modify_parameter\")\n        .add_attribute(\"name\", \"nfts_wanted\")\n        .add_attribute(\"operation_type\", \"remove\")\n        .add_attribute(\"value\", nfts_wanted.join(\",\"))\n        .add_attribute(\"trade_id\", trade_id.to_string())\n        .add_attribute(\"trader\", info.sender))\n}\n\n/// Confirm (and publish) a trade when creation is finished\npub fn confirm_trade(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    trade_id: Option\u003cu64\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // We verify the trade can ve published\n    let trade_id = trade_id_or_last(deps.as_ref(), info.sender.clone(), trade_id)?;\n    let mut trade_info = is_trader(deps.storage, \u0026info.sender, trade_id)?;\n    if trade_info.state != TradeState::Created {\n        return Err(ContractError::CantChangeTradeState {\n            from: trade_info.state,\n            to: TradeState::Published,\n        });\n    }\n    // We set the state as published\n    trade_info.state = TradeState::Published;\n    TRADE_INFO.save(deps.storage, trade_id, \u0026trade_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"confirm_trade\")\n        .add_attribute(\"trade_id\", trade_id.to_string())\n        .add_attribute(\"trader\", info.sender))\n}\n\n/// Accept a counter trade\npub fn accept_trade(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    trade_id: u64,\n    counter_id: u64,\n    comment: Option\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // Only the initial trader can accept a trade\n    let mut trade_info = is_trader(deps.storage, \u0026info.sender, trade_id)?;\n    // We check the counter trade exists\n    let mut counter_info = load_counter_trade(deps.storage, trade_id, counter_id)?;\n\n    // We check we can accept the trade\n    if trade_info.state != TradeState::Countered {\n        // TARPAULIN : This code does not seem to be reachable\n        return Err(ContractError::CantChangeTradeState {\n            from: trade_info.state,\n            to: TradeState::Accepted,\n        });\n    }\n    // We check this specific counter trade can be accepted\n    if counter_info.state != TradeState::Published {\n        return Err(ContractError::CantAcceptNotPublishedCounter {});\n    }\n\n    // We accept the trade\n    // We update the trade accepted info to make indexing easier\n    let accepted_info = CounterTradeInfo {\n        trade_id,\n        counter_id,\n    };\n    trade_info.state = TradeState::Accepted;\n    trade_info.accepted_info = Some(accepted_info);\n    TRADE_INFO.save(deps.storage, trade_id, \u0026trade_info)?;\n\n    // We update the coounter info comment and state\n    counter_info.additionnal_info.trader_comment = comment.map(|comment| Comment {\n        time: env.block.time,\n        comment,\n    });\n    counter_info.state = TradeState::Accepted;\n    COUNTER_TRADE_INFO.save(deps.storage, (trade_id, counter_id), \u0026counter_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"accept_counter_trade\")\n        .add_attribute(\"trade_id\", trade_id.to_string())\n        .add_attribute(\"counter_id\", counter_id.to_string())\n        .add_attribute(\"trader\", trade_info.owner)\n        .add_attribute(\"counter_trader\", counter_info.owner))\n}\n\n/// Refuse a counter trade\n/// This function is only informational and not needed if the user doesn't deem it necessary\npub fn refuse_counter_trade(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    trade_id: u64,\n    counter_id: u64,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // Only the initial trader can refuse a trade\n    let trade_info = is_trader(deps.storage, \u0026info.sender, trade_id)?;\n    // We check the counter trade exists\n    let mut counter_info = load_counter_trade(deps.storage, trade_id, counter_id)?;\n\n    if trade_info.state == TradeState::Accepted {\n        return Err(ContractError::TradeAlreadyAccepted {});\n    }\n    if trade_info.state == TradeState::Cancelled {\n        return Err(ContractError::TradeCancelled {});\n    }\n    counter_info.state = TradeState::Refused;\n    COUNTER_TRADE_INFO.save(deps.storage, (trade_id, counter_id), \u0026counter_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"refuse_counter_trade\")\n        .add_attribute(\"trade_id\", trade_id.to_string())\n        .add_attribute(\"counter_id\", counter_id.to_string())\n        .add_attribute(\"trader\", trade_info.owner)\n        .add_attribute(\"counter_trader\", counter_info.owner))\n}\n\n/// Cancel a trade\n/// The trade isn't modifiable, but the funds are withdrawnable after this call.\npub fn cancel_trade(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    trade_id: u64,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // Only the initial trader can cancel the trade\n    let mut trade_info = is_trader(deps.storage, \u0026info.sender, trade_id)?;\n\n    // We can't cancel an accepted trade\n    if trade_info.state == TradeState::Accepted {\n        return Err(ContractError::CantChangeTradeState {\n            from: trade_info.state,\n            to: TradeState::Cancelled,\n        });\n    }\n\n    // We change the trade state\n    trade_info.state = TradeState::Cancelled;\n    TRADE_INFO.save(deps.storage, trade_id, \u0026trade_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"cancel_trade\")\n        .add_attribute(\"trade_id\", trade_id.to_string())\n        .add_attribute(\"trader\", trade_info.owner))\n}\n\n/// Withdraw all assets from a created (not published yet) or cancelled trade\n/// If the trade is only in the created state, it is automatically cancelled before withdrawing assets\npub fn withdraw_all_from_trade(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    trade_id: u64,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // We load the trade and verify it has the right trader\n    let mut trade_info = is_trader(deps.storage, \u0026info.sender, trade_id)?;\n\n    // If the trade was just created, we cancel it on the spot\n    if trade_info.state == TradeState::Created {\n        trade_info.state = TradeState::Cancelled;\n    }\n    // This funtion is only callable if the trade is cancelled\n    if trade_info.state != TradeState::Cancelled {\n        return Err(ContractError::TradeNotCancelled {});\n    }\n\n    let res = check_and_create_withdraw_messages(env, \u0026info.sender, \u0026trade_info)?;\n    trade_info.assets_withdrawn = true;\n    TRADE_INFO.save(deps.storage, trade_id, \u0026trade_info)?;\n\n    Ok(res\n        .add_attribute(\"action\", \"withdraw_all_funds\")\n        .add_attribute(\"type\", \"trade\")\n        .add_attribute(\"trade_id\", trade_id.to_string())\n        .add_attribute(\"trader\", trade_info.owner))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","raffles","examples","p2p_schema.rs"],"content":"use std::env::current_dir;\nuse std::fs::create_dir_all;\n\nuse cosmwasm_schema::{export_schema, remove_schemas, schema_for};\n\nuse raffles_export::msg::{ExecuteMsg, InstantiateMsg, QueryMsg};\n\nfn main() {\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"schema\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n\n    export_schema(\u0026schema_for!(InstantiateMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(ExecuteMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(QueryMsg), \u0026out_dir);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","raffles","src","contract.rs"],"content":"use anyhow::{anyhow, Result};\nuse cosmwasm_std::entry_point;\nuse cosmwasm_std::{\n    from_binary, to_binary, Addr, Binary, Coin, Deps, DepsMut, Env, Event, MessageInfo, Reply,\n    Response, StdError, StdResult, SubMsgResult, Timestamp, Uint128,\n};\n#[cfg(not(feature = \"library\"))]\nuse std::convert::TryInto;\n\nuse cw2::set_contract_version;\n\nuse crate::error::ContractError;\n\nuse crate::state::{\n    assert_randomness_origin_and_order, can_buy_ticket, get_asset_amount,\n    get_raffle_owner_finished_messages, get_raffle_state, get_raffle_winner,\n    get_raffle_winner_message, is_owner, load_raffle, CONTRACT_INFO, RAFFLE_INFO,\n};\nuse raffles_export::msg::{\n    into_cosmos_msg, DrandRandomness, ExecuteMsg, InstantiateMsg, MigrateMsg, QueryMsg,\n};\nuse raffles_export::state::{\n    AssetInfo, ContractInfo, Cw1155Coin, Cw20Coin, Cw721Coin, RaffleInfo, RaffleState,\n    MAXIMUM_PARTICIPANT_NUMBER, MINIMUM_RAFFLE_DURATION, MINIMUM_RAFFLE_TIMEOUT, MINIMUM_RAND_FEE,\n};\n\nuse cw1155::Cw1155ExecuteMsg;\nuse cw20::Cw20ExecuteMsg;\nuse cw721::Cw721ExecuteMsg;\n\nuse crate::query::{query_all_raffles, query_contract_info};\n\nconst CONTRACT_NAME: \u0026str = \"illiquidlabs.io:raffles\";\nconst CONTRACT_VERSION: \u0026str = \"0.1.0\";\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // Verify the contract name\n\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    msg.validate()?;\n    // store token info\n    let data = ContractInfo {\n        name: msg.name,\n        owner: deps\n            .api\n            .addr_validate(\u0026msg.owner.unwrap_or_else(|| info.sender.to_string()))?,\n        fee_addr: deps\n            .api\n            .addr_validate(\u0026msg.fee_addr.unwrap_or_else(|| info.sender.to_string()))?,\n        last_raffle_id: None,\n        minimum_raffle_duration: msg\n            .minimum_raffle_duration\n            .unwrap_or(MINIMUM_RAFFLE_DURATION)\n            .max(MINIMUM_RAFFLE_DURATION),\n        minimum_raffle_timeout: msg\n            .minimum_raffle_timeout\n            .unwrap_or(MINIMUM_RAFFLE_TIMEOUT)\n            .max(MINIMUM_RAFFLE_TIMEOUT),\n        raffle_fee: msg.raffle_fee.unwrap_or(Uint128::zero()),\n        rand_fee: msg\n            .rand_fee\n            .unwrap_or_else(|| Uint128::from(MINIMUM_RAND_FEE)),\n        lock: false,\n        drand_url: msg\n            .drand_url\n            .unwrap_or_else(|| \"https://api.drand.sh/\".to_string()),\n        random_pubkey: msg.random_pubkey,\n        verify_signature_contract: deps.api.addr_validate(\u0026msg.verify_signature_contract)?,\n    };\n    CONTRACT_INFO.save(deps.storage, \u0026data)?;\n    Ok(Response::default()\n        .add_attribute(\"action\", \"init\")\n        .add_attribute(\"contract\", \"raffle\")\n        .add_attribute(\"owner\", data.owner))\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg) -\u003e Result\u003cResponse\u003e {\n    match msg {\n        ExecuteMsg::CreateRaffle {\n            asset,\n            raffle_start_timestamp,\n            raffle_duration,\n            raffle_timeout,\n            comment,\n            raffle_ticket_price,\n            max_participant_number,\n        } =\u003e execute_create_raffle(\n            deps,\n            env,\n            info,\n            asset,\n            raffle_start_timestamp,\n            raffle_duration,\n            raffle_timeout,\n            comment,\n            raffle_ticket_price,\n            max_participant_number,\n        ),\n        ExecuteMsg::BuyTicket {\n            raffle_id,\n            sent_assets,\n        } =\u003e execute_buy_ticket(deps, env, info, raffle_id, sent_assets),\n        ExecuteMsg::Receive {\n            sender,\n            amount,\n            msg,\n        } =\u003e execute_receive(deps, env, info, sender, amount, msg),\n        ExecuteMsg::ReceiveNft {\n            sender,\n            token_id,\n            msg,\n        } =\u003e execute_receive_nft(deps, env, info, sender, token_id, msg),\n        ExecuteMsg::Cw1155ReceiveMsg {\n            operator,\n            from,\n            token_id,\n            amount,\n            msg,\n        } =\u003e execute_receive_1155(\n            deps,\n            env,\n            info,\n            from.unwrap_or(operator),\n            token_id,\n            amount,\n            msg,\n        ),\n        ExecuteMsg::ClaimNft { raffle_id } =\u003e execute_claim(deps, env, info, raffle_id),\n        ExecuteMsg::UpdateRandomness {\n            raffle_id,\n            randomness,\n        } =\u003e execute_update_randomness(deps, env, info, raffle_id, randomness),\n\n        // Admin messages\n        ExecuteMsg::ToggleLock { lock } =\u003e execute_toggle_lock(deps, env, info, lock),\n        ExecuteMsg::Renounce {} =\u003e execute_renounce(deps, env, info),\n        ExecuteMsg::ChangeParameter { parameter, value } =\u003e {\n            execute_change_parameter(deps, env, info, parameter, value)\n        }\n    }\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn migrate(_deps: DepsMut, _env: Env, _msg: MigrateMsg) -\u003e Result\u003cResponse, ContractError\u003e {\n    // No state migrations performed, just returned a Response\n    Ok(Response::default())\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, env: Env, msg: QueryMsg) -\u003e Result\u003cBinary\u003e {\n    match msg {\n        QueryMsg::ContractInfo {} =\u003e to_binary(\u0026query_contract_info(deps)?).map_err(|x| anyhow!(x)),\n        QueryMsg::RaffleInfo { raffle_id } =\u003e {\n            to_binary(\u0026load_raffle(deps.storage, raffle_id)?).map_err(|x| anyhow!(x))\n        }\n\n        QueryMsg::GetAllRaffles {\n            start_after,\n            limit,\n            filters,\n        } =\u003e to_binary(\u0026query_all_raffles(deps, env, start_after, limit, filters)?)\n            .map_err(|x| anyhow!(x)),\n    }\n}\n\n/// Replace the current contract owner with the provided owner address\n/// * `owner` must be a valid Terra address\n/// The owner has limited power on this contract :\n/// 1. Change the contract owner\n/// 2. Change the fee contract\npub fn execute_renounce(deps: DepsMut, env: Env, info: MessageInfo) -\u003e Result\u003cResponse\u003e {\n    let mut contract_info = is_owner(deps.storage, info.sender)?;\n\n    contract_info.owner = env.contract.address;\n    CONTRACT_INFO.save(deps.storage, \u0026contract_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"modify_parameter\")\n        .add_attribute(\"parameter\", \"owner\")\n        .add_attribute(\"value\", contract_info.owner))\n}\n\n/// Replace the current fee_contract with the provided fee_contract address\n/// * `fee_addr` must be a valid Terra address\npub fn set_new_fee_addr(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    fee_addr: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut contract_info = is_owner(deps.storage, info.sender)?;\n\n    let fee_addr = deps.api.addr_validate(\u0026fee_addr)?;\n    contract_info.fee_addr = fee_addr.clone();\n    CONTRACT_INFO.save(deps.storage, \u0026contract_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"modify_parameter\")\n        .add_attribute(\"parameter\", \"fee_addr\")\n        .add_attribute(\"value\", fee_addr))\n}\n\npub fn execute_toggle_lock(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    lock: bool,\n) -\u003e Result\u003cResponse\u003e {\n    let mut contract_info = is_owner(deps.storage, info.sender)?;\n\n    contract_info.lock = lock;\n    CONTRACT_INFO.save(deps.storage, \u0026contract_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"modify_parameter\")\n        .add_attribute(\"parameter\", \"contract_lock\")\n        .add_attribute(\"value\", lock.to_string()))\n}\n\npub fn execute_change_parameter(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    parameter: String,\n    value: String,\n) -\u003e Result\u003cResponse\u003e {\n    let mut contract_info = is_owner(deps.storage, info.sender)?;\n\n    match parameter.as_str() {\n        \"fee_addr\" =\u003e {\n            let addr = deps.api.addr_validate(\u0026value)?;\n            contract_info.fee_addr = addr;\n        }\n        \"minimum_raffle_duration\" =\u003e {\n            let time = value.parse::\u003cu64\u003e()?;\n            contract_info.minimum_raffle_duration = time;\n        }\n        \"minimum_raffle_timeout\" =\u003e {\n            let time = value.parse::\u003cu64\u003e()?;\n            contract_info.minimum_raffle_timeout = time;\n        }\n        \"raffle_fee\" =\u003e {\n            let fee = Uint128::from(value.parse::\u003cu128\u003e()?);\n            contract_info.raffle_fee = fee;\n        }\n        \"rand_fee\" =\u003e {\n            let fee = Uint128::from(value.parse::\u003cu128\u003e()?);\n            contract_info.rand_fee = fee;\n        }\n        \"drand_url\" =\u003e {\n            contract_info.drand_url = value.clone();\n        }\n        \"verify_signature_contract\" =\u003e {\n            let addr = deps.api.addr_validate(\u0026value)?;\n            contract_info.verify_signature_contract = addr;\n        }\n        \"random_pubkey\" =\u003e {\n            contract_info.random_pubkey = Binary::from_base64(\u0026value).unwrap();\n        }\n        _ =\u003e return Err(anyhow!(ContractError::ParameterNotFound {})),\n    }\n\n    CONTRACT_INFO.save(deps.storage, \u0026contract_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"modify_parameter\")\n        .add_attribute(\"parameter\", parameter)\n        .add_attribute(\"value\", value))\n}\n\n/// Create a new raffle by depositing assets\n#[allow(clippy::too_many_arguments)]\npub fn execute_create_raffle(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    asset: AssetInfo,\n    raffle_start_timestamp: Option\u003cu64\u003e,\n    raffle_duration: Option\u003cu64\u003e,\n    raffle_timeout: Option\u003cu64\u003e,\n    comment: Option\u003cString\u003e,\n    raffle_ticket_price: AssetInfo,\n    max_participant_number: Option\u003cu64\u003e,\n) -\u003e Result\u003cResponse\u003e {\n    let contract_info = CONTRACT_INFO.load(deps.storage)?;\n\n    if contract_info.lock {\n        return Err(anyhow!(ContractError::ContractIsLocked {}));\n    }\n\n    // First we physcially transfer the AssetInfo\n    let transfer_message = match \u0026asset {\n        AssetInfo::Cw721Coin(token) =\u003e {\n            let message = Cw721ExecuteMsg::TransferNft {\n                recipient: env.contract.address.clone().into(),\n                token_id: token.token_id.clone(),\n            };\n\n            into_cosmos_msg(message, token.address.clone())?\n        }\n        AssetInfo::Cw1155Coin(token) =\u003e {\n            let message = Cw1155ExecuteMsg::SendFrom {\n                from: info.sender.to_string(),\n                to: env.contract.address.clone().into(),\n                token_id: token.token_id.clone(),\n                value: token.value,\n                msg: None,\n            };\n\n            into_cosmos_msg(message, token.address.clone())?\n        }\n        _ =\u003e return Err(anyhow!(ContractError::WrongAssetType {})),\n    };\n    // Then we create the internal raffle structure\n    let raffle_id = _create_raffle(\n        deps,\n        env,\n        info.sender.clone(),\n        asset,\n        raffle_start_timestamp,\n        raffle_duration,\n        raffle_timeout,\n        comment,\n        raffle_ticket_price,\n        max_participant_number,\n    )?;\n\n    Ok(Response::new()\n        .add_message(transfer_message)\n        .add_attribute(\"action\", \"create_raffle\")\n        .add_attribute(\"raffle_id\", raffle_id.to_string())\n        .add_attribute(\"owner\", info.sender))\n}\n\n/// Create a new raffle by depositing assets\npub fn execute_receive_nft(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    sender: String,\n    token_id: String,\n    msg: Binary,\n) -\u003e Result\u003cResponse\u003e {\n    let sender = deps.api.addr_validate(\u0026sender)?;\n    match from_binary(\u0026msg)? {\n        ExecuteMsg::CreateRaffle {\n            asset,\n            raffle_start_timestamp,\n            raffle_duration,\n            raffle_timeout,\n            comment,\n            raffle_ticket_price,\n            max_participant_number,\n        } =\u003e {\n            // First we make sure the received NFT is the one specified in the message\n\n            match asset.clone() {\n                AssetInfo::Cw721Coin(Cw721Coin {\n                    address: address_received,\n                    token_id: token_id_received,\n                }) =\u003e {\n                    if deps.api.addr_validate(\u0026address_received)? == info.sender\n                        \u0026\u0026 token_id_received == token_id\n                    {\n                        // The asset is a match, we can create the raffle object and return\n                        let raffle_id = _create_raffle(\n                            deps,\n                            env,\n                            sender,\n                            asset,\n                            raffle_start_timestamp,\n                            raffle_duration,\n                            raffle_timeout,\n                            comment,\n                            raffle_ticket_price,\n                            max_participant_number,\n                        )?;\n\n                        Ok(Response::new()\n                            .add_attribute(\"action\", \"create_raffle\")\n                            .add_attribute(\"raffle_id\", raffle_id.to_string())\n                            .add_attribute(\"owner\", info.sender))\n                    } else {\n                        Err(anyhow!(ContractError::AssetMismatch {}))\n                    }\n                }\n                _ =\u003e Err(anyhow!(ContractError::AssetMismatch {})),\n            }\n        }\n        _ =\u003e Err(anyhow!(ContractError::Unauthorized {})),\n    }\n}\n\n/// Create a new raffle by depositing assets\npub fn execute_receive_1155(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    from: String,\n    token_id: String,\n    amount: Uint128,\n    msg: Binary,\n) -\u003e Result\u003cResponse\u003e {\n    let sender = deps.api.addr_validate(\u0026from)?;\n    match from_binary(\u0026msg)? {\n        ExecuteMsg::CreateRaffle {\n            asset,\n            raffle_start_timestamp,\n            raffle_duration,\n            raffle_timeout,\n            comment,\n            raffle_ticket_price,\n            max_participant_number,\n        } =\u003e {\n            // First we make sure the received NFT is the one specified in the message\n            match asset.clone() {\n                AssetInfo::Cw1155Coin(Cw1155Coin {\n                    address: address_received,\n                    token_id: token_id_received,\n                    value: value_received,\n                }) =\u003e {\n                    if deps.api.addr_validate(\u0026address_received)? == info.sender\n                        \u0026\u0026 token_id_received == token_id\n                        \u0026\u0026 value_received == amount\n                    {\n                        // The asset is a match, we can create the raffle object and return\n                        let raffle_id = _create_raffle(\n                            deps,\n                            env,\n                            sender,\n                            asset,\n                            raffle_start_timestamp,\n                            raffle_duration,\n                            raffle_timeout,\n                            comment,\n                            raffle_ticket_price,\n                            max_participant_number,\n                        )?;\n\n                        Ok(Response::new()\n                            .add_attribute(\"action\", \"create_raffle\")\n                            .add_attribute(\"raffle_id\", raffle_id.to_string())\n                            .add_attribute(\"owner\", info.sender))\n                    } else {\n                        Err(anyhow!(ContractError::AssetMismatch {}))\n                    }\n                }\n                _ =\u003e Err(anyhow!(ContractError::AssetMismatch {})),\n            }\n        }\n        _ =\u003e Err(anyhow!(ContractError::Unauthorized {})),\n    }\n}\n\n/// Create a new raffle and assign it a unique id\n#[allow(clippy::too_many_arguments)]\npub fn _create_raffle(\n    deps: DepsMut,\n    env: Env,\n    owner: Addr,\n    asset: AssetInfo,\n    raffle_start_timestamp: Option\u003cu64\u003e,\n    raffle_duration: Option\u003cu64\u003e,\n    raffle_timeout: Option\u003cu64\u003e,\n    comment: Option\u003cString\u003e,\n    raffle_ticket_price: AssetInfo,\n    max_participant_number: Option\u003cu64\u003e,\n) -\u003e Result\u003cu64\u003e {\n    let contract_info = CONTRACT_INFO.load(deps.storage)?;\n\n    // We start by creating a new trade_id (simply incremented from the last id)\n    let raffle_id: u64 = CONTRACT_INFO\n        .update(deps.storage, |mut c| -\u003e StdResult\u003c_\u003e {\n            c.last_raffle_id = c.last_raffle_id.map_or(Some(0), |id| Some(id + 1));\n            Ok(c)\n        })?\n        .last_raffle_id\n        .unwrap(); // This is safe because of the function architecture just there\n\n    RAFFLE_INFO.update(deps.storage, raffle_id, |trade| match trade {\n        // If the trade id already exists, the contract is faulty\n        // Or an external error happened, or whatever...\n        // In that case, we emit an error\n        // The priority is : We do not want to overwrite existing data\n        Some(_) =\u003e Err(ContractError::ExistsInRaffleInfo {}),\n        None =\u003e Ok(RaffleInfo {\n            owner,\n            asset,\n            raffle_start_timestamp: raffle_start_timestamp\n                .map(Timestamp::from_seconds)\n                .unwrap_or(env.block.time),\n            raffle_duration: raffle_duration\n                .unwrap_or(contract_info.minimum_raffle_duration)\n                .max(contract_info.minimum_raffle_duration),\n            raffle_timeout: raffle_timeout\n                .unwrap_or(contract_info.minimum_raffle_timeout)\n                .max(contract_info.minimum_raffle_timeout),\n            comment,\n            raffle_ticket_price: raffle_ticket_price.clone(),\n            accumulated_ticket_fee: match raffle_ticket_price {\n                AssetInfo::Cw20Coin(coin) =\u003e AssetInfo::Cw20Coin(Cw20Coin {\n                    address: coin.address,\n                    amount: Uint128::zero(),\n                }),\n                AssetInfo::Coin(coin) =\u003e AssetInfo::Coin(Coin {\n                    denom: coin.denom,\n                    amount: Uint128::zero(),\n                }),\n                _ =\u003e return Err(ContractError::WrongFundsType {}),\n            },\n            tickets: vec![],\n            randomness_owner: None,\n            randomness: \u003c[u8; 32]\u003e::default(),\n            randomness_round: 0,\n            max_participant_number: max_participant_number\n                .unwrap_or(MAXIMUM_PARTICIPANT_NUMBER)\n                .min(MAXIMUM_PARTICIPANT_NUMBER),\n            winner: None,\n        }),\n    })?;\n    Ok(raffle_id)\n}\n\npub fn execute_buy_ticket(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    raffle_id: u64,\n    assets: AssetInfo,\n) -\u003e Result\u003cResponse\u003e {\n    // First we physcially transfer the AssetInfo\n    let transfer_messages = match \u0026assets {\n        AssetInfo::Cw20Coin(token) =\u003e {\n            let message = Cw20ExecuteMsg::Transfer {\n                recipient: env.contract.address.clone().into(),\n                amount: token.amount,\n            };\n\n            vec![into_cosmos_msg(message, token.address.clone())?]\n        }\n        // or verify the sent coins match the message coins\n        AssetInfo::Coin(coin) =\u003e {\n            if info.funds.len() != 1 {\n                return Err(anyhow!(ContractError::AssetMismatch {}));\n            }\n            if info.funds[0].denom != coin.denom || info.funds[0].amount != coin.amount {\n                return Err(anyhow!(ContractError::AssetMismatch {}));\n            }\n            vec![]\n        }\n        _ =\u003e return Err(anyhow!(ContractError::WrongAssetType {})),\n    };\n    // Then we verify the funds sent match the raffle conditions and we save the ticket that was bought\n    _buy_ticket(deps, env, info.sender.clone(), raffle_id, assets)?;\n\n    Ok(Response::new()\n        .add_messages(transfer_messages)\n        .add_attribute(\"action\", \"buy_ticket\")\n        .add_attribute(\"raffle_id\", raffle_id.to_string())\n        .add_attribute(\"owner\", info.sender))\n}\n/// Create a new raffle by depositing assets\npub fn execute_receive(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    sender: String,\n    amount: Uint128,\n    msg: Binary,\n) -\u003e Result\u003cResponse\u003e {\n    let sender = deps.api.addr_validate(\u0026sender)?;\n    match from_binary(\u0026msg)? {\n        ExecuteMsg::BuyTicket {\n            raffle_id,\n            sent_assets,\n        } =\u003e {\n            // First we make sure the received Assets is the one specified in the message\n            match sent_assets.clone() {\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    address: address_received,\n                    amount: amount_received,\n                }) =\u003e {\n                    if deps.api.addr_validate(\u0026address_received)? == info.sender\n                        \u0026\u0026 amount_received == amount\n                    {\n                        // The asset is a match, we can create the raffle object and return\n                        _buy_ticket(deps, env, sender, raffle_id, sent_assets)?;\n\n                        Ok(Response::new()\n                            .add_attribute(\"action\", \"create_raffle\")\n                            .add_attribute(\"raffle_id\", raffle_id.to_string())\n                            .add_attribute(\"owner\", info.sender))\n                    } else {\n                        Err(anyhow!(ContractError::AssetMismatch {}))\n                    }\n                }\n                _ =\u003e Err(anyhow!(ContractError::AssetMismatch {})),\n            }\n        }\n        _ =\u003e Err(anyhow!(ContractError::Unauthorized {})),\n    }\n}\n\npub fn _buy_ticket(\n    deps: DepsMut,\n    env: Env,\n    owner: Addr,\n    raffle_id: u64,\n    assets: AssetInfo,\n) -\u003e Result\u003c()\u003e {\n    let mut raffle_info = RAFFLE_INFO.load(deps.storage, raffle_id)?;\n\n    // We first check the raffle is in the right state\n    can_buy_ticket(env, raffle_info.clone())?;\n\n    // We then check the sent assets match the raffle assets\n    if raffle_info.raffle_ticket_price != assets {\n        return Err(anyhow!(ContractError::PaiementNotSufficient {\n            assets_wanted: raffle_info.raffle_ticket_price,\n            assets_received: assets\n        }));\n    }\n\n    // Then we save the sender to the bought tickets\n    if raffle_info.tickets.len() \u003e= raffle_info.max_participant_number as usize {\n        return Err(anyhow!(ContractError::TooMuchTickets {}));\n    }\n    raffle_info.tickets.push(owner);\n    let ticket_amount = get_asset_amount(raffle_info.raffle_ticket_price.clone())?;\n    let accumulated_amount = get_asset_amount(raffle_info.accumulated_ticket_fee)?;\n    raffle_info.accumulated_ticket_fee = match raffle_info.raffle_ticket_price.clone() {\n        AssetInfo::Cw20Coin(coin) =\u003e AssetInfo::Cw20Coin(Cw20Coin {\n            address: coin.address,\n            amount: accumulated_amount + ticket_amount,\n        }),\n        AssetInfo::Coin(coin) =\u003e AssetInfo::Coin(Coin {\n            denom: coin.denom,\n            amount: accumulated_amount + ticket_amount,\n        }),\n        _ =\u003e return Err(anyhow!(ContractError::WrongFundsType {})),\n    };\n    RAFFLE_INFO.save(deps.storage, raffle_id, \u0026raffle_info)?;\n\n    Ok(())\n}\n\npub fn execute_update_randomness(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    raffle_id: u64,\n    randomness: DrandRandomness,\n) -\u003e Result\u003cResponse\u003e {\n    let raffle_info = RAFFLE_INFO.load(deps.storage, raffle_id)?;\n    let raffle_state = get_raffle_state(env, raffle_info);\n    if raffle_state != RaffleState::Closed {\n        return Err(anyhow!(ContractError::WrongStateForRandmness {\n            status: raffle_state\n        }));\n    }\n    // We assert the randomness is correct\n    assert_randomness_origin_and_order(deps.as_ref(), info.sender, raffle_id, randomness)\n}\n\npub fn execute_claim(\n    deps: DepsMut,\n    env: Env,\n    _info: MessageInfo,\n    raffle_id: u64,\n) -\u003e Result\u003cResponse\u003e {\n    // Loading the raffle object\n    let mut raffle_info = RAFFLE_INFO.load(deps.storage, raffle_id)?;\n\n    // We make sure the raffle is ended\n    let raffle_state = get_raffle_state(env.clone(), raffle_info.clone());\n    if raffle_state != RaffleState::Finished {\n        return Err(anyhow!(ContractError::WrongStateForClaim {\n            status: raffle_state\n        }));\n    }\n\n    // If there was no participant, the winner is the raffle owner and we pay no fees whatsoever\n    if raffle_info.tickets.is_empty() {\n        raffle_info.winner = Some(raffle_info.owner.clone());\n    } else {\n        // We get the winner of the raffle and save it to the contract. The raffle is now claimed !\n        let winner = get_raffle_winner(raffle_info.clone())?;\n        raffle_info.winner = Some(winner);\n    }\n    RAFFLE_INFO.save(deps.storage, raffle_id, \u0026raffle_info)?;\n\n    // We send the asset to the winner\n    let winner_transfer_message = get_raffle_winner_message(env.clone(), raffle_info.clone())?;\n    let funds_transfer_messages =\n        get_raffle_owner_finished_messages(deps.storage, env, raffle_info.clone())?;\n    // We distribute the ticket prices to the owner and in part to the treasury\n    Ok(Response::new()\n        .add_message(winner_transfer_message)\n        .add_messages(funds_transfer_messages)\n        .add_attribute(\"action\", \"claim\")\n        .add_attribute(\"raffle_id\", raffle_id.to_string())\n        .add_attribute(\"winner\", raffle_info.winner.unwrap()))\n}\n\n// Messages triggered after random generation\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn reply(deps: DepsMut, env: Env, msg: Reply) -\u003e Result\u003cResponse, ContractError\u003e {\n    match msg.id {\n        0 =\u003e Ok(verify(deps, env, msg.result)?),\n        _ =\u003e Err(ContractError::Unauthorized {}),\n    }\n}\n\npub fn verify(deps: DepsMut, _env: Env, msg: SubMsgResult) -\u003e Result\u003cResponse, StdError\u003e {\n    match msg {\n        SubMsgResult::Ok(subcall) =\u003e {\n            let event: Event = subcall\n                .events\n                .into_iter()\n                .find(|e| e.ty == \"wasm\")\n                .ok_or_else(|| StdError::generic_err(\"no wasm result\"))?;\n\n            let round = event\n                .attributes\n                .clone()\n                .into_iter()\n                .find(|attr| attr.key == \"round\")\n                .map_or(Err(StdError::generic_err(\"np round response\")), |round| {\n                    round\n                        .value\n                        .parse::\u003cu64\u003e()\n                        .map_err(|_| StdError::generic_err(\"round value is shit\"))\n                })?;\n\n            let randomness: String = event\n                .attributes\n                .clone()\n                .into_iter()\n                .find(|attr| attr.key == \"randomness\")\n                .map(|rand| rand.value)\n                .ok_or_else(|| StdError::generic_err(\"randomnesss value error\"))?;\n\n            let raffle_id: u64 = event\n                .attributes\n                .clone()\n                .into_iter()\n                .find(|attr| attr.key == \"raffle_id\")\n                .map(|raffle_id| raffle_id.value.parse::\u003cu64\u003e())\n                .transpose()\n                .map_err(|_| StdError::generic_err(\"raffle_id parse error\"))?\n                .ok_or_else(|| StdError::generic_err(\"raffle_id parse error 1\"))?;\n\n            let owner = deps.api.addr_validate(\n                \u0026event\n                    .attributes\n                    .into_iter()\n                    .find(|attr| attr.key == \"owner\")\n                    .map(|raffle_id| raffle_id.value)\n                    .ok_or_else(|| StdError::generic_err(\"owner parse err\"))?,\n            )?;\n\n            let mut raffle_info = RAFFLE_INFO.load(deps.storage, raffle_id)?;\n\n            raffle_info.randomness = Binary::from_base64(\u0026randomness)?\n                .as_slice()\n                .try_into()\n                .map_err(|_| StdError::generic_err(\"randomness parse err\"))?;\n            raffle_info.randomness_round = round;\n            raffle_info.randomness_owner = Some(owner.clone());\n            RAFFLE_INFO.save(deps.storage, raffle_id, \u0026raffle_info)?;\n\n            Ok(Response::new()\n                .add_attribute(\"action\", \"update_randomness\")\n                .add_attribute(\"raffle_id\", raffle_id.to_string())\n                .add_attribute(\"sender\", owner))\n        }\n        SubMsgResult::Err(_) =\u003e Err(StdError::generic_err(\"err\")),\n    }\n}\n\n#[cfg(test)]\npub mod tests {\n    use super::*;\n    use base64;\n    use cosmwasm_std::{\n        coin, coins,\n        testing::{mock_dependencies, mock_env, mock_info, MOCK_CONTRACT_ADDR},\n        Api, BankMsg, Coin, SubMsg,\n    };\n    use raffles_export::msg::VerifierExecuteMsg;\n    const HEX_PUBKEY: \u0026str = \"868f005eb8e6e4ca0a47c8a77ceaa5309a47978a7c71bc5cce96366b5d7a569937c529eeda66c7293784a9402801af31\";\n    fn init_helper(deps: DepsMut) {\n        let instantiate_msg = InstantiateMsg {\n            name: \"nft-raffle\".to_string(),\n            owner: None,\n            random_pubkey: Binary::from_base64(\u0026base64::encode(HEX_PUBKEY)).unwrap(),\n            drand_url: None,\n            verify_signature_contract: \"verifier\".to_string(),\n            fee_addr: None,\n            minimum_raffle_timeout: None,\n            minimum_raffle_duration: None,\n            raffle_fee: Some(Uint128::from(2u128)),\n            rand_fee: None,\n        };\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n\n        instantiate(deps, env, info, instantiate_msg).unwrap();\n    }\n\n    fn create_raffle(deps: DepsMut) -\u003e Result\u003cResponse\u003e {\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::CreateRaffle {\n                asset: AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft\".to_string(),\n                    token_id: \"token_id\".to_string(),\n                }),\n                raffle_start_timestamp: None,\n                raffle_duration: None,\n                raffle_timeout: None,\n                comment: None,\n                raffle_ticket_price: AssetInfo::Coin(coin(10000u128, \"uluna\")),\n                max_participant_number: None,\n            },\n        )\n    }\n\n    fn create_raffle_cw1155(deps: DepsMut) -\u003e Result\u003cResponse\u003e {\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::CreateRaffle {\n                asset: AssetInfo::Cw1155Coin(Cw1155Coin {\n                    address: \"nft\".to_string(),\n                    token_id: \"token_id\".to_string(),\n                    value: Uint128::from(675u128),\n                }),\n                raffle_start_timestamp: None,\n                raffle_duration: None,\n                raffle_timeout: None,\n                comment: None,\n                raffle_ticket_price: AssetInfo::Coin(coin(10000u128, \"uluna\")),\n                max_participant_number: None,\n            },\n        )\n    }\n\n    fn buy_ticket_coin(\n        deps: DepsMut,\n        raffle_id: u64,\n        buyer: \u0026str,\n        c: Coin,\n        delta: u64,\n    ) -\u003e Result\u003cResponse\u003e {\n        let info = mock_info(buyer, \u0026[c.clone()]);\n        let mut env = mock_env();\n        env.block.time = env.block.time.plus_seconds(delta);\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::BuyTicket {\n                raffle_id,\n                sent_assets: AssetInfo::Coin(c),\n            },\n        )\n    }\n\n    fn claim_nft(deps: DepsMut, raffle_id: u64, time_delta: u64) -\u003e Result\u003cResponse\u003e {\n        let info = mock_info(\"creator\", \u0026[]);\n        let mut env = mock_env();\n        env.block.time = env.block.time.plus_seconds(time_delta);\n        execute(deps, env, info, ExecuteMsg::ClaimNft { raffle_id })\n    }\n\n    #[test]\n    fn test_init_sanity() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n    }\n\n    #[test]\n    fn test_create_raffle() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n        create_raffle(deps.as_mut()).unwrap();\n    }\n\n    #[test]\n    fn test_claim_raffle() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n        create_raffle(deps.as_mut()).unwrap();\n\n        // Update the randomness internally\n        let mut raffle_info = RAFFLE_INFO.load(\u0026deps.storage, 0).unwrap();\n\n        let mut randomness: [u8; 32] = [0; 32];\n        hex::decode_to_slice(\n            \"89580f6a639add6c90dcf3d222e35415f89d9ee2cd6ef6fc4f23134cdffa5d1e\",\n            randomness.as_mut_slice(),\n        )\n        .unwrap();\n        raffle_info.randomness = randomness;\n        raffle_info.randomness_round = 2098475u64;\n        raffle_info.randomness_owner = Some(deps.api.addr_validate(\"rand_provider\").unwrap());\n        RAFFLE_INFO\n            .save(deps.as_mut().storage, 0, \u0026raffle_info)\n            .unwrap();\n\n        claim_nft(deps.as_mut(), 0, 1000u64).unwrap();\n    }\n\n    #[test]\n    fn test_ticket_and_claim_raffle() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n        create_raffle(deps.as_mut()).unwrap();\n\n        //Buy some tickets\n        buy_ticket_coin(deps.as_mut(), 0, \"first\", coin(10, \"uluna\"), 0u64).unwrap_err();\n        buy_ticket_coin(deps.as_mut(), 0, \"first\", coin(1000000, \"uluna\"), 0u64).unwrap_err();\n        buy_ticket_coin(deps.as_mut(), 0, \"first\", coin(10000, \"uluna\"), 0u64).unwrap();\n        buy_ticket_coin(deps.as_mut(), 0, \"first\", coin(10000, \"uluna\"), 0u64).unwrap();\n        buy_ticket_coin(deps.as_mut(), 0, \"second\", coin(10000, \"uluna\"), 0u64).unwrap();\n        buy_ticket_coin(deps.as_mut(), 0, \"third\", coin(10000, \"uluna\"), 0u64).unwrap();\n        buy_ticket_coin(deps.as_mut(), 0, \"fourth\", coin(10000, \"uluna\"), 0u64).unwrap();\n\n        // Update the randomness internally\n        let mut raffle_info = RAFFLE_INFO.load(\u0026deps.storage, 0).unwrap();\n\n        let mut randomness: [u8; 32] = [0; 32];\n        hex::decode_to_slice(\n            \"89580f6a639add6c90dcf3d222e35415f89d9ee2cd6ef6fc4f23134cdffa5d1e\",\n            randomness.as_mut_slice(),\n        )\n        .unwrap();\n        raffle_info.randomness = randomness;\n        raffle_info.randomness_round = 2098475u64;\n        raffle_info.randomness_owner = Some(deps.api.addr_validate(\"rand_provider\").unwrap());\n        RAFFLE_INFO\n            .save(deps.as_mut().storage, 0, \u0026raffle_info)\n            .unwrap();\n\n        let response = claim_nft(deps.as_mut(), 0, 1000u64).unwrap();\n\n        assert_eq!(\n            response.messages,\n            vec![\n                SubMsg::new(\n                    into_cosmos_msg(\n                        Cw721ExecuteMsg::TransferNft {\n                            recipient: \"first\".to_string(),\n                            token_id: \"token_id\".to_string()\n                        },\n                        \"nft\".to_string()\n                    )\n                    .unwrap()\n                ),\n                SubMsg::new(BankMsg::Send {\n                    to_address: \"rand_provider\".to_string(),\n                    amount: coins(5, \"uluna\")\n                }),\n                SubMsg::new(BankMsg::Send {\n                    to_address: \"creator\".to_string(),\n                    amount: coins(10, \"uluna\")\n                }),\n                SubMsg::new(BankMsg::Send {\n                    to_address: \"creator\".to_string(),\n                    amount: coins(49985u128, \"uluna\")\n                }),\n            ]\n        );\n\n        // You can't buy tickets when the raffle is over\n        buy_ticket_coin(deps.as_mut(), 0, \"first\", coin(10000, \"uluna\"), 100u64).unwrap_err();\n        buy_ticket_coin(deps.as_mut(), 0, \"first\", coin(10000, \"uluna\"), 1000u64).unwrap_err();\n    }\n\n    #[test]\n    fn test_ticket_and_claim_raffle_cw1155() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n        create_raffle_cw1155(deps.as_mut()).unwrap();\n\n        //Buy some tickets\n        buy_ticket_coin(deps.as_mut(), 0, \"first\", coin(10, \"uluna\"), 0u64).unwrap_err();\n        buy_ticket_coin(deps.as_mut(), 0, \"first\", coin(1000000, \"uluna\"), 0u64).unwrap_err();\n        buy_ticket_coin(deps.as_mut(), 0, \"first\", coin(10000, \"uluna\"), 0u64).unwrap();\n        buy_ticket_coin(deps.as_mut(), 0, \"first\", coin(10000, \"uluna\"), 0u64).unwrap();\n        buy_ticket_coin(deps.as_mut(), 0, \"second\", coin(10000, \"uluna\"), 0u64).unwrap();\n        buy_ticket_coin(deps.as_mut(), 0, \"third\", coin(10000, \"uluna\"), 0u64).unwrap();\n        buy_ticket_coin(deps.as_mut(), 0, \"fourth\", coin(10000, \"uluna\"), 0u64).unwrap();\n\n        // Update the randomness internally\n        let mut raffle_info = RAFFLE_INFO.load(\u0026deps.storage, 0).unwrap();\n\n        let mut randomness: [u8; 32] = [0; 32];\n        hex::decode_to_slice(\n            \"89580f6a639add6c90dcf3d222e35415f89d9ee2cd6ef6fc4f23134cdffa5d1e\",\n            randomness.as_mut_slice(),\n        )\n        .unwrap();\n        raffle_info.randomness = randomness;\n        raffle_info.randomness_round = 2098475u64;\n        raffle_info.randomness_owner = Some(deps.api.addr_validate(\"rand_provider\").unwrap());\n        RAFFLE_INFO\n            .save(deps.as_mut().storage, 0, \u0026raffle_info)\n            .unwrap();\n\n        let response = claim_nft(deps.as_mut(), 0, 1000u64).unwrap();\n\n        assert_eq!(\n            response.messages,\n            vec![\n                SubMsg::new(\n                    into_cosmos_msg(\n                        Cw1155ExecuteMsg::SendFrom {\n                            from: MOCK_CONTRACT_ADDR.to_string(),\n                            to: \"first\".to_string(),\n                            token_id: \"token_id\".to_string(),\n                            value: Uint128::from(675u128),\n                            msg: None,\n                        },\n                        \"nft\".to_string()\n                    )\n                    .unwrap()\n                ),\n                SubMsg::new(BankMsg::Send {\n                    to_address: \"rand_provider\".to_string(),\n                    amount: coins(5, \"uluna\")\n                }),\n                SubMsg::new(BankMsg::Send {\n                    to_address: \"creator\".to_string(),\n                    amount: coins(10, \"uluna\")\n                }),\n                SubMsg::new(BankMsg::Send {\n                    to_address: \"creator\".to_string(),\n                    amount: coins(49985u128, \"uluna\")\n                }),\n            ]\n        );\n\n        // You can't buy tickets when the raffle is over\n        buy_ticket_coin(deps.as_mut(), 0, \"first\", coin(10000, \"uluna\"), 100u64).unwrap_err();\n        buy_ticket_coin(deps.as_mut(), 0, \"first\", coin(10000, \"uluna\"), 1000u64).unwrap_err();\n    }\n\n    #[test]\n    fn test_randomness_provider() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n        create_raffle_cw1155(deps.as_mut()).unwrap();\n        let mut env = mock_env();\n        env.block.time = env.block.time.plus_seconds(2u64);\n        let info = mock_info(\"anyone\", \u0026[]);\n        let randomness = DrandRandomness {\n            round: 90,\n            signature: Binary::from_base64(\"quid\").unwrap(),\n            previous_signature: Binary::from_base64(\"quid\").unwrap(),\n        };\n        let response = execute(\n            deps.as_mut(),\n            env,\n            info,\n            ExecuteMsg::UpdateRandomness {\n                raffle_id: 0,\n                randomness: randomness.clone(),\n            },\n        )\n        .unwrap();\n        let msg = VerifierExecuteMsg::Verify {\n            randomness,\n            pubkey: Binary::from_base64(\u0026base64::encode(HEX_PUBKEY)).unwrap(),\n            raffle_id: 0,\n            owner: \"anyone\".to_string(),\n        };\n        \n        assert_eq!(\n            response.messages,\n            vec![SubMsg::reply_on_success(\n                into_cosmos_msg(msg, \"verifier\".to_string()).unwrap(),\n                0\n            )]\n        );\n    }\n\n    // Admin functions\n    #[test]\n    fn test_renounce() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n        let info = mock_info(\"bad_person\", \u0026[]);\n        let env = mock_env();\n        execute(deps.as_mut(), env.clone(), info, ExecuteMsg::Renounce {}).unwrap_err();\n\n        let info = mock_info(\"creator\", \u0026[]);\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            ExecuteMsg::Renounce {},\n        )\n        .unwrap();\n\n        execute(deps.as_mut(), env, info, ExecuteMsg::Renounce {}).unwrap_err();\n    }\n\n    #[test]\n    fn test_lock() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n        assert!(!CONTRACT_INFO.load(\u0026deps.storage).unwrap().lock);\n\n        let info = mock_info(\"bad_person\", \u0026[]);\n        let env = mock_env();\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            ExecuteMsg::ToggleLock { lock: false },\n        )\n        .unwrap_err();\n\n        let info = mock_info(\"creator\", \u0026[]);\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            ExecuteMsg::ToggleLock { lock: true },\n        )\n        .unwrap();\n        assert!(CONTRACT_INFO.load(\u0026deps.storage).unwrap().lock);\n\n        execute(\n            deps.as_mut(),\n            env,\n            info,\n            ExecuteMsg::ToggleLock { lock: false },\n        )\n        .unwrap();\n        assert!(!CONTRACT_INFO.load(\u0026deps.storage).unwrap().lock);\n    }\n\n    #[test]\n    fn test_change_parameter() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n\n        let info = mock_info(\"bad_person\", \u0026[]);\n        let env = mock_env();\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            ExecuteMsg::ChangeParameter {\n                parameter: \"any\".to_string(),\n                value: \"any\".to_string(),\n            },\n        )\n        .unwrap_err();\n\n        let info = mock_info(\"creator\", \u0026[]);\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            ExecuteMsg::ChangeParameter {\n                parameter: \"any\".to_string(),\n                value: \"any\".to_string(),\n            },\n        )\n        .unwrap_err();\n\n        execute(\n            deps.as_mut(),\n            env,\n            info,\n            ExecuteMsg::ChangeParameter {\n                parameter: \"fee_addr\".to_string(),\n                value: \"any\".to_string(),\n            },\n        )\n        .unwrap();\n        assert_eq!(\n            CONTRACT_INFO\n                .load(\u0026deps.storage)\n                .unwrap()\n                .fee_addr\n                .to_string(),\n            \"any\"\n        );\n    }\n}\n","traces":[{"line":37,"address":[1072672,1078329],"length":1,"stats":{"Line":1},"fn_name":"instantiate"},{"line":45,"address":[1073148,1072730,1072996,1072934],"length":1,"stats":{"Line":8},"fn_name":null},{"line":47,"address":[1073210,1073405,1073560,1072966],"length":1,"stats":{"Line":14},"fn_name":null},{"line":50,"address":[1073268],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[1073811,1074135,1073299,1073691,1073745],"length":1,"stats":{"Line":15},"fn_name":null},{"line":54,"address":[1074367,1074501,1073901,1074421,1074754],"length":1,"stats":{"Line":9},"fn_name":null},{"line":58,"address":[1074587,1074952],"length":1,"stats":{"Line":8},"fn_name":null},{"line":62,"address":[1075016],"length":1,"stats":{"Line":7},"fn_name":null},{"line":66,"address":[1075071],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[1075169],"length":1,"stats":{"Line":7},"fn_name":null},{"line":71,"address":[1075215],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[1075292],"length":1,"stats":{"Line":7},"fn_name":null},{"line":75,"address":[1075929,1075512,1075446,1075330],"length":1,"stats":{"Line":8},"fn_name":null},{"line":77,"address":[1076500,1076632,1076804],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[1076614,1077419,1077555],"length":1,"stats":{"Line":9},"fn_name":null},{"line":81,"address":[1077515],"length":1,"stats":{"Line":7},"fn_name":null},{"line":85,"address":[1081745,1078352],"length":1,"stats":{"Line":1},"fn_name":"execute"},{"line":86,"address":[1078417],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[1078650],"length":1,"stats":{"Line":3},"fn_name":null},{"line":96,"address":[1078737],"length":1,"stats":{"Line":4},"fn_name":null},{"line":97,"address":[1078763],"length":1,"stats":{"Line":4},"fn_name":null},{"line":98,"address":[1078789],"length":1,"stats":{"Line":4},"fn_name":null},{"line":99,"address":[1078807],"length":1,"stats":{"Line":4},"fn_name":null},{"line":103,"address":[1078833],"length":1,"stats":{"Line":4},"fn_name":null},{"line":104,"address":[1078881],"length":1,"stats":{"Line":4},"fn_name":null},{"line":107,"address":[1079099],"length":1,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[1079330],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[1079665],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[1080167],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[1080199],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[1080234],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[1080301],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[1080344],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[1081425],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[1081465],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[1080458],"length":1,"stats":{"Line":1},"fn_name":null},{"line":137,"address":[1080600],"length":1,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[1080814],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[1080962],"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[1081090],"length":1,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[1081162],"length":1,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[1081776,1081894],"length":1,"stats":{"Line":0},"fn_name":"migrate"},{"line":154,"address":[1081803],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[1083728,1081936],"length":1,"stats":{"Line":0},"fn_name":"query"},{"line":159,"address":[1081968],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[837911,837904],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":161,"address":[1082091],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[838160,838167],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":165,"address":[1082143],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[838423,838416],"length":1,"stats":{"Line":0},"fn_name":"{closure#2}"},{"line":179,"address":[1016496,1017551],"length":1,"stats":{"Line":1},"fn_name":"execute_renounce"},{"line":180,"address":[1016673,1016531,1016930,1016829],"length":1,"stats":{"Line":3},"fn_name":null},{"line":182,"address":[1016993,1017067,1016775],"length":1,"stats":{"Line":2},"fn_name":null},{"line":183,"address":[1017424,1017033,1017179,1017255],"length":1,"stats":{"Line":2},"fn_name":null},{"line":185,"address":[1017240,1017613,1017749],"length":1,"stats":{"Line":3},"fn_name":null},{"line":188,"address":[1017709],"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[1020167,1018320],"length":1,"stats":{"Line":0},"fn_name":"set_new_fee_addr"},{"line":199,"address":[1018363,1018622,1018485,1018721],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[1018993,1018787,1018844,1018584,1019145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[1019336,1018978,1019267,1019202],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[1019427,1019653,1019481,1019299],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[1019466,1019942,1019806],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[1019902],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[1020192,1021404],"length":1,"stats":{"Line":1},"fn_name":"execute_toggle_lock"},{"line":217,"address":[1020507,1020237,1020363,1020608],"length":1,"stats":{"Line":3},"fn_name":null},{"line":219,"address":[1020464],"length":1,"stats":{"Line":1},"fn_name":null},{"line":220,"address":[1020719,1020766,1020935,1020475,1020674],"length":1,"stats":{"Line":3},"fn_name":null},{"line":222,"address":[1021150,1020751,1021026,1021255],"length":1,"stats":{"Line":4},"fn_name":null},{"line":224,"address":[1021122],"length":1,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[1021350,1021143,1021201],"length":1,"stats":{"Line":1},"fn_name":null},{"line":228,"address":[1021424,1026450],"length":1,"stats":{"Line":1},"fn_name":"execute_change_parameter"},{"line":235,"address":[1021932,1021663,1021490,1021804],"length":1,"stats":{"Line":3},"fn_name":null},{"line":237,"address":[1021997,1021778],"length":1,"stats":{"Line":2},"fn_name":null},{"line":238,"address":[1022019,1022093],"length":1,"stats":{"Line":2},"fn_name":null},{"line":239,"address":[1022606,1022160,1022446],"length":1,"stats":{"Line":1},"fn_name":null},{"line":240,"address":[1022713,1022655,1022376],"length":1,"stats":{"Line":2},"fn_name":null},{"line":242,"address":[1022872,1022115],"length":1,"stats":{"Line":2},"fn_name":null},{"line":243,"address":[1022931,1023195],"length":1,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[1023174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[1023239,1022894],"length":1,"stats":{"Line":2},"fn_name":null},{"line":247,"address":[1023298,1023562],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[1023541],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[1023606,1023261],"length":1,"stats":{"Line":2},"fn_name":null},{"line":251,"address":[1023665],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[1023900],"length":1,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[1023628,1023928],"length":1,"stats":{"Line":2},"fn_name":null},{"line":255,"address":[1023984],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[1024195],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[1023950,1024362,1024220],"length":1,"stats":{"Line":2},"fn_name":null},{"line":259,"address":[1024276,1024367],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[1024242,1024446],"length":1,"stats":{"Line":2},"fn_name":null},{"line":262,"address":[1024772,1024510,1024935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[1024702,1024962,1025023],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[1024468,1025131,1025354],"length":1,"stats":{"Line":2},"fn_name":null},{"line":266,"address":[1025359,1025211],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[1025137,1026103],"length":1,"stats":{"Line":2},"fn_name":null},{"line":271,"address":[1025507,1022825,1025450,1025662],"length":1,"stats":{"Line":2},"fn_name":null},{"line":273,"address":[1025489,1025776,1025858,1025689],"length":1,"stats":{"Line":4},"fn_name":null},{"line":275,"address":[1025745],"length":1,"stats":{"Line":1},"fn_name":null},{"line":276,"address":[1025827],"length":1,"stats":{"Line":1},"fn_name":null},{"line":281,"address":[1031279,1026480],"length":1,"stats":{"Line":4},"fn_name":"execute_create_raffle"},{"line":293,"address":[1027248,1026994,1027096,1026765],"length":1,"stats":{"Line":8},"fn_name":null},{"line":295,"address":[1027069],"length":1,"stats":{"Line":4},"fn_name":null},{"line":296,"address":[1027348,1027578],"length":1,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[1027302],"length":1,"stats":{"Line":4},"fn_name":null},{"line":301,"address":[1027751],"length":1,"stats":{"Line":3},"fn_name":null},{"line":303,"address":[1028989,1027771],"length":1,"stats":{"Line":6},"fn_name":null},{"line":304,"address":[1029004],"length":1,"stats":{"Line":3},"fn_name":null},{"line":307,"address":[1029481,1029111,1029259],"length":1,"stats":{"Line":4},"fn_name":null},{"line":309,"address":[1027809],"length":1,"stats":{"Line":1},"fn_name":null},{"line":311,"address":[1027837],"length":1,"stats":{"Line":1},"fn_name":null},{"line":312,"address":[1028046],"length":1,"stats":{"Line":1},"fn_name":null},{"line":313,"address":[1028137],"length":1,"stats":{"Line":1},"fn_name":null},{"line":314,"address":[1028168],"length":1,"stats":{"Line":1},"fn_name":null},{"line":318,"address":[1028344,1028540,1028759],"length":1,"stats":{"Line":2},"fn_name":null},{"line":320,"address":[1027847,1027666],"length":1,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[1028845],"length":1,"stats":{"Line":3},"fn_name":null},{"line":325,"address":[1028880],"length":1,"stats":{"Line":3},"fn_name":null},{"line":326,"address":[1028963],"length":1,"stats":{"Line":4},"fn_name":null},{"line":327,"address":[1029631],"length":1,"stats":{"Line":4},"fn_name":null},{"line":331,"address":[1029702],"length":1,"stats":{"Line":4},"fn_name":null},{"line":332,"address":[1029733],"length":1,"stats":{"Line":4},"fn_name":null},{"line":336,"address":[1030739,1030829,1030179,1030964,1031033],"length":1,"stats":{"Line":25},"fn_name":null},{"line":337,"address":[1030579],"length":1,"stats":{"Line":5},"fn_name":null},{"line":338,"address":[1030794],"length":1,"stats":{"Line":5},"fn_name":null},{"line":339,"address":[1031007,1030802,1030880],"length":1,"stats":{"Line":5},"fn_name":null},{"line":340,"address":[1030933],"length":1,"stats":{"Line":5},"fn_name":null},{"line":344,"address":[1031312,1037604],"length":1,"stats":{"Line":0},"fn_name":"execute_receive_nft"},{"line":352,"address":[1031833,1031409,1031681,1031993],"length":1,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[1031815,1032058,1032106],"length":1,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[1032605],"length":1,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[1033282,1032957],"length":1,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[1033403],"length":1,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[1036463,1034385,1033907,1033850,1034266,1034357,1033443,1034310],"length":1,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[1034366,1034210,1034272,1034336],"length":1,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[1034547],"length":1,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[1034582],"length":1,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[1034649],"length":1,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[1034689],"length":1,"stats":{"Line":0},"fn_name":null},{"line":382,"address":[1034777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[1034817],"length":1,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[1035945,1036163,1036232,1035177,1036028],"length":1,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[1035993],"length":1,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[1036079,1036206,1036001],"length":1,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[1036132],"length":1,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[1034395,1036291],"length":1,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[1033501,1033732],"length":1,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[1033197,1032967],"length":1,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[1037664,1044070],"length":1,"stats":{"Line":0},"fn_name":"execute_receive_1155"},{"line":412,"address":[1038201,1037777,1038049,1038361],"length":1,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[1038426,1038183,1038474],"length":1,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[1039021],"length":1,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[1039325,1039650],"length":1,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[1039811],"length":1,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[1042929,1040666,1040851,1040307,1040250,1040710,1040757,1039843,1040823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[1040736],"length":1,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[1040832,1040802,1040610,1040672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[1041013],"length":1,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[1041048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[1041115],"length":1,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[1041155],"length":1,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[1041243],"length":1,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[1041283],"length":1,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[1042629,1042494,1041643,1042698,1042411],"length":1,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[1042459],"length":1,"stats":{"Line":0},"fn_name":null},{"line":450,"address":[1042672,1042467,1042545],"length":1,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[1042598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":453,"address":[1042757,1040861],"length":1,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[1039901,1040132],"length":1,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[1039335,1039565],"length":1,"stats":{"Line":0},"fn_name":null},{"line":465,"address":[1044128,1046592],"length":1,"stats":{"Line":4},"fn_name":"_create_raffle"},{"line":477,"address":[1044862,1044323,1044630,1044480],"length":1,"stats":{"Line":8},"fn_name":null},{"line":480,"address":[1044972,1044924,1045377,1045231,1044605],"length":1,"stats":{"Line":16},"fn_name":null},{"line":481,"address":[833104,833298],"length":1,"stats":{"Line":8},"fn_name":"{closure#0}"},{"line":482,"address":[833328,833337,833125],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":483,"address":[833200],"length":1,"stats":{"Line":4},"fn_name":null},{"line":488,"address":[835935,833463,833424],"length":1,"stats":{"Line":12},"fn_name":"{closure#1}"},{"line":493,"address":[833717],"length":1,"stats":{"Line":0},"fn_name":null},{"line":494,"address":[835215],"length":1,"stats":{"Line":5},"fn_name":null},{"line":495,"address":[833576],"length":1,"stats":{"Line":4},"fn_name":null},{"line":496,"address":[833607],"length":1,"stats":{"Line":4},"fn_name":null},{"line":497,"address":[833812,833675],"length":1,"stats":{"Line":8},"fn_name":null},{"line":499,"address":[833804],"length":1,"stats":{"Line":4},"fn_name":null},{"line":500,"address":[833892,833925,833881,833873],"length":1,"stats":{"Line":16},"fn_name":null},{"line":501,"address":[833888,833877],"length":1,"stats":{"Line":8},"fn_name":null},{"line":502,"address":[833917],"length":1,"stats":{"Line":4},"fn_name":null},{"line":503,"address":[833967,834000,833949],"length":1,"stats":{"Line":12},"fn_name":null},{"line":504,"address":[833963,833945],"length":1,"stats":{"Line":8},"fn_name":null},{"line":505,"address":[833992],"length":1,"stats":{"Line":4},"fn_name":null},{"line":506,"address":[834020],"length":1,"stats":{"Line":4},"fn_name":null},{"line":507,"address":[834058],"length":1,"stats":{"Line":4},"fn_name":null},{"line":508,"address":[834088],"length":1,"stats":{"Line":4},"fn_name":null},{"line":509,"address":[834256,834896],"length":1,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[834309],"length":1,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[834341],"length":1,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[834719,834373],"length":1,"stats":{"Line":8},"fn_name":null},{"line":514,"address":[834426],"length":1,"stats":{"Line":4},"fn_name":null},{"line":515,"address":[834458],"length":1,"stats":{"Line":4},"fn_name":null},{"line":517,"address":[834177],"length":1,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[834876],"length":1,"stats":{"Line":4},"fn_name":null},{"line":520,"address":[835029],"length":1,"stats":{"Line":4},"fn_name":null},{"line":521,"address":[835041],"length":1,"stats":{"Line":4},"fn_name":null},{"line":523,"address":[835109,835191],"length":1,"stats":{"Line":10},"fn_name":null},{"line":526,"address":[835203],"length":1,"stats":{"Line":5},"fn_name":null},{"line":529,"address":[1046461],"length":1,"stats":{"Line":5},"fn_name":null},{"line":532,"address":[1046608,1050255],"length":1,"stats":{"Line":2},"fn_name":"execute_buy_ticket"},{"line":540,"address":[1046671],"length":1,"stats":{"Line":2},"fn_name":null},{"line":541,"address":[1046906],"length":1,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[1048134,1046926],"length":1,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[1048149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":547,"address":[1048437,1048633,1049113,1048235],"length":1,"stats":{"Line":0},"fn_name":null},{"line":550,"address":[1046964],"length":1,"stats":{"Line":2},"fn_name":null},{"line":551,"address":[1046984,1047272],"length":1,"stats":{"Line":4},"fn_name":null},{"line":552,"address":[1047320],"length":1,"stats":{"Line":0},"fn_name":null},{"line":554,"address":[1047286,1047573],"length":1,"stats":{"Line":4},"fn_name":null},{"line":555,"address":[1047718],"length":1,"stats":{"Line":0},"fn_name":null},{"line":557,"address":[1047708],"length":1,"stats":{"Line":2},"fn_name":null},{"line":559,"address":[1047171,1046821,1047010],"length":1,"stats":{"Line":0},"fn_name":null},{"line":562,"address":[1047990,1049469,1049164,1049517,1049368],"length":1,"stats":{"Line":6},"fn_name":null},{"line":564,"address":[1049451,1050074,1049772,1049862,1049997],"length":1,"stats":{"Line":10},"fn_name":null},{"line":565,"address":[1049708],"length":1,"stats":{"Line":2},"fn_name":null},{"line":566,"address":[1049827],"length":1,"stats":{"Line":2},"fn_name":null},{"line":567,"address":[1049835,1050040,1049913],"length":1,"stats":{"Line":2},"fn_name":null},{"line":568,"address":[1049966],"length":1,"stats":{"Line":2},"fn_name":null},{"line":571,"address":[1054891,1050288],"length":1,"stats":{"Line":0},"fn_name":"execute_receive"},{"line":579,"address":[1050784,1050944,1050400,1050632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":580,"address":[1050766,1051009,1051057],"length":1,"stats":{"Line":0},"fn_name":null},{"line":581,"address":[1051444],"length":1,"stats":{"Line":0},"fn_name":null},{"line":586,"address":[1051875,1051556],"length":1,"stats":{"Line":0},"fn_name":null},{"line":587,"address":[1051988],"length":1,"stats":{"Line":0},"fn_name":null},{"line":591,"address":[1052379,1052874,1052789,1052020,1052436,1054340,1052833,1052902],"length":1,"stats":{"Line":0},"fn_name":null},{"line":592,"address":[1052795,1052736,1052859,1052883],"length":1,"stats":{"Line":0},"fn_name":null},{"line":595,"address":[1053357,1053392,1052994],"length":1,"stats":{"Line":0},"fn_name":null},{"line":597,"address":[1053339,1054042,1053907,1054111,1053824],"length":1,"stats":{"Line":0},"fn_name":null},{"line":598,"address":[1053872],"length":1,"stats":{"Line":0},"fn_name":null},{"line":599,"address":[1053958,1053880,1054085],"length":1,"stats":{"Line":0},"fn_name":null},{"line":600,"address":[1054011],"length":1,"stats":{"Line":0},"fn_name":null},{"line":602,"address":[1054170,1052912],"length":1,"stats":{"Line":0},"fn_name":null},{"line":605,"address":[1052066,1052276],"length":1,"stats":{"Line":0},"fn_name":null},{"line":608,"address":[1051566,1051793],"length":1,"stats":{"Line":0},"fn_name":null},{"line":612,"address":[1054944,1059993],"length":1,"stats":{"Line":2},"fn_name":"_buy_ticket"},{"line":619,"address":[1055459,1055011,1055216,1055635],"length":1,"stats":{"Line":4},"fn_name":null},{"line":622,"address":[1055697,1055820,1055366,1055929,1055985],"length":1,"stats":{"Line":6},"fn_name":null},{"line":625,"address":[1055907,1056041],"length":1,"stats":{"Line":4},"fn_name":null},{"line":626,"address":[1056236],"length":1,"stats":{"Line":2},"fn_name":null},{"line":627,"address":[1056081],"length":1,"stats":{"Line":2},"fn_name":null},{"line":628,"address":[1056169],"length":1,"stats":{"Line":2},"fn_name":null},{"line":633,"address":[1056047,1056657],"length":1,"stats":{"Line":4},"fn_name":null},{"line":634,"address":[1056732],"length":1,"stats":{"Line":0},"fn_name":null},{"line":636,"address":[1056675],"length":1,"stats":{"Line":2},"fn_name":null},{"line":637,"address":[1056985,1057251,1057310],"length":1,"stats":{"Line":2},"fn_name":null},{"line":638,"address":[1057460,1057513,1057140,1057353],"length":1,"stats":{"Line":4},"fn_name":null},{"line":639,"address":[1057540,1058339,1057437],"length":1,"stats":{"Line":6},"fn_name":null},{"line":640,"address":[1057685,1058481],"length":1,"stats":{"Line":0},"fn_name":null},{"line":641,"address":[1057741],"length":1,"stats":{"Line":0},"fn_name":null},{"line":642,"address":[1057773],"length":1,"stats":{"Line":0},"fn_name":null},{"line":644,"address":[1057823,1058206],"length":1,"stats":{"Line":4},"fn_name":null},{"line":645,"address":[1057879],"length":1,"stats":{"Line":2},"fn_name":null},{"line":646,"address":[1057911],"length":1,"stats":{"Line":2},"fn_name":null},{"line":648,"address":[1057935,1058106,1057593],"length":1,"stats":{"Line":0},"fn_name":null},{"line":650,"address":[1059053,1058880,1058762],"length":1,"stats":{"Line":2},"fn_name":null},{"line":652,"address":[1058846],"length":1,"stats":{"Line":2},"fn_name":null},{"line":655,"address":[1061454,1060032],"length":1,"stats":{"Line":1},"fn_name":"execute_update_randomness"},{"line":662,"address":[1060650,1060498,1060248,1060091],"length":1,"stats":{"Line":2},"fn_name":null},{"line":663,"address":[1060708,1060373],"length":1,"stats":{"Line":2},"fn_name":null},{"line":664,"address":[1060790,1060715],"length":1,"stats":{"Line":2},"fn_name":null},{"line":665,"address":[1060829],"length":1,"stats":{"Line":0},"fn_name":null},{"line":666,"address":[1060822],"length":1,"stats":{"Line":0},"fn_name":null},{"line":670,"address":[1061238,1060812],"length":1,"stats":{"Line":2},"fn_name":null},{"line":673,"address":[1061488,1066106],"length":1,"stats":{"Line":1},"fn_name":"execute_claim"},{"line":680,"address":[1061853,1061728,1062005,1061534],"length":1,"stats":{"Line":2},"fn_name":null},{"line":683,"address":[1061838,1062249,1062131,1062059],"length":1,"stats":{"Line":3},"fn_name":null},{"line":684,"address":[1062272,1062219],"length":1,"stats":{"Line":2},"fn_name":null},{"line":685,"address":[1062307],"length":1,"stats":{"Line":0},"fn_name":null},{"line":686,"address":[1062300],"length":1,"stats":{"Line":0},"fn_name":null},{"line":691,"address":[1062734,1062278,1062572,1063242],"length":1,"stats":{"Line":5},"fn_name":null},{"line":692,"address":[1062620,1062736],"length":1,"stats":{"Line":1},"fn_name":null},{"line":695,"address":[1063108,1062594,1062888,1063151],"length":1,"stats":{"Line":4},"fn_name":null},{"line":696,"address":[1063247,1063178,1063012],"length":1,"stats":{"Line":4},"fn_name":null},{"line":698,"address":[1063434,1063589,1062824,1063375],"length":1,"stats":{"Line":2},"fn_name":null},{"line":701,"address":[1064189,1063616,1063419,1064221],"length":1,"stats":{"Line":2},"fn_name":null},{"line":702,"address":[1064069,1064602,1064271,1064394,1064546],"length":1,"stats":{"Line":2},"fn_name":null},{"line":705,"address":[1065070,1065367,1064980,1064531,1064868,1065262],"length":1,"stats":{"Line":6},"fn_name":null},{"line":706,"address":[1064708],"length":1,"stats":{"Line":1},"fn_name":null},{"line":707,"address":[1064916],"length":1,"stats":{"Line":1},"fn_name":null},{"line":708,"address":[1065035],"length":1,"stats":{"Line":1},"fn_name":null},{"line":709,"address":[1065244,1065121,1065043],"length":1,"stats":{"Line":1},"fn_name":null},{"line":710,"address":[1065313,1065174,1065484],"length":1,"stats":{"Line":1},"fn_name":null},{"line":715,"address":[1083776,1084534],"length":1,"stats":{"Line":0},"fn_name":"reply"},{"line":716,"address":[1083808],"length":1,"stats":{"Line":0},"fn_name":null},{"line":717,"address":[1084144,1084192,1084462,1083865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":718,"address":[1084067],"length":1,"stats":{"Line":0},"fn_name":null},{"line":722,"address":[1066144,1072647],"length":1,"stats":{"Line":0},"fn_name":"verify"},{"line":723,"address":[1066194],"length":1,"stats":{"Line":0},"fn_name":null},{"line":724,"address":[1066245],"length":1,"stats":{"Line":0},"fn_name":null},{"line":725,"address":[1066620,1066495,1066281,1066560,1066904],"length":1,"stats":{"Line":0},"fn_name":null},{"line":728,"address":[836576,836603],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":729,"address":[836640,836652],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":731,"address":[1067082,1067594,1067267,1066998,1067367,1067392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":735,"address":[836688,836715],"length":1,"stats":{"Line":0},"fn_name":"{closure#2}"},{"line":736,"address":[836925,836752],"length":1,"stats":{"Line":0},"fn_name":"{closure#3}"},{"line":737,"address":[836779,836875],"length":1,"stats":{"Line":0},"fn_name":null},{"line":740,"address":[836979,836960],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":743,"address":[1067680,1067832,1068103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":747,"address":[837035,837008],"length":1,"stats":{"Line":0},"fn_name":"{closure#4}"},{"line":748,"address":[837072,837095],"length":1,"stats":{"Line":0},"fn_name":"{closure#5}"},{"line":749,"address":[837136,837148],"length":1,"stats":{"Line":0},"fn_name":"{closure#6}"},{"line":751,"address":[1068356,1068170,1068254,1068670,1068755,1068959],"length":1,"stats":{"Line":0},"fn_name":null},{"line":755,"address":[837184,837211],"length":1,"stats":{"Line":0},"fn_name":"{closure#7}"},{"line":756,"address":[837257,837248],"length":1,"stats":{"Line":0},"fn_name":"{closure#8}"},{"line":758,"address":[837424,837443],"length":1,"stats":{"Line":0},"fn_name":"{closure#9}"},{"line":759,"address":[837472,837484],"length":1,"stats":{"Line":0},"fn_name":"{closure#10}"},{"line":761,"address":[1069598,1069928,1069652,1069045],"length":1,"stats":{"Line":0},"fn_name":null},{"line":762,"address":[1069063,1069228,1069509],"length":1,"stats":{"Line":0},"fn_name":null},{"line":765,"address":[837520,837547],"length":1,"stats":{"Line":0},"fn_name":"{closure#11}"},{"line":766,"address":[837584,837607],"length":1,"stats":{"Line":0},"fn_name":"{closure#12}"},{"line":767,"address":[837648,837660],"length":1,"stats":{"Line":0},"fn_name":"{closure#13}"},{"line":770,"address":[1070452,1070300,1070093],"length":1,"stats":{"Line":0},"fn_name":null},{"line":772,"address":[1070272,1070511,1070587,1070911,1071286,1070984],"length":1,"stats":{"Line":0},"fn_name":null},{"line":775,"address":[837707,837696],"length":1,"stats":{"Line":0},"fn_name":"{closure#14}"},{"line":776,"address":[1071384],"length":1,"stats":{"Line":0},"fn_name":null},{"line":777,"address":[1071408,1071551],"length":1,"stats":{"Line":0},"fn_name":null},{"line":778,"address":[1071699,1071854,1071506,1071642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":780,"address":[1072161,1072366,1071681,1072078,1072297],"length":1,"stats":{"Line":0},"fn_name":null},{"line":781,"address":[1072126],"length":1,"stats":{"Line":0},"fn_name":null},{"line":782,"address":[1072340,1072212,1072134],"length":1,"stats":{"Line":0},"fn_name":null},{"line":783,"address":[1072257],"length":1,"stats":{"Line":0},"fn_name":null},{"line":785,"address":[1066339],"length":1,"stats":{"Line":0},"fn_name":null},{"line":800,"address":[1185504,1185673],"length":1,"stats":{"Line":7},"fn_name":"init_helper"},{"line":802,"address":[1185532],"length":1,"stats":{"Line":7},"fn_name":null},{"line":804,"address":[1185569,1185698,1185758],"length":1,"stats":{"Line":21},"fn_name":null},{"line":806,"address":[1185800],"length":1,"stats":{"Line":7},"fn_name":null},{"line":810,"address":[1185944,1185863],"length":1,"stats":{"Line":15},"fn_name":null},{"line":813,"address":[1186451,1186535],"length":1,"stats":{"Line":15},"fn_name":null},{"line":814,"address":[1186543],"length":1,"stats":{"Line":1},"fn_name":null},{"line":816,"address":[1186857,1186567],"length":1,"stats":{"Line":14},"fn_name":null},{"line":819,"address":[1186976,1188240],"length":1,"stats":{"Line":1},"fn_name":"create_raffle"},{"line":820,"address":[1186997],"length":1,"stats":{"Line":3},"fn_name":null},{"line":821,"address":[1187064],"length":1,"stats":{"Line":3},"fn_name":null},{"line":824,"address":[1187084],"length":1,"stats":{"Line":3},"fn_name":null},{"line":825,"address":[1187119],"length":1,"stats":{"Line":3},"fn_name":null},{"line":826,"address":[1187195],"length":1,"stats":{"Line":3},"fn_name":null},{"line":827,"address":[1187713],"length":1,"stats":{"Line":3},"fn_name":null},{"line":828,"address":[1187386],"length":1,"stats":{"Line":3},"fn_name":null},{"line":829,"address":[1187250],"length":1,"stats":{"Line":3},"fn_name":null},{"line":830,"address":[1187318],"length":1,"stats":{"Line":3},"fn_name":null},{"line":832,"address":[1187510],"length":1,"stats":{"Line":3},"fn_name":null},{"line":833,"address":[1187522],"length":1,"stats":{"Line":3},"fn_name":null},{"line":834,"address":[1187534],"length":1,"stats":{"Line":3},"fn_name":null},{"line":835,"address":[1187546],"length":1,"stats":{"Line":3},"fn_name":null},{"line":836,"address":[1187641,1187558],"length":1,"stats":{"Line":6},"fn_name":null},{"line":837,"address":[1187701],"length":1,"stats":{"Line":3},"fn_name":null},{"line":842,"address":[1189649,1188272],"length":1,"stats":{"Line":1},"fn_name":"create_raffle_cw1155"},{"line":843,"address":[1188294],"length":1,"stats":{"Line":1},"fn_name":null},{"line":844,"address":[1188361],"length":1,"stats":{"Line":1},"fn_name":null},{"line":847,"address":[1188382],"length":1,"stats":{"Line":1},"fn_name":null},{"line":848,"address":[1188417],"length":1,"stats":{"Line":1},"fn_name":null},{"line":849,"address":[1188496],"length":1,"stats":{"Line":1},"fn_name":null},{"line":850,"address":[1189122],"length":1,"stats":{"Line":1},"fn_name":null},{"line":851,"address":[1188763],"length":1,"stats":{"Line":1},"fn_name":null},{"line":852,"address":[1188551],"length":1,"stats":{"Line":1},"fn_name":null},{"line":853,"address":[1188619],"length":1,"stats":{"Line":1},"fn_name":null},{"line":854,"address":[1188687],"length":1,"stats":{"Line":1},"fn_name":null},{"line":856,"address":[1188919],"length":1,"stats":{"Line":1},"fn_name":null},{"line":857,"address":[1188931],"length":1,"stats":{"Line":1},"fn_name":null},{"line":858,"address":[1188943],"length":1,"stats":{"Line":1},"fn_name":null},{"line":859,"address":[1188955],"length":1,"stats":{"Line":1},"fn_name":null},{"line":860,"address":[1188967,1189050],"length":1,"stats":{"Line":2},"fn_name":null},{"line":861,"address":[1189110],"length":1,"stats":{"Line":1},"fn_name":null},{"line":866,"address":[1190710,1189680],"length":1,"stats":{"Line":2},"fn_name":"buy_ticket_coin"},{"line":873,"address":[1189767,1189951],"length":1,"stats":{"Line":4},"fn_name":null},{"line":874,"address":[1190011],"length":1,"stats":{"Line":2},"fn_name":null},{"line":875,"address":[1190076],"length":1,"stats":{"Line":2},"fn_name":null},{"line":877,"address":[1190149],"length":1,"stats":{"Line":2},"fn_name":null},{"line":878,"address":[1190184],"length":1,"stats":{"Line":2},"fn_name":null},{"line":879,"address":[1190280],"length":1,"stats":{"Line":2},"fn_name":null},{"line":880,"address":[1190430],"length":1,"stats":{"Line":2},"fn_name":null},{"line":882,"address":[1190327],"length":1,"stats":{"Line":2},"fn_name":null},{"line":887,"address":[1190752,1191341],"length":1,"stats":{"Line":1},"fn_name":"claim_nft"},{"line":888,"address":[1190800],"length":1,"stats":{"Line":1},"fn_name":null},{"line":889,"address":[1190867],"length":1,"stats":{"Line":1},"fn_name":null},{"line":890,"address":[1190888,1190986],"length":1,"stats":{"Line":2},"fn_name":null},{"line":891,"address":[1190991],"length":1,"stats":{"Line":1},"fn_name":null},{"line":895,"address":[1191469,1191376],"length":1,"stats":{"Line":3},"fn_name":"test_init_sanity"},{"line":896,"address":[1191383],"length":1,"stats":{"Line":1},"fn_name":null},{"line":897,"address":[1191404],"length":1,"stats":{"Line":1},"fn_name":null},{"line":901,"address":[1191504,1191675],"length":1,"stats":{"Line":3},"fn_name":"test_create_raffle"},{"line":902,"address":[1191511],"length":1,"stats":{"Line":1},"fn_name":null},{"line":903,"address":[1191528],"length":1,"stats":{"Line":1},"fn_name":null},{"line":904,"address":[1191590],"length":1,"stats":{"Line":1},"fn_name":null},{"line":908,"address":[1192674,1191712],"length":1,"stats":{"Line":3},"fn_name":"test_claim_raffle"},{"line":909,"address":[1191719],"length":1,"stats":{"Line":1},"fn_name":null},{"line":910,"address":[1191743],"length":1,"stats":{"Line":1},"fn_name":null},{"line":911,"address":[1191815],"length":1,"stats":{"Line":1},"fn_name":null},{"line":914,"address":[1191890],"length":1,"stats":{"Line":1},"fn_name":null},{"line":916,"address":[1191959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":919,"address":[1191986],"length":1,"stats":{"Line":1},"fn_name":null},{"line":922,"address":[1192153],"length":1,"stats":{"Line":1},"fn_name":null},{"line":923,"address":[1192217],"length":1,"stats":{"Line":1},"fn_name":null},{"line":924,"address":[1192398,1192229],"length":1,"stats":{"Line":1},"fn_name":null},{"line":925,"address":[1192489],"length":1,"stats":{"Line":1},"fn_name":null},{"line":926,"address":[1192473,1192391],"length":1,"stats":{"Line":2},"fn_name":null},{"line":929,"address":[1192559],"length":1,"stats":{"Line":1},"fn_name":null},{"line":933,"address":[1192704,1196818],"length":1,"stats":{"Line":3},"fn_name":"test_ticket_and_claim_raffle"},{"line":934,"address":[1192717],"length":1,"stats":{"Line":1},"fn_name":null},{"line":935,"address":[1192755],"length":1,"stats":{"Line":1},"fn_name":null},{"line":936,"address":[1192833],"length":1,"stats":{"Line":1},"fn_name":null},{"line":939,"address":[1192924],"length":1,"stats":{"Line":1},"fn_name":null},{"line":940,"address":[1193107],"length":1,"stats":{"Line":1},"fn_name":null},{"line":941,"address":[1193290],"length":1,"stats":{"Line":1},"fn_name":null},{"line":942,"address":[1193453],"length":1,"stats":{"Line":1},"fn_name":null},{"line":943,"address":[1193616],"length":1,"stats":{"Line":1},"fn_name":null},{"line":944,"address":[1193779],"length":1,"stats":{"Line":1},"fn_name":null},{"line":945,"address":[1193942],"length":1,"stats":{"Line":1},"fn_name":null},{"line":948,"address":[1194089],"length":1,"stats":{"Line":1},"fn_name":null},{"line":950,"address":[1194161],"length":1,"stats":{"Line":1},"fn_name":null},{"line":953,"address":[1194188],"length":1,"stats":{"Line":1},"fn_name":null},{"line":956,"address":[1194357],"length":1,"stats":{"Line":1},"fn_name":null},{"line":957,"address":[1194421],"length":1,"stats":{"Line":1},"fn_name":null},{"line":958,"address":[1194433,1194608],"length":1,"stats":{"Line":1},"fn_name":null},{"line":959,"address":[1194699],"length":1,"stats":{"Line":1},"fn_name":null},{"line":960,"address":[1194601,1194683],"length":1,"stats":{"Line":2},"fn_name":null},{"line":963,"address":[1194772],"length":1,"stats":{"Line":1},"fn_name":null},{"line":965,"address":[1196215],"length":1,"stats":{"Line":1},"fn_name":null},{"line":967,"address":[1195384,1195628,1195872,1196087,1194864,1194985],"length":1,"stats":{"Line":2},"fn_name":null},{"line":968,"address":[1195315],"length":1,"stats":{"Line":1},"fn_name":null},{"line":969,"address":[1195166,1195250],"length":1,"stats":{"Line":2},"fn_name":null},{"line":970,"address":[1195014],"length":1,"stats":{"Line":1},"fn_name":null},{"line":971,"address":[1194886],"length":1,"stats":{"Line":1},"fn_name":null},{"line":972,"address":[1194953],"length":1,"stats":{"Line":1},"fn_name":null},{"line":974,"address":[1195098],"length":1,"stats":{"Line":1},"fn_name":null},{"line":978,"address":[1195424],"length":1,"stats":{"Line":1},"fn_name":null},{"line":979,"address":[1195322],"length":1,"stats":{"Line":1},"fn_name":null},{"line":980,"address":[1195349],"length":1,"stats":{"Line":1},"fn_name":null},{"line":982,"address":[1195668],"length":1,"stats":{"Line":1},"fn_name":null},{"line":983,"address":[1195564],"length":1,"stats":{"Line":1},"fn_name":null},{"line":984,"address":[1195591],"length":1,"stats":{"Line":1},"fn_name":null},{"line":986,"address":[1195912],"length":1,"stats":{"Line":1},"fn_name":null},{"line":987,"address":[1195808],"length":1,"stats":{"Line":1},"fn_name":null},{"line":988,"address":[1195835],"length":1,"stats":{"Line":1},"fn_name":null},{"line":994,"address":[1196431],"length":1,"stats":{"Line":1},"fn_name":null},{"line":995,"address":[1196608],"length":1,"stats":{"Line":1},"fn_name":null},{"line":999,"address":[1196848,1201209],"length":1,"stats":{"Line":3},"fn_name":"test_ticket_and_claim_raffle_cw1155"},{"line":1000,"address":[1196861],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1001,"address":[1196899],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1002,"address":[1196977],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1005,"address":[1197068],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1006,"address":[1197251],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1007,"address":[1197434],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1008,"address":[1197597],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1009,"address":[1197760],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1010,"address":[1197923],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1011,"address":[1198086],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1014,"address":[1198233],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1016,"address":[1198305],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1019,"address":[1198332],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1022,"address":[1198513],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1023,"address":[1198577],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1024,"address":[1198589,1198764],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1025,"address":[1198855],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1026,"address":[1198757,1198839],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1029,"address":[1198928],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1031,"address":[1200606],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1033,"address":[1199141,1199020,1200263,1200478,1200019,1199775],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1034,"address":[1199706],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1035,"address":[1199557,1199641],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1036,"address":[1199325],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1037,"address":[1199042],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1038,"address":[1199109],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1039,"address":[1199170],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1040,"address":[1199235],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1041,"address":[1199313],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1043,"address":[1199489],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1047,"address":[1199815],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1048,"address":[1199713],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1049,"address":[1199740],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1051,"address":[1200059],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1052,"address":[1199955],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1053,"address":[1199982],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1055,"address":[1200303],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1056,"address":[1200199],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1057,"address":[1200226],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1063,"address":[1200822],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1064,"address":[1200999],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1068,"address":[1201232,1203859],"length":1,"stats":{"Line":3},"fn_name":"test_randomness_provider"},{"line":1069,"address":[1201239],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1070,"address":[1201327],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1071,"address":[1201399],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1072,"address":[1201474],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1073,"address":[1201493],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1074,"address":[1201551,1201635],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1077,"address":[1201643],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1078,"address":[1201742],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1081,"address":[1201938],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1082,"address":[1201945],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1083,"address":[1202049],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1084,"address":[1202177],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1086,"address":[1202129],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1092,"address":[1202526,1202644,1202704],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1094,"address":[1202734],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1097,"address":[1203477],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1099,"address":[1203391,1203011,1203345],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1100,"address":[1203074,1203355],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1108,"address":[1203888,1205087],"length":1,"stats":{"Line":3},"fn_name":"test_renounce"},{"line":1109,"address":[1203895],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1110,"address":[1203951],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1111,"address":[1204010],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1112,"address":[1204061],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1113,"address":[1204210,1204080,1204165],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1115,"address":[1204380],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1117,"address":[1204444],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1118,"address":[1204467,1204515],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1119,"address":[1204539],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1120,"address":[1204546],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1124,"address":[1204731],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1128,"address":[1206743,1205120],"length":1,"stats":{"Line":3},"fn_name":"test_lock"},{"line":1129,"address":[1205127],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1130,"address":[1205183],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1131,"address":[1205389,1205242],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1133,"address":[1205421,1205346],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1134,"address":[1205429],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1136,"address":[1205469],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1137,"address":[1205533],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1138,"address":[1205578],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1139,"address":[1205634],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1143,"address":[1205756],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1145,"address":[1205820],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1146,"address":[1205891,1205843],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1147,"address":[1205915],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1148,"address":[1205922],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1151,"address":[1206228,1206102],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1154,"address":[1206221],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1155,"address":[1206261],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1156,"address":[1206349],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1157,"address":[1206405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1160,"address":[1206653,1206513],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1164,"address":[1206768,1209202],"length":1,"stats":{"Line":3},"fn_name":"test_change_parameter"},{"line":1165,"address":[1206775],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1166,"address":[1206871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1168,"address":[1206930],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1169,"address":[1206981],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1171,"address":[1207021],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1172,"address":[1207085,1207130],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1173,"address":[1207138],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1174,"address":[1207297],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1175,"address":[1207202],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1176,"address":[1207229],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1181,"address":[1207598],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1183,"address":[1207662],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1184,"address":[1207685,1207733],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1185,"address":[1207757],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1186,"address":[1207902],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1187,"address":[1207772],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1188,"address":[1207837],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1194,"address":[1208204],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1195,"address":[1208211],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1196,"address":[1208307],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1197,"address":[1208466],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1198,"address":[1208371],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1199,"address":[1208398],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1203,"address":[1208848],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1204,"address":[1208753],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":403,"coverable":562},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","raffles","src","error.rs"],"content":"use cosmwasm_std::StdError;\nuse raffles_export::state::{AssetInfo, RaffleState};\nuse thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized {},\n\n    #[error(\"An unplanned bug just happened :/\")]\n    ContractBug {},\n\n    #[error(\"This action is not allowed, the contract is locked\")]\n    ContractIsLocked {},\n\n    #[error(\"Key already exists in RaffleInfo\")]\n    ExistsInRaffleInfo {},\n\n    #[error(\"Raffle ID does not exist\")]\n    NotFoundInRaffleInfo {},\n\n    #[error(\"You can't buy tickets on this raffle anymore\")]\n    CantBuyTickets {},\n\n    #[error(\"A raffle can only be done with CW721 or CW1155 assets\")]\n    WrongAssetType {},\n\n    #[error(\"Tickets to a raffle can only be bought with native assets or CW20 coins\")]\n    WrongFundsType {},\n\n    #[error(\"The sent asset doesn't match the asset in the message sent along with it\")]\n    AssetMismatch {},\n\n    #[error(\"The sent assets ({assets_received:?}) don't match the required assets ({assets_wanted:?}) for this raffle\")]\n    PaiementNotSufficient {\n        assets_wanted: AssetInfo,\n        assets_received: AssetInfo,\n    },\n\n    #[error(\"Too much tickets were already purchased for this raffle\")]\n    TooMuchTickets {},\n\n    #[error(\"The provided randomness is invalid current round : {round:?}\")]\n    RandomnessNotAccepted { round: u64 },\n\n    #[error(\"This raffle is not ready to accept new randomness. Only Closed raffles can be decided upon. Current status : {status:?}\")]\n    WrongStateForRandmness { status: RaffleState },\n\n    #[error(\"This raffle is not ready to be claimed.  Current status : {status:?}\")]\n    WrongStateForClaim { status: RaffleState },\n\n    #[error(\"The public key you indicated is invalid\")]\n    InvalidPubkey {},\n\n    #[error(\"The randomness signatur is invalid\")]\n    InvalidSignature {},\n\n    #[error(\"Wrong Format for the verify response\")]\n    ParseReplyError {},\n\n    #[error(\"This parameter name was not found, you can't change it !\")]\n    ParameterNotFound {},\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","raffles","src","lib.rs"],"content":"pub mod contract;\nmod error;\npub mod query;\npub mod rand;\npub mod state;\n\npub use crate::error::ContractError;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","raffles","src","query.rs"],"content":"use anyhow::Result;\n#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::{Addr, Api, Deps, Env, Order, StdResult};\n\nuse cw_storage_plus::Bound;\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse crate::state::{get_raffle_state, CONTRACT_INFO, RAFFLE_INFO};\nuse raffles_export::msg::QueryFilters;\nuse raffles_export::state::{AssetInfo, ContractInfo, RaffleInfo};\n\n// settings for pagination\nconst MAX_LIMIT: u32 = 30;\nconst DEFAULT_LIMIT: u32 = 10;\nconst BASE_LIMIT: usize = 100;\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug, Default)]\npub struct RaffleResponse {\n    pub raffle_id: u64,\n    pub raffle_info: Option\u003cRaffleInfo\u003e,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug, Default)]\npub struct AllRafflesResponse {\n    pub raffles: Vec\u003cRaffleResponse\u003e,\n}\n\npub fn query_contract_info(deps: Deps) -\u003e StdResult\u003cContractInfo\u003e {\n    CONTRACT_INFO.load(deps.storage)\n}\n\n/*\n\n         QueryMsg::GetTickets {\n            raffle_id,\n            start_after,\n            limit,\n            filters,\n        } =\u003e query_tickets(deps, env, raffle_id, start_after, limit, filters),\n         QueryMsg::GetAllTickets {\n            start_after,\n            limit,\n            filters,\n        } =\u003e query_all_tickets(deps, env, start_after, limit, filters),\n\n*/\n\n// parse raffles to human readable format\nfn parse_raffles(_: \u0026dyn Api, item: StdResult\u003c(u64, RaffleInfo)\u003e) -\u003e StdResult\u003cRaffleResponse\u003e {\n    item.map(|(raffle_id, raffle)| RaffleResponse {\n        raffle_id,\n        raffle_info: Some(raffle),\n    })\n}\n\npub fn raffle_filter(\n    _api: \u0026dyn Api,\n    env: Env,\n    raffle_info: \u0026StdResult\u003cRaffleResponse\u003e,\n    filters: \u0026Option\u003cQueryFilters\u003e,\n) -\u003e bool {\n    if let Some(filters) = filters {\n        let raffle = raffle_info.as_ref().unwrap();\n\n        (match \u0026filters.states {\n            Some(state) =\u003e state\n                .contains(\u0026get_raffle_state(env, raffle.raffle_info.clone().unwrap()).to_string()),\n            None =\u003e true,\n        } \u0026\u0026 match \u0026filters.owner {\n            Some(owner) =\u003e raffle.raffle_info.as_ref().unwrap().owner == owner.clone(),\n            None =\u003e true,\n        } \u0026\u0026 match \u0026filters.ticket_depositor {\n            Some(ticket_depositor) =\u003e raffle\n                .raffle_info\n                .as_ref()\n                .unwrap()\n                .tickets\n                .contains(ticket_depositor),\n            None =\u003e true,\n        } \u0026\u0026 match \u0026filters.contains_token {\n            Some(token) =\u003e match raffle.raffle_info.clone().unwrap().asset {\n                AssetInfo::Coin(x) =\u003e x.denom == token.as_ref(),\n                AssetInfo::Cw20Coin(x) =\u003e x.address == token.as_ref(),\n                AssetInfo::Cw721Coin(x) =\u003e x.address == token.as_ref(),\n                AssetInfo::Cw1155Coin(x) =\u003e x.address == token.as_ref(),\n            },\n            None =\u003e true,\n        })\n    } else {\n        true\n    }\n}\n\npub fn query_ticket_number(\n    deps: Deps,\n    _env: Env,\n    raffle_id: u64,\n    ticket_depositor: Addr,\n) -\u003e Result\u003cu64\u003e {\n    let raffle_info = RAFFLE_INFO.load(deps.storage, raffle_id)?;\n    Ok(raffle_info\n        .tickets\n        .iter()\n        .filter(|\u0026t| *t == ticket_depositor)\n        .count() as u64)\n}\npub fn query_all_raffles(\n    deps: Deps,\n    env: Env,\n    start_after: Option\u003cu64\u003e,\n    limit: Option\u003cu32\u003e,\n    filters: Option\u003cQueryFilters\u003e,\n) -\u003e StdResult\u003cAllRafflesResponse\u003e {\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n    let start = start_after.map(Bound::exclusive);\n\n    let mut raffles: Vec\u003cRaffleResponse\u003e = RAFFLE_INFO\n        .range(deps.storage, None, start.clone(), Order::Descending)\n        .take(BASE_LIMIT)\n        .map(|kv_item| parse_raffles(deps.api, kv_item))\n        .filter(|response| raffle_filter(deps.api, env.clone(), response, \u0026filters))\n        .take(limit)\n        .collect::\u003cStdResult\u003cVec\u003cRaffleResponse\u003e\u003e\u003e()?;\n\n    if raffles.is_empty() {\n        let raffle_id = RAFFLE_INFO\n            .keys(deps.storage, None, start, Order::Descending)\n            .take(BASE_LIMIT)\n            .last();\n\n        if let Some(Ok(raffle_id)) = raffle_id {\n            if raffle_id != 0 {\n                raffles = vec![RaffleResponse {\n                    raffle_id,\n                    raffle_info: None,\n                }]\n            }\n        }\n    }\n    Ok(AllRafflesResponse { raffles })\n}\n","traces":[{"line":29,"address":[819504],"length":1,"stats":{"Line":0},"fn_name":"query_contract_info"},{"line":30,"address":[819512],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[819552],"length":1,"stats":{"Line":0},"fn_name":"parse_raffles"},{"line":51,"address":[819598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[1172548],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[819648,822672],"length":1,"stats":{"Line":0},"fn_name":"raffle_filter"},{"line":63,"address":[819711],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[819777,819843,819922],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[820442,822703,821027,819930,820751],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[820352,819982],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[820065,820382],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[819961],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[820473],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[820538],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[820509],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[820798],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[820863],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[820834],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[821074],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[821139],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[821519],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[822047,821245],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[821331,821921],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[821417,821795],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[821110],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[819800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[822768,823515],"length":1,"stats":{"Line":0},"fn_name":"query_ticket_number"},{"line":101,"address":[822796,823219,823004,822886],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[822972,823325,823407],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[1172656,1172673],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":108,"address":[823536,825548],"length":1,"stats":{"Line":0},"fn_name":"query_all_raffles"},{"line":115,"address":[823766,823653],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[823789],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[823890,824191,824069,824513,824012],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[823947,824038,823812],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[824061],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[824143],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[824363,824675],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[824966],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[824899],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[825068,825130],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[825151,825392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[825337,825397,825167,825196],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[825184],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[824733],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":45},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","raffles","src","rand.rs"],"content":"// Credits to the scrtlabs raffle contract : https://github.com/scrtlabs/secret-raffle/blob/master/src/rand.rs\n\nuse rand_chacha::ChaChaRng;\nuse rand_core::{RngCore, SeedableRng};\n\nuse sha2::{Digest, Sha256};\n\npub struct Prng {\n    seed: Vec\u003cu8\u003e,\n    pos: u128,\n}\n\nimpl Prng {\n    pub fn new(seed: \u0026[u8]) -\u003e Self {\n        Self {\n            seed: seed.to_vec(),\n            pos: 0,\n        }\n    }\n\n    /// Return a random number (inclusive) between `from` and `to`\n    pub fn random_between(\u0026mut self, from: u32, to: u32) -\u003e u32 {\n        if from \u003e to {\n            return 0;\n        }\n\n        from + (self.rand_u32() % (to - from + 1))\n    }\n\n    fn rand_u32(\u0026mut self) -\u003e u32 {\n        let mut hasher = Sha256::new();\n\n        // write input message\n        hasher.update(\u0026self.seed);\n        let hash = hasher.finalize();\n\n        let mut result = [0u8; 32];\n        result.copy_from_slice(hash.as_slice());\n\n        let mut rng: ChaChaRng = ChaChaRng::from_seed(result);\n\n        rng.set_word_pos(self.pos);\n        self.pos += 8;\n\n        rng.next_u32()\n    }\n}\n","traces":[{"line":14,"address":[629552],"length":1,"stats":{"Line":2},"fn_name":"new"},{"line":16,"address":[629575],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[629648],"length":1,"stats":{"Line":2},"fn_name":"random_between"},{"line":23,"address":[629678],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[629698],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[629904,629687,629723],"length":1,"stats":{"Line":4},"fn_name":null},{"line":30,"address":[629936],"length":1,"stats":{"Line":2},"fn_name":"rand_u32"},{"line":31,"address":[629956],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[629971],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[629981],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[630025],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[630045],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[630115],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[630205],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[630231,630306],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[630287],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":15,"coverable":16},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","raffles","src","state.rs"],"content":"use anyhow::{anyhow, Result};\nuse cw_storage_plus::{Item, Map};\n\nuse cosmwasm_std::{\n    coins, Addr, BankMsg, CosmosMsg, Deps, Env, Response, StdError, Storage, SubMsg, Uint128,\n};\n\nuse crate::error::ContractError;\nuse crate::rand::Prng;\nuse raffles_export::msg::{into_cosmos_msg, DrandRandomness, VerifierExecuteMsg};\nuse raffles_export::state::{AssetInfo, ContractInfo, RaffleInfo, RaffleState};\n\nuse cw1155::Cw1155ExecuteMsg;\nuse cw20::Cw20ExecuteMsg;\nuse cw721::Cw721ExecuteMsg;\n\npub const CONTRACT_INFO: Item\u003cContractInfo\u003e = Item::new(\"contract_info\");\n\npub const RAFFLE_INFO: Map\u003cu64, RaffleInfo\u003e = Map::new(\"raffle_info\");\npub const USER_TICKETS: Map\u003c(\u0026Addr, u64), u64\u003e = Map::new(\"uset_tickets\");\n\n// This function is largely inspired (and even directly copied) from https://github.com/confio/rand/.\n// Part of the randomness flow was inspired from https://github.com/scrtlabs/secret-raffle/ and https://github.com/LoTerra/terrand-contract-step1/\n\npub fn assert_randomness_origin_and_order(\n    deps: Deps,\n    owner: Addr,\n    raffle_id: u64,\n    randomness: DrandRandomness,\n) -\u003e Result\u003cResponse\u003e {\n    let raffle_info = load_raffle(deps.storage, raffle_id)?;\n    let contract_info = CONTRACT_INFO.load(deps.storage)?;\n\n    if randomness.round \u003c= raffle_info.randomness_round {\n        return Err(anyhow!(ContractError::RandomnessNotAccepted {\n            round: randomness.round\n        }));\n    }\n\n    let msg = VerifierExecuteMsg::Verify {\n        randomness,\n        pubkey: contract_info.random_pubkey,\n        raffle_id,\n        owner: owner.to_string(),\n    };\n    let res = into_cosmos_msg(msg, contract_info.verify_signature_contract.to_string())?;\n\n    let msg = SubMsg::reply_on_success(res, 0);\n    Ok(Response::new().add_submessage(msg))\n}\n\npub fn is_owner(storage: \u0026dyn Storage, sender: Addr) -\u003e Result\u003cContractInfo, ContractError\u003e {\n    let contract_info = CONTRACT_INFO.load(storage)?;\n    if sender == contract_info.owner {\n        Ok(contract_info)\n    } else {\n        Err(ContractError::Unauthorized {})\n    }\n}\n\npub fn get_raffle_winner(raffle_info: RaffleInfo) -\u003e Result\u003cAddr\u003e {\n    // We initiate the random number generator\n    let mut rng: Prng = Prng::new(\u0026raffle_info.randomness);\n\n    // We pick a winner id\n    let winner_id = rng.random_between(0u32, raffle_info.tickets.len() as u32);\n    let winner = raffle_info.tickets[winner_id as usize].clone();\n\n    Ok(winner)\n}\n\npub fn get_raffle_state(env: Env, raffle_info: RaffleInfo) -\u003e RaffleState {\n    if env.block.time \u003c raffle_info.raffle_start_timestamp {\n        RaffleState::Created\n    } else if env.block.time\n        \u003c raffle_info\n            .raffle_start_timestamp\n            .plus_seconds(raffle_info.raffle_duration)\n    {\n        RaffleState::Started\n    } else if env.block.time\n        \u003c raffle_info\n            .raffle_start_timestamp\n            .plus_seconds(raffle_info.raffle_duration)\n            .plus_seconds(raffle_info.raffle_timeout)\n        || raffle_info.randomness_owner.is_none()\n    {\n        RaffleState::Closed\n    } else if raffle_info.winner.is_none() {\n        RaffleState::Finished\n    } else {\n        RaffleState::Claimed\n    }\n}\n\npub fn load_ticket_number(storage: \u0026dyn Storage, raffle_id: u64, owner: Addr) -\u003e Result\u003cu64\u003e {\n    let raffle_info = RAFFLE_INFO\n        .load(storage, raffle_id)\n        .map_err(|_| ContractError::NotFoundInRaffleInfo {})?;\n\n    Ok(raffle_info\n        .tickets\n        .iter()\n        .filter(|\u0026ticket_owner| *ticket_owner == owner)\n        .count() as u64)\n}\n\npub fn load_raffle(storage: \u0026dyn Storage, raffle_id: u64) -\u003e Result\u003cRaffleInfo\u003e {\n    RAFFLE_INFO\n        .load(storage, raffle_id)\n        .map_err(|_| anyhow!(ContractError::NotFoundInRaffleInfo {}))\n}\n\npub fn can_buy_ticket(env: Env, raffle_info: RaffleInfo) -\u003e Result\u003c()\u003e {\n    if get_raffle_state(env, raffle_info) == RaffleState::Started {\n        Ok(())\n    } else {\n        Err(anyhow!(ContractError::CantBuyTickets {}))\n    }\n}\n\npub fn get_asset_amount(asset: AssetInfo) -\u003e Result\u003cUint128\u003e {\n    match asset {\n        AssetInfo::Cw20Coin(coin) =\u003e Ok(coin.amount),\n        AssetInfo::Coin(coin) =\u003e Ok(coin.amount),\n        _ =\u003e Err(anyhow!(ContractError::WrongFundsType {})),\n    }\n}\n\npub fn get_raffle_winner_message(env: Env, raffle_info: RaffleInfo) -\u003e Result\u003cCosmosMsg\u003e {\n    match raffle_info.asset {\n        AssetInfo::Cw721Coin(nft) =\u003e {\n            let message = Cw721ExecuteMsg::TransferNft {\n                recipient: raffle_info.winner.unwrap().to_string(),\n                token_id: nft.token_id.clone(),\n            };\n            into_cosmos_msg(message, nft.address)\n        }\n        AssetInfo::Cw1155Coin(cw1155) =\u003e {\n            let message = Cw1155ExecuteMsg::SendFrom {\n                from: env.contract.address.to_string(),\n                to: raffle_info.winner.unwrap().to_string(),\n                token_id: cw1155.token_id.clone(),\n                value: cw1155.value,\n                msg: None,\n            };\n            into_cosmos_msg(message, cw1155.address)\n        }\n        _ =\u003e Err(anyhow!(StdError::generic_err(\n            \"Unreachable, wrong asset type raffled\"\n        ))),\n    }\n}\n\npub fn get_raffle_owner_finished_messages(\n    storage: \u0026dyn Storage,\n    _env: Env,\n    raffle_info: RaffleInfo,\n) -\u003e Result\u003cVec\u003cCosmosMsg\u003e\u003e {\n    let contract_info = CONTRACT_INFO.load(storage)?;\n    match raffle_info.accumulated_ticket_fee {\n        AssetInfo::Cw20Coin(coin) =\u003e {\n            // We start by splitting the fees between owner, treasury and radomness provider\n            let rand_amount = coin.amount * contract_info.rand_fee / Uint128::from(10_000u128);\n            let treasury_amount =\n                coin.amount * contract_info.raffle_fee / Uint128::from(10_000u128);\n            let owner_amount = coin.amount - rand_amount - treasury_amount;\n\n            let mut messages: Vec\u003cCosmosMsg\u003e = vec![];\n            if rand_amount != Uint128::zero() {\n                messages.push(into_cosmos_msg(\n                    Cw20ExecuteMsg::Transfer {\n                        recipient: raffle_info.randomness_owner.unwrap().to_string(),\n                        amount: rand_amount,\n                    },\n                    coin.address.clone(),\n                )?);\n            };\n            if treasury_amount != Uint128::zero() {\n                messages.push(into_cosmos_msg(\n                    Cw20ExecuteMsg::Transfer {\n                        recipient: contract_info.fee_addr.to_string(),\n                        amount: treasury_amount,\n                    },\n                    coin.address.clone(),\n                )?);\n            };\n            if owner_amount != Uint128::zero() {\n                messages.push(into_cosmos_msg(\n                    Cw20ExecuteMsg::Transfer {\n                        recipient: raffle_info.owner.to_string(),\n                        amount: owner_amount,\n                    },\n                    coin.address,\n                )?);\n            };\n            Ok(messages)\n        }\n        AssetInfo::Coin(coin) =\u003e {\n            // We start by splitting the fees between owner, treasury and radomness provider\n            let rand_amount = coin.amount * contract_info.rand_fee / Uint128::from(10_000u128);\n            let treasury_amount =\n                coin.amount * contract_info.raffle_fee / Uint128::from(10_000u128);\n            let owner_amount = coin.amount - rand_amount - treasury_amount;\n\n            let mut messages: Vec\u003cCosmosMsg\u003e = vec![];\n            if rand_amount != Uint128::zero() {\n                messages.push(\n                    BankMsg::Send {\n                        to_address: raffle_info.randomness_owner.unwrap().to_string(),\n                        amount: coins(rand_amount.u128(), coin.denom.clone()),\n                    }\n                    .into(),\n                );\n            };\n            if treasury_amount != Uint128::zero() {\n                messages.push(\n                    BankMsg::Send {\n                        to_address: contract_info.fee_addr.to_string(),\n                        amount: coins(treasury_amount.u128(), coin.denom.clone()),\n                    }\n                    .into(),\n                );\n            };\n            if owner_amount != Uint128::zero() {\n                messages.push(\n                    BankMsg::Send {\n                        to_address: raffle_info.owner.to_string(),\n                        amount: coins(owner_amount.u128(), coin.denom),\n                    }\n                    .into(),\n                );\n            };\n\n            Ok(messages)\n        }\n        _ =\u003e Err(anyhow!(ContractError::WrongFundsType {})),\n    }\n}\n","traces":[{"line":25,"address":[708865,705472],"length":1,"stats":{"Line":1},"fn_name":"assert_randomness_origin_and_order"},{"line":31,"address":[705668,705825,705526,705793],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[706047,706199,705887,705932,705759],"length":1,"stats":{"Line":3},"fn_name":null},{"line":34,"address":[706020],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[706384,706601],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[706381],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[706318],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[706366],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[706824,707607,707024,707650],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[707436,708107],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[708285,708171,708123],"length":1,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[708880,709564],"length":1,"stats":{"Line":1},"fn_name":"is_owner"},{"line":53,"address":[709307,708924,709015,709136],"length":1,"stats":{"Line":4},"fn_name":null},{"line":54,"address":[709351,709442,709112],"length":1,"stats":{"Line":4},"fn_name":null},{"line":55,"address":[709444],"length":1,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[709400],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[709584,709893],"length":1,"stats":{"Line":2},"fn_name":"get_raffle_winner"},{"line":63,"address":[709606],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[709697,709760,709635],"length":1,"stats":{"Line":6},"fn_name":null},{"line":67,"address":[709767],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[709817],"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[710431,709936],"length":1,"stats":{"Line":1},"fn_name":"get_raffle_state"},{"line":73,"address":[709953],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[710067],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[710106,710187,710031],"length":1,"stats":{"Line":4},"fn_name":null},{"line":76,"address":[710101,710040,710051],"length":1,"stats":{"Line":3},"fn_name":null},{"line":78,"address":[710047],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[710182],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[710351,710244,710297,710146],"length":1,"stats":{"Line":6},"fn_name":null},{"line":82,"address":[710199,710166,710208,710155],"length":1,"stats":{"Line":8},"fn_name":null},{"line":84,"address":[710162],"length":1,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[710204],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[710279],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[710346],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[710384,710360,710394,710328],"length":1,"stats":{"Line":5},"fn_name":null},{"line":90,"address":[710389],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[710379],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[710464,711163],"length":1,"stats":{"Line":0},"fn_name":"load_ticket_number"},{"line":97,"address":[710819,710512,710611],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[635159,635136],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":101,"address":[710707,710975,711060],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[635184,635201],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":108,"address":[711184],"length":1,"stats":{"Line":1},"fn_name":"load_raffle"},{"line":109,"address":[711233],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[635260,635248],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":114,"address":[711608,711280],"length":1,"stats":{"Line":2},"fn_name":"can_buy_ticket"},{"line":115,"address":[711647,711298],"length":1,"stats":{"Line":3},"fn_name":null},{"line":116,"address":[711460],"length":1,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[711397,711623,711482],"length":1,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[711664,712306],"length":1,"stats":{"Line":2},"fn_name":"get_asset_amount"},{"line":123,"address":[711686],"length":1,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[711834],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[711923],"length":1,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[712180,711758,712020],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[712448,715564],"length":1,"stats":{"Line":1},"fn_name":"get_raffle_winner_message"},{"line":131,"address":[712475],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[712636],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[712679,714061],"length":1,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[714109],"length":1,"stats":{"Line":1},"fn_name":null},{"line":137,"address":[714320],"length":1,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[712760],"length":1,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[712824],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[713322,713197],"length":1,"stats":{"Line":2},"fn_name":null},{"line":143,"address":[713367],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[713435],"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[713711],"length":1,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[712846,712597,712971],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[715600,723809],"length":1,"stats":{"Line":1},"fn_name":"get_raffle_owner_finished_messages"},{"line":160,"address":[715667,716168,716016,715841],"length":1,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[715959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[716297],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[716358,718860,718969],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[719028],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[719214],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[719360],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[719367,719485,720313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[719889,719863,719766,720214],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[719630],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[719523],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[719614],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[719698],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[721036,719491,720328],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[720539,720665,720990,720639],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[720444],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[720405],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[720428],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[720512],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[721051,720381,722677],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[721743,721385],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[721261],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[721238],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[721245],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[721321],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[721112],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[716428],"length":1,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[716909,716489,716800],"length":1,"stats":{"Line":3},"fn_name":null},{"line":202,"address":[716968],"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[717154],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[717312],"length":1,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[717319,717455],"length":1,"stats":{"Line":2},"fn_name":null},{"line":208,"address":[717885],"length":1,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[717770],"length":1,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[717499],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[717590,717763,717666],"length":1,"stats":{"Line":3},"fn_name":null},{"line":216,"address":[717930,717461],"length":1,"stats":{"Line":2},"fn_name":null},{"line":217,"address":[718299],"length":1,"stats":{"Line":2},"fn_name":null},{"line":218,"address":[718184],"length":1,"stats":{"Line":2},"fn_name":null},{"line":219,"address":[718019],"length":1,"stats":{"Line":1},"fn_name":null},{"line":220,"address":[718177,718042],"length":1,"stats":{"Line":4},"fn_name":null},{"line":225,"address":[718327,717989],"length":1,"stats":{"Line":2},"fn_name":null},{"line":226,"address":[718797],"length":1,"stats":{"Line":2},"fn_name":null},{"line":227,"address":[718682],"length":1,"stats":{"Line":2},"fn_name":null},{"line":228,"address":[718520],"length":1,"stats":{"Line":2},"fn_name":null},{"line":229,"address":[718527],"length":1,"stats":{"Line":2},"fn_name":null},{"line":235,"address":[718394],"length":1,"stats":{"Line":1},"fn_name":null},{"line":237,"address":[716712,716551,716217],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":79,"coverable":116},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","randomness_verifier","examples","oracle_schema.rs"],"content":"use std::env::current_dir;\nuse std::fs::create_dir_all;\n\nuse cosmwasm_schema::{export_schema, remove_schemas, schema_for};\n\nuse raffles_export::msg::{VerifierExecuteMsg};\n\nfn main() {\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"schema\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n\n    export_schema(\u0026schema_for!(VerifierExecuteMsg), \u0026out_dir);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","randomness_verifier","src","contract.rs"],"content":"#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::{\n    entry_point, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdError, StdResult,\n};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse raffles_export::msg::{DrandRandomness, VerifierExecuteMsg};\n\nuse drand_verify::{derive_randomness, g1_from_variable, verify};\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct EmptyMsg {}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    _deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    _msg: EmptyMsg,\n) -\u003e StdResult\u003cResponse\u003e {\n    // store token info\n    Ok(Response::default().add_attribute(\"fee_contract\", \"randomness_verifier\"))\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    _deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    msg: VerifierExecuteMsg,\n) -\u003e StdResult\u003cResponse\u003e {\n    match msg {\n        VerifierExecuteMsg::Verify {\n            randomness,\n            pubkey,\n            raffle_id,\n            owner,\n        } =\u003e execute_verify(randomness, pubkey, raffle_id, owner),\n    }\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(_deps: Deps, _env: Env, _msg: EmptyMsg) -\u003e StdResult\u003cBinary\u003e {\n    Err(StdError::generic_err(\"No queries\"))\n}\n\npub fn execute_verify(\n    randomness: DrandRandomness,\n    pubkey: Binary,\n    raffle_id: u64,\n    owner: String,\n) -\u003e StdResult\u003cResponse\u003e {\n    let pk = g1_from_variable(\u0026pubkey).map_err(|_| StdError::generic_err(\"Invalid Public Key\"))?;\n    let valid = verify(\n        \u0026pk,\n        randomness.round,\n        randomness.previous_signature.as_slice(),\n        randomness.signature.as_slice(),\n    )\n    .unwrap_or(false);\n\n    if !valid {\n        return Err(StdError::generic_err(\"Invalid Signature\"));\n    }\n\n    let randomness_result = derive_randomness(\u0026randomness.signature);\n\n    Ok(Response::new()\n        .add_attribute(\"round\", randomness.round.to_string())\n        .add_attribute(\"randomness\", Binary::from(randomness_result).to_string())\n        .add_attribute(\"raffle_id\", raffle_id.to_string())\n        .add_attribute(\"owner\", owner.to_string()))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","randomness_verifier","src","lib.rs"],"content":"pub mod contract;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","CW4626","src","lib.rs"],"content":"pub mod msg;\npub mod query;\npub mod state;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","CW4626","src","msg.rs"],"content":"use cosmwasm_std::{StdError, StdResult};\nuse cw20_base::msg::InstantiateMarketingInfo;\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse crate::state::AssetInfo;\nuse cosmwasm_std::{Binary, Uint128};\nuse cw20::{Cw20Coin, Expiration, Logo, MinterResponse};\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct InstantiateMsg {\n    pub name: String,\n    pub symbol: String,\n    pub decimals: u8,\n    pub initial_balances: Vec\u003cCw20Coin\u003e,\n    pub mint: Option\u003cMinterResponse\u003e,\n    pub marketing: Option\u003cInstantiateMarketingInfo\u003e,\n    pub asset: AssetInfo,\n    pub borrower: Option\u003cString\u003e,\n}\n\nimpl InstantiateMsg {\n    pub fn get_cap(\u0026self) -\u003e Option\u003cUint128\u003e {\n        self.mint.as_ref().and_then(|v| v.cap)\n    }\n\n    pub fn validate(\u0026self) -\u003e StdResult\u003c()\u003e {\n        // Check name, symbol, decimals\n        if !is_valid_name(\u0026self.name) {\n            return Err(StdError::generic_err(\n                \"Name is not in the expected format (3-50 UTF-8 bytes)\",\n            ));\n        }\n        if !is_valid_symbol(\u0026self.symbol) {\n            return Err(StdError::generic_err(\n                \"Ticker symbol is not in expected format [a-zA-Z\\\\-]{3,12}\",\n            ));\n        }\n        if self.decimals \u003e 18 {\n            return Err(StdError::generic_err(\"Decimals must not exceed 18\"));\n        }\n        Ok(())\n    }\n}\n\nfn is_valid_name(name: \u0026str) -\u003e bool {\n    let bytes = name.as_bytes();\n    if bytes.len() \u003c 3 || bytes.len() \u003e 50 {\n        return false;\n    }\n    true\n}\n\nfn is_valid_symbol(symbol: \u0026str) -\u003e bool {\n    let bytes = symbol.as_bytes();\n    if bytes.len() \u003c 3 || bytes.len() \u003e 12 {\n        return false;\n    }\n    for byte in bytes.iter() {\n        if (*byte != 45) \u0026\u0026 (*byte \u003c 65 || *byte \u003e 90) \u0026\u0026 (*byte \u003c 97 || *byte \u003e 122) {\n            return false;\n        }\n    }\n    true\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub enum ExecuteMsg {\n    /// Transfer is a base message to move tokens to another account without triggering actions\n    Transfer { recipient: String, amount: Uint128 },\n    /// Burn is a base message to destroy tokens forever\n    Burn { amount: Uint128 },\n    /// Send is a base message to transfer tokens to a contract and trigger an action\n    /// on the receiving contract.\n    Send {\n        contract: String,\n        amount: Uint128,\n        msg: Binary,\n    },\n    /// Only with \"approval\" extension. Allows spender to access an additional amount tokens\n    /// from the owner's (env.sender) account. If expires is Some(), overwrites current allowance\n    /// expiration with this one.\n    IncreaseAllowance {\n        spender: String,\n        amount: Uint128,\n        expires: Option\u003cExpiration\u003e,\n    },\n    /// Only with \"approval\" extension. Lowers the spender's access of tokens\n    /// from the owner's (env.sender) account by amount. If expires is Some(), overwrites current\n    /// allowance expiration with this one.\n    DecreaseAllowance {\n        spender: String,\n        amount: Uint128,\n        expires: Option\u003cExpiration\u003e,\n    },\n    /// Only with \"approval\" extension. Transfers amount tokens from owner -\u003e recipient\n    /// if `env.sender` has sufficient pre-approval.\n    TransferFrom {\n        owner: String,\n        recipient: String,\n        amount: Uint128,\n    },\n    /// Only with \"approval\" extension. Sends amount tokens from owner -\u003e contract\n    /// if `env.sender` has sufficient pre-approval.\n    SendFrom {\n        owner: String,\n        contract: String,\n        amount: Uint128,\n        msg: Binary,\n    },\n    /// Only with \"approval\" extension. Destroys tokens forever\n    BurnFrom { owner: String, amount: Uint128 },\n    /// Only with the \"marketing\" extension. If authorized, updates marketing metadata.\n    /// Setting None/null for any of these will leave it unchanged.\n    /// Setting Some(\"\") will clear this field on the contract storage\n    UpdateMarketing {\n        /// A URL pointing to the project behind this token.\n        project: Option\u003cString\u003e,\n        /// A longer description of the token and it's utility. Designed for tooltips or such\n        description: Option\u003cString\u003e,\n        /// The address (if any) who can update this data structure\n        marketing: Option\u003cString\u003e,\n    },\n    /// If set as the \"marketing\" role on the contract, upload a new URL, SVG, or PNG for the token\n    UploadLogo(Logo),\n\n    // EIP4626 specific functions\n    /// Deposit an exact amount of assets in the vault (will mint some shares of the asset to the receiver)\n    Deposit { assets: Uint128, receiver: String },\n    /// Deposit an variable amount of assets in the vault to mint exactly the indicated number of shares to the receiver\n    Mint { shares: Uint128, receiver: String },\n    /// Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n    Withdraw {\n        assets: Uint128,\n        owner: String,\n        receiver: String,\n    },\n    /// Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n    Redeem {\n        shares: Uint128,\n        owner: String,\n        receiver: String,\n    },\n\n    // Treasury borrow specific functions (outside of EIP 4626, but still needed in most cases, let us do that plz)\n    /// Borrow some underlying assets to get yield elsewhere\n    Borrow { receiver: String, assets: Uint128 },\n    Repay {\n        owner: Option\u003cString\u003e,\n        assets: Uint128,\n    },\n    Receive {\n        sender: String,\n        amount: Uint128,\n        msg: Binary,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub enum ReceiveMsg {\n    Repay { assets: Uint128 },\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","CW4626","src","query.rs"],"content":"use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_std::Uint128;\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    /// Returns the current balance of the given address, 0 if unset.\n    /// Return type: BalanceResponse.\n    Balance { address: String },\n    /// Returns metadata on the contract - name, decimals, supply, etc.\n    /// Return type: TokenInfoResponse.\n    TokenInfo {},\n    /// Only with \"allowance\" extension.\n    /// Returns how much spender can use from owner account, 0 if unset.\n    /// Return type: AllowanceResponse.\n    Allowance { owner: String, spender: String },\n    /// Only with \"mintable\" extension.\n    /// Returns who can mint and the hard cap on maximum tokens after minting.\n    /// Return type: MinterResponse.\n    Minter {},\n    /// Only with \"marketing\" extension\n    /// Returns more metadata on the contract to display in the client:\n    /// - description, logo, project url, etc.\n    /// Return type: MarketingInfoResponse.\n    MarketingInfo {},\n    /// Only with \"marketing\" extension\n    /// Downloads the embedded logo data (if stored on chain). Errors if no logo data stored for\n    /// this contract.\n    /// Return type: DownloadLogoResponse.\n    DownloadLogo {},\n    /// Only with \"enumerable\" extension (and \"allowances\")\n    /// Returns all allowances this owner has approved. Supports pagination.\n    /// Return type: AllAllowancesResponse.\n    AllAllowances {\n        owner: String,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    },\n    /// Only with \"enumerable\" extension\n    /// Returns all accounts that have balances. Supports pagination.\n    /// Return type: AllAccountsResponse.\n    AllAccounts {\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    },\n\n    // EIP4626 specific functions\n    /// Returns info about the underlying asset\n    Asset {},\n    /// Returns the total number of underlying assets backing the token\n    TotalAssets {},\n    /// Converts the asset to shares of the token\n    ConvertToShares { assets: Uint128 },\n    /// Converts the shares of the token to assets\n    ConvertToAssets { shares: Uint128 },\n    /// Converts the shares of the token to assets\n    MaxDeposit { receiver: String },\n    /// Converts the shares of the token to assets\n    PreviewDeposit { assets: Uint128 },\n    /// Maximum amount that can be minted to someone in one call\n    MaxMint { receiver: String },\n    /// Allows to preview what happens when minting\n    PreviewMint { shares: Uint128 },\n    /// Maximum amount that can be withdrawn (in assets) to someone in one call\n    MaxWithdraw { owner: String },\n    /// Allows to preview what happens when withdrawing funds (exactly the indicated number of underlying asset)\n    PreviewWithdraw { assets: Uint128 },\n    /// Maximum amount that can be redeemed (in shares) to someone in one call\n    MaxRedeem { owner: String },\n    /// Allows to preview what happens when redeeming funds (exactly the indicated number of pool shares)\n    PreviewRedeem { shares: Uint128 },\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","CW4626","src","state.rs"],"content":"use cosmwasm_std::{\n    to_binary, Addr, BalanceResponse, BankQuery, Deps, Env, QueryRequest, StdError, StdResult,\n    Uint128, WasmQuery,\n};\n\nuse cw20::{Cw20QueryMsg, TokenInfoResponse};\nuse cw_storage_plus::{Item, Key, KeyDeserialize, PrimaryKey};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\npub const STATE: Item\u003cState\u003e = Item::new(\"contract_state\");\n\n/// EIP specific 4626 info\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct State {\n    pub underlying_asset: AssetInfo,\n    pub total_underlying_asset_supply: Uint128,\n    pub total_assets_borrowed: Uint128,\n    pub borrower: Option\u003cAddr\u003e,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\npub struct MinterData {\n    pub minter: Addr,\n    /// cap is how many more tokens can be issued by the minter\n    pub cap: Option\u003cUint128\u003e,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub enum AssetInfo {\n    Coin(String),\n    Cw20(String),\n}\n\nimpl ToString for AssetInfo {\n    fn to_string(\u0026self) -\u003e String {\n        match self {\n            AssetInfo::Coin(x) =\u003e {\n                let mut ret = \"coin_\".to_string();\n                ret.push_str(x);\n                ret\n            }\n            AssetInfo::Cw20(x) =\u003e {\n                let mut ret = \"cw20_\".to_string();\n                ret.push_str(x);\n                ret\n            }\n        }\n    }\n}\n\nimpl KeyDeserialize for AssetInfo {\n    type Output = AssetInfo;\n\n    #[inline(always)]\n    fn from_vec(value: Vec\u003cu8\u003e) -\u003e StdResult\u003cSelf::Output\u003e {\n        let string_rep = String::from_utf8(value).map_err(StdError::invalid_utf8)?;\n        if let Some(coin_name) = string_rep.strip_prefix(\"coin_\") {\n            Ok(AssetInfo::Coin(coin_name.to_string()))\n        } else if let Some(cw20_name) = string_rep.strip_prefix(\"cw20_\") {\n            Ok(AssetInfo::Cw20(cw20_name.to_string()))\n        } else {\n            Err(StdError::generic_err(\"Wrong asset info saved in memory\"))\n        }\n    }\n}\n\n// Provide a string version of this to raw encode strings\nimpl\u003c'a\u003e PrimaryKey\u003c'a\u003e for AssetInfo {\n    type Prefix = ();\n    type SubPrefix = ();\n    type Suffix = Self;\n    type SuperSuffix = Self;\n\n    fn key(\u0026self) -\u003e Vec\u003cKey\u003e {\n        match self {\n            AssetInfo::Coin(x) =\u003e {\n                let mut keys = \"coin_\".key();\n                keys.extend(x.key());\n                keys\n            }\n            AssetInfo::Cw20(x) =\u003e {\n                let mut keys = \"cw20_\".key();\n                keys.extend(x.key());\n                keys\n            }\n        }\n    }\n}\n\npub fn query_asset_balance(deps: Deps, env: Env) -\u003e Result\u003cUint128, StdError\u003e {\n    let state = STATE.load(deps.storage)?;\n\n    match state.underlying_asset {\n        AssetInfo::Coin(denom) =\u003e query_fund_balance(deps, env.contract.address, denom),\n        AssetInfo::Cw20(address) =\u003e query_cw20_supply(deps, deps.api.addr_validate(\u0026address)?),\n    }\n}\n\npub fn query_asset_liabilities(deps: Deps, _env: Env) -\u003e Result\u003cUint128, StdError\u003e {\n    let state = STATE.load(deps.storage)?;\n    Ok(state.total_assets_borrowed)\n}\n\npub fn query_fund_balance(deps: Deps, account_addr: Addr, denom: String) -\u003e StdResult\u003cUint128\u003e {\n    // load price form the oracle\n    let balance: BalanceResponse = deps.querier.query(\u0026QueryRequest::Bank(BankQuery::Balance {\n        address: account_addr.to_string(),\n        denom,\n    }))?;\n    Ok(balance.amount.amount)\n}\n\npub fn query_cw20_supply(deps: Deps, contract_addr: Addr) -\u003e StdResult\u003cUint128\u003e {\n    // load price form the oracle\n    let token_info: TokenInfoResponse =\n        deps.querier.query(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n            contract_addr: contract_addr.to_string(),\n            msg: to_binary(\u0026Cw20QueryMsg::TokenInfo {})?,\n        }))?;\n\n    Ok(token_info.total_supply)\n}\n","traces":[{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":17},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","bignumber","src","lib.rs"],"content":"mod math;\n\npub use crate::math::{Decimal256, Uint256};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","bignumber","src","math.rs"],"content":"use schemars::JsonSchema;\nuse serde::{de, ser, Deserialize, Deserializer, Serialize};\nuse std::convert::TryFrom;\nuse std::fmt::{self, Write};\nuse std::ops;\nuse std::str::FromStr;\n\nuse bigint::U256;\nuse cosmwasm_std::{Decimal, StdError, Uint128};\n\n/// A fixed-point decimal value with 18 fractional digits, i.e. Decimal256(1_000_000_000_000_000_000) == 1.0\n/// The greatest possible value that can be represented is 115792089237316195423570985008687907853269984665640564039457.584007913129639935 (which is (2^128 - 1) / 10^18)\n#[derive(Copy, Clone, Default, Debug, PartialEq, Eq, PartialOrd, Ord, JsonSchema)]\npub struct Decimal256(#[schemars(with = \"String\")] pub U256);\n\nimpl Decimal256 {\n    pub const MAX: Decimal256 = Decimal256(U256::MAX);\n    pub const DECIMAL_FRACTIONAL: U256 = U256([1_000_000_000_000_000_000u64, 0, 0, 0]);\n\n    /// Create a 1.0 Decimal256\n    pub const fn one() -\u003e Decimal256 {\n        Decimal256(Decimal256::DECIMAL_FRACTIONAL)\n    }\n\n    /// Create a 0.0 Decimal256\n    pub const fn zero() -\u003e Decimal256 {\n        Decimal256(U256([0, 0, 0, 0]))\n    }\n\n    /// Convert x% into Decimal256\n    pub fn percent(x: u64) -\u003e Decimal256 {\n        Decimal256(U256::from(x) * U256::from(10_000_000_000_000_000u64))\n    }\n\n    /// Convert permille (x/1000) into Decimal256\n    pub fn permille(x: u64) -\u003e Decimal256 {\n        Decimal256(U256::from(x) * U256::from(1_000_000_000_000_000u64))\n    }\n\n    /// Returns the ratio (nominator / denominator) as a Decimal256\n    pub fn from_ratio\u003cA: Into\u003cU256\u003e, B: Into\u003cU256\u003e\u003e(nominator: A, denominator: B) -\u003e Decimal256 {\n        let nominator: U256 = nominator.into();\n        let denominator: U256 = denominator.into();\n        if denominator.is_zero() {\n            panic!(\"Denominator must not be zero\");\n        }\n\n        Decimal256(nominator * Decimal256::DECIMAL_FRACTIONAL / denominator)\n    }\n\n    pub fn from_uint256\u003cA: Into\u003cUint256\u003e\u003e(val: A) -\u003e Decimal256 {\n        let num: Uint256 = val.into();\n        Decimal256(num.0 * Decimal256::DECIMAL_FRACTIONAL)\n    }\n\n    pub fn is_zero(\u0026self) -\u003e bool {\n        self.0.is_zero()\n    }\n}\n\nimpl From\u003cDecimal\u003e for Decimal256 {\n    fn from(val: Decimal) -\u003e Self {\n        Decimal256::from_str(\u0026val.to_string()).unwrap()\n    }\n}\n\nimpl From\u003cDecimal256\u003e for Decimal {\n    fn from(n: Decimal256) -\u003e Self {\n        let U256(ref arr) = n.0;\n        assert!(arr[2] == 0u64);\n        assert!(arr[3] == 0u64);\n        Decimal::from_str(\u0026n.to_string()).unwrap()\n    }\n}\n\nimpl FromStr for Decimal256 {\n    type Err = StdError;\n\n    /// Converts the decimal string to a Decimal256\n    /// Possible inputs: \"1.23\", \"1\", \"000012\", \"1.123000000\"\n    /// Disallowed: \"\", \".23\"\n    ///\n    /// This never performs any kind of rounding.\n    /// More than 18 fractional digits, even zeros, result in an error.\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let parts: Vec\u003c\u0026str\u003e = input.split('.').collect();\n        match parts.len() {\n            1 =\u003e {\n                let whole = U256::from_dec_str(parts[0])\n                    .map_err(|_| StdError::generic_err(\"Error parsing whole\"))?;\n\n                let whole_as_atomics = whole * Decimal256::DECIMAL_FRACTIONAL;\n                Ok(Decimal256(whole_as_atomics))\n            }\n            2 =\u003e {\n                let whole = U256::from_dec_str(parts[0])\n                    .map_err(|_| StdError::generic_err(\"Error parsing whole\"))?;\n                let fractional = U256::from_dec_str(parts[1])\n                    .map_err(|_| StdError::generic_err(\"Error parsing fractional\"))?;\n                let exp = (18usize.checked_sub(parts[1].len())).ok_or_else(|| {\n                    StdError::generic_err(\"Cannot parse more than 18 fractional digits\")\n                })?;\n                let fractional_factor = U256::from(10).pow(exp.into());\n\n                let whole_as_atomics = whole * Decimal256::DECIMAL_FRACTIONAL;\n                let atomics = whole_as_atomics + fractional * fractional_factor;\n                Ok(Decimal256(atomics))\n            }\n            _ =\u003e Err(StdError::generic_err(\"Unexpected number of dots\")),\n        }\n    }\n}\n\nimpl fmt::Display for Decimal256 {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        let whole = (self.0) / Decimal256::DECIMAL_FRACTIONAL;\n        let fractional = (self.0) % Decimal256::DECIMAL_FRACTIONAL;\n\n        if fractional.is_zero() {\n            write!(f, \"{}\", whole)\n        } else {\n            let fractional_string = fractional.to_string();\n            let fractional_string = \"0\".repeat(18 - fractional_string.len()) + \u0026fractional_string;\n\n            f.write_str(\u0026whole.to_string())?;\n            f.write_char('.')?;\n            f.write_str(fractional_string.trim_end_matches('0'))?;\n\n            Ok(())\n        }\n    }\n}\n\nimpl ops::Add for Decimal256 {\n    type Output = Self;\n\n    fn add(self, rhs: Self) -\u003e Self {\n        Decimal256(self.0 + rhs.0)\n    }\n}\n\nimpl ops::AddAssign for Decimal256 {\n    fn add_assign(\u0026mut self, rhs: Self) {\n        self.0 = self.0 + rhs.0;\n    }\n}\n\nimpl ops::Sub for Decimal256 {\n    type Output = Self;\n\n    fn sub(self, rhs: Self) -\u003e Self {\n        assert!(self.0 \u003e= rhs.0);\n        Decimal256(self.0 - rhs.0)\n    }\n}\n\nimpl ops::Mul for Decimal256 {\n    type Output = Self;\n\n    fn mul(self, rhs: Self) -\u003e Self {\n        Decimal256(self.0 * rhs.0 / Decimal256::DECIMAL_FRACTIONAL)\n    }\n}\n\nimpl ops::Div for Decimal256 {\n    type Output = Self;\n\n    fn div(self, rhs: Self) -\u003e Self {\n        assert!(!rhs.is_zero());\n\n        Decimal256(self.0 * Decimal256::DECIMAL_FRACTIONAL / rhs.0)\n    }\n}\n\n/// Serializes as a decimal string\nimpl Serialize for Decimal256 {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: ser::Serializer,\n    {\n        serializer.serialize_str(\u0026self.to_string())\n    }\n}\n\n/// Deserializes as a base64 string\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for Decimal256 {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cDecimal256, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_str(Decimal256Visitor)\n    }\n}\n\nstruct Decimal256Visitor;\n\nimpl\u003c'de\u003e de::Visitor\u003c'de\u003e for Decimal256Visitor {\n    type Value = Decimal256;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"string-encoded decimal\")\n    }\n\n    fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: de::Error,\n    {\n        match Decimal256::from_str(v) {\n            Ok(d) =\u003e Ok(d),\n            Err(e) =\u003e Err(E::custom(format!(\"Error parsing decimal '{}': {}\", v, e))),\n        }\n    }\n}\n\n//*** Uint256 ***/\n#[derive(Copy, Clone, Default, Debug, PartialEq, Eq, PartialOrd, Ord, JsonSchema)]\npub struct Uint256(#[schemars(with = \"String\")] pub U256);\n\nimpl Uint256 {\n    /// Creates a Uint256(0)\n    pub const fn zero() -\u003e Self {\n        Uint256(U256([0, 0, 0, 0]))\n    }\n\n    /// Create a 1.0 Decimal256\n    pub const fn one() -\u003e Self {\n        Uint256(U256([1, 0, 0, 0]))\n    }\n\n    pub fn is_zero(\u0026self) -\u003e bool {\n        self.0.is_zero()\n    }\n}\n\nimpl From\u003cU256\u003e for Uint256 {\n    fn from(val: U256) -\u003e Self {\n        Uint256(val)\n    }\n}\n\nimpl From\u003cUint256\u003e for U256 {\n    fn from(val: Uint256) -\u003e Self {\n        val.0\n    }\n}\n\n#[inline(always)]\nfn split_u128(a: u128) -\u003e (u64, u64) {\n    ((a \u003e\u003e 64) as _, (a \u0026 0xFFFFFFFFFFFFFFFF) as _)\n}\n\nimpl From\u003cUint128\u003e for Uint256 {\n    fn from(val: Uint128) -\u003e Self {\n        Uint256::from(val.u128())\n    }\n}\n\nimpl From\u003cu128\u003e for Uint256 {\n    fn from(val: u128) -\u003e Self {\n        let (hi, low) = split_u128(val);\n        Uint256(U256([low, hi, 0, 0]))\n    }\n}\n\nimpl From\u003cu64\u003e for Uint256 {\n    fn from(val: u64) -\u003e Self {\n        Uint256(val.into())\n    }\n}\n\nimpl TryFrom\u003c\u0026str\u003e for Uint256 {\n    type Error = StdError;\n\n    fn try_from(val: \u0026str) -\u003e Result\u003cSelf, Self::Error\u003e {\n        match U256::from_dec_str(val) {\n            Ok(u) =\u003e Ok(Uint256(u)),\n            Err(_e) =\u003e Err(StdError::generic_err(format!(\"invalid Uint256 '{}'\", val))),\n        }\n    }\n}\n\nimpl FromStr for Uint256 {\n    type Err = StdError;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let number =\n            U256::from_dec_str(input).map_err(|_| StdError::generic_err(\"Error parsing number\"))?;\n        Ok(Uint256(number))\n    }\n}\n\nimpl From\u003cUint256\u003e for String {\n    fn from(n: Uint256) -\u003e Self {\n        n.0.to_string()\n    }\n}\n\nimpl From\u003cUint256\u003e for u128 {\n    fn from(n: Uint256) -\u003e Self {\n        let U256(ref arr) = n.0;\n        assert!(arr[2] == 0u64);\n        assert!(arr[3] == 0u64);\n\n        let (hi, low) = (arr[1], arr[0]);\n        ((hi as u128) \u003c\u003c 64) + (low as u128)\n    }\n}\n\nimpl From\u003cUint256\u003e for Uint128 {\n    fn from(n: Uint256) -\u003e Self {\n        let num: u128 = n.into();\n        Uint128::from(num)\n    }\n}\n\nimpl fmt::Display for Uint256 {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl ops::Add for Uint256 {\n    type Output = Self;\n\n    fn add(self, rhs: Self) -\u003e Self {\n        Uint256(self.0 + rhs.0)\n    }\n}\n\nimpl ops::AddAssign for Uint256 {\n    fn add_assign(\u0026mut self, other: Self) {\n        self.0 = self.0 + other.0;\n    }\n}\n\nimpl ops::Sub for Uint256 {\n    type Output = Self;\n\n    fn sub(self, rhs: Self) -\u003e Self::Output {\n        assert!(self.0 \u003e= rhs.0);\n        Uint256(self.0 - rhs.0)\n    }\n}\n\nimpl ops::Mul\u003cUint256\u003e for Uint256 {\n    type Output = Self;\n\n    #[allow(clippy::suspicious_arithmetic_impl)]\n    fn mul(self, rhs: Uint256) -\u003e Self::Output {\n        // 0*a and b*0 is always 0\n        if self.is_zero() || rhs.is_zero() {\n            return Uint256::zero();\n        }\n\n        Uint256(self.0 * rhs.0)\n    }\n}\n\n/// Both d*u and u*d with d: Decimal256 and u: Uint256 returns an Uint256. There is no\n/// specific reason for this decision other than the initial use cases we have. If you\n/// need a Decimal256 result for the same calculation, use Decimal256(d*u) or Decimal256(u*d).\nimpl ops::Mul\u003cDecimal256\u003e for Uint256 {\n    type Output = Self;\n\n    #[allow(clippy::suspicious_arithmetic_impl)]\n    fn mul(self, rhs: Decimal256) -\u003e Self::Output {\n        // 0*a and b*0 is always 0\n        if self.is_zero() || rhs.is_zero() {\n            return Uint256::zero();\n        }\n\n        self.multiply_ratio(rhs.0, Decimal256::DECIMAL_FRACTIONAL)\n    }\n}\n\nimpl ops::Div\u003cDecimal256\u003e for Uint256 {\n    type Output = Self;\n\n    fn div(self, rhs: Decimal256) -\u003e Self::Output {\n        assert!(!rhs.is_zero());\n\n        if self.is_zero() {\n            return Uint256::zero();\n        }\n\n        self.multiply_ratio(Decimal256::DECIMAL_FRACTIONAL, rhs.0)\n    }\n}\n\nimpl ops::Mul\u003cUint256\u003e for Decimal256 {\n    type Output = Uint256;\n\n    fn mul(self, rhs: Uint256) -\u003e Self::Output {\n        rhs * self\n    }\n}\n\nimpl Uint256 {\n    /// returns self * nom / denom\n    pub fn multiply_ratio\u003cA: Into\u003cU256\u003e, B: Into\u003cU256\u003e\u003e(\u0026self, nom: A, denom: B) -\u003e Uint256 {\n        let nominator: U256 = nom.into();\n        let denominator: U256 = denom.into();\n        if denominator.is_zero() {\n            panic!(\"Denominator must not be zero\");\n        }\n\n        // TODO: minimize rounding that takes place (using gcd algorithm)\n        let val = self.0 * nominator / denominator;\n        Uint256::from(val)\n    }\n}\n\n/// Serializes as a base64 string\nimpl Serialize for Uint256 {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: ser::Serializer,\n    {\n        serializer.serialize_str(\u0026self.to_string())\n    }\n}\n\n/// Deserializes as a base64 string\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for Uint256 {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cUint256, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_str(Uint256Visitor)\n    }\n}\n\nstruct Uint256Visitor;\n\nimpl\u003c'de\u003e de::Visitor\u003c'de\u003e for Uint256Visitor {\n    type Value = Uint256;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"string-encoded integer\")\n    }\n\n    fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: de::Error,\n    {\n        match U256::from_dec_str(v) {\n            Ok(u) =\u003e Ok(Uint256(u)),\n            Err(_e) =\u003e Err(E::custom(format!(\"invalid Uint256 '{}'\", v))),\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use cosmwasm_std::{from_slice, to_vec, StdResult};\n    use std::convert::TryInto;\n\n    #[test]\n    fn decimal_one() {\n        let value = Decimal256::one();\n        assert_eq!(value.0, Decimal256::DECIMAL_FRACTIONAL);\n    }\n\n    #[test]\n    fn decimal_zero() {\n        let value = Decimal256::zero();\n        assert_eq!(value.0, U256::zero());\n    }\n\n    #[test]\n    fn decimal_percent() {\n        let value = Decimal256::percent(50);\n        assert_eq!(value.0, Decimal256::DECIMAL_FRACTIONAL / 2.into());\n    }\n\n    #[test]\n    fn decimal_permille() {\n        let value = Decimal256::permille(125);\n        assert_eq!(value.0, Decimal256::DECIMAL_FRACTIONAL / 8.into());\n    }\n\n    #[test]\n    fn decimal_from_ratio_works() {\n        // 1.0\n        assert_eq!(Decimal256::from_ratio(1, 1), Decimal256::one());\n        assert_eq!(Decimal256::from_ratio(53, 53), Decimal256::one());\n        assert_eq!(Decimal256::from_ratio(125, 125), Decimal256::one());\n\n        // 1.5\n        assert_eq!(Decimal256::from_ratio(3, 2), Decimal256::percent(150));\n        assert_eq!(Decimal256::from_ratio(150, 100), Decimal256::percent(150));\n        assert_eq!(Decimal256::from_ratio(333, 222), Decimal256::percent(150));\n\n        // 0.125\n        assert_eq!(Decimal256::from_ratio(1, 8), Decimal256::permille(125));\n        assert_eq!(Decimal256::from_ratio(125, 1000), Decimal256::permille(125));\n\n        // 1/3 (result floored)\n        assert_eq!(\n            Decimal256::from_ratio(1, 3),\n            Decimal256(333_333_333_333_333_333u64.into())\n        );\n\n        // 2/3 (result floored)\n        assert_eq!(\n            Decimal256::from_ratio(2, 3),\n            Decimal256(666_666_666_666_666_666u64.into())\n        );\n    }\n\n    #[test]\n    #[should_panic(expected = \"Denominator must not be zero\")]\n    fn decimal_from_ratio_panics_for_zero_denominator() {\n        Decimal256::from_ratio(1, 0);\n    }\n\n    #[test]\n    fn decimal_from_str_works() {\n        // Integers\n        assert_eq!(Decimal256::from_str(\"\").unwrap(), Decimal256::percent(0));\n        assert_eq!(Decimal256::from_str(\"0\").unwrap(), Decimal256::percent(0));\n        assert_eq!(Decimal256::from_str(\"1\").unwrap(), Decimal256::percent(100));\n        assert_eq!(Decimal256::from_str(\"5\").unwrap(), Decimal256::percent(500));\n        assert_eq!(\n            Decimal256::from_str(\"42\").unwrap(),\n            Decimal256::percent(4200)\n        );\n        assert_eq!(Decimal256::from_str(\"000\").unwrap(), Decimal256::percent(0));\n        assert_eq!(\n            Decimal256::from_str(\"001\").unwrap(),\n            Decimal256::percent(100)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"005\").unwrap(),\n            Decimal256::percent(500)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"0042\").unwrap(),\n            Decimal256::percent(4200)\n        );\n\n        // Decimal256s\n        assert_eq!(\n            Decimal256::from_str(\"1.\").unwrap(),\n            Decimal256::percent(100)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"1.0\").unwrap(),\n            Decimal256::percent(100)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"1.5\").unwrap(),\n            Decimal256::percent(150)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"0.5\").unwrap(),\n            Decimal256::percent(50)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"0.123\").unwrap(),\n            Decimal256::permille(123)\n        );\n\n        assert_eq!(\n            Decimal256::from_str(\"40.00\").unwrap(),\n            Decimal256::percent(4000)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"04.00\").unwrap(),\n            Decimal256::percent(400)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"00.40\").unwrap(),\n            Decimal256::percent(40)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"00.04\").unwrap(),\n            Decimal256::percent(4)\n        );\n\n        // Can handle 18 fractional digits\n        assert_eq!(\n            Decimal256::from_str(\"7.123456789012345678\").unwrap(),\n            Decimal256(7123456789012345678u64.into())\n        );\n        assert_eq!(\n            Decimal256::from_str(\"7.999999999999999999\").unwrap(),\n            Decimal256(7999999999999999999u64.into())\n        );\n\n        // Works for documented max value\n        assert_eq!(\n            Decimal256::from_str(\n                \"115792089237316195423570985008687907853269984665640564039457.584007913129639935\"\n            )\n            .unwrap(),\n            Decimal256::MAX\n        );\n    }\n\n    #[test]\n    fn decimal_from_str_errors_for_broken_whole_part() {\n        match Decimal256::from_str(\" \").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Error parsing whole\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n\n        match Decimal256::from_str(\"-1\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Error parsing whole\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn decimal_from_str_errors_for_broken_fractinal_part() {\n        match Decimal256::from_str(\"1. \").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Error parsing fractional\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n\n        match Decimal256::from_str(\"1.e\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Error parsing fractional\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n\n        match Decimal256::from_str(\"1.2e3\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Error parsing fractional\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn decimal_from_str_errors_for_more_than_18_fractional_digits() {\n        match Decimal256::from_str(\"7.1234567890123456789\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e {\n                assert_eq!(msg, \"Cannot parse more than 18 fractional digits\")\n            }\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n\n        // No special rules for trailing zeros. This could be changed but adds gas cost for the happy path.\n        match Decimal256::from_str(\"7.1230000000000000000\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e {\n                assert_eq!(msg, \"Cannot parse more than 18 fractional digits\")\n            }\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn decimal_from_str_errors_for_invalid_number_of_dots() {\n        match Decimal256::from_str(\"1.2.3\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Unexpected number of dots\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n\n        match Decimal256::from_str(\"1.2.3.4\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Unexpected number of dots\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    #[should_panic(expected = \"arithmetic operation overflow\")]\n    fn decimal_from_str_errors_for_more_than_max_value_integer_part() {\n        let _ =\n            Decimal256::from_str(\"115792089237316195423570985008687907853269984665640564039458\");\n    }\n\n    #[test]\n    #[should_panic(expected = \"arithmetic operation overflow\")]\n    fn decimal_from_str_errors_for_more_than_max_value_integer_part_with_decimal() {\n        let _ =\n            Decimal256::from_str(\"115792089237316195423570985008687907853269984665640564039458.0\");\n    }\n    #[test]\n    #[should_panic(expected = \"arithmetic operation overflow\")]\n    fn decimal_from_str_errors_for_more_than_max_value_decimal_part() {\n        let _ = Decimal256::from_str(\n            \"115792089237316195423570985008687907853269984665640564039457.584007913129639936\",\n        );\n    }\n\n    #[test]\n    fn decimal_is_zero_works() {\n        assert!(Decimal256::zero().is_zero());\n        assert!(Decimal256::percent(0).is_zero());\n        assert!(Decimal256::permille(0).is_zero());\n\n        assert!(!Decimal256::one().is_zero());\n        assert!(!Decimal256::percent(123).is_zero());\n        assert!(!Decimal256::permille(1234).is_zero());\n    }\n\n    #[test]\n    fn decimal_add() {\n        let value = Decimal256::one() + Decimal256::percent(50); // 1.5\n        assert_eq!(\n            value.0,\n            Decimal256::DECIMAL_FRACTIONAL * U256::from(3) / U256::from(2)\n        );\n    }\n\n    #[test]\n    fn decimal_sub() {\n        assert_eq!(\n            Decimal256::percent(50),\n            Decimal256::one() - Decimal256::percent(50)\n        );\n    }\n\n    #[test]\n    fn decimal_mul() {\n        assert_eq!(\n            Decimal256::percent(25),\n            Decimal256::percent(50) * Decimal256::percent(50)\n        );\n    }\n\n    #[test]\n    fn decimal_div() {\n        assert_eq!(\n            Decimal256::one() + Decimal256::one(),\n            Decimal256::percent(50) / Decimal256::percent(25)\n        );\n    }\n\n    #[test]\n    fn decimal_to_string() {\n        // Integers\n        assert_eq!(Decimal256::zero().to_string(), \"0\");\n        assert_eq!(Decimal256::one().to_string(), \"1\");\n        assert_eq!(Decimal256::percent(500).to_string(), \"5\");\n\n        // Decimal256s\n        assert_eq!(Decimal256::percent(125).to_string(), \"1.25\");\n        assert_eq!(Decimal256::percent(42638).to_string(), \"426.38\");\n        assert_eq!(Decimal256::percent(1).to_string(), \"0.01\");\n        assert_eq!(Decimal256::permille(987).to_string(), \"0.987\");\n\n        assert_eq!(Decimal256(1u64.into()).to_string(), \"0.000000000000000001\");\n        assert_eq!(Decimal256(10u64.into()).to_string(), \"0.00000000000000001\");\n        assert_eq!(Decimal256(100u64.into()).to_string(), \"0.0000000000000001\");\n        assert_eq!(Decimal256(1000u64.into()).to_string(), \"0.000000000000001\");\n        assert_eq!(Decimal256(10000u64.into()).to_string(), \"0.00000000000001\");\n        assert_eq!(Decimal256(100000u64.into()).to_string(), \"0.0000000000001\");\n        assert_eq!(Decimal256(1000000u64.into()).to_string(), \"0.000000000001\");\n        assert_eq!(Decimal256(10000000u64.into()).to_string(), \"0.00000000001\");\n        assert_eq!(Decimal256(100000000u64.into()).to_string(), \"0.0000000001\");\n        assert_eq!(Decimal256(1000000000u64.into()).to_string(), \"0.000000001\");\n        assert_eq!(Decimal256(10000000000u64.into()).to_string(), \"0.00000001\");\n        assert_eq!(Decimal256(100000000000u64.into()).to_string(), \"0.0000001\");\n        assert_eq!(Decimal256(10000000000000u64.into()).to_string(), \"0.00001\");\n        assert_eq!(Decimal256(100000000000000u64.into()).to_string(), \"0.0001\");\n        assert_eq!(Decimal256(1000000000000000u64.into()).to_string(), \"0.001\");\n        assert_eq!(Decimal256(10000000000000000u64.into()).to_string(), \"0.01\");\n        assert_eq!(Decimal256(100000000000000000u64.into()).to_string(), \"0.1\");\n    }\n\n    #[test]\n    fn decimal_serialize() {\n        assert_eq!(to_vec(\u0026Decimal256::zero()).unwrap(), br#\"\"0\"\"#);\n        assert_eq!(to_vec(\u0026Decimal256::one()).unwrap(), br#\"\"1\"\"#);\n        assert_eq!(to_vec(\u0026Decimal256::percent(8)).unwrap(), br#\"\"0.08\"\"#);\n        assert_eq!(to_vec(\u0026Decimal256::percent(87)).unwrap(), br#\"\"0.87\"\"#);\n        assert_eq!(to_vec(\u0026Decimal256::percent(876)).unwrap(), br#\"\"8.76\"\"#);\n        assert_eq!(to_vec(\u0026Decimal256::percent(8765)).unwrap(), br#\"\"87.65\"\"#);\n    }\n\n    #[test]\n    fn decimal_deserialize() {\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"0\"\"#).unwrap(),\n            Decimal256::zero()\n        );\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"1\"\"#).unwrap(),\n            Decimal256::one()\n        );\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"000\"\"#).unwrap(),\n            Decimal256::zero()\n        );\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"001\"\"#).unwrap(),\n            Decimal256::one()\n        );\n\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"0.08\"\"#).unwrap(),\n            Decimal256::percent(8)\n        );\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"0.87\"\"#).unwrap(),\n            Decimal256::percent(87)\n        );\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"8.76\"\"#).unwrap(),\n            Decimal256::percent(876)\n        );\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"87.65\"\"#).unwrap(),\n            Decimal256::percent(8765)\n        );\n    }\n\n    #[test]\n    fn to_and_from_uint256() {\n        let a: Uint256 = 12345u64.into();\n        assert_eq!(U256::from(12345), a.0);\n        assert_eq!(\"12345\", a.to_string());\n\n        let a: Uint256 = \"34567\".try_into().unwrap();\n        assert_eq!(U256::from(34567), a.0);\n        assert_eq!(\"34567\", a.to_string());\n\n        let a: StdResult\u003cUint256\u003e = \"1.23\".try_into();\n        assert!(a.is_err());\n    }\n\n    #[test]\n    fn uint256_is_zero_works() {\n        assert!(Uint256::zero().is_zero());\n        assert!(Uint256::from(0u64).is_zero());\n\n        assert!(!Uint256::from(1u64).is_zero());\n        assert!(!Uint256::from(123u64).is_zero());\n    }\n\n    #[test]\n    fn uint256_json() {\n        let orig = Uint256::from(1234567890987654321u64);\n        let serialized = to_vec(\u0026orig).unwrap();\n        assert_eq!(serialized.as_slice(), b\"\\\"1234567890987654321\\\"\");\n        let parsed: Uint256 = from_slice(\u0026serialized).unwrap();\n        assert_eq!(parsed, orig);\n    }\n\n    #[test]\n    fn uint256_compare() {\n        let a = Uint256::from(12345u64);\n        let b = Uint256::from(23456u64);\n\n        assert!(a \u003c b);\n        assert!(b \u003e a);\n        assert_eq!(a, Uint256::from(12345u64));\n    }\n\n    #[test]\n    fn uint256_math() {\n        let a = Uint256::from(12345u64);\n        let b = Uint256::from(23456u64);\n\n        // test + and - for valid values\n        assert_eq!(a + b, Uint256::from(35801u64));\n        assert_eq!(b - a, Uint256::from(11111u64));\n\n        // test +=\n        let mut c = Uint256::from(300000u64);\n        c += b;\n        assert_eq!(c, Uint256::from(323456u64));\n    }\n    #[test]\n    #[should_panic]\n    fn uint256_math_sub_underflow() {\n        let _ = Uint256::from(12345u64) - Uint256::from(23456u64);\n    }\n\n    #[test]\n    #[should_panic]\n    fn uint256_math_overflow_panics() {\n        // almost_max is 2^256 - 10\n        let almost_max = Uint256::from(U256([\n            18446744073709551615,\n            18446744073709551615,\n            18446744073709551615,\n            18446744073709551615,\n        ]));\n        let _ = almost_max + Uint256::from(12u64);\n    }\n\n    #[test]\n    // in this test the Decimal256 is on the right\n    fn uint256_decimal_multiply() {\n        // a*b\n        let left = Uint256::from(300u64);\n        let right = Decimal256::one() + Decimal256::percent(50); // 1.5\n        assert_eq!(left * right, Uint256::from(450u64));\n\n        // a*0\n        let left = Uint256::from(300u64);\n        let right = Decimal256::zero();\n        assert_eq!(left * right, Uint256::from(0u64));\n\n        // 0*a\n        let left = Uint256::zero();\n        let right = Decimal256::one() + Decimal256::percent(50); // 1.5\n        assert_eq!(left * right, Uint256::zero());\n    }\n\n    #[test]\n    fn u256_multiply_ratio_works() {\n        let base = Uint256::from(500u64);\n\n        // factor 1/1\n        assert_eq!(base.multiply_ratio(1, 1), Uint256::from(500u64));\n        assert_eq!(base.multiply_ratio(3, 3), Uint256::from(500u64));\n        assert_eq!(base.multiply_ratio(654321, 654321), Uint256::from(500u64));\n\n        // factor 3/2\n        assert_eq!(base.multiply_ratio(3, 2), Uint256::from(750u64));\n        assert_eq!(base.multiply_ratio(333333, 222222), Uint256::from(750u64));\n\n        // factor 2/3 (integer devision always floors the result)\n        assert_eq!(base.multiply_ratio(2, 3), Uint256::from(333u64));\n        assert_eq!(base.multiply_ratio(222222, 333333), Uint256::from(333u64));\n\n        // factor 5/6 (integer devision always floors the result)\n        assert_eq!(base.multiply_ratio(5, 6), Uint256::from(416u64));\n        assert_eq!(base.multiply_ratio(100, 120), Uint256::from(416u64));\n    }\n\n    #[test]\n    fn u256_from_u128() {\n        assert_eq!(Uint256::from(100u64), Uint256::from(100u128));\n        let num = Uint256::from(1_000_000_000_000_000_000_000_000u128);\n        assert_eq!(num.to_string(), \"1000000000000000000000000\");\n    }\n\n    #[test]\n    #[should_panic(expected = \"Denominator must not be zero\")]\n    fn u256_multiply_ratio_panics_for_zero_denominator() {\n        Uint256::from(500u64).multiply_ratio(1, 0);\n    }\n\n    #[test]\n    fn u256_zero_one() {\n        assert_eq!(Uint256::zero().0, U256::zero());\n        assert_eq!(Uint256::one().0, U256::one());\n    }\n\n    #[test]\n    fn u256_into_u128() {\n        let val: u128 = Uint256::from(1234556700000000000999u128).into();\n        assert_eq!(val, 1234556700000000000999u128);\n    }\n\n    #[test]\n    #[should_panic]\n    fn u256_into_u128_panics_for_overflow() {\n        let _: u128 = Uint256::from_str(\"2134982317498312749832174923184732198471983247\")\n            .unwrap()\n            .into();\n    }\n\n    #[test]\n    // in this test the Decimal256 is on the left\n    fn decimal_uint256_multiply() {\n        // a*b\n        let left = Decimal256::one() + Decimal256::percent(50); // 1.5\n        let right = Uint256::from(300u64);\n        assert_eq!(left * right, Uint256::from(450u64));\n\n        // 0*a\n        let left = Decimal256::zero();\n        let right = Uint256::from(300u64);\n        assert_eq!(left * right, Uint256::from(0u64));\n\n        // a*0\n        let left = Decimal256::one() + Decimal256::percent(50); // 1.5\n        let right = Uint256::from(0u64);\n        assert_eq!(left * right, Uint256::from(0u64));\n    }\n}\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":32},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","fee_contract","src","error.rs"],"content":"use cosmwasm_std::StdError;\nuse thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized {},\n\n    #[error(\"Fee not paid correctly, required: {required:?}uust, provided {provided:?}uust\")]\n    FeeNotPaidCorrectly { required: u128, provided: u128 },\n\n    #[error(\"Fee not paid\")]\n    FeeNotPaid {},\n\n    #[error(\"Trade not accepted\")]\n    TradeNotAccepted {},\n\n    #[error(\"Fee Teers not ordered, you can't change them\")]\n    TeersNotOrdered {},\n\n    #[error(\"Error when encoding response message to binary string\")]\n    BinaryEncodingError {},\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","fee_contract","src","lib.rs"],"content":"pub mod error;\npub mod msg;\npub mod state;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","fee_contract","src","msg.rs"],"content":"use cosmwasm_std::{StdError, StdResult, Uint128};\nuse p2p_trading_export::state::AssetInfo;\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse utils::msg::is_valid_name;\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct MigrateMsg {}\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct InstantiateMsg {\n    pub name: String,\n    pub owner: Option\u003cString\u003e,\n    pub p2p_contract: String,\n    pub fee_distributor: String,\n}\n\nimpl InstantiateMsg {\n    pub fn validate(\u0026self) -\u003e StdResult\u003c()\u003e {\n        // Check name, symbol, decimals\n        if !is_valid_name(\u0026self.name) {\n            return Err(StdError::generic_err(\n                \"Name is not in the expected format (3-50 UTF-8 bytes)\",\n            ));\n        }\n        Ok(())\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum ExecuteMsg {\n    PayFeeAndWithdraw {\n        trade_id: u64,\n    },\n    UpdateFeeRates {\n        asset_fee_rate: Option\u003cUint128\u003e, // In thousandths (fee rate for liquid assets (terra native funds))\n        fee_max: Option\u003cUint128\u003e, // In uusd (max asset fee paid (outside of terra native funds))\n        first_teer_limit: Option\u003cUint128\u003e, // Max number of NFT to fall into the first tax teer\n        first_teer_rate: Option\u003cUint128\u003e, // Fee per asset in the first teer\n        second_teer_limit: Option\u003cUint128\u003e, // Max number of NFT to fall into the second tax teer\n        second_teer_rate: Option\u003cUint128\u003e, // Fee per asset in the second teer\n        third_teer_rate: Option\u003cUint128\u003e, // Fee per asset in the third teer\n        acceptable_fee_deviation: Option\u003cUint128\u003e, // To account for fluctuations in terra native prices, we allow the provided fee the deviate from the quoted fee (non simultaeous operations)\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    Fee {\n        trade_id: u64,\n        counter_id: Option\u003cu64\u003e,\n    },\n    SimulateFee {\n        trade_id: u64,\n        counter_assets: Vec\u003cAssetInfo\u003e,\n    },\n    ContractInfo {},\n    FeeRates {},\n}\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct FeeResponse {\n    pub fee: Uint128,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","fee_contract","src","state.rs"],"content":"use cosmwasm_std::{Addr, Uint128};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct ContractInfo {\n    pub name: String,\n    pub owner: Addr,\n    pub p2p_contract: Addr,\n    pub fee_distributor: Addr,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct FeeInfo {\n    pub asset_fee_rate: Uint128, // In thousandths\n    pub fee_max: Uint128,        // In uusd\n    pub first_teer_limit: Uint128,\n    pub first_teer_rate: Uint128,\n    pub second_teer_limit: Uint128,\n    pub second_teer_rate: Uint128,\n    pub third_teer_rate: Uint128,\n    pub acceptable_fee_deviation: Uint128, // In thousands\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","fee_distributor","src","lib.rs"],"content":"pub mod msg;\npub mod state;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","fee_distributor","src","msg.rs"],"content":"use cosmwasm_std::{StdError, StdResult, Uint128};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse utils::msg::is_valid_name;\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct MigrateMsg {}\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct InstantiateMsg {\n    pub name: String,\n    pub owner: Option\u003cString\u003e,\n    pub treasury: String,\n}\n\nimpl InstantiateMsg {\n    pub fn validate(\u0026self) -\u003e StdResult\u003c()\u003e {\n        // Check name, symbol, decimals\n        if !is_valid_name(\u0026self.name) {\n            return Err(StdError::generic_err(\n                \"Name is not in the expected format (3-50 UTF-8 bytes)\",\n            ));\n        }\n        Ok(())\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum ExecuteMsg {\n    ModifyContractInfo {\n        owner: Option\u003cString\u003e,\n        treasury: Option\u003cString\u003e,\n        projects_allocation: Option\u003cUint128\u003e,\n    },\n    DepositFees {\n        addresses: Vec\u003cString\u003e,\n    },\n    WithdrawFees {\n        addresses: Vec\u003cString\u003e,\n    },\n    AddAssociatedAddress {\n        address: String,\n        fee_address: String,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    ContractInfo {},\n    Amount {\n        address: String,\n    },\n    Addresses {\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    },\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","fee_distributor","src","state.rs"],"content":"use cosmwasm_std::{Addr, Uint128};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct ContractInfo {\n    pub name: String,\n    pub owner: Addr,\n    pub treasury: Addr,\n    pub projects_allocation: Uint128, // In percent\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","lender","src","lib.rs"],"content":"pub mod msg;\npub mod state;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","lender","src","msg.rs"],"content":"use cosmwasm_std::{Binary, StdError, StdResult};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse crate::state::{BorrowMode, BorrowZone, Cw721Info};\nuse cosmwasm_std::Uint128;\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct InstantiateMsg {\n    pub name: String,\n    pub owner: Option\u003cString\u003e,\n    pub oracle: Option\u003cString\u003e,\n    pub vault_token: String,\n    pub increasor_incentives: Uint128,\n    pub interests_fee_rate: Uint128,\n    pub fee_distributor: String,\n}\n\nimpl InstantiateMsg {\n    pub fn validate(\u0026self) -\u003e StdResult\u003c()\u003e {\n        // Check name, symbol, decimals\n        if !is_valid_name(\u0026self.name) {\n            return Err(StdError::generic_err(\n                \"Name is not in the expected format (3-50 UTF-8 bytes)\",\n            ));\n        }\n        Ok(())\n    }\n}\n\nfn is_valid_name(name: \u0026str) -\u003e bool {\n    let bytes = name.as_bytes();\n    if bytes.len() \u003c 3 || bytes.len() \u003e 50 {\n        return false;\n    }\n    true\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub enum ExecuteMsg {\n    // User accessible functions\n    Borrow {\n        asset_info: Cw721Info,\n        assets_to_borrow: Uint128,\n        borrow_mode: BorrowMode,\n    },\n    BorrowMore {\n        loan_id: u64,\n        assets_to_borrow: Uint128,\n    },\n    Repay {\n        borrower: String,\n        loan_id: u64,\n        assets: Uint128,\n    },\n    Receive {\n        sender: String,\n        amount: Uint128,\n        msg: Binary,\n    },\n    RaiseRate {\n        borrower: String,\n        loan_id: u64,\n    },\n    // Admin specific\n    SetOwner {\n        owner: String,\n    },\n    SetOracle {\n        oracle: String,\n    },\n    ToggleLock {\n        lock: bool,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    /// Returns the current state of the contract (locked)\n    /// Return type: StateResponse.\n    State {},\n    /// Returns metadata on the contract - name, owner, oracle, etc.\n    /// Return type: ContractInfoResponse.\n    ContratInfo {},\n    /// Returns the borrow info of the designated loan\n    BorrowInfo {\n        borrower: String,\n        loan_id: u64,\n    },\n    BorrowZones {\n        asset_info: Cw721Info,\n    },\n    BorrowTerms {\n        asset_info: Cw721Info,\n        borrow_mode: BorrowMode,\n        borrow_zone: BorrowZone,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct ZonesResponse {\n    pub safe_zone_limit: Uint128,\n    pub expensive_zone_limit: Uint128,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","lender","src","state.rs"],"content":"use cosmwasm_std::{Addr, Uint128};\nuse cw_storage_plus::{Item, Map};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cw_4626::state::AssetInfo;\npub const CONTRACT_INFO: Item\u003cContractInfo\u003e = Item::new(\"contract_info\");\npub const STATE: Item\u003cState\u003e = Item::new(\"state\");\npub const BORROWS: Map\u003c(\u0026Addr, u64), BorrowInfo\u003e = Map::new(\"borrows\");\n\n// This allows the interest to pay to be stable (at the scale of a human) with the blocks mined\npub const MIN_BLOCK_OFFSET: u64 = 10u64;\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct ContractInfo {\n    pub name: String,\n    pub vault_token: Addr,\n    pub vault_asset: AssetInfo,\n    pub owner: Addr,\n    pub oracle: Addr,\n    pub increasor_incentives: Uint128, // In 1/PERCENTAGE_RATE of the intersts surplus generated\n    pub interests_fee_rate: Uint128,   // In 1/PERCENTAGE_RATE of the total interests\n    pub fee_distributor: Addr,\n}\n\n/// Internal state of the contract\n/// Can be changed at anytime (without time locks for now) by the owner of the contract\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct State {\n    pub borrow_locked: bool,\n}\n\n/// Terms of borrowing for a contract\n/// If duration is not specified, the loan can be liquidated using info from the oracle contract\n/// The borrower has more risk so the terms should be favorable in that cas\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct BorrowTerms {\n    pub principle: Uint128,\n    pub interests: InterestType,\n}\n\npub const PERCENTAGE_RATE: u128 = 10_000u128;\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\npub enum InterestType {\n    Fixed {\n        interests: Uint128,\n        duration: u64,\n    },\n    Continuous {\n        last_interest_rate: Uint128, // In 1/PERCENTAGE_RATE per block\n        interests_accrued: Uint128,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\npub struct InterestsInfo {\n    pub safe_interest_rate: Uint128, // In 1/PERCENTAGE_RATE per block\n    pub expensive_interest_rate: Uint128, // In 1/PERCENTAGE_RATE per block\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\npub enum BorrowMode {\n    Fixed,\n    Continuous,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\npub enum BorrowZone {\n    SafeZone,\n    ExpensiveZone,\n    LiquidationZone,\n}\n\n/// Structure to hold the borrow informations\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct BorrowInfo {\n    pub collateral: Option\u003cCw721Info\u003e,\n    pub principle: Uint128,\n    pub interests: InterestType,\n    pub start_block: u64,\n    pub borrow_zone: BorrowZone,\n    pub rate_increasor: Option\u003cRateIncreasor\u003e,\n}\n\n/// Information about the increasor (their address, and the rate of the safe zone at the time of triggering)\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct RateIncreasor {\n    pub increasor: Addr,\n    pub previous_rate: Uint128,\n}\n\n/// Structure to hold the borrow informations\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct Cw721Info {\n    pub nft_address: String,\n    pub token_id: String,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","nft-loans","src","lib.rs"],"content":"pub mod msg;\npub mod state;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","nft-loans","src","msg.rs"],"content":"use cosmwasm_std::{StdError, StdResult, Uint128};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse utils::msg::is_valid_name;\n\nuse crate::state::{CollateralInfo, LoanTerms};\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct MigrateMsg {}\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct InstantiateMsg {\n    pub name: String,\n    pub owner: Option\u003cString\u003e,\n    pub fee_distributor: String,\n    pub fee_rate: Uint128,\n}\n\nimpl InstantiateMsg {\n    pub fn validate(\u0026self) -\u003e StdResult\u003c()\u003e {\n        // Check name, symbol, decimals\n        if !is_valid_name(\u0026self.name) {\n            return Err(StdError::generic_err(\n                \"Name is not in the expected format (3-50 UTF-8 bytes)\",\n            ));\n        }\n        Ok(())\n    }\n}\n/// This contract nevers holds any funds\n/// In case it does, it's that an error occured\n/// TODO, we need to provide a way to make sure we can get those funds back\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum ExecuteMsg {\n    //// We support both Cw721 and Cw1155\n    DepositCollateral {\n        address: String,\n        token_id: String,\n        value: Option\u003cUint128\u003e,\n        terms: Option\u003cLoanTerms\u003e,\n    },\n    /// Used to withdraw the collateral before the loan starts\n    WithdrawCollateral {\n        loan_id: u64,\n    },\n    SetTerms {\n        loan_id: u64,\n        terms: LoanTerms,\n    },\n    MakeOffer {\n        borrower: String,\n        loan_id: u64,\n        terms: LoanTerms,\n    },\n    CancelOffer {\n        borrower: String,\n        loan_id: u64,\n        offer_id: u64,\n    },\n    RefuseOffer {\n        loan_id: u64,\n        offer_id: u64,\n    },\n    WithdrawRefusedOffer {\n        borrower: String,\n        loan_id: u64,\n        offer_id: u64,\n    },\n    AcceptOffer {\n        loan_id: u64,\n        offer_id: u64,\n    },\n    AcceptLoan {\n        borrower: String,\n        loan_id: u64,\n    },\n    RepayBorrowedFunds {\n        loan_id: u64,\n    },\n    ForceDefault {\n        borrower: String,\n        loan_id: u64,\n    },\n    /// Used only when the loan can be paid back late\n    WithdrawDefaultedLoan {\n        borrower: String,\n        loan_id: u64,\n    },\n    /// Internal state\n    SetOwner {\n        owner: String,\n    },\n    SetFeeDistributor {\n        fee_depositor: String,\n    },\n    SetFeeRate {\n        fee_rate: Uint128,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    ContractInfo {},\n    CollateralInfo { borrower: String, loan_id: u64 },\n    BorrowerInfo { borrower: String },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct CollateralResponse {\n    pub borrower: String,\n    pub loan_id: u64,\n    pub collateral: CollateralInfo,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct OfferResponse {\n    pub lender: String,\n    pub borrower: String,\n    pub loan_id: u64,\n    pub offer_id: u64,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","nft-loans","src","state.rs"],"content":"use strum_macros;\n\nuse cosmwasm_std::{Addr, Coin, Uint128};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse utils::state::{AssetInfo, Cw20Coin};\n// We neep a map per user of all loans that are happening right now !\n// The info should be redondant and linked\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct CollateralInfo {\n    pub terms: Option\u003cLoanTerms\u003e,\n    pub associated_asset: AssetInfo,\n    pub state: LoanState,\n    pub offers: Vec\u003cOfferInfo\u003e,\n    pub active_loan: Option\u003cu64\u003e,\n    pub start_block: Option\u003cu64\u003e,\n}\n\nimpl Default for CollateralInfo {\n    fn default() -\u003e Self {\n        Self {\n            terms: None,\n            associated_asset: AssetInfo::Cw20Coin(Cw20Coin {\n                address: \"\".to_string(),\n                amount: Uint128::zero(),\n            }),\n            state: LoanState::Published,\n            offers: vec![],\n            active_loan: None,\n            start_block: None,\n        }\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug, Default)]\n#[serde(rename_all = \"snake_case\")]\npub struct BorrowerInfo {\n    pub last_collateral_id: u64,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct OfferInfo {\n    pub lender: Addr,\n    pub terms: LoanTerms,\n    pub state: OfferState,\n    pub deposited_funds: Option\u003cCoin\u003e,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema, Default)]\n#[serde(rename_all = \"snake_case\")]\npub struct LoanTerms {\n    pub principle: Coin,\n    pub interest: Uint128,\n    pub duration_in_blocks: u64,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug, strum_macros::Display)]\n#[serde(rename_all = \"snake_case\")]\npub enum LoanState {\n    Published,\n    Started,\n    Defaulted,\n    Ended,\n    AssetWithdrawn,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug, strum_macros::Display)]\n#[serde(rename_all = \"snake_case\")]\npub enum OfferState {\n    Published,\n    Accepted,\n    Refused,\n    Cancelled,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct ContractInfo {\n    pub name: String,\n    pub owner: Addr,\n    pub fee_distributor: String,\n    pub fee_rate: Uint128,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","oracle","src","lib.rs"],"content":"pub mod msg;\npub mod state;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","oracle","src","msg.rs"],"content":"use cosmwasm_std::{StdError, StdResult, Uint128};\nuse cw_4626::state::AssetInfo;\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse utils::msg::is_valid_name;\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct MigrateMsg {}\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct InstantiateMsg {\n    pub name: String,\n    pub owner: Option\u003cString\u003e,\n    pub timeout: Option\u003cu64\u003e,\n}\n\nimpl InstantiateMsg {\n    pub fn validate(\u0026self) -\u003e StdResult\u003c()\u003e {\n        // Check name, symbol, decimals\n        if !is_valid_name(\u0026self.name) {\n            return Err(StdError::generic_err(\n                \"Name is not in the expected format (3-50 UTF-8 bytes)\",\n            ));\n        }\n        Ok(())\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum ExecuteMsg {\n    SetNftPrice {\n        contract: String,\n        oracle_owner: Option\u003cString\u003e,\n        price: Uint128,\n        unit: AssetInfo,\n    },\n    SetOwner {\n        owner: String,\n    },\n    SetTimeout {\n        timeout: u64,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    NftPrice { contract: String, unit: AssetInfo },\n    ContractInfo {},\n}\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct NftPriceResponse {\n    pub contract: String,\n    pub price: Uint128,\n    pub unit: AssetInfo,\n    pub oracle_owner: String,\n    pub timeout: bool,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","oracle","src","state.rs"],"content":"use cosmwasm_std::{Addr, Timestamp, Uint128};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct ContractInfo {\n    pub name: String,\n    pub owner: Addr,\n    pub timeout: u64,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct NftPrice {\n    pub price: Uint128,\n    pub oracle_owner: Addr,\n    pub last_update: Timestamp,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","p2p-trading","src","lib.rs"],"content":"pub mod msg;\npub mod query;\npub mod state;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","p2p-trading","src","msg.rs"],"content":"use crate::state::{AssetInfo, CounterTradeInfo};\nuse cosmwasm_std::{to_binary, Binary, CosmosMsg, StdError, StdResult, WasmMsg};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nfn is_valid_name(name: \u0026str) -\u003e bool {\n    let bytes = name.as_bytes();\n    if bytes.len() \u003c 3 || bytes.len() \u003e 50 {\n        return false;\n    }\n    true\n}\n\npub fn into_binary\u003cM: Serialize\u003e(msg: M) -\u003e StdResult\u003cBinary\u003e {\n    to_binary(\u0026msg)\n}\n\npub fn into_cosmos_msg\u003cM: Serialize, T: Into\u003cString\u003e\u003e(\n    message: M,\n    contract_addr: T,\n) -\u003e StdResult\u003cCosmosMsg\u003e {\n    let msg = into_binary(message)?;\n    let execute = WasmMsg::Execute {\n        contract_addr: contract_addr.into(),\n        msg,\n        funds: vec![],\n    };\n    Ok(execute.into())\n}\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct InstantiateMsg {\n    pub name: String,\n    pub owner: Option\u003cString\u003e,\n}\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct MigrateMsg {}\n\nimpl InstantiateMsg {\n    pub fn validate(\u0026self) -\u003e StdResult\u003c()\u003e {\n        // Check name, symbol, decimals\n        if !is_valid_name(\u0026self.name) {\n            return Err(StdError::generic_err(\n                \"Name is not in the expected format (3-50 UTF-8 bytes)\",\n            ));\n        }\n        Ok(())\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum ExecuteMsg {\n    CreateTrade {\n        whitelisted_users: Option\u003cVec\u003cString\u003e\u003e,\n        comment: Option\u003cString\u003e,\n    },\n    AddAsset {\n        trade_id: Option\u003cu64\u003e,\n        counter_id: Option\u003cu64\u003e,\n        to_last_trade: Option\u003cbool\u003e,\n        to_last_counter: Option\u003cbool\u003e,\n        asset: AssetInfo,\n    },\n    RemoveAssets {\n        trade_id: u64,\n        counter_id: Option\u003cu64\u003e,\n        assets: Vec\u003c(u16, AssetInfo)\u003e,\n    },\n    AddWhitelistedUsers {\n        trade_id: u64,\n        whitelisted_users: Vec\u003cString\u003e,\n    },\n    RemoveWhitelistedUsers {\n        trade_id: u64,\n        whitelisted_users: Vec\u003cString\u003e,\n    },\n    SetComment {\n        trade_id: u64,\n        counter_id: Option\u003cu64\u003e,\n        comment: String,\n    },\n    AddNFTsWanted {\n        trade_id: Option\u003cu64\u003e,\n        nfts_wanted: Vec\u003cString\u003e,\n    },\n    RemoveNFTsWanted {\n        trade_id: u64,\n        nfts_wanted: Vec\u003cString\u003e,\n    },\n    /// Is used by the Trader to confirm they completed their end of the trade.\n    ConfirmTrade {\n        trade_id: Option\u003cu64\u003e,\n    },\n    /// Can be used to initiate Counter Trade, but also to add new tokens to it\n    SuggestCounterTrade {\n        trade_id: u64,\n        comment: Option\u003cString\u003e,\n    },\n    /// Is used by the Client to confirm they completed their end of the trade.\n    ConfirmCounterTrade {\n        trade_id: u64,\n        counter_id: Option\u003cu64\u003e,\n    },\n    /// Accept the Trade plain and simple, swap it up !\n    AcceptTrade {\n        trade_id: u64,\n        counter_id: u64,\n        comment: Option\u003cString\u003e,\n    },\n    /// Cancel the Trade :/ No luck there mate ?\n    CancelTrade {\n        trade_id: u64,\n    },\n    /// Cancel the Counter Trade :/ No luck there mate ?\n    CancelCounterTrade {\n        trade_id: u64,\n        counter_id: u64,\n    },\n    /// Refuse the Trade plain and simple, no madam, I'm not interested in your tokens !\n    RefuseCounterTrade {\n        trade_id: u64,\n        counter_id: u64,\n    },\n    /// Some parts of the traded tokens were interesting, but you can't accept the trade as is\n    ReviewCounterTrade {\n        trade_id: u64,\n        counter_id: u64,\n        comment: Option\u003cString\u003e,\n    },\n    /// The fee contract can Withdraw funds via this function only when the trade is accepted.\n    WithdrawPendingAssets {\n        trader: String,\n        trade_id: u64,\n    },\n    /// You can Withdraw funds only at specific steps of the trade, but you're allowed to try anytime !\n    WithdrawAllFromTrade {\n        trade_id: u64,\n    },\n    /// You can Withdraw funds when your counter trade is aborted (refused or cancelled)\n    /// Or when you are creating the trade and you just want to cancel it all\n    WithdrawAllFromCounter {\n        trade_id: u64,\n        counter_id: u64,\n    },\n    SetNewOwner {\n        owner: String,\n    },\n    SetNewFeeContract {\n        fee_contract: String,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema, Default)]\n#[serde(rename_all = \"snake_case\")]\npub struct QueryFilters {\n    pub states: Option\u003cVec\u003cString\u003e\u003e,\n    pub owner: Option\u003cString\u003e,\n    pub counterer: Option\u003cString\u003e,\n    pub has_whitelist: Option\u003cbool\u003e,\n    pub whitelisted_user: Option\u003cString\u003e,\n    pub contains_token: Option\u003cString\u003e,\n    pub wanted_nft: Option\u003cString\u003e,\n    pub assets_withdrawn: Option\u003cbool\u003e,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    ContractInfo {},\n    TradeInfo {\n        trade_id: u64,\n    },\n    CounterTradeInfo {\n        trade_id: u64,\n        counter_id: u64,\n    },\n    GetAllTrades {\n        start_after: Option\u003cu64\u003e,\n        limit: Option\u003cu32\u003e,\n        filters: Option\u003cQueryFilters\u003e,\n    },\n    GetCounterTrades {\n        trade_id: u64,\n        start_after: Option\u003cu64\u003e,\n        limit: Option\u003cu32\u003e,\n        filters: Option\u003cQueryFilters\u003e,\n    },\n    GetAllCounterTrades {\n        start_after: Option\u003cCounterTradeInfo\u003e,\n        limit: Option\u003cu32\u003e,\n        filters: Option\u003cQueryFilters\u003e,\n    },\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":6},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","p2p-trading","src","query.rs"],"content":"use cosmwasm_std::{to_binary, Addr, Deps, QueryRequest, StdError, StdResult, WasmQuery};\n\nuse crate::msg::QueryMsg as P2PQueryMsg;\nuse crate::state::TradeInfo;\n\n/// Load a trade and the provided counter trade\n/// If it isn't provided, the function will try to query the accepted counter trade if it exists\npub fn load_trade_and_accepted_counter_trade(\n    deps: Deps,\n    p2p_contract: Addr,\n    trade_id: u64,\n    counter_id: Option\u003cu64\u003e,\n) -\u003e StdResult\u003c(TradeInfo, TradeInfo)\u003e {\n    let trade_info = load_trade(deps, p2p_contract.clone(), trade_id)?;\n\n    let counter_id = match counter_id {\n        Some(counter_id) =\u003e counter_id,\n        None =\u003e {\n            trade_info\n                .clone()\n                .accepted_info\n                .ok_or_else(|| StdError::generic_err(\"Trade not accepted\"))?\n                .counter_id\n        }\n    };\n\n    let counter_info = load_counter_trade(deps, p2p_contract, trade_id, counter_id)?;\n\n    Ok((trade_info, counter_info))\n}\n\n/// Load a trade from the P2P contract\npub fn load_trade(deps: Deps, p2p_contract: Addr, trade_id: u64) -\u003e StdResult\u003cTradeInfo\u003e {\n    deps.querier.query(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n        contract_addr: p2p_contract.to_string(),\n        msg: to_binary(\u0026P2PQueryMsg::TradeInfo { trade_id })?,\n    }))\n}\n\n/// Load a counter_trade from the P2P contract\npub fn load_counter_trade(\n    deps: Deps,\n    p2p_contract: Addr,\n    trade_id: u64,\n    counter_id: u64,\n) -\u003e StdResult\u003cTradeInfo\u003e {\n    deps.querier.query(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n        contract_addr: p2p_contract.to_string(),\n        msg: to_binary(\u0026P2PQueryMsg::CounterTradeInfo {\n            trade_id,\n            counter_id,\n        })?,\n    }))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","p2p-trading","src","state.rs"],"content":"use strum_macros;\n\nuse cosmwasm_std::{Addr, Coin, Timestamp, Uint128};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse std::collections::HashSet;\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct Cw1155Coin {\n    pub address: String,\n    pub token_id: String,\n    pub value: Uint128,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct Cw721Coin {\n    pub address: String,\n    pub token_id: String,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct Cw20Coin {\n    pub address: String,\n    pub amount: Uint128,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub enum AssetInfo {\n    Cw20Coin(Cw20Coin),\n    Cw721Coin(Cw721Coin),\n    Cw1155Coin(Cw1155Coin),\n    Coin(Coin),\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug, strum_macros::Display)]\n#[serde(rename_all = \"snake_case\")]\npub enum TradeState {\n    Created,\n    Published,\n    Countered,\n    Refused,\n    Accepted,\n    Cancelled,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct ContractInfo {\n    pub name: String,\n    pub owner: Addr,\n    pub fee_contract: Option\u003cAddr\u003e,\n    pub last_trade_id: Option\u003cu64\u003e,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct CounterTradeInfo {\n    pub trade_id: u64,\n    pub counter_id: u64,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug, Default)]\n#[serde(rename_all = \"snake_case\")]\npub struct AdditionnalTradeInfo {\n    pub time: Timestamp,\n    pub owner_comment: Option\u003cComment\u003e,\n    pub trader_comment: Option\u003cComment\u003e,\n    pub nfts_wanted: HashSet\u003cAddr\u003e,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug, Default)]\n#[serde(rename_all = \"snake_case\")]\npub struct Comment {\n    pub time: Timestamp,\n    pub comment: String,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct TradeInfo {\n    pub owner: Addr,\n    pub associated_assets: Vec\u003cAssetInfo\u003e,\n    pub state: TradeState,\n    pub last_counter_id: Option\u003cu64\u003e,\n    pub whitelisted_users: HashSet\u003cAddr\u003e,\n    pub additionnal_info: AdditionnalTradeInfo,\n    pub accepted_info: Option\u003cCounterTradeInfo\u003e,\n    pub assets_withdrawn: bool,\n}\n\nimpl Default for TradeInfo {\n    fn default() -\u003e Self {\n        Self {\n            owner: Addr::unchecked(\"\"),\n            associated_assets: vec![],\n            state: TradeState::Created,\n            last_counter_id: None,\n            whitelisted_users: HashSet::new(),\n            additionnal_info: AdditionnalTradeInfo::default(),\n            accepted_info: None,\n            assets_withdrawn: false,\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","raffles","src","lib.rs"],"content":"pub mod msg;\npub mod state;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","raffles","src","msg.rs"],"content":"use crate::state::AssetInfo;\nuse anyhow::Result;\nuse cosmwasm_std::{to_binary, Addr, Binary, CosmosMsg, StdError, StdResult, Uint128, WasmMsg};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nfn is_valid_name(name: \u0026str) -\u003e bool {\n    let bytes = name.as_bytes();\n    if bytes.len() \u003c 3 || bytes.len() \u003e 50 {\n        return false;\n    }\n    true\n}\n\npub fn into_binary\u003cM: Serialize\u003e(msg: M) -\u003e StdResult\u003cBinary\u003e {\n    to_binary(\u0026msg)\n}\n\npub fn into_cosmos_msg\u003cM: Serialize, T: Into\u003cString\u003e\u003e(\n    message: M,\n    contract_addr: T,\n) -\u003e Result\u003cCosmosMsg\u003e {\n    let msg = into_binary(message)?;\n    let execute = WasmMsg::Execute {\n        contract_addr: contract_addr.into(),\n        msg,\n        funds: vec![],\n    };\n    Ok(execute.into())\n}\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct InstantiateMsg {\n    pub name: String,\n    pub owner: Option\u003cString\u003e,\n    pub fee_addr: Option\u003cString\u003e,\n    pub minimum_raffle_duration: Option\u003cu64\u003e,\n    pub minimum_raffle_timeout: Option\u003cu64\u003e,\n    pub raffle_fee: Option\u003cUint128\u003e, // in 10_000\n    pub rand_fee: Option\u003cUint128\u003e,   // in 10_000\n    pub drand_url: Option\u003cString\u003e,\n    pub random_pubkey: Binary,\n    pub verify_signature_contract: String,\n}\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct MigrateMsg {}\n\nimpl InstantiateMsg {\n    pub fn validate(\u0026self) -\u003e StdResult\u003c()\u003e {\n        // Check name, symbol, decimals\n        if !is_valid_name(\u0026self.name) {\n            return Err(StdError::generic_err(\n                \"Name is not in the expected format (3-50 UTF-8 bytes)\",\n            ));\n        }\n        Ok(())\n    }\n}\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct DrandRandomness {\n    pub round: u64,\n    pub previous_signature: Binary,\n    pub signature: Binary,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum ExecuteMsg {\n    CreateRaffle {\n        asset: AssetInfo,\n        raffle_start_timestamp: Option\u003cu64\u003e, // If not specified, starts immediately\n        raffle_duration: Option\u003cu64\u003e,\n        raffle_timeout: Option\u003cu64\u003e,\n        comment: Option\u003cString\u003e,\n        raffle_ticket_price: AssetInfo,\n        max_participant_number: Option\u003cu64\u003e,\n    },\n    BuyTicket {\n        raffle_id: u64,\n        sent_assets: AssetInfo,\n    },\n    Receive {\n        sender: String,\n        amount: Uint128,\n        msg: Binary,\n    },\n    ReceiveNft {\n        sender: String,\n        token_id: String,\n        msg: Binary,\n    },\n    Cw1155ReceiveMsg {\n        operator: String,\n        from: Option\u003cString\u003e,\n        token_id: String,\n        amount: Uint128,\n        msg: Binary,\n    },\n    ClaimNft {\n        raffle_id: u64,\n    },\n    UpdateRandomness {\n        raffle_id: u64,\n        randomness: DrandRandomness,\n    },\n\n    // Admin messages\n    ToggleLock {\n        lock: bool,\n    },\n    Renounce {},\n    ChangeParameter{\n        parameter: String,\n        value: String\n    }\n}\n\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema, Default)]\n#[serde(rename_all = \"snake_case\")]\npub struct QueryFilters {\n    pub states: Option\u003cVec\u003cString\u003e\u003e,\n    pub owner: Option\u003cAddr\u003e,\n    pub ticket_depositor: Option\u003cAddr\u003e,\n    pub contains_token: Option\u003cString\u003e,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    ContractInfo {},\n    RaffleInfo {\n        raffle_id: u64,\n    },\n    GetAllRaffles {\n        start_after: Option\u003cu64\u003e,\n        limit: Option\u003cu32\u003e,\n        filters: Option\u003cQueryFilters\u003e,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum VerifierExecuteMsg {\n    Verify {\n        randomness: DrandRandomness,\n        pubkey: Binary,\n        raffle_id: u64,\n        owner: String,\n    },\n}\n","traces":[{"line":7,"address":[2382352],"length":1,"stats":{"Line":1},"fn_name":"is_valid_name"},{"line":8,"address":[2382400],"length":1,"stats":{"Line":7},"fn_name":null},{"line":9,"address":[2382414],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[2382458],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[2382451],"length":1,"stats":{"Line":7},"fn_name":null},{"line":15,"address":[1084960,1084864,1085056,1085122,1085218,1084930,1085026,1085152],"length":1,"stats":{"Line":5},"fn_name":"into_binary\u003ccw1155::msg::Cw1155ExecuteMsg\u003e"},{"line":16,"address":[1084881,1085169,1084977,1085073],"length":1,"stats":{"Line":5},"fn_name":null},{"line":19,"address":[1086288,1087323,1087360,1088384,1088416,1089428,1086248,1085248],"length":1,"stats":{"Line":5},"fn_name":"into_cosmos_msg\u003ccw721::msg::Cw721ExecuteMsg, alloc::string::String\u003e"},{"line":23,"address":[1085587,1088926,1085746,1087573,1085437,1088438,1086663,1086314,1086821,1088767,1087882,1085270,1088617,1087382,1086517,1087723],"length":1,"stats":{"Line":10},"fn_name":null},{"line":25,"address":[1087657,1085521,1088701,1086597],"length":1,"stats":{"Line":5},"fn_name":null},{"line":27,"address":[1087956,1086895,1085820,1089000],"length":1,"stats":{"Line":3},"fn_name":null},{"line":29,"address":[1087063,1088321,1087260,1089365,1085988,1086185,1088124,1089168],"length":1,"stats":{"Line":10},"fn_name":null},{"line":50,"address":[2382480],"length":1,"stats":{"Line":1},"fn_name":"validate"},{"line":52,"address":[2382512],"length":1,"stats":{"Line":7},"fn_name":null},{"line":53,"address":[2382569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[2382561],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":14,"coverable":16},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","raffles","src","state.rs"],"content":"use strum_macros;\n\nuse cosmwasm_std::{Addr, Binary, Coin, Timestamp, Uint128};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\n/*\npub const MINIMUM_RAFFLE_DURATION: u64 = 3600; // A raffle last at least 1 hour\npub const MINIMUM_RAFFLE_TIMEOUT: u64 = 120; // The raffle duration is a least 2 minutes\npub const MINIMUM_RAND_FEE: u128 = 1; // The randomness provider gets at least 1/10_000 of the total raffle price\npub const MAXIMUM_PARTICIPANT_NUMBER: u64 = 1000;\n*/\n\npub const MINIMUM_RAFFLE_DURATION: u64 = 1; \npub const MINIMUM_RAFFLE_TIMEOUT: u64 = 120; // The raffle duration is a least 2 minutes\npub const MINIMUM_RAND_FEE: u128 = 1; // The randomness provider gets at least 1/10_000 of the total raffle price\npub const MAXIMUM_PARTICIPANT_NUMBER: u64 = 1000;\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct Cw1155Coin {\n    pub address: String,\n    pub token_id: String,\n    pub value: Uint128,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct Cw721Coin {\n    pub address: String,\n    pub token_id: String,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct Cw20Coin {\n    pub address: String,\n    pub amount: Uint128,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub enum AssetInfo {\n    Cw20Coin(Cw20Coin),\n    Cw721Coin(Cw721Coin),\n    Cw1155Coin(Cw1155Coin),\n    Coin(Coin),\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug, strum_macros::Display)]\n#[serde(rename_all = \"snake_case\")]\npub enum RaffleState {\n    Created,\n    Started,\n    Closed,\n    Finished,\n    Claimed,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct ContractInfo {\n    pub name: String,\n    pub owner: Addr,\n    pub fee_addr: Addr,\n    pub last_raffle_id: Option\u003cu64\u003e,\n    pub minimum_raffle_duration: u64,\n    pub minimum_raffle_timeout: u64,\n    pub raffle_fee: Uint128, // in 10_000\n    pub rand_fee: Uint128,   // in 10_000\n    pub lock: bool,\n    pub drand_url: String, \n    pub verify_signature_contract: Addr,\n    pub random_pubkey: Binary,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct RaffleTicket {\n    pub raffle_id: u64,\n    pub owner: Addr,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct RaffleInfo {\n    pub owner: Addr,\n    pub asset: AssetInfo,\n    pub raffle_start_timestamp: Timestamp,\n    pub raffle_duration: u64,\n    pub raffle_timeout: u64,\n    pub comment: Option\u003cString\u003e,\n    pub raffle_ticket_price: AssetInfo,\n    pub accumulated_ticket_fee: AssetInfo,\n    pub tickets: Vec\u003cAddr\u003e,\n    pub randomness: [u8; 32],\n    pub randomness_round: u64,\n    pub randomness_owner: Option\u003cAddr\u003e,\n    pub max_participant_number: u64,\n    pub winner: Option\u003cAddr\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","utils","src","lib.rs"],"content":"pub mod msg;\npub mod state;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","utils","src","msg.rs"],"content":"use cosmwasm_std::{to_binary, Binary, Coin, CosmosMsg, StdResult, WasmMsg};\nuse serde::Serialize;\n\npub fn is_valid_name(name: \u0026str) -\u003e bool {\n    let bytes = name.as_bytes();\n    if bytes.len() \u003c 3 || bytes.len() \u003e 50 {\n        return false;\n    }\n    true\n}\n\npub fn into_binary\u003cM: Serialize\u003e(msg: M) -\u003e StdResult\u003cBinary\u003e {\n    to_binary(\u0026msg)\n}\n\npub fn into_cosmos_msg\u003cM: Serialize, T: Into\u003cString\u003e\u003e(\n    message: M,\n    contract_addr: T,\n    funds: Option\u003cVec\u003cCoin\u003e\u003e,\n) -\u003e StdResult\u003cCosmosMsg\u003e {\n    let msg = into_binary(message)?;\n    let execute = WasmMsg::Execute {\n        contract_addr: contract_addr.into(),\n        msg,\n        funds: funds.unwrap_or_default(),\n    };\n    Ok(execute.into())\n}\n\n/*\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct TradeInfoResponse {\n    pub trade_info: TradeInfo,\n}\n*/\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":6},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","utils","src","state.rs"],"content":"use cosmwasm_std::{Addr, Api, StdResult, Uint128};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct Cw1155Coin {\n    pub address: String,\n    pub token_id: String,\n    pub value: Uint128,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct Cw721Coin {\n    pub address: String,\n    pub token_id: String,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct Cw20Coin {\n    pub address: String,\n    pub amount: Uint128,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub enum AssetInfo {\n    Cw20Coin(Cw20Coin),\n    Cw721Coin(Cw721Coin),\n    Cw1155Coin(Cw1155Coin),\n}\n\npub fn maybe_addr(api: \u0026dyn Api, human: Option\u003cString\u003e) -\u003e StdResult\u003cOption\u003cAddr\u003e\u003e {\n    human.map(|x| api.addr_validate(\u0026x)).transpose()\n}\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","ailiq_token","examples","ailiq_schema.rs"],"content":"use std::env::current_dir;\nuse std::fs::create_dir_all;\n\nuse cosmwasm_schema::{export_schema, remove_schemas, schema_for};\n\nuse cw20::{\n    AllAccountsResponse, AllAllowancesResponse, AllowanceResponse, BalanceResponse,\n    TokenInfoResponse,\n};\nuse cw20_base::msg::{ExecuteMsg, InstantiateMsg, QueryMsg};\n\nfn main() {\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"schema\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n\n    export_schema(\u0026schema_for!(InstantiateMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(ExecuteMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(QueryMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(AllowanceResponse), \u0026out_dir);\n    export_schema(\u0026schema_for!(BalanceResponse), \u0026out_dir);\n    export_schema(\u0026schema_for!(TokenInfoResponse), \u0026out_dir);\n    export_schema(\u0026schema_for!(AllAllowancesResponse), \u0026out_dir);\n    export_schema(\u0026schema_for!(AllAccountsResponse), \u0026out_dir);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","ailiq_token","src","allowances.rs"],"content":"use cosmwasm_std::{\n    attr, Addr, Binary, BlockInfo, Deps, DepsMut, Env, MessageInfo, Response, StdError, StdResult,\n    Storage, Uint128,\n};\nuse cw20::{AllowanceResponse, Cw20ReceiveMsg, Expiration};\n\nuse crate::error::ContractError;\nuse crate::state::{ALLOWANCES, BALANCES, TOKEN_INFO};\n\npub fn execute_increase_allowance(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    spender: String,\n    amount: Uint128,\n    expires: Option\u003cExpiration\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let spender_addr = deps.api.addr_validate(\u0026spender)?;\n    if spender_addr == info.sender {\n        return Err(ContractError::CannotSetOwnAccount {});\n    }\n\n    ALLOWANCES.update(\n        deps.storage,\n        (\u0026info.sender, \u0026spender_addr),\n        |allow| -\u003e StdResult\u003c_\u003e {\n            let mut val = allow.unwrap_or_default();\n            if let Some(exp) = expires {\n                val.expires = exp;\n            }\n            val.allowance += amount;\n            Ok(val)\n        },\n    )?;\n\n    let res = Response::new().add_attributes(vec![\n        attr(\"action\", \"increase_allowance\"),\n        attr(\"owner\", info.sender),\n        attr(\"spender\", spender),\n        attr(\"amount\", amount),\n    ]);\n    Ok(res)\n}\n\npub fn execute_decrease_allowance(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    spender: String,\n    amount: Uint128,\n    expires: Option\u003cExpiration\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let spender_addr = deps.api.addr_validate(\u0026spender)?;\n    if spender_addr == info.sender {\n        return Err(ContractError::CannotSetOwnAccount {});\n    }\n\n    let key = (\u0026info.sender, \u0026spender_addr);\n    // load value and delete if it hits 0, or update otherwise\n    let mut allowance = ALLOWANCES.load(deps.storage, key)?;\n    if amount \u003c allowance.allowance {\n        // update the new amount\n        allowance.allowance = allowance\n            .allowance\n            .checked_sub(amount)\n            .map_err(StdError::overflow)?;\n        if let Some(exp) = expires {\n            allowance.expires = exp;\n        }\n        ALLOWANCES.save(deps.storage, key, \u0026allowance)?;\n    } else {\n        ALLOWANCES.remove(deps.storage, key);\n    }\n\n    let res = Response::new().add_attributes(vec![\n        attr(\"action\", \"decrease_allowance\"),\n        attr(\"owner\", info.sender),\n        attr(\"spender\", spender),\n        attr(\"amount\", amount),\n    ]);\n    Ok(res)\n}\n\n// this can be used to update a lower allowance - call bucket.update with proper keys\npub fn deduct_allowance(\n    storage: \u0026mut dyn Storage,\n    owner: \u0026Addr,\n    spender: \u0026Addr,\n    block: \u0026BlockInfo,\n    amount: Uint128,\n) -\u003e Result\u003cAllowanceResponse, ContractError\u003e {\n    ALLOWANCES.update(storage, (owner, spender), |current| {\n        match current {\n            Some(mut a) =\u003e {\n                if a.expires.is_expired(block) {\n                    Err(ContractError::Expired {})\n                } else {\n                    // deduct the allowance if enough\n                    a.allowance = a\n                        .allowance\n                        .checked_sub(amount)\n                        .map_err(StdError::overflow)?;\n                    Ok(a)\n                }\n            }\n            None =\u003e Err(ContractError::NoAllowance {}),\n        }\n    })\n}\n\npub fn execute_transfer_from(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    owner: String,\n    recipient: String,\n    amount: Uint128,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let rcpt_addr = deps.api.addr_validate(\u0026recipient)?;\n    let owner_addr = deps.api.addr_validate(\u0026owner)?;\n\n    // deduct allowance before doing anything else have enough allowance\n    deduct_allowance(deps.storage, \u0026owner_addr, \u0026info.sender, \u0026env.block, amount)?;\n\n    BALANCES.update(\n        deps.storage,\n        \u0026owner_addr,\n        |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e {\n            Ok(balance.unwrap_or_default().checked_sub(amount)?)\n        },\n    )?;\n    BALANCES.update(\n        deps.storage,\n        \u0026rcpt_addr,\n        |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e { Ok(balance.unwrap_or_default() + amount) },\n    )?;\n\n    let res = Response::new().add_attributes(vec![\n        attr(\"action\", \"transfer_from\"),\n        attr(\"from\", owner),\n        attr(\"to\", recipient),\n        attr(\"by\", info.sender),\n        attr(\"amount\", amount),\n    ]);\n    Ok(res)\n}\n\npub fn execute_burn_from(\n    deps: DepsMut,\n\n    env: Env,\n    info: MessageInfo,\n    owner: String,\n    amount: Uint128,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let owner_addr = deps.api.addr_validate(\u0026owner)?;\n\n    // deduct allowance before doing anything else have enough allowance\n    deduct_allowance(deps.storage, \u0026owner_addr, \u0026info.sender, \u0026env.block, amount)?;\n\n    // lower balance\n    BALANCES.update(\n        deps.storage,\n        \u0026owner_addr,\n        |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e {\n            Ok(balance.unwrap_or_default().checked_sub(amount)?)\n        },\n    )?;\n    // reduce total_supply\n    TOKEN_INFO.update(deps.storage, |mut meta| -\u003e StdResult\u003c_\u003e {\n        meta.total_supply = meta.total_supply.checked_sub(amount)?;\n        Ok(meta)\n    })?;\n\n    let res = Response::new().add_attributes(vec![\n        attr(\"action\", \"burn_from\"),\n        attr(\"from\", owner),\n        attr(\"by\", info.sender),\n        attr(\"amount\", amount),\n    ]);\n    Ok(res)\n}\n\npub fn execute_send_from(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    owner: String,\n    contract: String,\n    amount: Uint128,\n    msg: Binary,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let rcpt_addr = deps.api.addr_validate(\u0026contract)?;\n    let owner_addr = deps.api.addr_validate(\u0026owner)?;\n\n    // deduct allowance before doing anything else have enough allowance\n    deduct_allowance(deps.storage, \u0026owner_addr, \u0026info.sender, \u0026env.block, amount)?;\n\n    // move the tokens to the contract\n    BALANCES.update(\n        deps.storage,\n        \u0026owner_addr,\n        |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e {\n            Ok(balance.unwrap_or_default().checked_sub(amount)?)\n        },\n    )?;\n    BALANCES.update(\n        deps.storage,\n        \u0026rcpt_addr,\n        |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e { Ok(balance.unwrap_or_default() + amount) },\n    )?;\n\n    let attrs = vec![\n        attr(\"action\", \"send_from\"),\n        attr(\"from\", \u0026owner),\n        attr(\"to\", \u0026contract),\n        attr(\"by\", \u0026info.sender),\n        attr(\"amount\", amount),\n    ];\n\n    // create a send message\n    let msg = Cw20ReceiveMsg {\n        sender: info.sender.into(),\n        amount,\n        msg,\n    }\n    .into_cosmos_msg(contract)?;\n\n    let res = Response::new().add_message(msg).add_attributes(attrs);\n    Ok(res)\n}\n\npub fn query_allowance(deps: Deps, owner: String, spender: String) -\u003e StdResult\u003cAllowanceResponse\u003e {\n    let owner_addr = deps.api.addr_validate(\u0026owner)?;\n    let spender_addr = deps.api.addr_validate(\u0026spender)?;\n    let allowance = ALLOWANCES\n        .may_load(deps.storage, (\u0026owner_addr, \u0026spender_addr))?\n        .unwrap_or_default();\n    Ok(allowance)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use cosmwasm_std::testing::{mock_dependencies_with_balance, mock_env, mock_info};\n    use cosmwasm_std::{coins, CosmosMsg, SubMsg, Timestamp, WasmMsg};\n    use cw20::{Cw20Coin, TokenInfoResponse};\n\n    use crate::contract::{execute, instantiate, query_balance, query_token_info};\n    use crate::msg::{ExecuteMsg, InstantiateMsg};\n\n    fn get_balance\u003cT: Into\u003cString\u003e\u003e(deps: Deps, address: T) -\u003e Uint128 {\n        query_balance(deps, address.into()).unwrap().balance\n    }\n\n    // this will set up the instantiation for other tests\n    fn do_instantiate\u003cT: Into\u003cString\u003e\u003e(\n        mut deps: DepsMut,\n        addr: T,\n        amount: Uint128,\n    ) -\u003e TokenInfoResponse {\n        let instantiate_msg = InstantiateMsg {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: addr.into(),\n                amount,\n            }],\n            mint: None,\n            marketing: None,\n        };\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n        instantiate(deps.branch(), env, info, instantiate_msg).unwrap();\n        query_token_info(deps.as_ref()).unwrap()\n    }\n\n    #[test]\n    fn increase_decrease_allowances() {\n        let mut deps = mock_dependencies_with_balance(\u0026coins(2, \"token\"));\n\n        let owner = String::from(\"addr0001\");\n        let spender = String::from(\"addr0002\");\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        do_instantiate(deps.as_mut(), owner.clone(), Uint128::new(12340000));\n\n        // no allowance to start\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        assert_eq!(allowance, AllowanceResponse::default());\n\n        // set allowance with height expiration\n        let allow1 = Uint128::new(7777);\n        let expires = Expiration::AtHeight(5432);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: allow1,\n            expires: Some(expires),\n        };\n        execute(deps.as_mut(), env.clone(), info.clone(), msg).unwrap();\n\n        // ensure it looks good\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        assert_eq!(\n            allowance,\n            AllowanceResponse {\n                allowance: allow1,\n                expires\n            }\n        );\n\n        // decrease it a bit with no expire set - stays the same\n        let lower = Uint128::new(4444);\n        let allow2 = allow1.checked_sub(lower).unwrap();\n        let msg = ExecuteMsg::DecreaseAllowance {\n            spender: spender.clone(),\n            amount: lower,\n            expires: None,\n        };\n        execute(deps.as_mut(), env.clone(), info.clone(), msg).unwrap();\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        assert_eq!(\n            allowance,\n            AllowanceResponse {\n                allowance: allow2,\n                expires\n            }\n        );\n\n        // increase it some more and override the expires\n        let raise = Uint128::new(87654);\n        let allow3 = allow2 + raise;\n        let new_expire = Expiration::AtTime(Timestamp::from_seconds(8888888888));\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: raise,\n            expires: Some(new_expire),\n        };\n        execute(deps.as_mut(), env.clone(), info.clone(), msg).unwrap();\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        assert_eq!(\n            allowance,\n            AllowanceResponse {\n                allowance: allow3,\n                expires: new_expire\n            }\n        );\n\n        // decrease it below 0\n        let msg = ExecuteMsg::DecreaseAllowance {\n            spender: spender.clone(),\n            amount: Uint128::new(99988647623876347),\n            expires: None,\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n        let allowance = query_allowance(deps.as_ref(), owner, spender).unwrap();\n        assert_eq!(allowance, AllowanceResponse::default());\n    }\n\n    #[test]\n    fn allowances_independent() {\n        let mut deps = mock_dependencies_with_balance(\u0026coins(2, \"token\"));\n\n        let owner = String::from(\"addr0001\");\n        let spender = String::from(\"addr0002\");\n        let spender2 = String::from(\"addr0003\");\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        do_instantiate(deps.as_mut(), \u0026owner, Uint128::new(12340000));\n\n        // no allowance to start\n        assert_eq!(\n            query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap(),\n            AllowanceResponse::default()\n        );\n        assert_eq!(\n            query_allowance(deps.as_ref(), owner.clone(), spender2.clone()).unwrap(),\n            AllowanceResponse::default()\n        );\n        assert_eq!(\n            query_allowance(deps.as_ref(), spender.clone(), spender2.clone()).unwrap(),\n            AllowanceResponse::default()\n        );\n\n        // set allowance with height expiration\n        let allow1 = Uint128::new(7777);\n        let expires = Expiration::AtHeight(5432);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: allow1,\n            expires: Some(expires),\n        };\n        execute(deps.as_mut(), env.clone(), info.clone(), msg).unwrap();\n\n        // set other allowance with no expiration\n        let allow2 = Uint128::new(87654);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender2.clone(),\n            amount: allow2,\n            expires: None,\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // check they are proper\n        let expect_one = AllowanceResponse {\n            allowance: allow1,\n            expires,\n        };\n        let expect_two = AllowanceResponse {\n            allowance: allow2,\n            expires: Expiration::Never {},\n        };\n        assert_eq!(\n            query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap(),\n            expect_one\n        );\n        assert_eq!(\n            query_allowance(deps.as_ref(), owner.clone(), spender2.clone()).unwrap(),\n            expect_two\n        );\n        assert_eq!(\n            query_allowance(deps.as_ref(), spender.clone(), spender2.clone()).unwrap(),\n            AllowanceResponse::default()\n        );\n\n        // also allow spender -\u003e spender2 with no interference\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let allow3 = Uint128::new(1821);\n        let expires3 = Expiration::AtTime(Timestamp::from_seconds(3767626296));\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender2.clone(),\n            amount: allow3,\n            expires: Some(expires3),\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n        let expect_three = AllowanceResponse {\n            allowance: allow3,\n            expires: expires3,\n        };\n        assert_eq!(\n            query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap(),\n            expect_one\n        );\n        assert_eq!(\n            query_allowance(deps.as_ref(), owner, spender2.clone()).unwrap(),\n            expect_two\n        );\n        assert_eq!(\n            query_allowance(deps.as_ref(), spender, spender2).unwrap(),\n            expect_three\n        );\n    }\n\n    #[test]\n    fn no_self_allowance() {\n        let mut deps = mock_dependencies_with_balance(\u0026coins(2, \"token\"));\n\n        let owner = String::from(\"addr0001\");\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        do_instantiate(deps.as_mut(), \u0026owner, Uint128::new(12340000));\n\n        // self-allowance\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: owner.clone(),\n            amount: Uint128::new(7777),\n            expires: None,\n        };\n        let err = execute(deps.as_mut(), env.clone(), info.clone(), msg).unwrap_err();\n        assert_eq!(err, ContractError::CannotSetOwnAccount {});\n\n        // decrease self-allowance\n        let msg = ExecuteMsg::DecreaseAllowance {\n            spender: owner,\n            amount: Uint128::new(7777),\n            expires: None,\n        };\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert_eq!(err, ContractError::CannotSetOwnAccount {});\n    }\n\n    #[test]\n    fn transfer_from_respects_limits() {\n        let mut deps = mock_dependencies_with_balance(\u0026[]);\n        let owner = String::from(\"addr0001\");\n        let spender = String::from(\"addr0002\");\n        let rcpt = String::from(\"addr0003\");\n\n        let start = Uint128::new(999999);\n        do_instantiate(deps.as_mut(), \u0026owner, start);\n\n        // provide an allowance\n        let allow1 = Uint128::new(77777);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: allow1,\n            expires: None,\n        };\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // valid transfer of part of the allowance\n        let transfer = Uint128::new(44444);\n        let msg = ExecuteMsg::TransferFrom {\n            owner: owner.clone(),\n            recipient: rcpt.clone(),\n            amount: transfer,\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let res = execute(deps.as_mut(), env, info, msg).unwrap();\n        assert_eq!(res.attributes[0], attr(\"action\", \"transfer_from\"));\n\n        // make sure money arrived\n        assert_eq!(\n            get_balance(deps.as_ref(), owner.clone()),\n            start.checked_sub(transfer).unwrap()\n        );\n        assert_eq!(get_balance(deps.as_ref(), rcpt.clone()), transfer);\n\n        // ensure it looks good\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        let expect = AllowanceResponse {\n            allowance: allow1.checked_sub(transfer).unwrap(),\n            expires: Expiration::Never {},\n        };\n        assert_eq!(expect, allowance);\n\n        // cannot send more than the allowance\n        let msg = ExecuteMsg::TransferFrom {\n            owner: owner.clone(),\n            recipient: rcpt.clone(),\n            amount: Uint128::new(33443),\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert!(matches!(err, ContractError::Std(StdError::Overflow { .. })));\n\n        // let us increase limit, but set the expiration (default env height is 12_345)\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: Uint128::new(1000),\n            expires: Some(Expiration::AtHeight(env.block.height)),\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // we should now get the expiration error\n        let msg = ExecuteMsg::TransferFrom {\n            owner,\n            recipient: rcpt,\n            amount: Uint128::new(33443),\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert_eq!(err, ContractError::Expired {});\n    }\n\n    #[test]\n    fn burn_from_respects_limits() {\n        let mut deps = mock_dependencies_with_balance(\u0026[]);\n        let owner = String::from(\"addr0001\");\n        let spender = String::from(\"addr0002\");\n\n        let start = Uint128::new(999999);\n        do_instantiate(deps.as_mut(), \u0026owner, start);\n\n        // provide an allowance\n        let allow1 = Uint128::new(77777);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: allow1,\n            expires: None,\n        };\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // valid burn of part of the allowance\n        let transfer = Uint128::new(44444);\n        let msg = ExecuteMsg::BurnFrom {\n            owner: owner.clone(),\n            amount: transfer,\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let res = execute(deps.as_mut(), env, info, msg).unwrap();\n        assert_eq!(res.attributes[0], attr(\"action\", \"burn_from\"));\n\n        // make sure money burnt\n        assert_eq!(\n            get_balance(deps.as_ref(), owner.clone()),\n            start.checked_sub(transfer).unwrap()\n        );\n\n        // ensure it looks good\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        let expect = AllowanceResponse {\n            allowance: allow1.checked_sub(transfer).unwrap(),\n            expires: Expiration::Never {},\n        };\n        assert_eq!(expect, allowance);\n\n        // cannot burn more than the allowance\n        let msg = ExecuteMsg::BurnFrom {\n            owner: owner.clone(),\n            amount: Uint128::new(33443),\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert!(matches!(err, ContractError::Std(StdError::Overflow { .. })));\n\n        // let us increase limit, but set the expiration (default env height is 12_345)\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: Uint128::new(1000),\n            expires: Some(Expiration::AtHeight(env.block.height)),\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // we should now get the expiration error\n        let msg = ExecuteMsg::BurnFrom {\n            owner,\n            amount: Uint128::new(33443),\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert_eq!(err, ContractError::Expired {});\n    }\n\n    #[test]\n    fn send_from_respects_limits() {\n        let mut deps = mock_dependencies_with_balance(\u0026[]);\n        let owner = String::from(\"addr0001\");\n        let spender = String::from(\"addr0002\");\n        let contract = String::from(\"cool-dex\");\n        let send_msg = Binary::from(r#\"{\"some\":123}\"#.as_bytes());\n\n        let start = Uint128::new(999999);\n        do_instantiate(deps.as_mut(), \u0026owner, start);\n\n        // provide an allowance\n        let allow1 = Uint128::new(77777);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: allow1,\n            expires: None,\n        };\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // valid send of part of the allowance\n        let transfer = Uint128::new(44444);\n        let msg = ExecuteMsg::SendFrom {\n            owner: owner.clone(),\n            amount: transfer,\n            contract: contract.clone(),\n            msg: send_msg.clone(),\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let res = execute(deps.as_mut(), env, info, msg).unwrap();\n        assert_eq!(res.attributes[0], attr(\"action\", \"send_from\"));\n        assert_eq!(1, res.messages.len());\n\n        // we record this as sent by the one who requested, not the one who was paying\n        let binary_msg = Cw20ReceiveMsg {\n            sender: spender.clone(),\n            amount: transfer,\n            msg: send_msg.clone(),\n        }\n        .into_binary()\n        .unwrap();\n        assert_eq!(\n            res.messages[0],\n            SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: contract.clone(),\n                msg: binary_msg,\n                funds: vec![],\n            }))\n        );\n\n        // make sure money sent\n        assert_eq!(\n            get_balance(deps.as_ref(), owner.clone()),\n            start.checked_sub(transfer).unwrap()\n        );\n        assert_eq!(get_balance(deps.as_ref(), contract.clone()), transfer);\n\n        // ensure it looks good\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        let expect = AllowanceResponse {\n            allowance: allow1.checked_sub(transfer).unwrap(),\n            expires: Expiration::Never {},\n        };\n        assert_eq!(expect, allowance);\n\n        // cannot send more than the allowance\n        let msg = ExecuteMsg::SendFrom {\n            owner: owner.clone(),\n            amount: Uint128::new(33443),\n            contract: contract.clone(),\n            msg: send_msg.clone(),\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert!(matches!(err, ContractError::Std(StdError::Overflow { .. })));\n\n        // let us increase limit, but set the expiration to current block (expired)\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: Uint128::new(1000),\n            expires: Some(Expiration::AtHeight(env.block.height)),\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // we should now get the expiration error\n        let msg = ExecuteMsg::SendFrom {\n            owner,\n            amount: Uint128::new(33443),\n            contract,\n            msg: send_msg,\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert_eq!(err, ContractError::Expired {});\n    }\n}\n","traces":[{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":9},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","ailiq_token","src","contract.rs"],"content":"use anyhow::{anyhow, Result};\n#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\nuse cosmwasm_std::{\n    from_binary, to_binary, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult, Uint128,\n};\n\nuse cw20_base::allowances::{\n    execute_burn_from, execute_decrease_allowance, execute_increase_allowance, execute_send_from,\n    execute_transfer_from, query_allowance,\n};\nuse cw20_base::contract::{\n    execute_burn, execute_send, execute_transfer, execute_update_marketing, execute_upload_logo,\n};\nuse cw20_base::contract::{\n    query_balance, query_download_logo, query_marketing_info, query_minter, query_token_info,\n};\n\nuse cw20_base::enumerable::{query_all_accounts, query_all_allowances};\n\nuse cw20_base::msg::InstantiateMsg as CW20InstantiateMsg;\nuse cw_4626::msg::{ExecuteMsg, InstantiateMsg};\nuse cw_4626::query::QueryMsg;\nuse cw_4626::state::{AssetInfo, State, STATE};\n\nuse crate::moving::{_repay, borrow, deposit, mint, redeem, repay, withdraw};\nuse crate::query::{\n    convert_to_assets, convert_to_shares, max_deposit, max_mint, max_redeem, max_withdraw,\n    preview_deposit, preview_mint, preview_redeem, preview_withdraw, query_asset,\n    query_total_assets,\n};\n\nuse crate::error::ContractError;\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e Result\u003cResponse\u003e {\n    // We start by initating the state of the contract\n    let borrower = msg\n        .borrower\n        .map(|x| deps.api.addr_validate(\u0026x))\n        .transpose()?;\n    let initial_state = State {\n        underlying_asset: msg.asset,\n        total_underlying_asset_supply: Uint128::zero(),\n        total_assets_borrowed: Uint128::zero(),\n        borrower,\n    };\n\n    STATE.save(deps.storage, \u0026initial_state)?;\n\n    let base_instantiate_msg = CW20InstantiateMsg {\n        name: msg.name,\n        symbol: msg.symbol,\n        decimals: msg.decimals,\n        initial_balances: vec![],\n        mint: msg.mint,\n        marketing: msg.marketing,\n    };\n\n    cw20_base::contract::instantiate(deps, env, info, base_instantiate_msg).map_err(|x| anyhow!(x))\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg) -\u003e Result\u003cResponse\u003e {\n    match msg {\n        ExecuteMsg::Transfer { recipient, amount } =\u003e {\n            execute_transfer(deps, env, info, recipient, amount).map_err(|x| anyhow!(x))\n        }\n        ExecuteMsg::Burn { amount } =\u003e {\n            execute_burn(deps, env, info, amount).map_err(|x| anyhow!(x))\n        }\n        ExecuteMsg::Send {\n            contract,\n            amount,\n            msg,\n        } =\u003e execute_send(deps, env, info, contract, amount, msg).map_err(|x| anyhow!(x)),\n        ExecuteMsg::IncreaseAllowance {\n            spender,\n            amount,\n            expires,\n        } =\u003e execute_increase_allowance(deps, env, info, spender, amount, expires)\n            .map_err(|x| anyhow!(x)),\n        ExecuteMsg::DecreaseAllowance {\n            spender,\n            amount,\n            expires,\n        } =\u003e execute_decrease_allowance(deps, env, info, spender, amount, expires)\n            .map_err(|x| anyhow!(x)),\n        ExecuteMsg::TransferFrom {\n            owner,\n            recipient,\n            amount,\n        } =\u003e {\n            execute_transfer_from(deps, env, info, owner, recipient, amount).map_err(|x| anyhow!(x))\n        }\n        ExecuteMsg::BurnFrom { owner, amount } =\u003e {\n            execute_burn_from(deps, env, info, owner, amount).map_err(|x| anyhow!(x))\n        }\n        ExecuteMsg::SendFrom {\n            owner,\n            contract,\n            amount,\n            msg,\n        } =\u003e {\n            execute_send_from(deps, env, info, owner, contract, amount, msg).map_err(|x| anyhow!(x))\n        }\n        ExecuteMsg::UpdateMarketing {\n            project,\n            description,\n            marketing,\n        } =\u003e execute_update_marketing(deps, env, info, project, description, marketing)\n            .map_err(|x| anyhow!(x)),\n        ExecuteMsg::UploadLogo(logo) =\u003e {\n            execute_upload_logo(deps, env, info, logo).map_err(|x| anyhow!(x))\n        }\n\n        // CW4626 specific functions\n        ExecuteMsg::Deposit { assets, receiver } =\u003e {\n            deposit(deps, env, info, receiver, assets).map_err(|x| anyhow!(x))\n        }\n        ExecuteMsg::Mint { shares, receiver } =\u003e {\n            mint(deps, env, info, receiver, shares).map_err(|x| anyhow!(x))\n        }\n        ExecuteMsg::Withdraw {\n            assets,\n            owner,\n            receiver,\n        } =\u003e withdraw(deps, env, info, owner, receiver, assets).map_err(|x| anyhow!(x)),\n        ExecuteMsg::Redeem {\n            shares,\n            owner,\n            receiver,\n        } =\u003e redeem(deps, env, info, owner, receiver, shares).map_err(|x| anyhow!(x)),\n        ExecuteMsg::Borrow { assets, receiver } =\u003e {\n            borrow(deps, env, info, receiver, assets).map_err(|x| anyhow!(x))\n        }\n        ExecuteMsg::Repay { owner, assets } =\u003e {\n            repay(deps, env, info, owner, assets).map_err(|x| anyhow!(x))\n        }\n        ExecuteMsg::Receive {\n            sender,\n            amount,\n            msg,\n        } =\u003e receive_assets(deps, env, info, sender, amount, msg).map_err(|x| anyhow!(x)),\n    }\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, env: Env, msg: QueryMsg) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::Balance { address } =\u003e to_binary(\u0026query_balance(deps, address)?),\n        QueryMsg::TokenInfo {} =\u003e to_binary(\u0026query_token_info(deps)?),\n        QueryMsg::Minter {} =\u003e to_binary(\u0026query_minter(deps)?),\n        QueryMsg::Allowance { owner, spender } =\u003e {\n            to_binary(\u0026query_allowance(deps, owner, spender)?)\n        }\n        QueryMsg::AllAllowances {\n            owner,\n            start_after,\n            limit,\n        } =\u003e to_binary(\u0026query_all_allowances(deps, owner, start_after, limit)?),\n        QueryMsg::AllAccounts { start_after, limit } =\u003e {\n            to_binary(\u0026query_all_accounts(deps, start_after, limit)?)\n        }\n        QueryMsg::MarketingInfo {} =\u003e to_binary(\u0026query_marketing_info(deps)?),\n        QueryMsg::DownloadLogo {} =\u003e to_binary(\u0026query_download_logo(deps)?),\n\n        // 4626 specific functions\n        QueryMsg::Asset {} =\u003e to_binary(\u0026query_asset(deps)?),\n        QueryMsg::TotalAssets {} =\u003e to_binary(\u0026query_total_assets(deps)?),\n        QueryMsg::ConvertToShares { assets } =\u003e {\n            to_binary(\u0026convert_to_shares(deps, env, assets, None)?)\n        }\n        QueryMsg::ConvertToAssets { shares } =\u003e {\n            to_binary(\u0026convert_to_assets(deps, env, shares, None)?)\n        }\n        QueryMsg::MaxDeposit { receiver } =\u003e to_binary(\u0026max_deposit(deps, env, receiver)?),\n        QueryMsg::PreviewDeposit { assets } =\u003e to_binary(\u0026preview_deposit(deps, env, assets)?),\n        QueryMsg::MaxMint { receiver } =\u003e to_binary(\u0026max_mint(deps, env, receiver)?),\n        QueryMsg::PreviewMint { shares } =\u003e to_binary(\u0026preview_mint(deps, env, shares)?),\n        QueryMsg::MaxWithdraw { owner } =\u003e to_binary(\u0026max_withdraw(deps, env, owner)?),\n        QueryMsg::PreviewWithdraw { assets } =\u003e to_binary(\u0026preview_withdraw(deps, env, assets)?),\n        QueryMsg::MaxRedeem { owner } =\u003e to_binary(\u0026max_redeem(deps, env, owner)?),\n        QueryMsg::PreviewRedeem { shares } =\u003e to_binary(\u0026preview_redeem(deps, env, shares)?),\n    }\n}\n\npub fn receive_assets(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    _sender: String,\n    amount: Uint128,\n    msg: Binary,\n) -\u003e Result\u003cResponse\u003e {\n    match from_binary(\u0026msg)? {\n        ExecuteMsg::Repay { assets, .. } =\u003e {\n            let state = STATE.load(deps.storage)?;\n            match state.underlying_asset {\n                AssetInfo::Cw20(x) =\u003e {\n                    if x != info.sender {\n                        return Err(anyhow!(ContractError::WrongAssetDeposited {\n                            sent: info.sender.to_string(),\n                            expected: x\n                        },));\n                    } else if amount != assets {\n                        return Err(anyhow!(ContractError::InsufficientAssetDeposited {\n                            sent: amount,\n                            expected: assets\n                        },));\n                    }\n                    let debt_repaid = _repay(deps.storage, amount)?;\n\n                    Ok(Response::new()\n                        .add_attribute(\"action\", \"repay\")\n                        .add_attribute(\"caller\", info.sender)\n                        .add_attribute(\"assets\", assets.to_string())\n                        .add_attribute(\"debt_repaid\", debt_repaid.to_string())\n                        .add_attribute(\"raw_deposit\", (assets - debt_repaid).to_string()))\n                }\n                AssetInfo::Coin(x) =\u003e Err(anyhow!(ContractError::WrongAssetDeposited {\n                    sent: info.sender.to_string(),\n                    expected: x\n                },)),\n            }\n        }\n        _ =\u003e Err(anyhow!(ContractError::InvalidMessage {})),\n    }\n}\n\n#[cfg(test)]\npub mod tests {\n    use super::*;\n    use crate::contract::instantiate;\n    use crate::query::convert_to_assets;\n    use cosmwasm_std::testing::{\n        mock_dependencies, mock_env, mock_info, MockQuerier, MOCK_CONTRACT_ADDR,\n    };\n    use cosmwasm_std::{coins, from_binary, BankMsg, Coin, DepsMut};\n    use cw20::BalanceResponse;\n    use cw_4626::msg::InstantiateMsg;\n    use cw_4626::state::AssetInfo;\n\n    use rand::Rng;\n\n    fn init_helper(deps: DepsMut) {\n        let instantiate_msg = InstantiateMsg {\n            name: \"Iliq treasury token\".to_string(),\n            symbol: \"ailiq\".to_string(),\n            decimals: 6u8,\n            initial_balances: vec![],\n            mint: None,\n            marketing: None,\n            asset: AssetInfo::Coin(\"uluna\".to_string()),\n            borrower: Some(\"borrower\".to_string()),\n        };\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n\n        instantiate(deps, env, info, instantiate_msg).unwrap();\n    }\n\n    fn deposit_helper(\n        deps: DepsMut,\n        address: \u0026str,\n        receiver: \u0026str,\n        assets: Vec\u003cCoin\u003e,\n    ) -\u003e Result\u003cResponse\u003e {\n        let info = mock_info(address, \u0026assets);\n        let env = mock_env();\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::Deposit {\n                assets: assets[0].amount,\n                receiver: receiver.to_string(),\n            },\n        )\n    }\n\n    fn mint_helper(\n        deps: DepsMut,\n        address: \u0026str,\n        receiver: \u0026str,\n        assets: Vec\u003cCoin\u003e,\n        shares: Uint128,\n    ) -\u003e Result\u003cResponse\u003e {\n        let info = mock_info(address, \u0026assets);\n        let env = mock_env();\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::Mint {\n                shares,\n                receiver: receiver.to_string(),\n            },\n        )\n    }\n\n    fn withdraw_helper(\n        deps: DepsMut,\n        address: \u0026str,\n        receiver: \u0026str,\n        assets: u128,\n    ) -\u003e Result\u003cResponse\u003e {\n        let info = mock_info(address, \u0026[]);\n        let env = mock_env();\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::Withdraw {\n                assets: Uint128::from(assets),\n                owner: address.to_string(),\n                receiver: receiver.to_string(),\n            },\n        )\n    }\n\n    fn redeem_helper(\n        deps: DepsMut,\n        address: \u0026str,\n        receiver: \u0026str,\n        shares: Uint128,\n    ) -\u003e Result\u003cResponse\u003e {\n        let info = mock_info(address, \u0026[]);\n        let env = mock_env();\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::Redeem {\n                shares,\n                owner: address.to_string(),\n                receiver: receiver.to_string(),\n            },\n        )\n    }\n\n    fn burn_helper(deps: DepsMut, address: \u0026str, assets: u128) -\u003e Result\u003cResponse\u003e {\n        let env = mock_env();\n        let info = mock_info(address, \u0026[]);\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::Burn {\n                amount: Uint128::from(assets),\n            },\n        )\n    }\n\n    fn equal_or_not_far_below(init: Uint128, fin: Uint128) -\u003e bool {\n        (init == fin) || ((init \u003e= fin) \u0026\u0026 (init \u003c= fin + Uint128::from(2u128)))\n    }\n\n    fn get_share_balance(deps: Deps, env: Env, address: String) -\u003e Uint128 {\n        // We need to check that in that specific case of a unique depositor, the underlying funds are unchanged\n        let balance = query(deps, env, QueryMsg::Balance { address }).unwrap();\n\n        from_binary::\u003cBalanceResponse\u003e(\u0026balance).unwrap().balance\n    }\n\n    fn get_asset_balance(deps: Deps, env: Env, address: String) -\u003e Uint128 {\n        // We need to check that in that specific case of a unique depositor, the underlying funds are unchanged\n        let share_balance = get_share_balance(deps, env.clone(), address);\n        convert_to_assets(deps, env, share_balance, None).unwrap()\n    }\n\n    #[test]\n    fn test_deposit_sanity() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n\n        let mut rng = rand::thread_rng();\n        let assets = rng.gen::\u003cu128\u003e();\n        let res =\n            deposit_helper(deps.as_mut(), \"depositor\", \"nicoco\", coins(assets, \"uluna\")).unwrap();\n\n        assert_eq!(\n            res,\n            Response::new()\n                .add_attribute(\"action\", \"deposit\")\n                .add_attribute(\"caller\", \"depositor\")\n                .add_attribute(\"owner\", \"nicoco\")\n                .add_attribute(\"assets\", assets.to_string())\n                .add_attribute(\"shares\", assets.to_string())\n        );\n\n        // Now we check the internal to be sure it updated\n        assert_eq!(\n            query_balance(deps.as_ref(), \"nicoco\".to_string()).unwrap(),\n            BalanceResponse {\n                balance: Uint128::from(assets)\n            }\n        );\n    }\n\n    #[test]\n    fn test_multiple_swaps_sanity() {\n        let mut deps = mock_dependencies();\n        let env = mock_env();\n        init_helper(deps.as_mut());\n\n        let mut rng = rand::thread_rng();\n        let assets1 = rng.gen_range(0u128..1000000u128);\n        // The funds are sent, we have to update the internal fund balance\n        deps.querier = MockQuerier::new(\u0026[(MOCK_CONTRACT_ADDR, \u0026coins(assets1, \"uluna\"))]);\n        deposit_helper(\n            deps.as_mut(),\n            \"depositor\",\n            \"nicoco\",\n            coins(assets1, \"uluna\"),\n        )\n        .unwrap();\n\n        // We burn some of the tokens to make the ratio increase\n        burn_helper(deps.as_mut(), \"nicoco\", assets1 / 2u128).unwrap();\n\n        // We need to check that in that specific case of a unique depositor, the underlying funds are unchanged\n\n        let asset_balance = get_asset_balance(deps.as_ref(), env.clone(), \"nicoco\".to_string());\n        assert!(asset_balance.u128() \u003c= assets1);\n\n        // We check it's impossible (on those 10_000 examples) to mint some free tokens\n        for _i in 0..5_000 {\n            let initial_assets = Uint128::from(rng.gen_range(0u128..1000000u128));\n            let shares =\n                convert_to_shares(deps.as_ref(), env.clone(), initial_assets, None).unwrap();\n            let final_assets = convert_to_assets(deps.as_ref(), env.clone(), shares, None).unwrap();\n            assert!(equal_or_not_far_below(initial_assets, final_assets));\n        }\n\n        for _i in 0..5_000 {\n            let initial_shares = Uint128::from(rng.gen_range(0u128..1000000u128));\n            let assets =\n                convert_to_assets(deps.as_ref(), env.clone(), initial_shares, None).unwrap();\n            let final_shares = convert_to_shares(deps.as_ref(), env.clone(), assets, None).unwrap();\n            assert!(equal_or_not_far_below(initial_shares, final_shares));\n        }\n    }\n\n    #[test]\n    fn test_multiple_deposits_sanity() {\n        let mut deps = mock_dependencies();\n        let env = mock_env();\n        init_helper(deps.as_mut());\n\n        let mut rng = rand::thread_rng();\n        let assets1 = rng.gen_range(0u128..1000000u128);\n        // The funds are sent, we have to update the internal fund balance\n        deps.querier = MockQuerier::new(\u0026[(MOCK_CONTRACT_ADDR, \u0026coins(assets1, \"uluna\"))]);\n        deposit_helper(\n            deps.as_mut(),\n            \"depositor\",\n            \"nicoco\",\n            coins(assets1, \"uluna\"),\n        )\n        .unwrap();\n\n        // We burn some of the tokens to make the ratio increase\n        burn_helper(deps.as_mut(), \"nicoco\", assets1 / 2u128).unwrap();\n\n        let assets2 = rng.gen_range(0u128..1000000u128);\n        // The funds are sent, we have to update the internal fund balance\n        deps.querier =\n            MockQuerier::new(\u0026[(MOCK_CONTRACT_ADDR, \u0026coins(assets1 + assets2, \"uluna\"))]);\n        deposit_helper(\n            deps.as_mut(),\n            \"depositor\",\n            \"nicoco\",\n            coins(assets2, \"uluna\"),\n        )\n        .unwrap();\n\n        let asset_balance = get_asset_balance(deps.as_ref(), env, \"nicoco\".to_string());\n        assert!(\n            equal_or_not_far_below(Uint128::from(assets1 + assets2), asset_balance),\n            \"first: {:?}, second: {:?}\",\n            asset_balance,\n            assets1 + assets2\n        );\n    }\n\n    #[test]\n    fn test_simple_withdraw_sanity() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n\n        let mut rng = rand::thread_rng();\n        let assets1 = rng.gen_range(0u128..1000000u128);\n        // The funds are sent, we have to update the internal fund balance\n        deps.querier = MockQuerier::new(\u0026[(MOCK_CONTRACT_ADDR, \u0026coins(assets1, \"uluna\"))]);\n        deposit_helper(\n            deps.as_mut(),\n            \"depositor\",\n            \"nicoco\",\n            coins(assets1, \"uluna\"),\n        )\n        .unwrap();\n        let res = withdraw_helper(deps.as_mut(), \"nicoco\", \"depositor\", assets1).unwrap();\n\n        assert_eq!(\n            res,\n            Response::new()\n                .add_message(BankMsg::Send {\n                    to_address: \"depositor\".to_string(),\n                    amount: coins(assets1, \"uluna\")\n                })\n                .add_attribute(\"action\", \"withdraw\")\n                .add_attribute(\"caller\", \"nicoco\")\n                .add_attribute(\"receiver\", \"depositor\")\n                .add_attribute(\"owner\", \"nicoco\")\n                .add_attribute(\"assets\", assets1.to_string())\n                .add_attribute(\"shares\", assets1.to_string())\n        );\n    }\n\n    #[test]\n    fn test_mint_sanity() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n\n        let mut rng = rand::thread_rng();\n        let shares = rng.gen::\u003cu128\u003e();\n        let res = mint_helper(\n            deps.as_mut(),\n            \"depositor\",\n            \"nicoco\",\n            coins(shares, \"uluna\"),\n            Uint128::from(shares),\n        )\n        .unwrap();\n\n        assert_eq!(\n            res,\n            Response::new()\n                .add_attribute(\"action\", \"mint\")\n                .add_attribute(\"caller\", \"depositor\")\n                .add_attribute(\"owner\", \"nicoco\")\n                .add_attribute(\"assets\", shares.to_string())\n                .add_attribute(\"shares\", shares.to_string())\n        );\n\n        // Now we check the internal to be sure it updated\n        assert_eq!(\n            query_balance(deps.as_ref(), \"nicoco\".to_string()).unwrap(),\n            BalanceResponse {\n                balance: Uint128::from(shares)\n            }\n        );\n    }\n\n    #[test]\n    fn test_mint_give_back_sanity() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n\n        let mut rng = rand::thread_rng();\n        let shares = rng.gen::\u003cu128\u003e();\n        let supplemental_assets = 69238u128;\n        let res = mint_helper(\n            deps.as_mut(),\n            \"depositor\",\n            \"nicoco\",\n            coins(shares + supplemental_assets, \"uluna\"),\n            Uint128::from(shares),\n        )\n        .unwrap();\n\n        assert_eq!(\n            res,\n            Response::new()\n                .add_message(BankMsg::Send {\n                    to_address: \"nicoco\".to_string(),\n                    amount: coins(supplemental_assets, \"uluna\")\n                })\n                .add_attribute(\"action\", \"mint\")\n                .add_attribute(\"caller\", \"depositor\")\n                .add_attribute(\"owner\", \"nicoco\")\n                .add_attribute(\"assets\", shares.to_string())\n                .add_attribute(\"shares\", shares.to_string())\n        );\n\n        // Now we check the internal to be sure it updated\n        assert_eq!(\n            query_balance(deps.as_ref(), \"nicoco\".to_string()).unwrap(),\n            BalanceResponse {\n                balance: Uint128::from(shares)\n            }\n        );\n    }\n\n    #[test]\n    fn test_multiple_swaps_after_mint_sanity() {\n        let mut deps = mock_dependencies();\n        let env = mock_env();\n        init_helper(deps.as_mut());\n\n        let mut rng = rand::thread_rng();\n        let assets1 = rng.gen_range(0u128..1000000u128);\n        // The funds are sent, we have to update the internal fund balance\n        deps.querier = MockQuerier::new(\u0026[(MOCK_CONTRACT_ADDR, \u0026coins(assets1, \"uluna\"))]);\n        mint_helper(\n            deps.as_mut(),\n            \"depositor\",\n            \"nicoco\",\n            coins(assets1, \"uluna\"),\n            Uint128::from(assets1),\n        )\n        .unwrap();\n\n        // We burn some of the tokens to make the ratio increase\n        burn_helper(deps.as_mut(), \"nicoco\", assets1 / 2u128).unwrap();\n\n        // We need to check that in that specific case of a unique depositor, the underlying funds are unchanged\n\n        let asset_balance = get_asset_balance(deps.as_ref(), env.clone(), \"nicoco\".to_string());\n        assert!(asset_balance \u003c= Uint128::from(assets1));\n\n        // We check it's impossible (on those 10_000 examples) to mint some free tokens\n        for _i in 0..5_000 {\n            let initial_assets = Uint128::from(rng.gen_range(0u128..1000000u128));\n            let shares =\n                convert_to_shares(deps.as_ref(), env.clone(), initial_assets, None).unwrap();\n            let final_assets = convert_to_assets(deps.as_ref(), env.clone(), shares, None).unwrap();\n            assert!(equal_or_not_far_below(initial_assets, final_assets));\n        }\n\n        for _i in 0..5_000 {\n            let initial_shares = Uint128::from(rng.gen_range(0u128..1000000u128));\n            let assets =\n                convert_to_assets(deps.as_ref(), env.clone(), initial_shares, None).unwrap();\n            let final_shares = convert_to_shares(deps.as_ref(), env.clone(), assets, None).unwrap();\n            assert!(equal_or_not_far_below(initial_shares, final_shares));\n        }\n    }\n\n    #[test]\n    fn test_multiple_mints_sanity() {\n        let mut deps = mock_dependencies();\n        let env = mock_env();\n        init_helper(deps.as_mut());\n\n        let mut rng = rand::thread_rng();\n        let assets1 = rng.gen_range(0u128..1000000u128);\n        // The funds are sent, we have to update the internal fund balance\n        deps.querier = MockQuerier::new(\u0026[(MOCK_CONTRACT_ADDR, \u0026coins(assets1, \"uluna\"))]);\n        mint_helper(\n            deps.as_mut(),\n            \"depositor\",\n            \"nicoco\",\n            coins(assets1, \"uluna\"),\n            Uint128::from(assets1),\n        )\n        .unwrap();\n\n        // We burn some of the tokens to make the ratio increase\n        burn_helper(deps.as_mut(), \"nicoco\", assets1 / 2u128).unwrap();\n\n        // We want to deposit at least some assets\n        let shares2 = rng.gen_range(0u128..1000000u128);\n        let assets2 = assets1 * shares2 / (assets1 - assets1 / 2);\n        println!(\"{:?} - {:?}\", shares2, assets2);\n\n        // The funds are sent, we have to update the internal fund balance\n        deps.querier =\n            MockQuerier::new(\u0026[(MOCK_CONTRACT_ADDR, \u0026coins(assets1 + assets2, \"uluna\"))]);\n        mint_helper(\n            deps.as_mut(),\n            \"depositor\",\n            \"nicoco\",\n            coins(assets2, \"uluna\"),\n            Uint128::from(shares2),\n        )\n        .unwrap();\n\n        let asset_balance = get_asset_balance(deps.as_ref(), env, \"nicoco\".to_string());\n        assert!(\n            equal_or_not_far_below(Uint128::from(assets1 + assets2), asset_balance),\n            \"first: {:?}, second: {:?}\",\n            asset_balance,\n            assets1 + assets2\n        );\n    }\n\n    #[test]\n    fn test_simple_redeem_sanity() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n\n        let mut rng = rand::thread_rng();\n        let assets1 = rng.gen_range(0u128..1000000u128);\n        // The funds are sent, we have to update the internal fund balance\n        deps.querier = MockQuerier::new(\u0026[(MOCK_CONTRACT_ADDR, \u0026coins(assets1, \"uluna\"))]);\n        mint_helper(\n            deps.as_mut(),\n            \"depositor\",\n            \"nicoco\",\n            coins(assets1, \"uluna\"),\n            Uint128::from(assets1),\n        )\n        .unwrap();\n        let res =\n            redeem_helper(deps.as_mut(), \"nicoco\", \"depositor\", Uint128::from(assets1)).unwrap();\n\n        assert_eq!(\n            res,\n            Response::new()\n                .add_message(BankMsg::Send {\n                    to_address: \"depositor\".to_string(),\n                    amount: coins(assets1, \"uluna\")\n                })\n                .add_attribute(\"action\", \"redeem\")\n                .add_attribute(\"caller\", \"nicoco\")\n                .add_attribute(\"receiver\", \"depositor\")\n                .add_attribute(\"owner\", \"nicoco\")\n                .add_attribute(\"assets\", assets1.to_string())\n                .add_attribute(\"shares\", assets1.to_string())\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","ailiq_token","src","enumerable.rs"],"content":"use cosmwasm_std::{Deps, Order, StdResult};\nuse cw20::{AllAccountsResponse, AllAllowancesResponse, AllowanceInfo};\n\nuse crate::state::{ALLOWANCES, BALANCES};\nuse cw_storage_plus::Bound;\n\n// settings for pagination\nconst MAX_LIMIT: u32 = 30;\nconst DEFAULT_LIMIT: u32 = 10;\n\npub fn query_all_allowances(\n    deps: Deps,\n    owner: String,\n    start_after: Option\u003cString\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e StdResult\u003cAllAllowancesResponse\u003e {\n    let owner_addr = deps.api.addr_validate(\u0026owner)?;\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n    let start = start_after.map(|s| Bound::ExclusiveRaw(s.into_bytes()));\n\n    let allowances = ALLOWANCES\n        .prefix(\u0026owner_addr)\n        .range(deps.storage, start, None, Order::Ascending)\n        .take(limit)\n        .map(|item| {\n            item.map(|(addr, allow)| AllowanceInfo {\n                spender: addr.into(),\n                allowance: allow.allowance,\n                expires: allow.expires,\n            })\n        })\n        .collect::\u003cStdResult\u003c_\u003e\u003e()?;\n    Ok(AllAllowancesResponse { allowances })\n}\n\npub fn query_all_accounts(\n    deps: Deps,\n    start_after: Option\u003cString\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e StdResult\u003cAllAccountsResponse\u003e {\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n    let start = start_after.map(|s| Bound::ExclusiveRaw(s.into()));\n\n    let accounts = BALANCES\n        .keys(deps.storage, start, None, Order::Ascending)\n        .take(limit)\n        .map(|item| item.map(Into::into))\n        .collect::\u003cStdResult\u003c_\u003e\u003e()?;\n\n    Ok(AllAccountsResponse { accounts })\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use cosmwasm_std::testing::{mock_dependencies_with_balance, mock_env, mock_info};\n    use cosmwasm_std::{coins, DepsMut, Uint128};\n    use cw20::{Cw20Coin, Expiration, TokenInfoResponse};\n\n    use crate::contract::{execute, instantiate, query_token_info};\n    use crate::msg::{ExecuteMsg, InstantiateMsg};\n\n    // this will set up the instantiation for other tests\n    fn do_instantiate(mut deps: DepsMut, addr: \u0026str, amount: Uint128) -\u003e TokenInfoResponse {\n        let instantiate_msg = InstantiateMsg {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: addr.into(),\n                amount,\n            }],\n            mint: None,\n            marketing: None,\n        };\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n        instantiate(deps.branch(), env, info, instantiate_msg).unwrap();\n        query_token_info(deps.as_ref()).unwrap()\n    }\n\n    #[test]\n    fn query_all_allowances_works() {\n        let mut deps = mock_dependencies_with_balance(\u0026coins(2, \"token\"));\n\n        let owner = String::from(\"owner\");\n        // these are in alphabetical order same than insert order\n        let spender1 = String::from(\"earlier\");\n        let spender2 = String::from(\"later\");\n\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        do_instantiate(deps.as_mut(), \u0026owner, Uint128::new(12340000));\n\n        // no allowance to start\n        let allowances = query_all_allowances(deps.as_ref(), owner.clone(), None, None).unwrap();\n        assert_eq!(allowances.allowances, vec![]);\n\n        // set allowance with height expiration\n        let allow1 = Uint128::new(7777);\n        let expires = Expiration::AtHeight(5432);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender1.clone(),\n            amount: allow1,\n            expires: Some(expires),\n        };\n        execute(deps.as_mut(), env.clone(), info.clone(), msg).unwrap();\n\n        // set allowance with no expiration\n        let allow2 = Uint128::new(54321);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender2.clone(),\n            amount: allow2,\n            expires: None,\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // query list gets 2\n        let allowances = query_all_allowances(deps.as_ref(), owner.clone(), None, None).unwrap();\n        assert_eq!(allowances.allowances.len(), 2);\n\n        // first one is spender1 (order of CanonicalAddr uncorrelated with String)\n        let allowances = query_all_allowances(deps.as_ref(), owner.clone(), None, Some(1)).unwrap();\n        assert_eq!(allowances.allowances.len(), 1);\n        let allow = \u0026allowances.allowances[0];\n        assert_eq!(\u0026allow.spender, \u0026spender1);\n        assert_eq!(\u0026allow.expires, \u0026expires);\n        assert_eq!(\u0026allow.allowance, \u0026allow1);\n\n        // next one is spender2\n        let allowances = query_all_allowances(\n            deps.as_ref(),\n            owner,\n            Some(allow.spender.clone()),\n            Some(10000),\n        )\n        .unwrap();\n        assert_eq!(allowances.allowances.len(), 1);\n        let allow = \u0026allowances.allowances[0];\n        assert_eq!(\u0026allow.spender, \u0026spender2);\n        assert_eq!(\u0026allow.expires, \u0026Expiration::Never {});\n        assert_eq!(\u0026allow.allowance, \u0026allow2);\n    }\n\n    #[test]\n    fn query_all_accounts_works() {\n        let mut deps = mock_dependencies_with_balance(\u0026coins(2, \"token\"));\n\n        // insert order and lexicographical order are different\n        let acct1 = String::from(\"acct01\");\n        let acct2 = String::from(\"zebra\");\n        let acct3 = String::from(\"nice\");\n        let acct4 = String::from(\"aaaardvark\");\n        let expected_order = [acct4.clone(), acct1.clone(), acct3.clone(), acct2.clone()];\n\n        do_instantiate(deps.as_mut(), \u0026acct1, Uint128::new(12340000));\n\n        // put money everywhere (to create balanaces)\n        let info = mock_info(acct1.as_ref(), \u0026[]);\n        let env = mock_env();\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            ExecuteMsg::Transfer {\n                recipient: acct2,\n                amount: Uint128::new(222222),\n            },\n        )\n        .unwrap();\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            ExecuteMsg::Transfer {\n                recipient: acct3,\n                amount: Uint128::new(333333),\n            },\n        )\n        .unwrap();\n        execute(\n            deps.as_mut(),\n            env,\n            info,\n            ExecuteMsg::Transfer {\n                recipient: acct4,\n                amount: Uint128::new(444444),\n            },\n        )\n        .unwrap();\n\n        // make sure we get the proper results\n        let accounts = query_all_accounts(deps.as_ref(), None, None).unwrap();\n        assert_eq!(accounts.accounts, expected_order);\n\n        // let's do pagination\n        let accounts = query_all_accounts(deps.as_ref(), None, Some(2)).unwrap();\n        assert_eq!(accounts.accounts, expected_order[0..2].to_vec());\n\n        let accounts =\n            query_all_accounts(deps.as_ref(), Some(accounts.accounts[1].clone()), Some(1)).unwrap();\n        assert_eq!(accounts.accounts, expected_order[2..3].to_vec());\n\n        let accounts =\n            query_all_accounts(deps.as_ref(), Some(accounts.accounts[0].clone()), Some(777))\n                .unwrap();\n        assert_eq!(accounts.accounts, expected_order[3..].to_vec());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","ailiq_token","src","error.rs"],"content":"use cosmwasm_std::{StdError, Uint128};\nuse thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized {},\n\n    #[error(\"Invalid Execute Message: lender contract\")]\n    InvalidMessage {},\n\n    #[error(\"Cannot set to own account\")]\n    CannotSetOwnAccount {},\n\n    #[error(\"Invalid zero amount\")]\n    InvalidZeroAmount {},\n\n    #[error(\"Allowance is expired\")]\n    Expired {},\n\n    #[error(\"No allowance for this account\")]\n    NoAllowance {},\n\n    #[error(\"Minting cannot exceed the cap\")]\n    CannotExceedCap {},\n\n    #[error(\"Logo binary data exceeds 5KB limit\")]\n    LogoTooBig {},\n\n    #[error(\"Invalid xml preamble for SVG\")]\n    InvalidXmlPreamble {},\n\n    #[error(\"Invalid png header\")]\n    InvalidPngHeader {},\n\n    #[error(\"Wrong asset deposited into the vault: sent {sent:?}, expected: {expected:?}\")]\n    WrongAssetDeposited { sent: String, expected: String },\n\n    #[error(\"Not enough assets deposited into the vault: sent {sent:?}, expected: {expected:?}\")]\n    InsufficientAssetDeposited { sent: Uint128, expected: Uint128 },\n\n    #[error(\"You can't deposit 0 assets\")]\n    ZeroDeposit {},\n\n    #[error(\"You can't burn assets right now, sorry (check your balance is high enough and you have the right to burn those tokens\")]\n    UnableToBurn {},\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","ailiq_token","src","lib.rs"],"content":"pub mod contract;\nmod error;\npub mod moving;\npub mod msg;\npub mod query;\n\npub use crate::error::ContractError;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","ailiq_token","src","moving.rs"],"content":"use crate::error::ContractError;\n#[cfg(not(feature = \"library\"))]\nuse anyhow::{anyhow, Result};\nuse cosmwasm_std::{\n    BankMsg, Coin, DepsMut, Env, MessageInfo, Response, StdResult, Storage, Uint128,\n};\nuse cw20::Cw20ExecuteMsg;\nuse cw20_base::allowances::execute_burn_from;\nuse cw20_base::contract::execute_burn;\nuse cw20_base::state::{BALANCES, TOKEN_INFO};\nuse cw_4626::state::{AssetInfo, State, STATE};\nuse utils::msg::into_cosmos_msg;\n\nuse crate::query::{convert_to_assets, convert_to_shares};\n\npub fn deposit(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    receiver: String,\n    deposit_amount: Uint128,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let state = STATE.load(deps.storage)?;\n\n    // Cannot deposit 0 amount\n    if deposit_amount == Uint128::zero() {\n        return Err(ContractError::ZeroDeposit {});\n    };\n    let mint_amount = convert_to_shares(\n        deps.as_ref(),\n        env.clone(),\n        deposit_amount,\n        info.funds.get(0).map(|x| x.amount),\n    )?;\n\n    // We mint new tokens to the receiver, in return for the deposit\n    _execute_mint(deps, receiver.clone(), mint_amount)?;\n\n    // Then we make sure the funds are correctly deposited to the contract\n    let res = Response::new();\n    let res = match state.underlying_asset {\n        AssetInfo::Coin(x) =\u003e {\n            // We need to check if the funds sent match the AssetInfo we have\n            if info.funds.len() != 1 || info.funds[0].denom != x {\n                return Err(ContractError::WrongAssetDeposited {\n                    sent: info.funds[0].denom.clone(),\n                    expected: x,\n                });\n            } else if deposit_amount != info.funds[0].amount {\n                return Err(ContractError::InsufficientAssetDeposited {\n                    sent: info.funds[0].amount,\n                    expected: deposit_amount,\n                });\n            }\n            res\n        }\n        AssetInfo::Cw20(x) =\u003e {\n            // If the vault relies on a CW20, we create a CW20 transferFrom message\n            res.add_message(into_cosmos_msg(\n                Cw20ExecuteMsg::TransferFrom {\n                    owner: info.sender.to_string(),\n                    recipient: env.contract.address.into(),\n                    amount: deposit_amount,\n                },\n                x,\n                None,\n            )?)\n        }\n    };\n\n    Ok(res\n        .add_attribute(\"action\", \"deposit\")\n        .add_attribute(\"caller\", info.sender)\n        .add_attribute(\"owner\", receiver)\n        .add_attribute(\"assets\", deposit_amount.to_string())\n        .add_attribute(\"shares\", mint_amount.to_string()))\n}\n\npub fn mint(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    receiver: String,\n    mint_amount: Uint128,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let state = STATE.load(deps.storage)?;\n\n    // Cannot deposit 0 amount\n    if mint_amount == Uint128::zero() {\n        return Err(ContractError::ZeroDeposit {});\n    }\n\n    // Computing the necessary deposit amount to get that number of shares\n    let deposit_amount = convert_to_assets(\n        deps.as_ref(),\n        env.clone(),\n        mint_amount,\n        info.funds.get(0).map(|x| x.amount),\n    )?;\n\n    // We mint new tokens to the receiver, in return for the deposit\n    _execute_mint(deps, receiver.clone(), mint_amount)?;\n\n    // Then we make sure the funds are correctly deposited to the contract\n    let res = Response::new();\n    let res = match state.underlying_asset {\n        AssetInfo::Coin(x) =\u003e {\n            // We need to check if the funds sent match the AssetInfo we have\n            if info.funds.len() != 1 || info.funds[0].denom != x {\n                return Err(ContractError::WrongAssetDeposited {\n                    sent: info.funds[0].denom.clone(),\n                    expected: x,\n                });\n            } else if deposit_amount \u003e info.funds[0].amount {\n                return Err(ContractError::InsufficientAssetDeposited {\n                    sent: info.funds[0].amount,\n                    expected: deposit_amount,\n                });\n            }\n            let cashback_amount = info.funds[0].amount - deposit_amount;\n            if cashback_amount \u003e Uint128::zero() {\n                res.add_message(BankMsg::Send {\n                    to_address: receiver.clone(),\n                    amount: vec![Coin {\n                        denom: info.funds[0].denom.clone(),\n                        amount: cashback_amount,\n                    }],\n                })\n            } else {\n                res\n            }\n        }\n        AssetInfo::Cw20(x) =\u003e {\n            // If the vault relies on a CW20, we create a CW20 transferFrom message\n            res.add_message(into_cosmos_msg(\n                Cw20ExecuteMsg::TransferFrom {\n                    owner: info.sender.to_string(),\n                    recipient: env.contract.address.into(),\n                    amount: deposit_amount,\n                },\n                x,\n                None,\n            )?)\n        }\n    };\n\n    Ok(res\n        .add_attribute(\"action\", \"mint\")\n        .add_attribute(\"caller\", info.sender)\n        .add_attribute(\"owner\", receiver)\n        .add_attribute(\"assets\", deposit_amount.to_string())\n        .add_attribute(\"shares\", mint_amount.to_string()))\n}\n\npub fn _add_asset_transfer_message(\n    state: \u0026State,\n    res: Response,\n    receiver: String,\n    assets: Uint128,\n) -\u003e Result\u003cResponse\u003e {\n    Ok(match state.underlying_asset.clone() {\n        AssetInfo::Coin(x) =\u003e res.add_message(BankMsg::Send {\n            to_address: receiver,\n            amount: vec![Coin {\n                denom: x,\n                amount: assets,\n            }],\n        }),\n        AssetInfo::Cw20(x) =\u003e {\n            // If the vault relies on a CW20, we create a CW20 transferFrom message\n            res.add_message(into_cosmos_msg(\n                Cw20ExecuteMsg::Transfer {\n                    recipient: receiver,\n                    amount: assets,\n                },\n                x,\n                None,\n            )?)\n        }\n    })\n}\n\npub fn withdraw(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    owner: String,\n    receiver: String,\n    assets: Uint128,\n) -\u003e Result\u003cResponse\u003e {\n    let state = STATE.load(deps.storage)?;\n    // Cannot withdraw 0 assets\n    if assets == Uint128::zero() {\n        return Err(anyhow::anyhow!(ContractError::ZeroDeposit {}));\n    }\n\n    let shares_needed = convert_to_shares(deps.as_ref(), env.clone(), assets, None)?;\n\n    // We burn shares_needed token from the owner balance in the info.sender's name\n    if info.sender == deps.api.addr_validate(\u0026owner)? {\n        execute_burn(deps, env, info.clone(), shares_needed)\n    } else {\n        execute_burn_from(deps, env, info.clone(), owner.clone(), shares_needed)\n    }?;\n\n    // We transfer the underlying asset to the receiver\n    let res = _add_asset_transfer_message(\u0026state, Response::new(), receiver.clone(), assets)?;\n    Ok(res\n        .add_attribute(\"action\", \"withdraw\")\n        .add_attribute(\"caller\", info.sender)\n        .add_attribute(\"receiver\", receiver)\n        .add_attribute(\"owner\", owner)\n        .add_attribute(\"assets\", assets)\n        .add_attribute(\"shares\", shares_needed))\n}\n\npub fn redeem(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    owner: String,\n    receiver: String,\n    shares: Uint128,\n) -\u003e Result\u003cResponse\u003e {\n    let state = STATE.load(deps.storage)?;\n\n    // Cannot withdraw 0 assets\n    if shares == Uint128::zero() {\n        return Err(anyhow::anyhow!(ContractError::ZeroDeposit {}));\n    }\n\n    let assets_needed = convert_to_shares(deps.as_ref(), env.clone(), shares, None)?;\n\n    // We burn shares_needed token from the owner balance in the info.sender's name\n    if info.sender == deps.api.addr_validate(\u0026owner)? {\n        execute_burn(deps, env, info.clone(), shares)\n    } else {\n        execute_burn_from(deps, env, info.clone(), owner.clone(), shares)\n    }?;\n\n    // We transfer the underlying asset to the reciever\n    let res =\n        _add_asset_transfer_message(\u0026state, Response::new(), receiver.clone(), assets_needed)?;\n    Ok(res\n        .add_attribute(\"action\", \"redeem\")\n        .add_attribute(\"caller\", info.sender)\n        .add_attribute(\"receiver\", receiver)\n        .add_attribute(\"owner\", owner)\n        .add_attribute(\"assets\", assets_needed.to_string())\n        .add_attribute(\"shares\", shares))\n}\n\n/// Mint new tokens without checks (eveyone can mint)\npub fn _execute_mint(\n    deps: DepsMut,\n    recipient: String,\n    amount: Uint128,\n) -\u003e Result\u003c(), ContractError\u003e {\n    if amount == Uint128::zero() {\n        return Err(ContractError::InvalidZeroAmount {});\n    }\n\n    let mut config = TOKEN_INFO.load(deps.storage)?;\n\n    // update supply and enforce cap\n    config.total_supply += amount;\n    if let Some(limit) = config.get_cap() {\n        if config.total_supply \u003e limit {\n            return Err(ContractError::CannotExceedCap {});\n        }\n    }\n    TOKEN_INFO.save(deps.storage, \u0026config)?;\n\n    // add amount to recipient balance\n    let rcpt_addr = deps.api.addr_validate(\u0026recipient)?;\n    BALANCES.update(\n        deps.storage,\n        \u0026rcpt_addr,\n        |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e { Ok(balance.unwrap_or_default() + amount) },\n    )?;\n\n    Ok(())\n}\n\n// Borrow mecanism\n/// Withdraw some underlying asset, with no repercussion.\n/// A configuration error could lead to draining of assets\npub fn borrow(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    receiver: String,\n    assets: Uint128,\n) -\u003e Result\u003cResponse\u003e {\n    let mut state = STATE.load(deps.storage)?;\n    // Only the authorized address can borrow assets (this usually is a contract address)\n    if state.borrower.is_none() || info.sender != state.borrower.clone().unwrap() {\n        return Err(anyhow::anyhow!(ContractError::Unauthorized {}));\n    }\n\n    // We update the internal state of the contract, more assets were borrowed\n    state.total_assets_borrowed += assets;\n    STATE.save(deps.storage, \u0026state)?;\n\n    let res = _add_asset_transfer_message(\u0026state, Response::new(), receiver.clone(), assets)?;\n\n    // We send the funds to the receiver\n    Ok(res\n        .add_attribute(\"action\", \"borrower\")\n        .add_attribute(\"caller\", info.sender)\n        .add_attribute(\"receiver\", receiver)\n        .add_attribute(\"assets\", assets.to_string()))\n}\n\n// Borrow mecanism\n/// Repay funds to lower the amount of debt of the contract\n/// If more funds than the current debt are sent via this mecanism, assets are deposited in the vault but no extra tokens are minted\npub fn repay(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    owner: Option\u003cString\u003e,\n    assets: Uint128,\n) -\u003e Result\u003cResponse\u003e {\n    let debt_repaid = _repay(deps.storage, assets)?;\n    let state = STATE.load(deps.storage)?;\n\n    // Then we make sure the funds are correctly deposited to the contract\n    let res = Response::new();\n    let res = match state.underlying_asset {\n        AssetInfo::Coin(x) =\u003e {\n            // We need to check if the funds sent match the AssetInfo we have\n            if info.funds.len() != 1 || info.funds[0].denom != x {\n                return Err(anyhow!(ContractError::WrongAssetDeposited {\n                    sent: info.funds[0].denom.clone(),\n                    expected: x,\n                }));\n            } else if assets != info.funds[0].amount {\n                return Err(anyhow!(ContractError::InsufficientAssetDeposited {\n                    sent: info.funds[0].amount,\n                    expected: assets,\n                }));\n            }\n            res\n        }\n        AssetInfo::Cw20(x) =\u003e {\n            // If the vault relies on a CW20, we create a CW20 transferFrom message\n            res.add_message(into_cosmos_msg(\n                Cw20ExecuteMsg::TransferFrom {\n                    owner: owner.unwrap_or_else(|| info.sender.to_string()),\n                    recipient: env.contract.address.into(),\n                    amount: assets,\n                },\n                x,\n                None,\n            )?)\n        }\n    };\n\n    Ok(res\n        .add_attribute(\"action\", \"repay\")\n        .add_attribute(\"caller\", info.sender)\n        .add_attribute(\"assets\", assets.to_string())\n        .add_attribute(\"debt_repaid\", debt_repaid.to_string())\n        .add_attribute(\"raw_deposit\", (assets - debt_repaid).to_string()))\n}\n\npub fn _repay(storage: \u0026mut dyn Storage, assets: Uint128) -\u003e Result\u003cUint128\u003e {\n    let mut state = STATE.load(storage)?;\n\n    // Cannot deposit 0 amount\n    if assets == Uint128::zero() {\n        return Err(anyhow!(ContractError::ZeroDeposit {}));\n    };\n    // Then we update the total debt\n    // If the current debt is higher than the repay amount, we repay some of the debt with the deposit\n    // Else we repay all the debt and simply deposit the rest in the contract without minting new vault tokens\n    let debt_repaid = if state.total_assets_borrowed \u003e assets {\n        state.total_assets_borrowed -= assets;\n        assets\n    } else {\n        state.total_assets_borrowed = Uint128::zero();\n        state.total_assets_borrowed\n    };\n    STATE.save(storage, \u0026state)?;\n    Ok(debt_repaid)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","ailiq_token","src","msg.rs"],"content":"use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\npub use cw20::Cw20ExecuteMsg as ExecuteMsg;\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    /// Returns the current balance of the given address, 0 if unset.\n    /// Return type: BalanceResponse.\n    Balance { address: String },\n    /// Returns metadata on the contract - name, decimals, supply, etc.\n    /// Return type: TokenInfoResponse.\n    TokenInfo {},\n    /// Only with \"mintable\" extension.\n    /// Returns who can mint and the hard cap on maximum tokens after minting.\n    /// Return type: MinterResponse.\n    Minter {},\n    /// Only with \"allowance\" extension.\n    /// Returns how much spender can use from owner account, 0 if unset.\n    /// Return type: AllowanceResponse.\n    Allowance { owner: String, spender: String },\n    /// Only with \"enumerable\" extension (and \"allowances\")\n    /// Returns all allowances this owner has approved. Supports pagination.\n    /// Return type: AllAllowancesResponse.\n    AllAllowances {\n        owner: String,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    },\n    /// Only with \"enumerable\" extension\n    /// Returns all accounts that have balances. Supports pagination.\n    /// Return type: AllAccountsResponse.\n    AllAccounts {\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    },\n    /// Only with \"marketing\" extension\n    /// Returns more metadata on the contract to display in the client:\n    /// - description, logo, project url, etc.\n    /// Return type: MarketingInfoResponse\n    MarketingInfo {},\n    /// Only with \"marketing\" extension\n    /// Downloads the mbeded logo data (if stored on chain). Errors if no logo data ftored for this\n    /// contract.\n    /// Return type: DownloadLogoResponse.\n    DownloadLogo {},\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","ailiq_token","src","query.rs"],"content":"#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::{Deps, Env, StdResult, Uint128};\nuse cw20_base::state::{TokenInfo, TOKEN_INFO};\n\nuse bignumber::{Decimal256, Uint256};\nuse cw_4626::state::{query_asset_balance, query_asset_liabilities, AssetInfo, STATE};\n\nuse cw20_base::contract::query_balance;\npub fn query_asset(deps: Deps) -\u003e StdResult\u003cAssetInfo\u003e {\n    let state = STATE.load(deps.storage)?;\n    Ok(state.underlying_asset)\n}\n\npub fn query_total_assets(deps: Deps) -\u003e StdResult\u003cUint128\u003e {\n    let state = STATE.load(deps.storage)?;\n    Ok(state.total_underlying_asset_supply)\n}\n\npub fn compute_exchange_rate(\n    deps: Deps,\n    env: Env,\n    token_info: \u0026TokenInfo,\n    deposit_amount: Option\u003cUint128\u003e,\n) -\u003e StdResult\u003cDecimal256\u003e {\n    let share_supply = token_info.total_supply;\n    if share_supply.is_zero() {\n        return Ok(Decimal256::one());\n    }\n\n    let asset_balance =\n        query_asset_balance(deps, env.clone())? - deposit_amount.unwrap_or_else(Uint128::zero);\n    let liabilities = query_asset_liabilities(deps, env)?;\n    let total_assets =\n        Decimal256::from_uint256(Uint256::from((asset_balance + liabilities).u128()));\n    Ok(total_assets / Decimal256::from_uint256(Uint256::from(share_supply.u128())))\n}\n\npub fn convert_to_shares(\n    deps: Deps,\n    env: Env,\n    assets: Uint128,\n    deposit_amount: Option\u003cUint128\u003e,\n) -\u003e StdResult\u003cUint128\u003e {\n    let token_info = TOKEN_INFO.load(deps.storage)?;\n\n    let exchange_rate = compute_exchange_rate(deps, env, \u0026token_info, deposit_amount)?;\n    Ok((Uint256::from(assets.u128()) / exchange_rate).into())\n}\n\npub fn convert_to_assets(\n    deps: Deps,\n    env: Env,\n    shares: Uint128,\n    deposit_amount: Option\u003cUint128\u003e,\n) -\u003e StdResult\u003cUint128\u003e {\n    let token_info = TOKEN_INFO.load(deps.storage)?;\n    let exchange_rate = compute_exchange_rate(deps, env, \u0026token_info, deposit_amount)?;\n    Ok((Uint256::from(shares) * exchange_rate).into())\n}\npub fn preview_deposit(deps: Deps, env: Env, assets: Uint128) -\u003e StdResult\u003cUint128\u003e {\n    convert_to_shares(deps, env, assets, None)\n}\n\npub fn preview_mint(deps: Deps, env: Env, shares: Uint128) -\u003e StdResult\u003cUint128\u003e {\n    convert_to_assets(deps, env, shares, None)\n}\n\npub fn preview_withdraw(deps: Deps, env: Env, assets: Uint128) -\u003e StdResult\u003cUint128\u003e {\n    convert_to_shares(deps, env, assets, None)\n}\n\npub fn preview_redeem(deps: Deps, env: Env, shares: Uint128) -\u003e StdResult\u003cUint128\u003e {\n    convert_to_assets(deps, env, shares, None)\n}\n\npub fn max_deposit(_deps: Deps, _env: Env, _receiver: String) -\u003e StdResult\u003cUint128\u003e {\n    Ok(Uint128::MAX)\n}\n\npub fn max_mint(_deps: Deps, _env: Env, _receiver: String) -\u003e StdResult\u003cUint256\u003e {\n    Ok(Uint256::from(Uint128::MAX))\n}\n\npub fn max_withdraw(deps: Deps, env: Env, owner: String) -\u003e StdResult\u003cUint128\u003e {\n    convert_to_shares(deps, env.clone(), max_redeem(deps, env, owner)?, None)\n}\n\npub fn max_redeem(deps: Deps, _env: Env, owner: String) -\u003e StdResult\u003cUint128\u003e {\n    Ok(query_balance(deps, owner)?.balance)\n}\n\n#[cfg(test)]\npub mod tests {\n    use super::*;\n    use crate::contract::instantiate;\n    use cosmwasm_std::testing::{mock_dependencies, mock_env, mock_info};\n    use cosmwasm_std::DepsMut;\n    use cw_4626::msg::InstantiateMsg;\n    fn init_helper(deps: DepsMut) {\n        let instantiate_msg = InstantiateMsg {\n            name: \"Iliq treasury token\".to_string(),\n            symbol: \"ailiq\".to_string(),\n            decimals: 6u8,\n            initial_balances: vec![],\n            mint: None,\n            marketing: None,\n            asset: AssetInfo::Coin(\"uluna\".to_string()),\n            borrower: Some(\"borrower\".to_string()),\n        };\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n\n        instantiate(deps, env, info, instantiate_msg).unwrap();\n    }\n\n    #[test]\n    fn test_convert_sanity() {\n        let mut deps = mock_dependencies();\n        let env = mock_env();\n        init_helper(deps.as_mut());\n        let initial_assets = Uint128::from(6764562356574737676u128);\n        let shares = convert_to_shares(deps.as_ref(), env.clone(), initial_assets, None).unwrap();\n\n        let final_assets = convert_to_assets(deps.as_ref(), env, shares, None).unwrap();\n\n        assert_eq!(initial_assets, final_assets);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","fee_contract","examples","fee_schema.rs"],"content":"use std::env::current_dir;\nuse std::fs::create_dir_all;\n\nuse cosmwasm_schema::{export_schema, remove_schemas, schema_for};\n\nuse fee_contract_export::msg::{ExecuteMsg, InstantiateMsg, QueryMsg};\n\nfn main() {\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"schema\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n\n    export_schema(\u0026schema_for!(InstantiateMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(ExecuteMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(QueryMsg), \u0026out_dir);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","fee_contract","src","contract.rs"],"content":"#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::{\n    entry_point, to_binary, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdError, StdResult,\n    Uint128,\n};\n\nuse fee_contract_export::error::ContractError;\nuse fee_contract_export::msg::{ExecuteMsg, FeeResponse, InstantiateMsg, MigrateMsg, QueryMsg};\nuse fee_contract_export::state::{ContractInfo, FeeInfo};\n\nuse p2p_trading_export::query::{load_trade, load_trade_and_accepted_counter_trade};\n\nuse crate::state::{is_admin, CONTRACT_INFO, FEE_RATES};\nuse fee_distributor_export::msg::ExecuteMsg as FeeDistributorMsg;\nuse p2p_trading_export::msg::ExecuteMsg as P2PExecuteMsg;\nuse p2p_trading_export::state::AssetInfo;\nuse utils::msg::into_cosmos_msg;\n\nconst ASSET_FEE_RATE: u128 = 40u128; // In thousands\nconst FEE_MAX: u128 = 10_000_000u128;\nconst FIRST_TEER_RATE: u128 = 500_000u128;\nconst FIRST_TEER_LIMIT: u128 = 4u128;\nconst SECOND_TEER_RATE: u128 = 200_000u128;\nconst SECOND_TEER_LIMIT: u128 = 14u128;\nconst THIRD_TEER_RATE: u128 = 50_000u128;\nconst ACCEPTABLE_FEE_DEVIATION: u128 = 50u128; // In thousands\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // Verify the contract name\n    msg.validate()?;\n    // store token info\n    let data = ContractInfo {\n        name: msg.name,\n        owner: msg\n            .owner\n            .map(|x| deps.api.addr_validate(\u0026x))\n            .unwrap_or(Ok(info.sender))?,\n        p2p_contract: deps.api.addr_validate(\u0026msg.p2p_contract)?,\n        fee_distributor: deps.api.addr_validate(\u0026msg.fee_distributor)?,\n    };\n    CONTRACT_INFO.save(deps.storage, \u0026data)?;\n    // Initialisation with fixed rates\n    FEE_RATES.save(\n        deps.storage,\n        \u0026FeeInfo {\n            asset_fee_rate: Uint128::from(ASSET_FEE_RATE), // In thousandths\n            fee_max: Uint128::from(FEE_MAX),               // In uusd\n            first_teer_limit: Uint128::from(FIRST_TEER_LIMIT),\n            first_teer_rate: Uint128::from(FIRST_TEER_RATE),\n            second_teer_limit: Uint128::from(SECOND_TEER_LIMIT),\n            second_teer_rate: Uint128::from(SECOND_TEER_RATE),\n            third_teer_rate: Uint128::from(THIRD_TEER_RATE),\n            acceptable_fee_deviation: Uint128::from(ACCEPTABLE_FEE_DEVIATION),\n        },\n    )?;\n    Ok(Response::default().add_attribute(\"fee_contract\", \"init\"))\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    match msg {\n        ExecuteMsg::PayFeeAndWithdraw { trade_id } =\u003e {\n            pay_fee_and_withdraw(deps, env, info, trade_id)\n        }\n        ExecuteMsg::UpdateFeeRates {\n            asset_fee_rate,\n            fee_max,\n            first_teer_limit,\n            first_teer_rate,\n            second_teer_limit,\n            second_teer_rate,\n            third_teer_rate,\n            acceptable_fee_deviation,\n        } =\u003e update_fee_rates(\n            deps,\n            env,\n            info,\n            asset_fee_rate,\n            fee_max,\n            first_teer_limit,\n            first_teer_rate,\n            second_teer_limit,\n            second_teer_rate,\n            third_teer_rate,\n            acceptable_fee_deviation,\n        ),\n    }\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn migrate(_deps: DepsMut, _env: Env, _msg: MigrateMsg) -\u003e Result\u003cResponse, ContractError\u003e {\n    // No state migrations performed, just returned a Response\n    Ok(Response::default())\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -\u003e Result\u003cBinary, ContractError\u003e {\n    match msg {\n        QueryMsg::ContractInfo {} =\u003e {\n            to_binary(\u0026contract_info(deps)?).map_err(|_| ContractError::BinaryEncodingError {})\n        }\n        QueryMsg::FeeRates {} =\u003e {\n            to_binary(\u0026fee_rates(deps)?).map_err(|_| ContractError::BinaryEncodingError {})\n        }\n        QueryMsg::Fee {\n            trade_id,\n            counter_id,\n        } =\u003e to_binary(\u0026query_fee_for(deps, trade_id, counter_id)?)\n            .map_err(|_| ContractError::BinaryEncodingError {}),\n        QueryMsg::SimulateFee {\n            trade_id,\n            counter_assets,\n        } =\u003e to_binary(\u0026simulate_fee(deps, trade_id, counter_assets)?)\n            .map_err(|_| ContractError::BinaryEncodingError {}),\n    }\n}\n\n/// This function is used to withdraw funds from an accepted trade.\n/// It uses information from the trades and counter trades to determine how much needs to be paid\n/// If the fee is sufficient, it sends the fee to the fee_depositor contract (responsible for fee distribution)\npub fn pay_fee_and_withdraw(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    trade_id: u64,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // The fee can be paid in any Terra native currency.\n    // It needs to be paid in a single currency\n    if info.funds.len() != 1 {\n        return Err(ContractError::FeeNotPaid {});\n    }\n\n    let funds = info.funds[0].clone();\n    let contract_info = CONTRACT_INFO.load(deps.storage)?;\n    let (trade_info, counter_info) = load_trade_and_accepted_counter_trade(\n        deps.as_ref(),\n        contract_info.p2p_contract.clone(),\n        trade_id,\n        None,\n    )?;\n    // Querying the required fee amount in \"uusd\"\n    let fee_amount = fee_amount_raw(\n        deps.as_ref(),\n        \u0026trade_info.associated_assets,\n        \u0026counter_info.associated_assets,\n    )?;\n    // We accept a small fee deviation, in case the exchange rates fluctuate a bit between the query and the paiement.\n    let acceptable_fee_deviation = FEE_RATES.load(deps.storage)?.acceptable_fee_deviation;\n\n    if funds.denom == \"uluna\" {\n        if funds.amount + funds.amount * acceptable_fee_deviation / Uint128::from(1_000u128)\n            \u003c fee_amount\n        {\n            return Err(ContractError::FeeNotPaidCorrectly {\n                required: fee_amount.u128(),\n                provided: funds.amount.u128(),\n            });\n        }\n    } else {\n        return Err(ContractError::FeeNotPaid {});\n    }\n\n    // Then we distribute the funds to the fee_distributor contract\n    let contract_addresses: Vec\u003cString\u003e = trade_info\n        .associated_assets\n        .iter()\n        .chain(counter_info.associated_assets.iter())\n        .filter_map(|x| match x {\n            AssetInfo::Cw721Coin(cw721) =\u003e Some(cw721.address.clone()),\n            AssetInfo::Cw1155Coin(cw1155) =\u003e Some(cw1155.address.clone()),\n            _ =\u003e None,\n        })\n        .collect();\n    let distribute_message = into_cosmos_msg(\n        FeeDistributorMsg::DepositFees {\n            addresses: contract_addresses,\n        },\n        contract_info.fee_distributor,\n        Some(info.funds),\n    )?;\n\n    // Then we call withdraw on the p2p contract\n    let withdraw_message = P2PExecuteMsg::WithdrawPendingAssets {\n        trader: info.sender.into(),\n        trade_id,\n    };\n    let message = into_cosmos_msg(withdraw_message, contract_info.p2p_contract, None)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"payed_trade_fee\")\n        .add_message(message)\n        .add_message(distribute_message))\n}\n\npub fn modify_contract_owner(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    owner: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    is_admin(deps.as_ref(), info.sender)?;\n\n    let owner_addr = deps.api.addr_validate(\u0026owner)?;\n    CONTRACT_INFO.update::\u003c_, StdError\u003e(deps.storage, |mut x| {\n        x.owner = owner_addr;\n        Ok(x)\n    })?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"parameter_update\")\n        .add_attribute(\"parameter\", \"owner\"))\n}\n\n#[allow(clippy::too_many_arguments)]\npub fn update_fee_rates(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    asset_fee_rate: Option\u003cUint128\u003e,\n    fee_max: Option\u003cUint128\u003e,\n    first_teer_limit: Option\u003cUint128\u003e,\n    first_teer_rate: Option\u003cUint128\u003e,\n    second_teer_limit: Option\u003cUint128\u003e,\n    second_teer_rate: Option\u003cUint128\u003e,\n    third_teer_rate: Option\u003cUint128\u003e,\n    acceptable_fee_deviation: Option\u003cUint128\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    is_admin(deps.as_ref(), info.sender)?;\n\n    FEE_RATES.update::\u003c_, StdError\u003e(deps.storage, |x| {\n        Ok(FeeInfo {\n            asset_fee_rate: asset_fee_rate.unwrap_or(x.asset_fee_rate),\n            fee_max: fee_max.unwrap_or(x.fee_max),\n            first_teer_limit: first_teer_limit.unwrap_or(x.first_teer_limit),\n            first_teer_rate: first_teer_rate.unwrap_or(x.first_teer_rate),\n            second_teer_limit: second_teer_limit.unwrap_or(x.second_teer_limit),\n            second_teer_rate: second_teer_rate.unwrap_or(x.second_teer_rate),\n            third_teer_rate: third_teer_rate.unwrap_or(x.third_teer_rate),\n            acceptable_fee_deviation: acceptable_fee_deviation\n                .unwrap_or(x.acceptable_fee_deviation),\n        })\n    })?;\n\n    // We verify the rates are ordered\n    let new_fee_rates = FEE_RATES.load(deps.storage)?;\n    if new_fee_rates.second_teer_limit \u003c= new_fee_rates.first_teer_limit {\n        return Err(ContractError::TeersNotOrdered {});\n    }\n\n    Ok(Response::new().add_attribute(\"updated\", \"fee_rates\"))\n}\n\n/// Compute the fee amount for trade and counter_trade assets\n/// This function contains 2 parts\n/// 1. Compute a fee relative to the number of tokens exchanged in the transaction (cw20, cw721 and cw1155)\n/// 2. Compute a percentage fee amount for all terra native funds\npub fn fee_amount_raw(\n    deps: Deps,\n    trade_assets: \u0026[AssetInfo],\n    counter_assets: \u0026[AssetInfo],\n) -\u003e Result\u003cUint128, ContractError\u003e {\n    let fee_info = FEE_RATES.load(deps.storage)?;\n\n    // Accumulate results to compute\n    // 1. The percentage fee for terra native tokens\n    // 2. The number of exchanged tokens in the transaction\n    let (fund_fee, asset_number) = trade_assets.iter().chain(counter_assets.iter()).try_fold(\n        (Uint128::zero(), Uint128::zero()),\n        |(fund_fee, asset_number), x| -\u003e Result\u003c(Uint128, Uint128), ContractError\u003e {\n            match x {\n                AssetInfo::Coin(coin) =\u003e {\n                    if coin.denom != \"uluna\" {\n                        return Err(ContractError::FeeNotPaid {});\n                    }\n\n                    let fee = coin.amount * fee_info.asset_fee_rate / Uint128::from(1_000u128);\n                    Ok((fund_fee + fee, asset_number))\n                }\n                _ =\u003e Ok((fund_fee, asset_number + Uint128::from(1u128))),\n            }\n        },\n    )?;\n\n    // We compute the fee dependant on the number of exchanged tokens (in teers, just like taxes)\n    let fee = fee_info.first_teer_rate * asset_number.min(fee_info.first_teer_limit)\n        + fee_info.second_teer_rate\n            * (asset_number\n                .min(fee_info.second_teer_limit)\n                .max(fee_info.first_teer_limit)\n                - fee_info.first_teer_limit)\n        + fee_info.third_teer_rate\n            * (asset_number.max(fee_info.second_teer_limit) - fee_info.second_teer_limit)\n                .min(fee_info.fee_max);\n\n    Ok((fee + fund_fee) / Uint128::from(2u128))\n}\n\npub fn contract_info(deps: Deps) -\u003e StdResult\u003cContractInfo\u003e {\n    CONTRACT_INFO.load(deps.storage)\n}\n\npub fn fee_rates(deps: Deps) -\u003e StdResult\u003cFeeInfo\u003e {\n    FEE_RATES.load(deps.storage)\n}\n\n/// Allows to simulate the fee that will need to be paid when withdrawing assets\n/// If `counter_id` is not specified, the accepted counter_trade will be considered for computing the fee\n/// If it is specified, the counter_id provided will be considered\npub fn query_fee_for(\n    deps: Deps,\n    trade_id: u64,\n    counter_id: Option\u003cu64\u003e,\n) -\u003e Result\u003cFeeResponse, ContractError\u003e {\n    let contract_info = CONTRACT_INFO.load(deps.storage)?;\n\n    let (trade_info, counter_info) = load_trade_and_accepted_counter_trade(\n        deps,\n        contract_info.p2p_contract,\n        trade_id,\n        counter_id,\n    )?;\n    let fee = fee_amount_raw(\n        deps,\n        \u0026trade_info.associated_assets,\n        \u0026counter_info.associated_assets,\n    )?;\n\n    Ok(FeeResponse { fee })\n}\n\n/// Allows to simulate the fee that will need to be paid if the submitted assets are those of the accepted counter trade\npub fn simulate_fee(\n    deps: Deps,\n    trade_id: u64,\n    counter_assets: Vec\u003cAssetInfo\u003e,\n) -\u003e Result\u003cFeeResponse, ContractError\u003e {\n    let contract_info = CONTRACT_INFO.load(deps.storage)?;\n\n    let trade_info = load_trade(deps, contract_info.p2p_contract, trade_id)?;\n    let fee = fee_amount_raw(deps, \u0026trade_info.associated_assets, \u0026counter_assets)?;\n\n    Ok(FeeResponse { fee })\n}\n\n#[cfg(test)]\npub mod tests {\n    use super::*;\n    use cosmwasm_std::testing::{mock_dependencies, mock_env, mock_info};\n    use p2p_trading_export::state::Cw20Coin;\n    //use cosmwasm_std::{coins, Coin, SubMsg};\n\n    fn init_helper(deps: DepsMut) -\u003e Response {\n        let instantiate_msg = InstantiateMsg {\n            name: \"fee_contract\".to_string(),\n            owner: None,\n            p2p_contract: \"p2p\".to_string(),\n            fee_distributor: \"treasury\".to_string(),\n        };\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n\n        instantiate(deps, env, info, instantiate_msg).unwrap()\n    }\n\n    #[test]\n    fn test_init_sanity() {\n        let mut deps = mock_dependencies();\n        let res = init_helper(deps.as_mut());\n        assert_eq!(0, res.messages.len());\n    }\n\n    #[test]\n    fn test_update_fee_rates() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n        execute(\n            deps.as_mut(),\n            env,\n            info,\n            ExecuteMsg::UpdateFeeRates {\n                asset_fee_rate: Some(Uint128::from(5u128)), // In thousandths\n                fee_max: Some(Uint128::from(6u128)),        // In uusd\n                first_teer_limit: Some(Uint128::from(7u128)),\n                first_teer_rate: Some(Uint128::from(8u128)),\n                second_teer_limit: Some(Uint128::from(9u128)),\n                second_teer_rate: Some(Uint128::from(10u128)),\n                third_teer_rate: Some(Uint128::from(11u128)),\n                acceptable_fee_deviation: Some(Uint128::from(12u128)),\n            },\n        )\n        .unwrap();\n\n        let fee_rate = FEE_RATES.load(\u0026deps.storage).unwrap();\n        assert_eq!(\n            fee_rate,\n            FeeInfo {\n                asset_fee_rate: Uint128::from(5u128), // In thousandths\n                fee_max: Uint128::from(6u128),        // In uusd\n                first_teer_limit: Uint128::from(7u128),\n                first_teer_rate: Uint128::from(8u128),\n                second_teer_limit: Uint128::from(9u128),\n                second_teer_rate: Uint128::from(10u128),\n                third_teer_rate: Uint128::from(11u128),\n                acceptable_fee_deviation: Uint128::from(12u128),\n            }\n        );\n    }\n\n    #[test]\n    fn test_fee_amount() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n\n        let fee = fee_amount_raw(deps.as_ref(), \u0026[], \u0026[]).unwrap();\n        assert_eq!(fee, Uint128::zero());\n\n        let fee = fee_amount_raw(\n            deps.as_ref(),\n            \u0026[AssetInfo::Cw20Coin(Cw20Coin {\n                amount: Uint128::from(42u64),\n                address: \"token\".to_string(),\n            })],\n            \u0026[],\n        )\n        .unwrap();\n        assert_eq!(fee, Uint128::new(250_000u128));\n\n        let fee = fee_amount_raw(\n            deps.as_ref(),\n            \u0026[AssetInfo::Cw20Coin(Cw20Coin {\n                amount: Uint128::from(42u64),\n                address: \"token\".to_string(),\n            })],\n            \u0026[AssetInfo::Cw20Coin(Cw20Coin {\n                amount: Uint128::from(42u64),\n                address: \"token\".to_string(),\n            })],\n        )\n        .unwrap();\n        assert_eq!(fee, Uint128::new(500_000u128));\n\n        let fee = fee_amount_raw(\n            deps.as_ref(),\n            \u0026[\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    amount: Uint128::from(42u64),\n                    address: \"token\".to_string(),\n                }),\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    amount: Uint128::from(42u64),\n                    address: \"token\".to_string(),\n                }),\n            ],\n            \u0026[],\n        )\n        .unwrap();\n        assert_eq!(fee, Uint128::new(500_000u128));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","fee_contract","src","lib.rs"],"content":"pub mod contract;\npub mod state;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","fee_contract","src","state.rs"],"content":"use cosmwasm_std::{Addr, Deps};\nuse cw_storage_plus::Item;\nuse fee_contract_export::error::ContractError;\nuse fee_contract_export::state::{ContractInfo, FeeInfo};\n\npub const CONTRACT_INFO: Item\u003cContractInfo\u003e = Item::new(\"contract_info\");\npub const FEE_RATES: Item\u003cFeeInfo\u003e = Item::new(\"fee_rates\");\n\npub fn is_admin(deps: Deps, addr: Addr) -\u003e Result\u003c(), ContractError\u003e {\n    if CONTRACT_INFO.load(deps.storage)?.owner == addr {\n        Ok(())\n    } else {\n        Err(ContractError::Unauthorized {})\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","fee_distributor","examples","fee_distributor_schema.rs"],"content":"use std::env::current_dir;\nuse std::fs::create_dir_all;\n\nuse cosmwasm_schema::{export_schema, remove_schemas, schema_for};\n\nuse fee_distributor_export::msg::{ExecuteMsg, InstantiateMsg, QueryMsg};\n\nfn main() {\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"schema\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n\n    export_schema(\u0026schema_for!(InstantiateMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(ExecuteMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(QueryMsg), \u0026out_dir);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","fee_distributor","src","contract.rs"],"content":"use cosmwasm_std::{\n    coin, coins, entry_point, to_binary, BankMsg, Binary, Coin, Deps, DepsMut, Env, MessageInfo,\n    Order, Response, StdError, StdResult, Uint128,\n};\nuse cw_storage_plus::Bound;\nuse itertools::Itertools;\n#[cfg(not(feature = \"library\"))]\nuse std::convert::TryInto;\nuse utils::state::maybe_addr;\n\nuse fee_distributor_export::msg::{ExecuteMsg, InstantiateMsg, MigrateMsg, QueryMsg};\nuse fee_distributor_export::state::ContractInfo;\n\nuse crate::error::ContractError;\nuse crate::state::{is_admin, ALLOCATED_FUNDS, ASSOCIATED_FEE_ADDRESS, CONTRACT_INFO};\n\nconst PROJECTS_ALLOCATION: u128 = 75u128; // In percent\nconst DEFAULT_LIMIT: u32 = 10u32;\nconst MAX_LIMIT: u32 = 30u32;\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // Verify the contract name\n    msg.validate()?;\n\n    // store contract info\n    let data = ContractInfo {\n        name: msg.name,\n        owner: msg\n            .owner\n            .map(|x| deps.api.addr_validate(\u0026x))\n            .unwrap_or(Ok(info.sender))?,\n        treasury: deps.api.addr_validate(\u0026msg.treasury)?,\n        projects_allocation: Uint128::from(PROJECTS_ALLOCATION),\n    };\n    CONTRACT_INFO.save(deps.storage, \u0026data)?;\n    Ok(Response::default()\n        .add_attribute(\"action\", \"init\")\n        .add_attribute(\"contract_name\", \"fee_distributor\"))\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    match msg {\n        ExecuteMsg::ModifyContractInfo {\n            owner,\n            treasury,\n            projects_allocation,\n        } =\u003e modify_contract_info(deps, env, info, owner, treasury, projects_allocation),\n        ExecuteMsg::AddAssociatedAddress {\n            address,\n            fee_address,\n        } =\u003e add_associated_address(deps, env, info, address, fee_address),\n        ExecuteMsg::DepositFees { addresses } =\u003e deposit_fees(deps, env, info, addresses),\n        ExecuteMsg::WithdrawFees { addresses } =\u003e withdraw_fees(deps, env, info, addresses),\n    }\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn migrate(_deps: DepsMut, _env: Env, _msg: MigrateMsg) -\u003e Result\u003cResponse, ContractError\u003e {\n    // No state migrations performed, just returned a Response\n    Ok(Response::default())\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::ContractInfo {} =\u003e to_binary(\u0026contract_info(deps)?),\n        QueryMsg::Amount { address } =\u003e to_binary(\u0026query_amount(deps, address)?),\n        QueryMsg::Addresses { start_after, limit } =\u003e {\n            to_binary(\u0026query_addresses(deps, start_after, limit)?)\n        }\n    }\n}\n\n/// Modify all contract info using this function\n/// Must be the admin to change the parameters\npub fn modify_contract_info(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    owner: Option\u003cString\u003e,\n    treasury: Option\u003cString\u003e,\n    projects_allocation: Option\u003cUint128\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    is_admin(deps.as_ref(), info.sender)?;\n\n    let mut contract_info = CONTRACT_INFO.load(deps.storage)?;\n    contract_info.owner = maybe_addr(deps.api, owner)?.unwrap_or(contract_info.owner);\n    contract_info.treasury = maybe_addr(deps.api, treasury)?.unwrap_or(contract_info.treasury);\n    contract_info.projects_allocation =\n        projects_allocation.unwrap_or(contract_info.projects_allocation);\n\n    if contract_info.projects_allocation.u128() \u003e 100u128 {\n        return Err(ContractError::AllocationTooHigh {});\n    }\n    CONTRACT_INFO.save(deps.storage, \u0026contract_info)?;\n\n    Ok(Response::new().add_attribute(\"action\", \"parameter_update\"))\n}\n\n/// Add or modify the address associated to a token to withdraw the funds deposited in the contract\npub fn add_associated_address(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    address: String,\n    fee_address: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    is_admin(deps.as_ref(), info.sender)?;\n\n    let valid_address = deps.api.addr_validate(\u0026address)?;\n    let valid_fee_address = deps.api.addr_validate(\u0026fee_address)?;\n    ASSOCIATED_FEE_ADDRESS.save(deps.storage, \u0026valid_address, \u0026valid_fee_address)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"associated_address_update\")\n        .add_attribute(\"address\", address)\n        .add_attribute(\"associated_addreee\", fee_address))\n}\n\n/// Main Function of this contract\n/// Deposit Fees and distribute them according to the addresses provided\npub fn deposit_fees(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    addresses: Vec\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // The deposited funds must be a unique fund type\n    if info.funds.len() != 1 {\n        return Err(ContractError::DepositNotCorrect {});\n    }\n\n    let fund = info.funds[0].clone();\n    let contract_info = CONTRACT_INFO.load(deps.storage)?;\n    let n_addresses: u128 = addresses.len().try_into().unwrap();\n    let each_project_allocation = if n_addresses \u003e 0 {\n        fund.amount * contract_info.projects_allocation\n            / Uint128::from(100u128)\n            / Uint128::from(n_addresses)\n    } else {\n        Uint128::zero()\n    };\n    let treasury_allocation = fund.amount - each_project_allocation * Uint128::from(n_addresses);\n    let each_project_fund = coin(each_project_allocation.u128(), fund.denom.clone());\n    // First we save the fees that just arrived into the contract memory\n    for address in \u0026addresses {\n        let valid_address = deps.api.addr_validate(address)?;\n        ALLOCATED_FUNDS.update::\u003c_, StdError\u003e(deps.storage, \u0026valid_address, |x| {\n            match x {\n                Some(mut funds) =\u003e {\n                    // We check the sent funds are with the right format\n                    let existing_denom = funds.iter_mut().find(|c| c.denom == fund.denom.clone());\n\n                    if let Some(existing_fund) = existing_denom {\n                        *existing_fund = Coin {\n                            denom: fund.denom.clone(),\n                            amount: existing_fund.amount + each_project_fund.amount,\n                        };\n                    } else {\n                        funds.push(each_project_fund.clone());\n                    }\n                    Ok(funds)\n                }\n                None =\u003e Ok(vec![each_project_fund.clone()]),\n            }\n        })?;\n    }\n    // Then we try to distribute the fees from the addresses that were just credited (if they have an associated address)\n    let fee_withdrawal_messages = if !addresses.is_empty() {\n        _withdraw_registered_addresses(deps, env, info, addresses)?\n    } else {\n        vec![]\n    };\n\n    // We send the treasury allocation\n    let treasury_message = BankMsg::Send {\n        to_address: contract_info.treasury.to_string(),\n        amount: coins(treasury_allocation.u128(), fund.denom.clone()),\n    };\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"saved_fee\")\n        .add_attribute(\"action\", \"distributed_fee\")\n        .add_message(treasury_message)\n        .add_messages(fee_withdrawal_messages))\n}\n\n/// Manually triggers withdrawal for the indicated addresses\n/// The fees will be withdrawn only if the indicated addresses have an associated address registered\n/// This function won't error if one or more addresses doesn't have an associated address\npub fn withdraw_fees(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    addresses: Vec\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let messages = _withdraw_registered_addresses(deps, env, info, addresses)?;\n    Ok(Response::new()\n        .add_attribute(\"action\", \"distributed_fee\")\n        .add_messages(messages))\n}\n\n/// Internal function\n/// It withdraws the fees for tokens with associated addresses in the list provided in argument\npub fn _withdraw_registered_addresses(\n    deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    addresses: Vec\u003cString\u003e,\n) -\u003e StdResult\u003cVec\u003cBankMsg\u003e\u003e {\n    let addresses: Vec\u003cString\u003e = addresses.into_iter().unique().collect();\n    let mut messages = vec![];\n    for address in \u0026addresses {\n        let valid_address = deps.api.addr_validate(address)?;\n        let loaded_funds = ALLOCATED_FUNDS.load(deps.storage, \u0026valid_address);\n        let associated_address = ASSOCIATED_FEE_ADDRESS.load(deps.storage, \u0026valid_address);\n        if let (Ok(loaded_funds), Ok(associated_address)) = (loaded_funds, associated_address) {\n            messages.push(BankMsg::Send {\n                to_address: associated_address.to_string(),\n                amount: loaded_funds,\n            });\n            ALLOCATED_FUNDS.save(deps.storage, \u0026valid_address, \u0026vec![])?;\n        }\n    }\n    Ok(messages)\n}\n\npub fn contract_info(deps: Deps) -\u003e StdResult\u003cContractInfo\u003e {\n    CONTRACT_INFO.load(deps.storage)\n}\n\n/// Query the amount of fee deposited in the contract for a given token address (cw721 and cw1155 supposedly)\npub fn query_amount(deps: Deps, address: String) -\u003e StdResult\u003cVec\u003cCoin\u003e\u003e {\n    let address = deps.api.addr_validate(\u0026address)?;\n    ALLOCATED_FUNDS.load(deps.storage, \u0026address).or(Ok(vec![]))\n}\n\npub fn query_addresses(\n    deps: Deps,\n    start_after: Option\u003cString\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e StdResult\u003cVec\u003cString\u003e\u003e {\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n    let addr = maybe_addr(deps.api, start_after)?;\n    let start = addr.as_ref().map(Bound::exclusive);\n\n    ALLOCATED_FUNDS\n        .keys(deps.storage, start, None, Order::Ascending)\n        .take(limit)\n        .map(|x| x.map(|s| s.to_string()))\n        .collect::\u003cResult\u003cVec\u003cString\u003e, StdError\u003e\u003e()\n}\n\n#[cfg(test)]\npub mod tests {\n    use super::*;\n    use cosmwasm_std::{\n        from_binary,\n        testing::{mock_dependencies, mock_env, mock_info},\n        SubMsg,\n    };\n    //use cosmwasm_std::{coins, Coin, SubMsg};\n\n    fn init_helper(deps: DepsMut) -\u003e Response {\n        let instantiate_msg = InstantiateMsg {\n            name: \"fee_contract\".to_string(),\n            owner: None,\n            treasury: \"treasury\".to_string(),\n        };\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n\n        instantiate(deps, env, info, instantiate_msg).unwrap()\n    }\n\n    #[test]\n    fn test_init_sanity() {\n        let mut deps = mock_dependencies();\n        let res = init_helper(deps.as_mut());\n        assert_eq!(0, res.messages.len());\n    }\n\n    #[test]\n    fn test_modify_info() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            ExecuteMsg::ModifyContractInfo {\n                owner: Some(\"memyselfandi\".to_string()),\n                treasury: Some(\"newtreasury\".to_string()),\n                projects_allocation: Some(Uint128::from(34u128)),\n            },\n        )\n        .unwrap();\n\n        let err = execute(\n            deps.as_mut(),\n            env,\n            info,\n            ExecuteMsg::ModifyContractInfo {\n                owner: Some(\"memyselfandi\".to_string()),\n                treasury: Some(\"newtreasury\".to_string()),\n                projects_allocation: Some(Uint128::from(34u128)),\n            },\n        )\n        .unwrap_err();\n        assert_eq!(err, ContractError::Unauthorized {})\n    }\n\n    #[test]\n    fn test_deposit_funds() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n\n        let info = mock_info(\"creator\", \u0026coins(54u128, \"uluna\"));\n        let env = mock_env();\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            ExecuteMsg::DepositFees {\n                addresses: vec![\"test\".to_string()],\n            },\n        )\n        .unwrap();\n        let response = query(\n            deps.as_ref(),\n            env.clone(),\n            QueryMsg::Amount {\n                address: \"test\".to_string(),\n            },\n        )\n        .unwrap();\n        assert_eq!(\n            from_binary::\u003cVec\u003cCoin\u003e\u003e(\u0026response).unwrap(),\n            coins(54u128 * 75u128 / 100u128, \"uluna\")\n        );\n\n        let response = execute(\n            deps.as_mut(),\n            env,\n            info,\n            ExecuteMsg::DepositFees {\n                addresses: vec![\"test\".to_string()],\n            },\n        )\n        .unwrap();\n        assert_eq!(\n            response.messages,\n            vec![SubMsg::new(BankMsg::Send {\n                to_address: \"treasury\".to_string(),\n                amount: coins(54u128 - 54u128 * 75u128 / 100u128, \"uluna\")\n            })]\n        );\n    }\n\n    #[test]\n    fn test_deposit_funds_before_and_after() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n\n        let info = mock_info(\"creator\", \u0026coins(54u128, \"uluna\"));\n        let env = mock_env();\n\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            ExecuteMsg::DepositFees {\n                addresses: vec![\"test\".to_string()],\n            },\n        )\n        .unwrap();\n\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            ExecuteMsg::DepositFees {\n                addresses: vec![\"test\".to_string()],\n            },\n        )\n        .unwrap();\n\n        let response = query(\n            deps.as_ref(),\n            env.clone(),\n            QueryMsg::Amount {\n                address: \"test\".to_string(),\n            },\n        )\n        .unwrap();\n        assert_eq!(\n            from_binary::\u003cVec\u003cCoin\u003e\u003e(\u0026response).unwrap(),\n            coins(\n                54u128 * 75u128 / 100u128 + 54u128 * 75u128 / 100u128,\n                \"uluna\"\n            )\n        );\n\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            ExecuteMsg::AddAssociatedAddress {\n                address: \"test\".to_string(),\n                fee_address: \"fee\".to_string(),\n            },\n        )\n        .unwrap();\n\n        let response = execute(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            ExecuteMsg::DepositFees {\n                addresses: vec![\"test\".to_string()],\n            },\n        )\n        .unwrap();\n\n        assert_eq!(\n            response.messages,\n            vec![\n                SubMsg::new(BankMsg::Send {\n                    to_address: \"treasury\".to_string(),\n                    amount: coins(54u128 - 54u128 * 75u128 / 100u128, \"uluna\")\n                }),\n                SubMsg::new(BankMsg::Send {\n                    to_address: \"fee\".to_string(),\n                    amount: coins(54u128 * 75u128 / 100u128 * 3u128, \"uluna\")\n                })\n            ]\n        );\n\n        let response = query(\n            deps.as_ref(),\n            env.clone(),\n            QueryMsg::Amount {\n                address: \"test\".to_string(),\n            },\n        )\n        .unwrap();\n        assert_eq!(from_binary::\u003cVec\u003cCoin\u003e\u003e(\u0026response).unwrap(), vec![]);\n\n        let response = execute(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            ExecuteMsg::DepositFees {\n                addresses: vec![\"test\".to_string()],\n            },\n        )\n        .unwrap();\n\n        assert_eq!(\n            response.messages,\n            vec![\n                SubMsg::new(BankMsg::Send {\n                    to_address: \"treasury\".to_string(),\n                    amount: coins(54u128 - 54u128 * 75u128 / 100u128, \"uluna\")\n                }),\n                SubMsg::new(BankMsg::Send {\n                    to_address: \"fee\".to_string(),\n                    amount: coins(54u128 * 75u128 / 100u128, \"uluna\")\n                })\n            ]\n        );\n\n        let response = query(\n            deps.as_ref(),\n            env,\n            QueryMsg::Amount {\n                address: \"test\".to_string(),\n            },\n        )\n        .unwrap();\n        assert_eq!(from_binary::\u003cVec\u003cCoin\u003e\u003e(\u0026response).unwrap(), vec![]);\n    }\n\n    #[test]\n    fn test_multiple_addresses() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n\n        let info = mock_info(\"creator\", \u0026coins(54u128, \"uluna\"));\n        let env = mock_env();\n\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            ExecuteMsg::DepositFees {\n                addresses: vec![\n                    \"test\".to_string(),\n                    \"test1\".to_string(),\n                    \"test2\".to_string(),\n                    \"test3\".to_string(),\n                    \"test4\".to_string(),\n                    \"test5\".to_string(),\n                    \"test6\".to_string(),\n                    \"test7\".to_string(),\n                    \"test8\".to_string(),\n                    \"test9\".to_string(),\n                ],\n            },\n        )\n        .unwrap();\n\n        let response = query(\n            deps.as_ref(),\n            env.clone(),\n            QueryMsg::Addresses {\n                start_after: None,\n                limit: Some(4u32),\n            },\n        )\n        .unwrap();\n        assert_eq!(\n            from_binary::\u003cVec\u003cString\u003e\u003e(\u0026response).unwrap(),\n            [\"test\", \"test1\", \"test2\", \"test3\"]\n        );\n\n        let response = query(\n            deps.as_ref(),\n            env,\n            QueryMsg::Addresses {\n                start_after: Some(\"test3\".to_string()),\n                limit: Some(8u32),\n            },\n        )\n        .unwrap();\n        assert_eq!(\n            from_binary::\u003cVec\u003cString\u003e\u003e(\u0026response).unwrap(),\n            [\"test4\", \"test5\", \"test6\", \"test7\", \"test8\", \"test9\"]\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","fee_distributor","src","error.rs"],"content":"use cosmwasm_std::StdError;\nuse thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized {},\n\n    #[error(\"Fee not paid correctly, please provide only one native asset at a time\")]\n    DepositNotCorrect {},\n\n    #[error(\"Projects fee allocation cannot be higher than 100%\")]\n    AllocationTooHigh {},\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","fee_distributor","src","lib.rs"],"content":"pub mod contract;\nmod error;\npub mod state;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","fee_distributor","src","state.rs"],"content":"use crate::error::ContractError;\nuse cosmwasm_std::{Addr, Coin, Deps};\nuse cw_storage_plus::{Item, Map};\nuse fee_distributor_export::state::ContractInfo;\n\npub const CONTRACT_INFO: Item\u003cContractInfo\u003e = Item::new(\"contract_info\");\npub const ALLOCATED_FUNDS: Map\u003c\u0026Addr, Vec\u003cCoin\u003e\u003e = Map::new(\"allocated_funds\");\npub const ASSOCIATED_FEE_ADDRESS: Map\u003c\u0026Addr, Addr\u003e = Map::new(\"associated_fee_address\");\n\npub fn is_admin(deps: Deps, addr: Addr) -\u003e Result\u003c(), ContractError\u003e {\n    if CONTRACT_INFO.load(deps.storage)?.owner == addr {\n        Ok(())\n    } else {\n        Err(ContractError::Unauthorized {})\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","iliq_token","examples","iliq_schema.rs"],"content":"use std::env::current_dir;\nuse std::fs::create_dir_all;\n\nuse cosmwasm_schema::{export_schema, remove_schemas, schema_for};\n\nuse cw20::{\n    AllAccountsResponse, AllAllowancesResponse, AllowanceResponse, BalanceResponse,\n    TokenInfoResponse,\n};\nuse cw20_base::msg::{ExecuteMsg, InstantiateMsg, QueryMsg};\n\nfn main() {\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"schema\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n\n    export_schema(\u0026schema_for!(InstantiateMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(ExecuteMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(QueryMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(AllowanceResponse), \u0026out_dir);\n    export_schema(\u0026schema_for!(BalanceResponse), \u0026out_dir);\n    export_schema(\u0026schema_for!(TokenInfoResponse), \u0026out_dir);\n    export_schema(\u0026schema_for!(AllAllowancesResponse), \u0026out_dir);\n    export_schema(\u0026schema_for!(AllAccountsResponse), \u0026out_dir);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","iliq_token","src","allowances.rs"],"content":"use cosmwasm_std::{\n    attr, Addr, Binary, BlockInfo, Deps, DepsMut, Env, MessageInfo, Response, StdError, StdResult,\n    Storage, Uint128,\n};\nuse cw20::{AllowanceResponse, Cw20ReceiveMsg, Expiration};\n\nuse crate::error::ContractError;\nuse crate::state::{ALLOWANCES, BALANCES, TOKEN_INFO};\n\npub fn execute_increase_allowance(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    spender: String,\n    amount: Uint128,\n    expires: Option\u003cExpiration\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let spender_addr = deps.api.addr_validate(\u0026spender)?;\n    if spender_addr == info.sender {\n        return Err(ContractError::CannotSetOwnAccount {});\n    }\n\n    ALLOWANCES.update(\n        deps.storage,\n        (\u0026info.sender, \u0026spender_addr),\n        |allow| -\u003e StdResult\u003c_\u003e {\n            let mut val = allow.unwrap_or_default();\n            if let Some(exp) = expires {\n                val.expires = exp;\n            }\n            val.allowance += amount;\n            Ok(val)\n        },\n    )?;\n\n    let res = Response::new().add_attributes(vec![\n        attr(\"action\", \"increase_allowance\"),\n        attr(\"owner\", info.sender),\n        attr(\"spender\", spender),\n        attr(\"amount\", amount),\n    ]);\n    Ok(res)\n}\n\npub fn execute_decrease_allowance(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    spender: String,\n    amount: Uint128,\n    expires: Option\u003cExpiration\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let spender_addr = deps.api.addr_validate(\u0026spender)?;\n    if spender_addr == info.sender {\n        return Err(ContractError::CannotSetOwnAccount {});\n    }\n\n    let key = (\u0026info.sender, \u0026spender_addr);\n    // load value and delete if it hits 0, or update otherwise\n    let mut allowance = ALLOWANCES.load(deps.storage, key)?;\n    if amount \u003c allowance.allowance {\n        // update the new amount\n        allowance.allowance = allowance\n            .allowance\n            .checked_sub(amount)\n            .map_err(StdError::overflow)?;\n        if let Some(exp) = expires {\n            allowance.expires = exp;\n        }\n        ALLOWANCES.save(deps.storage, key, \u0026allowance)?;\n    } else {\n        ALLOWANCES.remove(deps.storage, key);\n    }\n\n    let res = Response::new().add_attributes(vec![\n        attr(\"action\", \"decrease_allowance\"),\n        attr(\"owner\", info.sender),\n        attr(\"spender\", spender),\n        attr(\"amount\", amount),\n    ]);\n    Ok(res)\n}\n\n// this can be used to update a lower allowance - call bucket.update with proper keys\npub fn deduct_allowance(\n    storage: \u0026mut dyn Storage,\n    owner: \u0026Addr,\n    spender: \u0026Addr,\n    block: \u0026BlockInfo,\n    amount: Uint128,\n) -\u003e Result\u003cAllowanceResponse, ContractError\u003e {\n    ALLOWANCES.update(storage, (owner, spender), |current| {\n        match current {\n            Some(mut a) =\u003e {\n                if a.expires.is_expired(block) {\n                    Err(ContractError::Expired {})\n                } else {\n                    // deduct the allowance if enough\n                    a.allowance = a\n                        .allowance\n                        .checked_sub(amount)\n                        .map_err(StdError::overflow)?;\n                    Ok(a)\n                }\n            }\n            None =\u003e Err(ContractError::NoAllowance {}),\n        }\n    })\n}\n\npub fn execute_transfer_from(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    owner: String,\n    recipient: String,\n    amount: Uint128,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let rcpt_addr = deps.api.addr_validate(\u0026recipient)?;\n    let owner_addr = deps.api.addr_validate(\u0026owner)?;\n\n    // deduct allowance before doing anything else have enough allowance\n    deduct_allowance(deps.storage, \u0026owner_addr, \u0026info.sender, \u0026env.block, amount)?;\n\n    BALANCES.update(\n        deps.storage,\n        \u0026owner_addr,\n        |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e {\n            Ok(balance.unwrap_or_default().checked_sub(amount)?)\n        },\n    )?;\n    BALANCES.update(\n        deps.storage,\n        \u0026rcpt_addr,\n        |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e { Ok(balance.unwrap_or_default() + amount) },\n    )?;\n\n    let res = Response::new().add_attributes(vec![\n        attr(\"action\", \"transfer_from\"),\n        attr(\"from\", owner),\n        attr(\"to\", recipient),\n        attr(\"by\", info.sender),\n        attr(\"amount\", amount),\n    ]);\n    Ok(res)\n}\n\npub fn execute_burn_from(\n    deps: DepsMut,\n\n    env: Env,\n    info: MessageInfo,\n    owner: String,\n    amount: Uint128,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let owner_addr = deps.api.addr_validate(\u0026owner)?;\n\n    // deduct allowance before doing anything else have enough allowance\n    deduct_allowance(deps.storage, \u0026owner_addr, \u0026info.sender, \u0026env.block, amount)?;\n\n    // lower balance\n    BALANCES.update(\n        deps.storage,\n        \u0026owner_addr,\n        |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e {\n            Ok(balance.unwrap_or_default().checked_sub(amount)?)\n        },\n    )?;\n    // reduce total_supply\n    TOKEN_INFO.update(deps.storage, |mut meta| -\u003e StdResult\u003c_\u003e {\n        meta.total_supply = meta.total_supply.checked_sub(amount)?;\n        Ok(meta)\n    })?;\n\n    let res = Response::new().add_attributes(vec![\n        attr(\"action\", \"burn_from\"),\n        attr(\"from\", owner),\n        attr(\"by\", info.sender),\n        attr(\"amount\", amount),\n    ]);\n    Ok(res)\n}\n\npub fn execute_send_from(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    owner: String,\n    contract: String,\n    amount: Uint128,\n    msg: Binary,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let rcpt_addr = deps.api.addr_validate(\u0026contract)?;\n    let owner_addr = deps.api.addr_validate(\u0026owner)?;\n\n    // deduct allowance before doing anything else have enough allowance\n    deduct_allowance(deps.storage, \u0026owner_addr, \u0026info.sender, \u0026env.block, amount)?;\n\n    // move the tokens to the contract\n    BALANCES.update(\n        deps.storage,\n        \u0026owner_addr,\n        |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e {\n            Ok(balance.unwrap_or_default().checked_sub(amount)?)\n        },\n    )?;\n    BALANCES.update(\n        deps.storage,\n        \u0026rcpt_addr,\n        |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e { Ok(balance.unwrap_or_default() + amount) },\n    )?;\n\n    let attrs = vec![\n        attr(\"action\", \"send_from\"),\n        attr(\"from\", \u0026owner),\n        attr(\"to\", \u0026contract),\n        attr(\"by\", \u0026info.sender),\n        attr(\"amount\", amount),\n    ];\n\n    // create a send message\n    let msg = Cw20ReceiveMsg {\n        sender: info.sender.into(),\n        amount,\n        msg,\n    }\n    .into_cosmos_msg(contract)?;\n\n    let res = Response::new().add_message(msg).add_attributes(attrs);\n    Ok(res)\n}\n\npub fn query_allowance(deps: Deps, owner: String, spender: String) -\u003e StdResult\u003cAllowanceResponse\u003e {\n    let owner_addr = deps.api.addr_validate(\u0026owner)?;\n    let spender_addr = deps.api.addr_validate(\u0026spender)?;\n    let allowance = ALLOWANCES\n        .may_load(deps.storage, (\u0026owner_addr, \u0026spender_addr))?\n        .unwrap_or_default();\n    Ok(allowance)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use cosmwasm_std::testing::{mock_dependencies_with_balance, mock_env, mock_info};\n    use cosmwasm_std::{coins, CosmosMsg, SubMsg, Timestamp, WasmMsg};\n    use cw20::{Cw20Coin, TokenInfoResponse};\n\n    use crate::contract::{execute, instantiate, query_balance, query_token_info};\n    use crate::msg::{ExecuteMsg, InstantiateMsg};\n\n    fn get_balance\u003cT: Into\u003cString\u003e\u003e(deps: Deps, address: T) -\u003e Uint128 {\n        query_balance(deps, address.into()).unwrap().balance\n    }\n\n    // this will set up the instantiation for other tests\n    fn do_instantiate\u003cT: Into\u003cString\u003e\u003e(\n        mut deps: DepsMut,\n        addr: T,\n        amount: Uint128,\n    ) -\u003e TokenInfoResponse {\n        let instantiate_msg = InstantiateMsg {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: addr.into(),\n                amount,\n            }],\n            mint: None,\n            marketing: None,\n        };\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n        instantiate(deps.branch(), env, info, instantiate_msg).unwrap();\n        query_token_info(deps.as_ref()).unwrap()\n    }\n\n    #[test]\n    fn increase_decrease_allowances() {\n        let mut deps = mock_dependencies_with_balance(\u0026coins(2, \"token\"));\n\n        let owner = String::from(\"addr0001\");\n        let spender = String::from(\"addr0002\");\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        do_instantiate(deps.as_mut(), owner.clone(), Uint128::new(12340000));\n\n        // no allowance to start\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        assert_eq!(allowance, AllowanceResponse::default());\n\n        // set allowance with height expiration\n        let allow1 = Uint128::new(7777);\n        let expires = Expiration::AtHeight(5432);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: allow1,\n            expires: Some(expires),\n        };\n        execute(deps.as_mut(), env.clone(), info.clone(), msg).unwrap();\n\n        // ensure it looks good\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        assert_eq!(\n            allowance,\n            AllowanceResponse {\n                allowance: allow1,\n                expires\n            }\n        );\n\n        // decrease it a bit with no expire set - stays the same\n        let lower = Uint128::new(4444);\n        let allow2 = allow1.checked_sub(lower).unwrap();\n        let msg = ExecuteMsg::DecreaseAllowance {\n            spender: spender.clone(),\n            amount: lower,\n            expires: None,\n        };\n        execute(deps.as_mut(), env.clone(), info.clone(), msg).unwrap();\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        assert_eq!(\n            allowance,\n            AllowanceResponse {\n                allowance: allow2,\n                expires\n            }\n        );\n\n        // increase it some more and override the expires\n        let raise = Uint128::new(87654);\n        let allow3 = allow2 + raise;\n        let new_expire = Expiration::AtTime(Timestamp::from_seconds(8888888888));\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: raise,\n            expires: Some(new_expire),\n        };\n        execute(deps.as_mut(), env.clone(), info.clone(), msg).unwrap();\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        assert_eq!(\n            allowance,\n            AllowanceResponse {\n                allowance: allow3,\n                expires: new_expire\n            }\n        );\n\n        // decrease it below 0\n        let msg = ExecuteMsg::DecreaseAllowance {\n            spender: spender.clone(),\n            amount: Uint128::new(99988647623876347),\n            expires: None,\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n        let allowance = query_allowance(deps.as_ref(), owner, spender).unwrap();\n        assert_eq!(allowance, AllowanceResponse::default());\n    }\n\n    #[test]\n    fn allowances_independent() {\n        let mut deps = mock_dependencies_with_balance(\u0026coins(2, \"token\"));\n\n        let owner = String::from(\"addr0001\");\n        let spender = String::from(\"addr0002\");\n        let spender2 = String::from(\"addr0003\");\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        do_instantiate(deps.as_mut(), \u0026owner, Uint128::new(12340000));\n\n        // no allowance to start\n        assert_eq!(\n            query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap(),\n            AllowanceResponse::default()\n        );\n        assert_eq!(\n            query_allowance(deps.as_ref(), owner.clone(), spender2.clone()).unwrap(),\n            AllowanceResponse::default()\n        );\n        assert_eq!(\n            query_allowance(deps.as_ref(), spender.clone(), spender2.clone()).unwrap(),\n            AllowanceResponse::default()\n        );\n\n        // set allowance with height expiration\n        let allow1 = Uint128::new(7777);\n        let expires = Expiration::AtHeight(5432);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: allow1,\n            expires: Some(expires),\n        };\n        execute(deps.as_mut(), env.clone(), info.clone(), msg).unwrap();\n\n        // set other allowance with no expiration\n        let allow2 = Uint128::new(87654);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender2.clone(),\n            amount: allow2,\n            expires: None,\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // check they are proper\n        let expect_one = AllowanceResponse {\n            allowance: allow1,\n            expires,\n        };\n        let expect_two = AllowanceResponse {\n            allowance: allow2,\n            expires: Expiration::Never {},\n        };\n        assert_eq!(\n            query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap(),\n            expect_one\n        );\n        assert_eq!(\n            query_allowance(deps.as_ref(), owner.clone(), spender2.clone()).unwrap(),\n            expect_two\n        );\n        assert_eq!(\n            query_allowance(deps.as_ref(), spender.clone(), spender2.clone()).unwrap(),\n            AllowanceResponse::default()\n        );\n\n        // also allow spender -\u003e spender2 with no interference\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let allow3 = Uint128::new(1821);\n        let expires3 = Expiration::AtTime(Timestamp::from_seconds(3767626296));\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender2.clone(),\n            amount: allow3,\n            expires: Some(expires3),\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n        let expect_three = AllowanceResponse {\n            allowance: allow3,\n            expires: expires3,\n        };\n        assert_eq!(\n            query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap(),\n            expect_one\n        );\n        assert_eq!(\n            query_allowance(deps.as_ref(), owner, spender2.clone()).unwrap(),\n            expect_two\n        );\n        assert_eq!(\n            query_allowance(deps.as_ref(), spender, spender2).unwrap(),\n            expect_three\n        );\n    }\n\n    #[test]\n    fn no_self_allowance() {\n        let mut deps = mock_dependencies_with_balance(\u0026coins(2, \"token\"));\n\n        let owner = String::from(\"addr0001\");\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        do_instantiate(deps.as_mut(), \u0026owner, Uint128::new(12340000));\n\n        // self-allowance\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: owner.clone(),\n            amount: Uint128::new(7777),\n            expires: None,\n        };\n        let err = execute(deps.as_mut(), env.clone(), info.clone(), msg).unwrap_err();\n        assert_eq!(err, ContractError::CannotSetOwnAccount {});\n\n        // decrease self-allowance\n        let msg = ExecuteMsg::DecreaseAllowance {\n            spender: owner,\n            amount: Uint128::new(7777),\n            expires: None,\n        };\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert_eq!(err, ContractError::CannotSetOwnAccount {});\n    }\n\n    #[test]\n    fn transfer_from_respects_limits() {\n        let mut deps = mock_dependencies_with_balance(\u0026[]);\n        let owner = String::from(\"addr0001\");\n        let spender = String::from(\"addr0002\");\n        let rcpt = String::from(\"addr0003\");\n\n        let start = Uint128::new(999999);\n        do_instantiate(deps.as_mut(), \u0026owner, start);\n\n        // provide an allowance\n        let allow1 = Uint128::new(77777);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: allow1,\n            expires: None,\n        };\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // valid transfer of part of the allowance\n        let transfer = Uint128::new(44444);\n        let msg = ExecuteMsg::TransferFrom {\n            owner: owner.clone(),\n            recipient: rcpt.clone(),\n            amount: transfer,\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let res = execute(deps.as_mut(), env, info, msg).unwrap();\n        assert_eq!(res.attributes[0], attr(\"action\", \"transfer_from\"));\n\n        // make sure money arrived\n        assert_eq!(\n            get_balance(deps.as_ref(), owner.clone()),\n            start.checked_sub(transfer).unwrap()\n        );\n        assert_eq!(get_balance(deps.as_ref(), rcpt.clone()), transfer);\n\n        // ensure it looks good\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        let expect = AllowanceResponse {\n            allowance: allow1.checked_sub(transfer).unwrap(),\n            expires: Expiration::Never {},\n        };\n        assert_eq!(expect, allowance);\n\n        // cannot send more than the allowance\n        let msg = ExecuteMsg::TransferFrom {\n            owner: owner.clone(),\n            recipient: rcpt.clone(),\n            amount: Uint128::new(33443),\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert!(matches!(err, ContractError::Std(StdError::Overflow { .. })));\n\n        // let us increase limit, but set the expiration (default env height is 12_345)\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: Uint128::new(1000),\n            expires: Some(Expiration::AtHeight(env.block.height)),\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // we should now get the expiration error\n        let msg = ExecuteMsg::TransferFrom {\n            owner,\n            recipient: rcpt,\n            amount: Uint128::new(33443),\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert_eq!(err, ContractError::Expired {});\n    }\n\n    #[test]\n    fn burn_from_respects_limits() {\n        let mut deps = mock_dependencies_with_balance(\u0026[]);\n        let owner = String::from(\"addr0001\");\n        let spender = String::from(\"addr0002\");\n\n        let start = Uint128::new(999999);\n        do_instantiate(deps.as_mut(), \u0026owner, start);\n\n        // provide an allowance\n        let allow1 = Uint128::new(77777);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: allow1,\n            expires: None,\n        };\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // valid burn of part of the allowance\n        let transfer = Uint128::new(44444);\n        let msg = ExecuteMsg::BurnFrom {\n            owner: owner.clone(),\n            amount: transfer,\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let res = execute(deps.as_mut(), env, info, msg).unwrap();\n        assert_eq!(res.attributes[0], attr(\"action\", \"burn_from\"));\n\n        // make sure money burnt\n        assert_eq!(\n            get_balance(deps.as_ref(), owner.clone()),\n            start.checked_sub(transfer).unwrap()\n        );\n\n        // ensure it looks good\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        let expect = AllowanceResponse {\n            allowance: allow1.checked_sub(transfer).unwrap(),\n            expires: Expiration::Never {},\n        };\n        assert_eq!(expect, allowance);\n\n        // cannot burn more than the allowance\n        let msg = ExecuteMsg::BurnFrom {\n            owner: owner.clone(),\n            amount: Uint128::new(33443),\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert!(matches!(err, ContractError::Std(StdError::Overflow { .. })));\n\n        // let us increase limit, but set the expiration (default env height is 12_345)\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: Uint128::new(1000),\n            expires: Some(Expiration::AtHeight(env.block.height)),\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // we should now get the expiration error\n        let msg = ExecuteMsg::BurnFrom {\n            owner,\n            amount: Uint128::new(33443),\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert_eq!(err, ContractError::Expired {});\n    }\n\n    #[test]\n    fn send_from_respects_limits() {\n        let mut deps = mock_dependencies_with_balance(\u0026[]);\n        let owner = String::from(\"addr0001\");\n        let spender = String::from(\"addr0002\");\n        let contract = String::from(\"cool-dex\");\n        let send_msg = Binary::from(r#\"{\"some\":123}\"#.as_bytes());\n\n        let start = Uint128::new(999999);\n        do_instantiate(deps.as_mut(), \u0026owner, start);\n\n        // provide an allowance\n        let allow1 = Uint128::new(77777);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: allow1,\n            expires: None,\n        };\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // valid send of part of the allowance\n        let transfer = Uint128::new(44444);\n        let msg = ExecuteMsg::SendFrom {\n            owner: owner.clone(),\n            amount: transfer,\n            contract: contract.clone(),\n            msg: send_msg.clone(),\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let res = execute(deps.as_mut(), env, info, msg).unwrap();\n        assert_eq!(res.attributes[0], attr(\"action\", \"send_from\"));\n        assert_eq!(1, res.messages.len());\n\n        // we record this as sent by the one who requested, not the one who was paying\n        let binary_msg = Cw20ReceiveMsg {\n            sender: spender.clone(),\n            amount: transfer,\n            msg: send_msg.clone(),\n        }\n        .into_binary()\n        .unwrap();\n        assert_eq!(\n            res.messages[0],\n            SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: contract.clone(),\n                msg: binary_msg,\n                funds: vec![],\n            }))\n        );\n\n        // make sure money sent\n        assert_eq!(\n            get_balance(deps.as_ref(), owner.clone()),\n            start.checked_sub(transfer).unwrap()\n        );\n        assert_eq!(get_balance(deps.as_ref(), contract.clone()), transfer);\n\n        // ensure it looks good\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        let expect = AllowanceResponse {\n            allowance: allow1.checked_sub(transfer).unwrap(),\n            expires: Expiration::Never {},\n        };\n        assert_eq!(expect, allowance);\n\n        // cannot send more than the allowance\n        let msg = ExecuteMsg::SendFrom {\n            owner: owner.clone(),\n            amount: Uint128::new(33443),\n            contract: contract.clone(),\n            msg: send_msg.clone(),\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert!(matches!(err, ContractError::Std(StdError::Overflow { .. })));\n\n        // let us increase limit, but set the expiration to current block (expired)\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: Uint128::new(1000),\n            expires: Some(Expiration::AtHeight(env.block.height)),\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // we should now get the expiration error\n        let msg = ExecuteMsg::SendFrom {\n            owner,\n            amount: Uint128::new(33443),\n            contract,\n            msg: send_msg,\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert_eq!(err, ContractError::Expired {});\n    }\n}\n","traces":[{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":9},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","iliq_token","src","contract.rs"],"content":"#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\nuse cosmwasm_std::{to_binary, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult};\n\nuse cw20_base::allowances::{\n    execute_burn_from, execute_decrease_allowance, execute_increase_allowance, execute_send_from,\n    execute_transfer_from, query_allowance,\n};\nuse cw20_base::contract::{\n    execute_burn, execute_mint, execute_send, execute_transfer, execute_update_marketing,\n    execute_upload_logo,\n};\nuse cw20_base::contract::{\n    query_balance, query_download_logo, query_marketing_info, query_minter, query_token_info,\n};\n\nuse cw20_base::enumerable::{query_all_accounts, query_all_allowances};\nuse cw20_base::ContractError;\n\nuse crate::msg::{ExecuteMsg, InstantiateMsg, QueryMsg};\n/*\nuse crate::state::{MinterData, TokenInfo, BALANCES, LOGO, MARKETING_INFO, TOKEN_INFO};\n*/\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let base_instantiate_msg = cw20_base::msg::InstantiateMsg {\n        name: msg.name,\n        symbol: msg.symbol,\n        decimals: msg.decimals,\n        initial_balances: msg.initial_balances,\n        mint: msg.mint,\n        marketing: msg.marketing,\n    };\n\n    cw20_base::contract::instantiate(deps, env, info, base_instantiate_msg)\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    match msg {\n        ExecuteMsg::Transfer { recipient, amount } =\u003e {\n            execute_transfer(deps, env, info, recipient, amount)\n        }\n        ExecuteMsg::Burn { amount } =\u003e execute_burn(deps, env, info, amount),\n        ExecuteMsg::Send {\n            contract,\n            amount,\n            msg,\n        } =\u003e execute_send(deps, env, info, contract, amount, msg),\n        ExecuteMsg::Mint { recipient, amount } =\u003e execute_mint(deps, env, info, recipient, amount),\n        ExecuteMsg::IncreaseAllowance {\n            spender,\n            amount,\n            expires,\n        } =\u003e execute_increase_allowance(deps, env, info, spender, amount, expires),\n        ExecuteMsg::DecreaseAllowance {\n            spender,\n            amount,\n            expires,\n        } =\u003e execute_decrease_allowance(deps, env, info, spender, amount, expires),\n        ExecuteMsg::TransferFrom {\n            owner,\n            recipient,\n            amount,\n        } =\u003e execute_transfer_from(deps, env, info, owner, recipient, amount),\n        ExecuteMsg::BurnFrom { owner, amount } =\u003e execute_burn_from(deps, env, info, owner, amount),\n        ExecuteMsg::SendFrom {\n            owner,\n            contract,\n            amount,\n            msg,\n        } =\u003e execute_send_from(deps, env, info, owner, contract, amount, msg),\n        ExecuteMsg::UpdateMarketing {\n            project,\n            description,\n            marketing,\n        } =\u003e execute_update_marketing(deps, env, info, project, description, marketing),\n        ExecuteMsg::UploadLogo(logo) =\u003e execute_upload_logo(deps, env, info, logo),\n    }\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::Balance { address } =\u003e to_binary(\u0026query_balance(deps, address)?),\n        QueryMsg::TokenInfo {} =\u003e to_binary(\u0026query_token_info(deps)?),\n        QueryMsg::Minter {} =\u003e to_binary(\u0026query_minter(deps)?),\n        QueryMsg::Allowance { owner, spender } =\u003e {\n            to_binary(\u0026query_allowance(deps, owner, spender)?)\n        }\n        QueryMsg::AllAllowances {\n            owner,\n            start_after,\n            limit,\n        } =\u003e to_binary(\u0026query_all_allowances(deps, owner, start_after, limit)?),\n        QueryMsg::AllAccounts { start_after, limit } =\u003e {\n            to_binary(\u0026query_all_accounts(deps, start_after, limit)?)\n        }\n        QueryMsg::MarketingInfo {} =\u003e to_binary(\u0026query_marketing_info(deps)?),\n        QueryMsg::DownloadLogo {} =\u003e to_binary(\u0026query_download_logo(deps)?),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","iliq_token","src","enumerable.rs"],"content":"use cosmwasm_std::{Deps, Order, StdResult};\nuse cw20::{AllAccountsResponse, AllAllowancesResponse, AllowanceInfo};\n\nuse crate::state::{ALLOWANCES, BALANCES};\nuse cw_storage_plus::Bound;\n\n// settings for pagination\nconst MAX_LIMIT: u32 = 30;\nconst DEFAULT_LIMIT: u32 = 10;\n\npub fn query_all_allowances(\n    deps: Deps,\n    owner: String,\n    start_after: Option\u003cString\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e StdResult\u003cAllAllowancesResponse\u003e {\n    let owner_addr = deps.api.addr_validate(\u0026owner)?;\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n    let start = start_after.map(|s| Bound::ExclusiveRaw(s.into_bytes()));\n\n    let allowances = ALLOWANCES\n        .prefix(\u0026owner_addr)\n        .range(deps.storage, start, None, Order::Ascending)\n        .take(limit)\n        .map(|item| {\n            item.map(|(addr, allow)| AllowanceInfo {\n                spender: addr.into(),\n                allowance: allow.allowance,\n                expires: allow.expires,\n            })\n        })\n        .collect::\u003cStdResult\u003c_\u003e\u003e()?;\n    Ok(AllAllowancesResponse { allowances })\n}\n\npub fn query_all_accounts(\n    deps: Deps,\n    start_after: Option\u003cString\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e StdResult\u003cAllAccountsResponse\u003e {\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n    let start = start_after.map(|s| Bound::ExclusiveRaw(s.into()));\n\n    let accounts = BALANCES\n        .keys(deps.storage, start, None, Order::Ascending)\n        .take(limit)\n        .map(|item| item.map(Into::into))\n        .collect::\u003cStdResult\u003c_\u003e\u003e()?;\n\n    Ok(AllAccountsResponse { accounts })\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use cosmwasm_std::testing::{mock_dependencies_with_balance, mock_env, mock_info};\n    use cosmwasm_std::{coins, DepsMut, Uint128};\n    use cw20::{Cw20Coin, Expiration, TokenInfoResponse};\n\n    use crate::contract::{execute, instantiate, query_token_info};\n    use crate::msg::{ExecuteMsg, InstantiateMsg};\n\n    // this will set up the instantiation for other tests\n    fn do_instantiate(mut deps: DepsMut, addr: \u0026str, amount: Uint128) -\u003e TokenInfoResponse {\n        let instantiate_msg = InstantiateMsg {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: addr.into(),\n                amount,\n            }],\n            mint: None,\n            marketing: None,\n        };\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n        instantiate(deps.branch(), env, info, instantiate_msg).unwrap();\n        query_token_info(deps.as_ref()).unwrap()\n    }\n\n    #[test]\n    fn query_all_allowances_works() {\n        let mut deps = mock_dependencies_with_balance(\u0026coins(2, \"token\"));\n\n        let owner = String::from(\"owner\");\n        // these are in alphabetical order same than insert order\n        let spender1 = String::from(\"earlier\");\n        let spender2 = String::from(\"later\");\n\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        do_instantiate(deps.as_mut(), \u0026owner, Uint128::new(12340000));\n\n        // no allowance to start\n        let allowances = query_all_allowances(deps.as_ref(), owner.clone(), None, None).unwrap();\n        assert_eq!(allowances.allowances, vec![]);\n\n        // set allowance with height expiration\n        let allow1 = Uint128::new(7777);\n        let expires = Expiration::AtHeight(5432);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender1.clone(),\n            amount: allow1,\n            expires: Some(expires),\n        };\n        execute(deps.as_mut(), env.clone(), info.clone(), msg).unwrap();\n\n        // set allowance with no expiration\n        let allow2 = Uint128::new(54321);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender2.clone(),\n            amount: allow2,\n            expires: None,\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // query list gets 2\n        let allowances = query_all_allowances(deps.as_ref(), owner.clone(), None, None).unwrap();\n        assert_eq!(allowances.allowances.len(), 2);\n\n        // first one is spender1 (order of CanonicalAddr uncorrelated with String)\n        let allowances = query_all_allowances(deps.as_ref(), owner.clone(), None, Some(1)).unwrap();\n        assert_eq!(allowances.allowances.len(), 1);\n        let allow = \u0026allowances.allowances[0];\n        assert_eq!(\u0026allow.spender, \u0026spender1);\n        assert_eq!(\u0026allow.expires, \u0026expires);\n        assert_eq!(\u0026allow.allowance, \u0026allow1);\n\n        // next one is spender2\n        let allowances = query_all_allowances(\n            deps.as_ref(),\n            owner,\n            Some(allow.spender.clone()),\n            Some(10000),\n        )\n        .unwrap();\n        assert_eq!(allowances.allowances.len(), 1);\n        let allow = \u0026allowances.allowances[0];\n        assert_eq!(\u0026allow.spender, \u0026spender2);\n        assert_eq!(\u0026allow.expires, \u0026Expiration::Never {});\n        assert_eq!(\u0026allow.allowance, \u0026allow2);\n    }\n\n    #[test]\n    fn query_all_accounts_works() {\n        let mut deps = mock_dependencies_with_balance(\u0026coins(2, \"token\"));\n\n        // insert order and lexicographical order are different\n        let acct1 = String::from(\"acct01\");\n        let acct2 = String::from(\"zebra\");\n        let acct3 = String::from(\"nice\");\n        let acct4 = String::from(\"aaaardvark\");\n        let expected_order = [acct4.clone(), acct1.clone(), acct3.clone(), acct2.clone()];\n\n        do_instantiate(deps.as_mut(), \u0026acct1, Uint128::new(12340000));\n\n        // put money everywhere (to create balanaces)\n        let info = mock_info(acct1.as_ref(), \u0026[]);\n        let env = mock_env();\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            ExecuteMsg::Transfer {\n                recipient: acct2,\n                amount: Uint128::new(222222),\n            },\n        )\n        .unwrap();\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            ExecuteMsg::Transfer {\n                recipient: acct3,\n                amount: Uint128::new(333333),\n            },\n        )\n        .unwrap();\n        execute(\n            deps.as_mut(),\n            env,\n            info,\n            ExecuteMsg::Transfer {\n                recipient: acct4,\n                amount: Uint128::new(444444),\n            },\n        )\n        .unwrap();\n\n        // make sure we get the proper results\n        let accounts = query_all_accounts(deps.as_ref(), None, None).unwrap();\n        assert_eq!(accounts.accounts, expected_order);\n\n        // let's do pagination\n        let accounts = query_all_accounts(deps.as_ref(), None, Some(2)).unwrap();\n        assert_eq!(accounts.accounts, expected_order[0..2].to_vec());\n\n        let accounts =\n            query_all_accounts(deps.as_ref(), Some(accounts.accounts[1].clone()), Some(1)).unwrap();\n        assert_eq!(accounts.accounts, expected_order[2..3].to_vec());\n\n        let accounts =\n            query_all_accounts(deps.as_ref(), Some(accounts.accounts[0].clone()), Some(777))\n                .unwrap();\n        assert_eq!(accounts.accounts, expected_order[3..].to_vec());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","iliq_token","src","error.rs"],"content":"use cosmwasm_std::StdError;\nuse thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized {},\n\n    #[error(\"Cannot set to own account\")]\n    CannotSetOwnAccount {},\n\n    #[error(\"Invalid zero amount\")]\n    InvalidZeroAmount {},\n\n    #[error(\"Allowance is expired\")]\n    Expired {},\n\n    #[error(\"No allowance for this account\")]\n    NoAllowance {},\n\n    #[error(\"Minting cannot exceed the cap\")]\n    CannotExceedCap {},\n\n    #[error(\"Logo binary data exceeds 5KB limit\")]\n    LogoTooBig {},\n\n    #[error(\"Invalid xml preamble for SVG\")]\n    InvalidXmlPreamble {},\n\n    #[error(\"Invalid png header\")]\n    InvalidPngHeader {},\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","iliq_token","src","lib.rs"],"content":"pub mod contract;\nmod error;\npub mod msg;\n\npub use crate::error::ContractError;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","iliq_token","src","msg.rs"],"content":"use cosmwasm_std::{StdError, StdResult, Uint128};\nuse cw20::MinterResponse;\nuse cw20_base::msg::InstantiateMarketingInfo;\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\npub use cw20::Cw20ExecuteMsg as ExecuteMsg;\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct InstantiateMsg {\n    pub custom: String,\n    pub name: String,\n    pub symbol: String,\n    pub decimals: u8,\n    pub initial_balances: Vec\u003ccw20::Cw20Coin\u003e,\n    pub mint: Option\u003cMinterResponse\u003e,\n    pub marketing: Option\u003cInstantiateMarketingInfo\u003e,\n}\n\nimpl InstantiateMsg {\n    pub fn get_cap(\u0026self) -\u003e Option\u003cUint128\u003e {\n        self.mint.as_ref().and_then(|v| v.cap)\n    }\n\n    pub fn validate(\u0026self) -\u003e StdResult\u003c()\u003e {\n        // Check name, symbol, decimals\n        if !is_valid_name(\u0026self.name) {\n            return Err(StdError::generic_err(\n                \"Name is not in the expected format (3-50 UTF-8 bytes)\",\n            ));\n        }\n        if !is_valid_symbol(\u0026self.symbol) {\n            return Err(StdError::generic_err(\n                \"Ticker symbol is not in expected format [a-zA-Z\\\\-]{3,12}\",\n            ));\n        }\n        if self.decimals \u003e 18 {\n            return Err(StdError::generic_err(\"Decimals must not exceed 18\"));\n        }\n        Ok(())\n    }\n}\n\nfn is_valid_name(name: \u0026str) -\u003e bool {\n    let bytes = name.as_bytes();\n    if bytes.len() \u003c 3 || bytes.len() \u003e 50 {\n        return false;\n    }\n    true\n}\n\nfn is_valid_symbol(symbol: \u0026str) -\u003e bool {\n    let bytes = symbol.as_bytes();\n    if bytes.len() \u003c 3 || bytes.len() \u003e 12 {\n        return false;\n    }\n    for byte in bytes.iter() {\n        if (*byte != 45) \u0026\u0026 (*byte \u003c 65 || *byte \u003e 90) \u0026\u0026 (*byte \u003c 97 || *byte \u003e 122) {\n            return false;\n        }\n    }\n    true\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    /// Returns the current balance of the given address, 0 if unset.\n    /// Return type: BalanceResponse.\n    Balance { address: String },\n    /// Returns metadata on the contract - name, decimals, supply, etc.\n    /// Return type: TokenInfoResponse.\n    TokenInfo {},\n    /// Only with \"mintable\" extension.\n    /// Returns who can mint and the hard cap on maximum tokens after minting.\n    /// Return type: MinterResponse.\n    Minter {},\n    /// Only with \"allowance\" extension.\n    /// Returns how much spender can use from owner account, 0 if unset.\n    /// Return type: AllowanceResponse.\n    Allowance { owner: String, spender: String },\n    /// Only with \"enumerable\" extension (and \"allowances\")\n    /// Returns all allowances this owner has approved. Supports pagination.\n    /// Return type: AllAllowancesResponse.\n    AllAllowances {\n        owner: String,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    },\n    /// Only with \"enumerable\" extension\n    /// Returns all accounts that have balances. Supports pagination.\n    /// Return type: AllAccountsResponse.\n    AllAccounts {\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    },\n    /// Only with \"marketing\" extension\n    /// Returns more metadata on the contract to display in the client:\n    /// - description, logo, project url, etc.\n    /// Return type: MarketingInfoResponse\n    MarketingInfo {},\n    /// Only with \"marketing\" extension\n    /// Downloads the mbeded logo data (if stored on chain). Errors if no logo data ftored for this\n    /// contract.\n    /// Return type: DownloadLogoResponse.\n    DownloadLogo {},\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","lender","examples","lender_schema.rs"],"content":"use std::env::current_dir;\nuse std::fs::create_dir_all;\n\nuse cosmwasm_schema::{export_schema, remove_schemas, schema_for};\n\nuse lender_export::msg::{ExecuteMsg, InstantiateMsg, QueryMsg};\n\nfn main() {\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"schema\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n\n    export_schema(\u0026schema_for!(InstantiateMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(ExecuteMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(QueryMsg), \u0026out_dir);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","lender","src","allowances.rs"],"content":"use cosmwasm_std::{\n    attr, Addr, Binary, BlockInfo, Deps, DepsMut, Env, MessageInfo, Response, StdError, StdResult,\n    Storage, Uint128,\n};\nuse cw20::{AllowanceResponse, Cw20ReceiveMsg, Expiration};\n\nuse crate::error::ContractError;\nuse crate::state::{ALLOWANCES, BALANCES, TOKEN_INFO};\n\npub fn execute_increase_allowance(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    spender: String,\n    amount: Uint128,\n    expires: Option\u003cExpiration\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let spender_addr = deps.api.addr_validate(\u0026spender)?;\n    if spender_addr == info.sender {\n        return Err(ContractError::CannotSetOwnAccount {});\n    }\n\n    ALLOWANCES.update(\n        deps.storage,\n        (\u0026info.sender, \u0026spender_addr),\n        |allow| -\u003e StdResult\u003c_\u003e {\n            let mut val = allow.unwrap_or_default();\n            if let Some(exp) = expires {\n                val.expires = exp;\n            }\n            val.allowance += amount;\n            Ok(val)\n        },\n    )?;\n\n    let res = Response::new().add_attributes(vec![\n        attr(\"action\", \"increase_allowance\"),\n        attr(\"owner\", info.sender),\n        attr(\"spender\", spender),\n        attr(\"amount\", amount),\n    ]);\n    Ok(res)\n}\n\npub fn execute_decrease_allowance(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    spender: String,\n    amount: Uint128,\n    expires: Option\u003cExpiration\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let spender_addr = deps.api.addr_validate(\u0026spender)?;\n    if spender_addr == info.sender {\n        return Err(ContractError::CannotSetOwnAccount {});\n    }\n\n    let key = (\u0026info.sender, \u0026spender_addr);\n    // load value and delete if it hits 0, or update otherwise\n    let mut allowance = ALLOWANCES.load(deps.storage, key)?;\n    if amount \u003c allowance.allowance {\n        // update the new amount\n        allowance.allowance = allowance\n            .allowance\n            .checked_sub(amount)\n            .map_err(StdError::overflow)?;\n        if let Some(exp) = expires {\n            allowance.expires = exp;\n        }\n        ALLOWANCES.save(deps.storage, key, \u0026allowance)?;\n    } else {\n        ALLOWANCES.remove(deps.storage, key);\n    }\n\n    let res = Response::new().add_attributes(vec![\n        attr(\"action\", \"decrease_allowance\"),\n        attr(\"owner\", info.sender),\n        attr(\"spender\", spender),\n        attr(\"amount\", amount),\n    ]);\n    Ok(res)\n}\n\n// this can be used to update a lower allowance - call bucket.update with proper keys\npub fn deduct_allowance(\n    storage: \u0026mut dyn Storage,\n    owner: \u0026Addr,\n    spender: \u0026Addr,\n    block: \u0026BlockInfo,\n    amount: Uint128,\n) -\u003e Result\u003cAllowanceResponse, ContractError\u003e {\n    ALLOWANCES.update(storage, (owner, spender), |current| {\n        match current {\n            Some(mut a) =\u003e {\n                if a.expires.is_expired(block) {\n                    Err(ContractError::Expired {})\n                } else {\n                    // deduct the allowance if enough\n                    a.allowance = a\n                        .allowance\n                        .checked_sub(amount)\n                        .map_err(StdError::overflow)?;\n                    Ok(a)\n                }\n            }\n            None =\u003e Err(ContractError::NoAllowance {}),\n        }\n    })\n}\n\npub fn execute_transfer_from(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    owner: String,\n    recipient: String,\n    amount: Uint128,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let rcpt_addr = deps.api.addr_validate(\u0026recipient)?;\n    let owner_addr = deps.api.addr_validate(\u0026owner)?;\n\n    // deduct allowance before doing anything else have enough allowance\n    deduct_allowance(deps.storage, \u0026owner_addr, \u0026info.sender, \u0026env.block, amount)?;\n\n    BALANCES.update(\n        deps.storage,\n        \u0026owner_addr,\n        |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e {\n            Ok(balance.unwrap_or_default().checked_sub(amount)?)\n        },\n    )?;\n    BALANCES.update(\n        deps.storage,\n        \u0026rcpt_addr,\n        |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e { Ok(balance.unwrap_or_default() + amount) },\n    )?;\n\n    let res = Response::new().add_attributes(vec![\n        attr(\"action\", \"transfer_from\"),\n        attr(\"from\", owner),\n        attr(\"to\", recipient),\n        attr(\"by\", info.sender),\n        attr(\"amount\", amount),\n    ]);\n    Ok(res)\n}\n\npub fn execute_burn_from(\n    deps: DepsMut,\n\n    env: Env,\n    info: MessageInfo,\n    owner: String,\n    amount: Uint128,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let owner_addr = deps.api.addr_validate(\u0026owner)?;\n\n    // deduct allowance before doing anything else have enough allowance\n    deduct_allowance(deps.storage, \u0026owner_addr, \u0026info.sender, \u0026env.block, amount)?;\n\n    // lower balance\n    BALANCES.update(\n        deps.storage,\n        \u0026owner_addr,\n        |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e {\n            Ok(balance.unwrap_or_default().checked_sub(amount)?)\n        },\n    )?;\n    // reduce total_supply\n    TOKEN_INFO.update(deps.storage, |mut meta| -\u003e StdResult\u003c_\u003e {\n        meta.total_supply = meta.total_supply.checked_sub(amount)?;\n        Ok(meta)\n    })?;\n\n    let res = Response::new().add_attributes(vec![\n        attr(\"action\", \"burn_from\"),\n        attr(\"from\", owner),\n        attr(\"by\", info.sender),\n        attr(\"amount\", amount),\n    ]);\n    Ok(res)\n}\n\npub fn execute_send_from(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    owner: String,\n    contract: String,\n    amount: Uint128,\n    msg: Binary,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let rcpt_addr = deps.api.addr_validate(\u0026contract)?;\n    let owner_addr = deps.api.addr_validate(\u0026owner)?;\n\n    // deduct allowance before doing anything else have enough allowance\n    deduct_allowance(deps.storage, \u0026owner_addr, \u0026info.sender, \u0026env.block, amount)?;\n\n    // move the tokens to the contract\n    BALANCES.update(\n        deps.storage,\n        \u0026owner_addr,\n        |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e {\n            Ok(balance.unwrap_or_default().checked_sub(amount)?)\n        },\n    )?;\n    BALANCES.update(\n        deps.storage,\n        \u0026rcpt_addr,\n        |balance: Option\u003cUint128\u003e| -\u003e StdResult\u003c_\u003e { Ok(balance.unwrap_or_default() + amount) },\n    )?;\n\n    let attrs = vec![\n        attr(\"action\", \"send_from\"),\n        attr(\"from\", \u0026owner),\n        attr(\"to\", \u0026contract),\n        attr(\"by\", \u0026info.sender),\n        attr(\"amount\", amount),\n    ];\n\n    // create a send message\n    let msg = Cw20ReceiveMsg {\n        sender: info.sender.into(),\n        amount,\n        msg,\n    }\n    .into_cosmos_msg(contract)?;\n\n    let res = Response::new().add_message(msg).add_attributes(attrs);\n    Ok(res)\n}\n\npub fn query_allowance(deps: Deps, owner: String, spender: String) -\u003e StdResult\u003cAllowanceResponse\u003e {\n    let owner_addr = deps.api.addr_validate(\u0026owner)?;\n    let spender_addr = deps.api.addr_validate(\u0026spender)?;\n    let allowance = ALLOWANCES\n        .may_load(deps.storage, (\u0026owner_addr, \u0026spender_addr))?\n        .unwrap_or_default();\n    Ok(allowance)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use cosmwasm_std::testing::{mock_dependencies_with_balance, mock_env, mock_info};\n    use cosmwasm_std::{coins, CosmosMsg, SubMsg, Timestamp, WasmMsg};\n    use cw20::{Cw20Coin, TokenInfoResponse};\n\n    use crate::contract::{execute, instantiate, query_balance, query_token_info};\n    use crate::msg::{ExecuteMsg, InstantiateMsg};\n\n    fn get_balance\u003cT: Into\u003cString\u003e\u003e(deps: Deps, address: T) -\u003e Uint128 {\n        query_balance(deps, address.into()).unwrap().balance\n    }\n\n    // this will set up the instantiation for other tests\n    fn do_instantiate\u003cT: Into\u003cString\u003e\u003e(\n        mut deps: DepsMut,\n        addr: T,\n        amount: Uint128,\n    ) -\u003e TokenInfoResponse {\n        let instantiate_msg = InstantiateMsg {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: addr.into(),\n                amount,\n            }],\n            mint: None,\n            marketing: None,\n        };\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n        instantiate(deps.branch(), env, info, instantiate_msg).unwrap();\n        query_token_info(deps.as_ref()).unwrap()\n    }\n\n    #[test]\n    fn increase_decrease_allowances() {\n        let mut deps = mock_dependencies_with_balance(\u0026coins(2, \"token\"));\n\n        let owner = String::from(\"addr0001\");\n        let spender = String::from(\"addr0002\");\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        do_instantiate(deps.as_mut(), owner.clone(), Uint128::new(12340000));\n\n        // no allowance to start\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        assert_eq!(allowance, AllowanceResponse::default());\n\n        // set allowance with height expiration\n        let allow1 = Uint128::new(7777);\n        let expires = Expiration::AtHeight(5432);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: allow1,\n            expires: Some(expires),\n        };\n        execute(deps.as_mut(), env.clone(), info.clone(), msg).unwrap();\n\n        // ensure it looks good\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        assert_eq!(\n            allowance,\n            AllowanceResponse {\n                allowance: allow1,\n                expires\n            }\n        );\n\n        // decrease it a bit with no expire set - stays the same\n        let lower = Uint128::new(4444);\n        let allow2 = allow1.checked_sub(lower).unwrap();\n        let msg = ExecuteMsg::DecreaseAllowance {\n            spender: spender.clone(),\n            amount: lower,\n            expires: None,\n        };\n        execute(deps.as_mut(), env.clone(), info.clone(), msg).unwrap();\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        assert_eq!(\n            allowance,\n            AllowanceResponse {\n                allowance: allow2,\n                expires\n            }\n        );\n\n        // increase it some more and override the expires\n        let raise = Uint128::new(87654);\n        let allow3 = allow2 + raise;\n        let new_expire = Expiration::AtTime(Timestamp::from_seconds(8888888888));\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: raise,\n            expires: Some(new_expire),\n        };\n        execute(deps.as_mut(), env.clone(), info.clone(), msg).unwrap();\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        assert_eq!(\n            allowance,\n            AllowanceResponse {\n                allowance: allow3,\n                expires: new_expire\n            }\n        );\n\n        // decrease it below 0\n        let msg = ExecuteMsg::DecreaseAllowance {\n            spender: spender.clone(),\n            amount: Uint128::new(99988647623876347),\n            expires: None,\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n        let allowance = query_allowance(deps.as_ref(), owner, spender).unwrap();\n        assert_eq!(allowance, AllowanceResponse::default());\n    }\n\n    #[test]\n    fn allowances_independent() {\n        let mut deps = mock_dependencies_with_balance(\u0026coins(2, \"token\"));\n\n        let owner = String::from(\"addr0001\");\n        let spender = String::from(\"addr0002\");\n        let spender2 = String::from(\"addr0003\");\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        do_instantiate(deps.as_mut(), \u0026owner, Uint128::new(12340000));\n\n        // no allowance to start\n        assert_eq!(\n            query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap(),\n            AllowanceResponse::default()\n        );\n        assert_eq!(\n            query_allowance(deps.as_ref(), owner.clone(), spender2.clone()).unwrap(),\n            AllowanceResponse::default()\n        );\n        assert_eq!(\n            query_allowance(deps.as_ref(), spender.clone(), spender2.clone()).unwrap(),\n            AllowanceResponse::default()\n        );\n\n        // set allowance with height expiration\n        let allow1 = Uint128::new(7777);\n        let expires = Expiration::AtHeight(5432);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: allow1,\n            expires: Some(expires),\n        };\n        execute(deps.as_mut(), env.clone(), info.clone(), msg).unwrap();\n\n        // set other allowance with no expiration\n        let allow2 = Uint128::new(87654);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender2.clone(),\n            amount: allow2,\n            expires: None,\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // check they are proper\n        let expect_one = AllowanceResponse {\n            allowance: allow1,\n            expires,\n        };\n        let expect_two = AllowanceResponse {\n            allowance: allow2,\n            expires: Expiration::Never {},\n        };\n        assert_eq!(\n            query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap(),\n            expect_one\n        );\n        assert_eq!(\n            query_allowance(deps.as_ref(), owner.clone(), spender2.clone()).unwrap(),\n            expect_two\n        );\n        assert_eq!(\n            query_allowance(deps.as_ref(), spender.clone(), spender2.clone()).unwrap(),\n            AllowanceResponse::default()\n        );\n\n        // also allow spender -\u003e spender2 with no interference\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let allow3 = Uint128::new(1821);\n        let expires3 = Expiration::AtTime(Timestamp::from_seconds(3767626296));\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender2.clone(),\n            amount: allow3,\n            expires: Some(expires3),\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n        let expect_three = AllowanceResponse {\n            allowance: allow3,\n            expires: expires3,\n        };\n        assert_eq!(\n            query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap(),\n            expect_one\n        );\n        assert_eq!(\n            query_allowance(deps.as_ref(), owner, spender2.clone()).unwrap(),\n            expect_two\n        );\n        assert_eq!(\n            query_allowance(deps.as_ref(), spender, spender2).unwrap(),\n            expect_three\n        );\n    }\n\n    #[test]\n    fn no_self_allowance() {\n        let mut deps = mock_dependencies_with_balance(\u0026coins(2, \"token\"));\n\n        let owner = String::from(\"addr0001\");\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        do_instantiate(deps.as_mut(), \u0026owner, Uint128::new(12340000));\n\n        // self-allowance\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: owner.clone(),\n            amount: Uint128::new(7777),\n            expires: None,\n        };\n        let err = execute(deps.as_mut(), env.clone(), info.clone(), msg).unwrap_err();\n        assert_eq!(err, ContractError::CannotSetOwnAccount {});\n\n        // decrease self-allowance\n        let msg = ExecuteMsg::DecreaseAllowance {\n            spender: owner,\n            amount: Uint128::new(7777),\n            expires: None,\n        };\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert_eq!(err, ContractError::CannotSetOwnAccount {});\n    }\n\n    #[test]\n    fn transfer_from_respects_limits() {\n        let mut deps = mock_dependencies_with_balance(\u0026[]);\n        let owner = String::from(\"addr0001\");\n        let spender = String::from(\"addr0002\");\n        let rcpt = String::from(\"addr0003\");\n\n        let start = Uint128::new(999999);\n        do_instantiate(deps.as_mut(), \u0026owner, start);\n\n        // provide an allowance\n        let allow1 = Uint128::new(77777);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: allow1,\n            expires: None,\n        };\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // valid transfer of part of the allowance\n        let transfer = Uint128::new(44444);\n        let msg = ExecuteMsg::TransferFrom {\n            owner: owner.clone(),\n            recipient: rcpt.clone(),\n            amount: transfer,\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let res = execute(deps.as_mut(), env, info, msg).unwrap();\n        assert_eq!(res.attributes[0], attr(\"action\", \"transfer_from\"));\n\n        // make sure money arrived\n        assert_eq!(\n            get_balance(deps.as_ref(), owner.clone()),\n            start.checked_sub(transfer).unwrap()\n        );\n        assert_eq!(get_balance(deps.as_ref(), rcpt.clone()), transfer);\n\n        // ensure it looks good\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        let expect = AllowanceResponse {\n            allowance: allow1.checked_sub(transfer).unwrap(),\n            expires: Expiration::Never {},\n        };\n        assert_eq!(expect, allowance);\n\n        // cannot send more than the allowance\n        let msg = ExecuteMsg::TransferFrom {\n            owner: owner.clone(),\n            recipient: rcpt.clone(),\n            amount: Uint128::new(33443),\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert!(matches!(err, ContractError::Std(StdError::Overflow { .. })));\n\n        // let us increase limit, but set the expiration (default env height is 12_345)\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: Uint128::new(1000),\n            expires: Some(Expiration::AtHeight(env.block.height)),\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // we should now get the expiration error\n        let msg = ExecuteMsg::TransferFrom {\n            owner,\n            recipient: rcpt,\n            amount: Uint128::new(33443),\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert_eq!(err, ContractError::Expired {});\n    }\n\n    #[test]\n    fn burn_from_respects_limits() {\n        let mut deps = mock_dependencies_with_balance(\u0026[]);\n        let owner = String::from(\"addr0001\");\n        let spender = String::from(\"addr0002\");\n\n        let start = Uint128::new(999999);\n        do_instantiate(deps.as_mut(), \u0026owner, start);\n\n        // provide an allowance\n        let allow1 = Uint128::new(77777);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: allow1,\n            expires: None,\n        };\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // valid burn of part of the allowance\n        let transfer = Uint128::new(44444);\n        let msg = ExecuteMsg::BurnFrom {\n            owner: owner.clone(),\n            amount: transfer,\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let res = execute(deps.as_mut(), env, info, msg).unwrap();\n        assert_eq!(res.attributes[0], attr(\"action\", \"burn_from\"));\n\n        // make sure money burnt\n        assert_eq!(\n            get_balance(deps.as_ref(), owner.clone()),\n            start.checked_sub(transfer).unwrap()\n        );\n\n        // ensure it looks good\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        let expect = AllowanceResponse {\n            allowance: allow1.checked_sub(transfer).unwrap(),\n            expires: Expiration::Never {},\n        };\n        assert_eq!(expect, allowance);\n\n        // cannot burn more than the allowance\n        let msg = ExecuteMsg::BurnFrom {\n            owner: owner.clone(),\n            amount: Uint128::new(33443),\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert!(matches!(err, ContractError::Std(StdError::Overflow { .. })));\n\n        // let us increase limit, but set the expiration (default env height is 12_345)\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: Uint128::new(1000),\n            expires: Some(Expiration::AtHeight(env.block.height)),\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // we should now get the expiration error\n        let msg = ExecuteMsg::BurnFrom {\n            owner,\n            amount: Uint128::new(33443),\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert_eq!(err, ContractError::Expired {});\n    }\n\n    #[test]\n    fn send_from_respects_limits() {\n        let mut deps = mock_dependencies_with_balance(\u0026[]);\n        let owner = String::from(\"addr0001\");\n        let spender = String::from(\"addr0002\");\n        let contract = String::from(\"cool-dex\");\n        let send_msg = Binary::from(r#\"{\"some\":123}\"#.as_bytes());\n\n        let start = Uint128::new(999999);\n        do_instantiate(deps.as_mut(), \u0026owner, start);\n\n        // provide an allowance\n        let allow1 = Uint128::new(77777);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: allow1,\n            expires: None,\n        };\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // valid send of part of the allowance\n        let transfer = Uint128::new(44444);\n        let msg = ExecuteMsg::SendFrom {\n            owner: owner.clone(),\n            amount: transfer,\n            contract: contract.clone(),\n            msg: send_msg.clone(),\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let res = execute(deps.as_mut(), env, info, msg).unwrap();\n        assert_eq!(res.attributes[0], attr(\"action\", \"send_from\"));\n        assert_eq!(1, res.messages.len());\n\n        // we record this as sent by the one who requested, not the one who was paying\n        let binary_msg = Cw20ReceiveMsg {\n            sender: spender.clone(),\n            amount: transfer,\n            msg: send_msg.clone(),\n        }\n        .into_binary()\n        .unwrap();\n        assert_eq!(\n            res.messages[0],\n            SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: contract.clone(),\n                msg: binary_msg,\n                funds: vec![],\n            }))\n        );\n\n        // make sure money sent\n        assert_eq!(\n            get_balance(deps.as_ref(), owner.clone()),\n            start.checked_sub(transfer).unwrap()\n        );\n        assert_eq!(get_balance(deps.as_ref(), contract.clone()), transfer);\n\n        // ensure it looks good\n        let allowance = query_allowance(deps.as_ref(), owner.clone(), spender.clone()).unwrap();\n        let expect = AllowanceResponse {\n            allowance: allow1.checked_sub(transfer).unwrap(),\n            expires: Expiration::Never {},\n        };\n        assert_eq!(expect, allowance);\n\n        // cannot send more than the allowance\n        let msg = ExecuteMsg::SendFrom {\n            owner: owner.clone(),\n            amount: Uint128::new(33443),\n            contract: contract.clone(),\n            msg: send_msg.clone(),\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert!(matches!(err, ContractError::Std(StdError::Overflow { .. })));\n\n        // let us increase limit, but set the expiration to current block (expired)\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender.clone(),\n            amount: Uint128::new(1000),\n            expires: Some(Expiration::AtHeight(env.block.height)),\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // we should now get the expiration error\n        let msg = ExecuteMsg::SendFrom {\n            owner,\n            amount: Uint128::new(33443),\n            contract,\n            msg: send_msg,\n        };\n        let info = mock_info(spender.as_ref(), \u0026[]);\n        let env = mock_env();\n        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();\n        assert_eq!(err, ContractError::Expired {});\n    }\n}\n","traces":[{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":9},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","lender","src","contract.rs"],"content":"use anyhow::{anyhow, Result};\n#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\nuse cosmwasm_std::{\n    from_binary, to_binary, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult, Uint128,\n};\n\nuse lender_export::msg::{ExecuteMsg, InstantiateMsg, QueryMsg, ZonesResponse};\nuse lender_export::state::{ContractInfo, State, BORROWS, CONTRACT_INFO, STATE};\n\nuse crate::error::ContractError;\nuse crate::execute::{\n    _execute_repay, execute_borrow, execute_borrow_more, execute_raise_interest_rate,\n};\nuse crate::query::{\n    get_asset_interests, get_asset_price, get_expensive_zone_limit_price,\n    get_safe_zone_limit_price, get_vault_token_asset,\n};\nuse crate::state::{set_lock, set_oracle, set_owner};\nuse cw_4626::state::AssetInfo;\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e Result\u003cResponse\u003e {\n    // We start by initating the state of the contract\n    let initial_state = State {\n        borrow_locked: false,\n    };\n\n    STATE.save(deps.storage, \u0026initial_state)?;\n\n    let vault_token = deps.api.addr_validate(\u0026msg.vault_token)?;\n    // Then the contract info\n    let contract_info = ContractInfo {\n        name: msg.name,\n        oracle: msg\n            .oracle\n            .map(|x| deps.api.addr_validate(\u0026x))\n            .transpose()?\n            .unwrap_or_else(|| info.sender.clone()),\n        owner: msg\n            .owner\n            .map(|x| deps.api.addr_validate(\u0026x))\n            .transpose()?\n            .unwrap_or(info.sender),\n        vault_token: vault_token.clone(),\n        vault_asset: get_vault_token_asset(deps.as_ref(), vault_token.to_string())?,\n        increasor_incentives: msg.increasor_incentives,\n        interests_fee_rate: msg.interests_fee_rate,\n        fee_distributor: deps.api.addr_validate(\u0026msg.fee_distributor)?,\n    };\n    CONTRACT_INFO.save(deps.storage, \u0026contract_info)?;\n\n    Ok(Response::default()\n        .add_attribute(\"action\", \"init\")\n        .add_attribute(\"contract\", \"lender\")\n        .add_attribute(\"owner\", contract_info.owner))\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg) -\u003e Result\u003cResponse\u003e {\n    match msg {\n        // Functions used to borrow funds\n        ExecuteMsg::Borrow {\n            asset_info,\n            assets_to_borrow,\n            borrow_mode,\n        } =\u003e execute_borrow(deps, env, info, asset_info, assets_to_borrow, borrow_mode),\n        ExecuteMsg::BorrowMore {\n            loan_id,\n            assets_to_borrow,\n        } =\u003e execute_borrow_more(deps, env, info, loan_id, assets_to_borrow),\n\n        // Functions used to repay or liquidate loans\n        ExecuteMsg::Receive {\n            sender,\n            amount,\n            msg,\n        } =\u003e receive_assets(deps, env, info, sender, amount, msg),\n\n        ExecuteMsg::Repay {\n            borrower,\n            loan_id,\n            assets,\n        } =\u003e execute_repay_native_funds(deps, env, info, borrower, loan_id, assets),\n\n        // Function used to raise the interests rate\n        ExecuteMsg::RaiseRate { borrower, loan_id } =\u003e {\n            execute_raise_interest_rate(deps, env, info, borrower, loan_id)\n        }\n\n        // Contract Administration\n        ExecuteMsg::SetOwner { owner } =\u003e set_owner(deps, info, owner),\n        ExecuteMsg::SetOracle { oracle } =\u003e set_oracle(deps, info, oracle),\n        ExecuteMsg::ToggleLock { lock } =\u003e set_lock(deps, info, lock),\n    }\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, env: Env, msg: QueryMsg) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::State {} =\u003e to_binary(\u0026STATE.load(deps.storage)?),\n        QueryMsg::ContratInfo {} =\u003e to_binary(\u0026CONTRACT_INFO.load(deps.storage)?),\n        QueryMsg::BorrowInfo { borrower, loan_id } =\u003e {\n            let borrower = deps.api.addr_validate(\u0026borrower)?;\n            to_binary(\u0026BORROWS.load(deps.storage, (\u0026borrower, loan_id))?)\n        }\n        QueryMsg::BorrowZones { asset_info } =\u003e {\n            let collateral_price = get_asset_price(deps, env, asset_info)?;\n            let safe_zone_limit = get_safe_zone_limit_price(collateral_price)?;\n            let expensive_zone_limit = get_expensive_zone_limit_price(collateral_price)?;\n            to_binary(\u0026ZonesResponse {\n                safe_zone_limit,\n                expensive_zone_limit,\n            })\n        }\n        QueryMsg::BorrowTerms {\n            asset_info,\n            borrow_mode,\n            borrow_zone,\n        } =\u003e to_binary(\u0026get_asset_interests(\n            deps,\n            env,\n            asset_info,\n            borrow_mode,\n            borrow_zone,\n        )?),\n    }\n}\n\npub fn receive_assets(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    sender: String,\n    amount: Uint128,\n    msg: Binary,\n) -\u003e Result\u003cResponse\u003e {\n    match from_binary(\u0026msg)? {\n        ExecuteMsg::Repay {\n            borrower,\n            loan_id,\n            assets,\n        } =\u003e {\n            // This function can accept a Cw20 Token solely\n            // We make sure the sent assets correspond to the vault saved\n            let contract_info = CONTRACT_INFO.load(deps.storage)?;\n            if let AssetInfo::Cw20(x) = contract_info.vault_asset {\n                if deps.api.addr_validate(\u0026x)? != info.sender {\n                    return Err(anyhow!(ContractError::AssetsSentDontMatch {}));\n                }\n            } else {\n                return Err(anyhow!(ContractError::AssetsSentDontMatch {}));\n            }\n\n            // We make sure the amount sent is the amount specified in the repay message\n            if assets != amount {\n                return Err(anyhow!(ContractError::AssetsSentDontMatch {}));\n            }\n\n            let sender = deps.api.addr_validate(\u0026sender)?;\n            // We now call the repay function accordingly\n            _execute_repay(deps, env, sender, borrower, loan_id, assets)\n        }\n        _ =\u003e Err(anyhow!(ContractError::ReceiveMsgNotAccepted {})),\n    }\n}\n\npub fn execute_repay_native_funds(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    borrower: String,\n    loan_id: u64,\n    assets: Uint128,\n) -\u003e Result\u003cResponse\u003e {\n    let contract_info = CONTRACT_INFO.load(deps.storage)?;\n    // We test that the funds sent match the assets\n    if info.funds.len() != 1 {\n        return Err(anyhow!(ContractError::AssetsSentDontMatch {}));\n    }\n\n    // This function can accept a native tokens solely\n    // We make sure the sent assets correspond to the vault saved\n    if let AssetInfo::Coin(x) = contract_info.vault_asset {\n        if x != info.funds[0].denom {\n            return Err(anyhow!(ContractError::AssetsSentDontMatch {}));\n        }\n    } else {\n        return Err(anyhow!(ContractError::AssetsSentDontMatch {}));\n    }\n    // We make sure the amount sent is the amount specified in the repay message\n    if assets != info.funds[0].amount {\n        return Err(anyhow!(ContractError::AssetsSentDontMatch {}));\n    }\n\n    // We now call the repay function accordingly\n    _execute_repay(deps, env, info.sender, borrower, loan_id, assets)\n}\n\n#[cfg(test)]\npub mod tests {\n    use super::*;\n    use crate::contract::instantiate;\n    use crate::custom_mock_querier::tests::mock_dependencies;\n    use crate::error::ContractError;\n    use cosmwasm_std::testing::{mock_env, mock_info};\n    use cosmwasm_std::{coins, Api, Coin, CosmosMsg, DepsMut, Uint128, WasmMsg};\n    use cw721::Cw721ExecuteMsg;\n    use cw_4626::msg::ExecuteMsg as Cw4626ExecuteMsg;\n    use fee_distributor_export::msg::ExecuteMsg as DistributorExecuteMsg;\n    use lender_export::msg::InstantiateMsg;\n    use lender_export::state::{BorrowMode, Cw721Info};\n    use utils::msg::into_cosmos_msg;\n\n    fn init_helper(deps: DepsMut) {\n        let instantiate_msg = InstantiateMsg {\n            name: \"Iliq treasury token\".to_string(),\n            owner: Some(\"creator\".to_string()),\n            oracle: Some(\"oracle\".to_string()),\n            vault_token: \"vault_token\".to_string(),\n            increasor_incentives: Uint128::from(100u128),\n            interests_fee_rate: Uint128::from(1_000u128),\n            fee_distributor: \"distributor\".to_string(),\n        };\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n\n        instantiate(deps, env, info, instantiate_msg).unwrap();\n    }\n\n    fn borrow_helper(\n        deps: DepsMut,\n        sender: \u0026str,\n        nft_address: \u0026str,\n        token_id: \u0026str,\n        assets: Vec\u003cCoin\u003e,\n        principle: u128,\n    ) -\u003e Result\u003cResponse\u003e {\n        let info = mock_info(sender, \u0026assets);\n        let env = mock_env();\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::Borrow {\n                asset_info: Cw721Info {\n                    nft_address: nft_address.to_string(),\n                    token_id: token_id.to_string(),\n                },\n                assets_to_borrow: Uint128::from(principle),\n                borrow_mode: BorrowMode::Fixed,\n            },\n        )\n    }\n\n    fn borrow_continuous_helper(\n        deps: DepsMut,\n        sender: \u0026str,\n        nft_address: \u0026str,\n        token_id: \u0026str,\n        assets: Vec\u003cCoin\u003e,\n        principle: u128,\n    ) -\u003e Result\u003cResponse\u003e {\n        let info = mock_info(sender, \u0026assets);\n        let env = mock_env();\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::Borrow {\n                asset_info: Cw721Info {\n                    nft_address: nft_address.to_string(),\n                    token_id: token_id.to_string(),\n                },\n                assets_to_borrow: Uint128::from(principle),\n                borrow_mode: BorrowMode::Continuous,\n            },\n        )\n    }\n\n    fn borrow_more_helper(\n        deps: DepsMut,\n        sender: \u0026str,\n        loan_id: u64,\n        assets: Vec\u003cCoin\u003e,\n        principle: u128,\n    ) -\u003e Result\u003cResponse\u003e {\n        let info = mock_info(sender, \u0026assets);\n        let env = mock_env();\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::BorrowMore {\n                loan_id,\n                assets_to_borrow: Uint128::from(principle),\n            },\n        )\n    }\n\n    fn repay_helper(\n        deps: DepsMut,\n        address: \u0026str,\n        borrower: \u0026str,\n        loan_id: u64,\n        assets: u128,\n        block_height_delay: Option\u003cu64\u003e,\n    ) -\u003e Result\u003cResponse\u003e {\n        let mut env = mock_env();\n        if let Some(block_height) = block_height_delay {\n            env.block.height += block_height\n        }\n\n        let info = mock_info(address, \u0026coins(assets, \"utest\"));\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::Repay {\n                borrower: borrower.to_string(),\n                loan_id,\n                assets: Uint128::from(assets),\n            },\n        )\n    }\n\n    #[test]\n    fn test_init_sanity() {\n        let mut deps = mock_dependencies(\u0026[]);\n        init_helper(deps.as_mut());\n    }\n\n    #[test]\n    fn test_borrow_sanity() {\n        let mut deps = mock_dependencies(\u0026[]);\n        init_helper(deps.as_mut());\n\n        let err = borrow_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"nft\",\n            \"token_id\",\n            vec![],\n            8_600_000_000u128,\n        )\n        .unwrap_err();\n        assert_eq!(\n            err.downcast::\u003cContractError\u003e().unwrap(),\n            ContractError::TooMuchBorrowed {\n                collateral_address: \"nft\".to_string(),\n                wanted: Uint128::from(8_600_000_000u128),\n                limit: Uint128::from(53661300u128)\n            }\n        );\n\n        let res = borrow_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"nft\",\n            \"token_id\",\n            vec![],\n            8742u128,\n        )\n        .unwrap();\n        assert_eq!(\n            res,\n            Response::new()\n                .add_message(\n                    into_cosmos_msg(\n                        Cw721ExecuteMsg::TransferNft {\n                            recipient: \"cosmos2contract\".to_string(),\n                            token_id: \"token_id\".to_string(),\n                        },\n                        \"nft\".to_string(),\n                        None\n                    )\n                    .unwrap()\n                )\n                .add_message(\n                    into_cosmos_msg(\n                        Cw4626ExecuteMsg::Borrow {\n                            receiver: \"creator\".to_string(),\n                            assets: Uint128::from(8742u128)\n                        },\n                        \"vault_token\".to_string(),\n                        None\n                    )\n                    .unwrap()\n                )\n                .add_attribute(\"action\", \"borrow\")\n                .add_attribute(\"collateral_address\", \"nft\")\n                .add_attribute(\"collateral_token_id\", \"token_id\")\n                .add_attribute(\"borrower\", \"creator\")\n        );\n\n        // We verify the internal structure has changed\n        let borrower = deps.api.addr_validate(\"creator\").unwrap();\n        assert_eq!(\n            BORROWS\n                .load(\u0026deps.storage, (\u0026borrower, 0u64))\n                .unwrap()\n                .principle,\n            Uint128::from(8742u128)\n        )\n    }\n\n    #[test]\n    fn test_repay_sanity() {\n        let mut deps = mock_dependencies(\u0026[]);\n        init_helper(deps.as_mut());\n\n        // If the person is not the creator, it can't liquidate before the duration ends\n        borrow_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"nft\",\n            \"token_id\",\n            vec![],\n            8742u128,\n        )\n        .unwrap();\n        let err = repay_helper(\n            deps.as_mut(),\n            \"bad_guy\",\n            \"creator\",\n            0u64,\n            8742u128 + 67u128,\n            None,\n        )\n        .unwrap_err();\n        assert_eq!(\n            err.downcast::\u003cContractError\u003e().unwrap(),\n            ContractError::CannotLiquidateBeforeDefault {}\n        );\n\n        // If the loan doesn't exist it should return an error\n        repay_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"anyone\",\n            0u64,\n            8742u128 + 67u128,\n            None,\n        )\n        .unwrap_err();\n\n        // We should return the asset to the borrower at then end of the loan\n        let res = repay_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"creator\",\n            0u64,\n            8742u128 + 67u128,\n            None,\n        )\n        .unwrap();\n\n        // We print the messages for debugging\n        res.messages.iter().for_each(|x| {\n            if let CosmosMsg::Wasm(WasmMsg::Execute { msg, .. }) = x.msg.clone() {\n                println!(\"{:?}\", std::str::from_utf8(msg.as_slice()));\n            }\n        });\n\n        assert_eq!(\n            res,\n            Response::new()\n                .add_message(\n                    into_cosmos_msg(\n                        Cw721ExecuteMsg::TransferNft {\n                            recipient: \"creator\".to_string(),\n                            token_id: \"token_id\".to_string(),\n                        },\n                        \"nft\".to_string(),\n                        None\n                    )\n                    .unwrap()\n                )\n                .add_message(\n                    into_cosmos_msg(\n                        DistributorExecuteMsg::DepositFees {\n                            addresses: vec![\"nft\".to_string()],\n                        },\n                        \"distributor\".to_string(),\n                        Some(coins(6u128, \"utest\"))\n                    )\n                    .unwrap()\n                )\n                .add_message(\n                    into_cosmos_msg(\n                        Cw4626ExecuteMsg::Repay {\n                            owner: None,\n                            assets: Uint128::from(8803u128)\n                        },\n                        \"vault_token\".to_string(),\n                        Some(coins(8803u128, \"utest\"))\n                    )\n                    .unwrap()\n                )\n                .add_attribute(\"action\", \"repay\")\n                .add_attribute(\"caller\", \"creator\")\n                .add_attribute(\"borrower\", \"creator\")\n                .add_attribute(\"assets\", 8809u128.to_string())\n                .add_attribute(\"collateral_withdrawn\", \"true\")\n        );\n        let err = repay_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"creator\",\n            0u64,\n            8742u128 + 67u128,\n            None,\n        )\n        .unwrap_err();\n        assert_eq!(\n            err.downcast::\u003cContractError\u003e().unwrap(),\n            ContractError::AssetAlreadyWithdrawn {}\n        );\n    }\n\n    #[test]\n    fn test_liquidate_sanity() {\n        let mut deps = mock_dependencies(\u0026[]);\n        init_helper(deps.as_mut());\n\n        // If the person is not the creator, it can't liquidate before the duration ends\n        borrow_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"nft\",\n            \"token_id\",\n            vec![],\n            8742u128,\n        )\n        .unwrap();\n\n        repay_helper(\n            deps.as_mut(),\n            \"bad_guy\",\n            \"creator\",\n            0u64,\n            8742u128 + 67u128,\n            None,\n        )\n        .unwrap_err();\n\n        // We allow the querier to deliver response from the vault token\n        let err = repay_helper(\n            deps.as_mut(),\n            \"bad_guy\",\n            \"creator\",\n            0u64,\n            8u128,\n            Some(765u64),\n        )\n        .unwrap_err();\n        assert_eq!(\n            err.downcast::\u003cContractError\u003e().unwrap(),\n            ContractError::CanOnlyLiquidateWholeLoan {}\n        );\n\n        let res = repay_helper(\n            deps.as_mut(),\n            \"bad_guy\",\n            \"creator\",\n            0u64,\n            8742u128 + 67u128,\n            Some(765u64),\n        )\n        .unwrap();\n        // We print the messages for debugging\n        res.messages.iter().for_each(|x| {\n            if let CosmosMsg::Wasm(WasmMsg::Execute { msg, .. }) = x.msg.clone() {\n                println!(\"{:?}\", std::str::from_utf8(msg.as_slice()));\n            }\n        });\n\n        assert_eq!(\n            res,\n            Response::new()\n                .add_message(\n                    into_cosmos_msg(\n                        Cw721ExecuteMsg::TransferNft {\n                            recipient: \"bad_guy\".to_string(),\n                            token_id: \"token_id\".to_string(),\n                        },\n                        \"nft\".to_string(),\n                        None\n                    )\n                    .unwrap()\n                )\n                .add_message(\n                    into_cosmos_msg(\n                        DistributorExecuteMsg::DepositFees {\n                            addresses: vec![\"nft\".to_string()],\n                        },\n                        \"distributor\".to_string(),\n                        Some(coins(6u128, \"utest\"))\n                    )\n                    .unwrap()\n                )\n                .add_message(\n                    into_cosmos_msg(\n                        Cw4626ExecuteMsg::Repay {\n                            owner: None,\n                            assets: Uint128::from(8803u128)\n                        },\n                        \"vault_token\".to_string(),\n                        Some(coins(8803u128, \"utest\"))\n                    )\n                    .unwrap()\n                )\n                .add_attribute(\"action\", \"repay\")\n                .add_attribute(\"caller\", \"bad_guy\")\n                .add_attribute(\"borrower\", \"creator\")\n                .add_attribute(\"assets\", 8809u128.to_string())\n                .add_attribute(\"collateral_withdrawn\", \"true\")\n        );\n    }\n\n    #[test]\n    fn test_no_borrow_fixed() {\n        let mut deps = mock_dependencies(\u0026[]);\n        init_helper(deps.as_mut());\n\n        borrow_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"nft\",\n            \"token_id\",\n            vec![],\n            50_000_000u128,\n        )\n        .unwrap();\n\n        // You can't borrow too much funds for a unique collateral\n        borrow_more_helper(deps.as_mut(), \"creator\", 0u64, vec![], 50_000_000u128).unwrap_err();\n\n        borrow_more_helper(deps.as_mut(), \"creator\", 0u64, vec![], 1_000_000u128).unwrap_err();\n    }\n\n    #[test]\n    fn test_borrow_more_sanity() {\n        let mut deps = mock_dependencies(\u0026[]);\n        init_helper(deps.as_mut());\n\n        borrow_continuous_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"nft\",\n            \"token_id\",\n            vec![],\n            50_000_000u128,\n        )\n        .unwrap();\n\n        // You can't borrow too much funds for a unique collateral\n        borrow_more_helper(deps.as_mut(), \"creator\", 0u64, vec![], 50_000_000u128).unwrap_err();\n\n        let res =\n            borrow_more_helper(deps.as_mut(), \"creator\", 0u64, vec![], 1_000_000u128).unwrap();\n\n        assert_eq!(\n            res,\n            Response::new()\n                .add_message(\n                    into_cosmos_msg(\n                        Cw4626ExecuteMsg::Borrow {\n                            receiver: \"creator\".to_string(),\n                            assets: Uint128::from(1_000_000u128),\n                        },\n                        \"vault_token\".to_string(),\n                        None,\n                    )\n                    .unwrap()\n                )\n                .add_attribute(\"action\", \"borrow\")\n                .add_attribute(\"borrower\", \"creator\")\n                .add_attribute(\"loan_id\", \"0\")\n                .add_attribute(\"asset_borrowed\", \"1000000\")\n        );\n\n        // We verify the internal structure has changed\n        let borrower = deps.api.addr_validate(\"creator\").unwrap();\n        assert_eq!(\n            BORROWS\n                .load(\u0026deps.storage, (\u0026borrower, 0u64))\n                .unwrap()\n                .principle,\n            Uint128::from(51_000_000u128)\n        )\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","lender","src","custom_mock_querier.rs"],"content":"#[cfg(test)]\npub mod tests {\n    use cosmwasm_std::testing::{\n        MockApi, MockQuerierCustomHandlerResult, MockStorage, MOCK_CONTRACT_ADDR,\n    };\n\n    use cosmwasm_std::{\n        from_binary, from_slice, to_binary, AllBalanceResponse, BalanceResponse, BankQuery, Binary,\n        Coin, ContractResult, CustomQuery, Empty, OwnedDeps, Querier, QuerierResult, QueryRequest,\n        SystemError, SystemResult, WasmQuery,\n    };\n\n    use serde::de::DeserializeOwned;\n    use std::collections::HashMap;\n    use std::marker::PhantomData;\n\n    use cw_4626::query::QueryMsg as Cw4626QueryMsg;\n    use cw_4626::state::AssetInfo;\n\n    // All external requirements that can be injected for unit tests.\n    /// It sets the given balance for the contract itself, nothing else\n    pub fn mock_dependencies(\n        contract_balance: \u0026[Coin],\n    ) -\u003e OwnedDeps\u003cMockStorage, MockApi, MockQuerier\u003e {\n        OwnedDeps {\n            storage: MockStorage::default(),\n            api: MockApi::default(),\n            querier: MockQuerier::new(\u0026[(MOCK_CONTRACT_ADDR, contract_balance)]),\n            custom_query_type: PhantomData,\n        }\n    }\n\n    /// MockQuerier holds an immutable table of bank balances\n    pub struct MockQuerier\u003cC: DeserializeOwned = Empty\u003e {\n        bank: BankQuerier,\n        #[cfg(feature = \"staking\")]\n        staking: StakingQuerier,\n        // placeholder to add support later\n        wasm: CustomWasmQuerier,\n        /// A handler to handle custom queries. This is set to a dummy handler that\n        /// always errors by default. Update it via `with_custom_handler`.\n        ///\n        /// Use box to avoid the need of another generic type\n        custom_handler: Box\u003cdyn for\u003c'a\u003e Fn(\u0026'a C) -\u003e MockQuerierCustomHandlerResult\u003e,\n    }\n\n    impl\u003cC: DeserializeOwned\u003e MockQuerier\u003cC\u003e {\n        pub fn new(balances: \u0026[(\u0026str, \u0026[Coin])]) -\u003e Self {\n            MockQuerier {\n                bank: BankQuerier::new(balances),\n                #[cfg(feature = \"staking\")]\n                staking: StakingQuerier::default(),\n                wasm: CustomWasmQuerier {},\n                // strange argument notation suggested as a workaround here: https://github.com/rust-lang/rust/issues/41078#issuecomment-294296365\n                custom_handler: Box::from(|_: \u0026_| -\u003e MockQuerierCustomHandlerResult {\n                    SystemResult::Err(SystemError::UnsupportedRequest {\n                        kind: \"custom\".to_string(),\n                    })\n                }),\n            }\n        }\n\n        // set a new balance for the given address and return the old balance\n        pub fn update_balance(\n            \u0026mut self,\n            addr: impl Into\u003cString\u003e,\n            balance: Vec\u003cCoin\u003e,\n        ) -\u003e Option\u003cVec\u003cCoin\u003e\u003e {\n            self.bank.balances.insert(addr.into(), balance)\n        }\n\n        #[cfg(feature = \"staking\")]\n        pub fn update_staking(\n            \u0026mut self,\n            denom: \u0026str,\n            validators: \u0026[crate::query::Validator],\n            delegations: \u0026[crate::query::FullDelegation],\n        ) {\n            self.staking = StakingQuerier::new(denom, validators, delegations);\n        }\n\n        pub fn with_custom_handler\u003cCH: 'static\u003e(mut self, handler: CH) -\u003e Self\n        where\n            CH: Fn(\u0026C) -\u003e MockQuerierCustomHandlerResult,\n        {\n            self.custom_handler = Box::from(handler);\n            self\n        }\n    }\n\n    impl\u003cC: CustomQuery + DeserializeOwned\u003e Querier for MockQuerier\u003cC\u003e {\n        fn raw_query(\u0026self, bin_request: \u0026[u8]) -\u003e QuerierResult {\n            let request: QueryRequest\u003cC\u003e = match from_slice(bin_request) {\n                Ok(v) =\u003e v,\n                Err(e) =\u003e {\n                    return SystemResult::Err(SystemError::InvalidRequest {\n                        error: format!(\"Parsing query request: {}\", e),\n                        request: bin_request.into(),\n                    })\n                }\n            };\n            self.handle_query(\u0026request)\n        }\n    }\n\n    impl\u003cC: CustomQuery + DeserializeOwned\u003e MockQuerier\u003cC\u003e {\n        pub fn handle_query(\u0026self, request: \u0026QueryRequest\u003cC\u003e) -\u003e QuerierResult {\n            match \u0026request {\n                QueryRequest::Bank(bank_query) =\u003e self.bank.query(bank_query),\n                QueryRequest::Custom(custom_query) =\u003e (*self.custom_handler)(custom_query),\n                #[cfg(feature = \"staking\")]\n                QueryRequest::Staking(staking_query) =\u003e self.staking.query(staking_query),\n                QueryRequest::Wasm(msg) =\u003e self.wasm.query(msg),\n                #[cfg(feature = \"stargate\")]\n                QueryRequest::Stargate { .. } =\u003e {\n                    SystemResult::Err(SystemError::UnsupportedRequest {\n                        kind: \"Stargate\".to_string(),\n                    })\n                }\n                #[cfg(feature = \"stargate\")]\n                QueryRequest::Ibc(_) =\u003e SystemResult::Err(SystemError::UnsupportedRequest {\n                    kind: \"Ibc\".to_string(),\n                }),\n                _ =\u003e SystemResult::Err(SystemError::UnsupportedRequest {\n                    kind: \"custom\".to_string(),\n                }),\n            }\n        }\n    }\n\n    #[derive(Clone, Default)]\n    pub struct BankQuerier {\n        balances: HashMap\u003cString, Vec\u003cCoin\u003e\u003e,\n    }\n\n    impl BankQuerier {\n        pub fn new(balances: \u0026[(\u0026str, \u0026[Coin])]) -\u003e Self {\n            let mut map = HashMap::new();\n            for (addr, coins) in balances.iter() {\n                map.insert(addr.to_string(), coins.to_vec());\n            }\n            BankQuerier { balances: map }\n        }\n\n        pub fn query(\u0026self, request: \u0026BankQuery) -\u003e QuerierResult {\n            let contract_result: ContractResult\u003cBinary\u003e = match request {\n                BankQuery::Balance { address, denom } =\u003e {\n                    // proper error on not found, serialize result on found\n                    let amount = self\n                        .balances\n                        .get(address)\n                        .and_then(|v| v.iter().find(|c| \u0026c.denom == denom).map(|c| c.amount))\n                        .unwrap_or_default();\n                    let bank_res = BalanceResponse {\n                        amount: Coin {\n                            amount,\n                            denom: denom.to_string(),\n                        },\n                    };\n                    to_binary(\u0026bank_res).into()\n                }\n                BankQuery::AllBalances { address } =\u003e {\n                    // proper error on not found, serialize result on found\n                    let bank_res = AllBalanceResponse {\n                        amount: self.balances.get(address).cloned().unwrap_or_default(),\n                    };\n                    to_binary(\u0026bank_res).into()\n                }\n                _ =\u003e {\n                    return SystemResult::Err(SystemError::UnsupportedRequest {\n                        kind: \"custom\".to_string(),\n                    })\n                }\n            };\n            // system result is always ok in the mock implementation\n            SystemResult::Ok(contract_result)\n        }\n    }\n\n    #[cfg(feature = \"staking\")]\n    #[derive(Clone, Default)]\n    pub struct StakingQuerier {\n        denom: String,\n        validators: Vec\u003cValidator\u003e,\n        delegations: Vec\u003cFullDelegation\u003e,\n    }\n\n    #[cfg(feature = \"staking\")]\n    impl StakingQuerier {\n        pub fn new(denom: \u0026str, validators: \u0026[Validator], delegations: \u0026[FullDelegation]) -\u003e Self {\n            StakingQuerier {\n                denom: denom.to_string(),\n                validators: validators.to_vec(),\n                delegations: delegations.to_vec(),\n            }\n        }\n\n        pub fn query(\u0026self, request: \u0026StakingQuery) -\u003e QuerierResult {\n            let contract_result: ContractResult\u003cBinary\u003e = match request {\n                StakingQuery::BondedDenom {} =\u003e {\n                    let res = BondedDenomResponse {\n                        denom: self.denom.clone(),\n                    };\n                    to_binary(\u0026res).into()\n                }\n                StakingQuery::AllValidators {} =\u003e {\n                    let res = AllValidatorsResponse {\n                        validators: self.validators.clone(),\n                    };\n                    to_binary(\u0026res).into()\n                }\n                StakingQuery::Validator { address } =\u003e {\n                    let validator: Option\u003cValidator\u003e = self\n                        .validators\n                        .iter()\n                        .find(|validator| validator.address == *address)\n                        .cloned();\n                    let res = ValidatorResponse { validator };\n                    to_binary(\u0026res).into()\n                }\n                StakingQuery::AllDelegations { delegator } =\u003e {\n                    let delegations: Vec\u003c_\u003e = self\n                        .delegations\n                        .iter()\n                        .filter(|d| d.delegator.as_str() == delegator)\n                        .cloned()\n                        .map(|d| d.into())\n                        .collect();\n                    let res = AllDelegationsResponse { delegations };\n                    to_binary(\u0026res).into()\n                }\n                StakingQuery::Delegation {\n                    delegator,\n                    validator,\n                } =\u003e {\n                    let delegation = self\n                        .delegations\n                        .iter()\n                        .find(|d| d.delegator.as_str() == delegator \u0026\u0026 d.validator == *validator);\n                    let res = DelegationResponse {\n                        delegation: delegation.cloned(),\n                    };\n                    to_binary(\u0026res).into()\n                }\n            };\n            // system result is always ok in the mock implementation\n            SystemResult::Ok(contract_result)\n        }\n    }\n\n    #[derive(Clone, Default)]\n    struct CustomWasmQuerier {\n        // FIXME: actually provide a way to call out\n    }\n\n    impl CustomWasmQuerier {\n        fn query(\u0026self, request: \u0026WasmQuery) -\u003e QuerierResult {\n            match request {\n                WasmQuery::Smart { contract_addr, msg } =\u003e {\n                    if contract_addr == \"vault_token\" {\n                        let msg: Cw4626QueryMsg = from_binary(msg).unwrap();\n                        match msg {\n                            Cw4626QueryMsg::Asset {} =\u003e {\n                                let contract_result: ContractResult\u003cBinary\u003e =\n                                    to_binary(\u0026AssetInfo::Coin(\"utest\".to_string())).into();\n                                SystemResult::Ok(contract_result)\n                            }\n                            _ =\u003e SystemResult::Err(SystemError::UnsupportedRequest {\n                                kind: \"message of vault token\".to_string(),\n                            }),\n                        }\n                    } else {\n                        SystemResult::Err(SystemError::NoSuchContract {\n                            addr: contract_addr.clone(),\n                        })\n                    }\n                }\n                _ =\u003e SystemResult::Err(SystemError::UnsupportedRequest {\n                    kind: \"custom\".to_string(),\n                }),\n            }\n        }\n    }\n}\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":30},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","lender","src","enumerable.rs"],"content":"use cosmwasm_std::{Deps, Order, StdResult};\nuse cw20::{AllAccountsResponse, AllAllowancesResponse, AllowanceInfo};\n\nuse crate::state::{ALLOWANCES, BALANCES};\nuse cw_storage_plus::Bound;\n\n// settings for pagination\nconst MAX_LIMIT: u32 = 30;\nconst DEFAULT_LIMIT: u32 = 10;\n\npub fn query_all_allowances(\n    deps: Deps,\n    owner: String,\n    start_after: Option\u003cString\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e StdResult\u003cAllAllowancesResponse\u003e {\n    let owner_addr = deps.api.addr_validate(\u0026owner)?;\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n    let start = start_after.map(|s| Bound::ExclusiveRaw(s.into_bytes()));\n\n    let allowances = ALLOWANCES\n        .prefix(\u0026owner_addr)\n        .range(deps.storage, start, None, Order::Ascending)\n        .take(limit)\n        .map(|item| {\n            item.map(|(addr, allow)| AllowanceInfo {\n                spender: addr.into(),\n                allowance: allow.allowance,\n                expires: allow.expires,\n            })\n        })\n        .collect::\u003cStdResult\u003c_\u003e\u003e()?;\n    Ok(AllAllowancesResponse { allowances })\n}\n\npub fn query_all_accounts(\n    deps: Deps,\n    start_after: Option\u003cString\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e StdResult\u003cAllAccountsResponse\u003e {\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n    let start = start_after.map(|s| Bound::ExclusiveRaw(s.into()));\n\n    let accounts = BALANCES\n        .keys(deps.storage, start, None, Order::Ascending)\n        .take(limit)\n        .map(|item| item.map(Into::into))\n        .collect::\u003cStdResult\u003c_\u003e\u003e()?;\n\n    Ok(AllAccountsResponse { accounts })\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use cosmwasm_std::testing::{mock_dependencies_with_balance, mock_env, mock_info};\n    use cosmwasm_std::{coins, DepsMut, Uint128};\n    use cw20::{Cw20Coin, Expiration, TokenInfoResponse};\n\n    use crate::contract::{execute, instantiate, query_token_info};\n    use crate::msg::{ExecuteMsg, InstantiateMsg};\n\n    // this will set up the instantiation for other tests\n    fn do_instantiate(mut deps: DepsMut, addr: \u0026str, amount: Uint128) -\u003e TokenInfoResponse {\n        let instantiate_msg = InstantiateMsg {\n            name: \"Auto Gen\".to_string(),\n            symbol: \"AUTO\".to_string(),\n            decimals: 3,\n            initial_balances: vec![Cw20Coin {\n                address: addr.into(),\n                amount,\n            }],\n            mint: None,\n            marketing: None,\n        };\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n        instantiate(deps.branch(), env, info, instantiate_msg).unwrap();\n        query_token_info(deps.as_ref()).unwrap()\n    }\n\n    #[test]\n    fn query_all_allowances_works() {\n        let mut deps = mock_dependencies_with_balance(\u0026coins(2, \"token\"));\n\n        let owner = String::from(\"owner\");\n        // these are in alphabetical order same than insert order\n        let spender1 = String::from(\"earlier\");\n        let spender2 = String::from(\"later\");\n\n        let info = mock_info(owner.as_ref(), \u0026[]);\n        let env = mock_env();\n        do_instantiate(deps.as_mut(), \u0026owner, Uint128::new(12340000));\n\n        // no allowance to start\n        let allowances = query_all_allowances(deps.as_ref(), owner.clone(), None, None).unwrap();\n        assert_eq!(allowances.allowances, vec![]);\n\n        // set allowance with height expiration\n        let allow1 = Uint128::new(7777);\n        let expires = Expiration::AtHeight(5432);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender1.clone(),\n            amount: allow1,\n            expires: Some(expires),\n        };\n        execute(deps.as_mut(), env.clone(), info.clone(), msg).unwrap();\n\n        // set allowance with no expiration\n        let allow2 = Uint128::new(54321);\n        let msg = ExecuteMsg::IncreaseAllowance {\n            spender: spender2.clone(),\n            amount: allow2,\n            expires: None,\n        };\n        execute(deps.as_mut(), env, info, msg).unwrap();\n\n        // query list gets 2\n        let allowances = query_all_allowances(deps.as_ref(), owner.clone(), None, None).unwrap();\n        assert_eq!(allowances.allowances.len(), 2);\n\n        // first one is spender1 (order of CanonicalAddr uncorrelated with String)\n        let allowances = query_all_allowances(deps.as_ref(), owner.clone(), None, Some(1)).unwrap();\n        assert_eq!(allowances.allowances.len(), 1);\n        let allow = \u0026allowances.allowances[0];\n        assert_eq!(\u0026allow.spender, \u0026spender1);\n        assert_eq!(\u0026allow.expires, \u0026expires);\n        assert_eq!(\u0026allow.allowance, \u0026allow1);\n\n        // next one is spender2\n        let allowances = query_all_allowances(\n            deps.as_ref(),\n            owner,\n            Some(allow.spender.clone()),\n            Some(10000),\n        )\n        .unwrap();\n        assert_eq!(allowances.allowances.len(), 1);\n        let allow = \u0026allowances.allowances[0];\n        assert_eq!(\u0026allow.spender, \u0026spender2);\n        assert_eq!(\u0026allow.expires, \u0026Expiration::Never {});\n        assert_eq!(\u0026allow.allowance, \u0026allow2);\n    }\n\n    #[test]\n    fn query_all_accounts_works() {\n        let mut deps = mock_dependencies_with_balance(\u0026coins(2, \"token\"));\n\n        // insert order and lexicographical order are different\n        let acct1 = String::from(\"acct01\");\n        let acct2 = String::from(\"zebra\");\n        let acct3 = String::from(\"nice\");\n        let acct4 = String::from(\"aaaardvark\");\n        let expected_order = [acct4.clone(), acct1.clone(), acct3.clone(), acct2.clone()];\n\n        do_instantiate(deps.as_mut(), \u0026acct1, Uint128::new(12340000));\n\n        // put money everywhere (to create balanaces)\n        let info = mock_info(acct1.as_ref(), \u0026[]);\n        let env = mock_env();\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            ExecuteMsg::Transfer {\n                recipient: acct2,\n                amount: Uint128::new(222222),\n            },\n        )\n        .unwrap();\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            ExecuteMsg::Transfer {\n                recipient: acct3,\n                amount: Uint128::new(333333),\n            },\n        )\n        .unwrap();\n        execute(\n            deps.as_mut(),\n            env,\n            info,\n            ExecuteMsg::Transfer {\n                recipient: acct4,\n                amount: Uint128::new(444444),\n            },\n        )\n        .unwrap();\n\n        // make sure we get the proper results\n        let accounts = query_all_accounts(deps.as_ref(), None, None).unwrap();\n        assert_eq!(accounts.accounts, expected_order);\n\n        // let's do pagination\n        let accounts = query_all_accounts(deps.as_ref(), None, Some(2)).unwrap();\n        assert_eq!(accounts.accounts, expected_order[0..2].to_vec());\n\n        let accounts =\n            query_all_accounts(deps.as_ref(), Some(accounts.accounts[1].clone()), Some(1)).unwrap();\n        assert_eq!(accounts.accounts, expected_order[2..3].to_vec());\n\n        let accounts =\n            query_all_accounts(deps.as_ref(), Some(accounts.accounts[0].clone()), Some(777))\n                .unwrap();\n        assert_eq!(accounts.accounts, expected_order[3..].to_vec());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","lender","src","error.rs"],"content":"use cosmwasm_std::{StdError, Uint128};\nuse thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized {},\n\n    #[error(\"The contract doesn't accept borrowing. You can only repay your debts\")]\n    BorrowLocked {},\n\n    #[error(\"You can't borrow more than the borrow limit on this asset. Asset: {collateral_address}, wanted: {wanted:?}, limit: {limit:?}\")]\n    TooMuchBorrowed {\n        collateral_address: String,\n        wanted: Uint128,\n        limit: Uint128,\n    },\n\n    #[error(\"Only the borrower can repay a loan if it's not defaulted\")]\n    CannotLiquidateBeforeDefault {},\n\n    #[error(\"The Loan is defaulted, you can't repay your own debt anymore...\")]\n    CannotRepayWhenDefaulted {},\n\n    #[error(\"Fixed loans cannot be repaid partially. Expected assets : {expected:?}, Provided assets: {provided:?}\")]\n    CanOnlyRepayWholeFixedLoan {\n        expected: Uint128,\n        provided: Uint128,\n    },\n\n    #[error(\"Loans cannot be liquidated partially, this is not Anchor\")]\n    CanOnlyLiquidateWholeLoan {},\n\n    #[error(\"You can't repay a loan whose collateral has already been withdrawn\")]\n    AssetAlreadyWithdrawn {},\n\n    // Rate increase-decrease errors\n    #[error(\"Only the original borrower can decrease their interest rate\")]\n    OnlyBorrowerCanLowerRate {},\n\n    #[error(\"You can't have multiple rate increasors\")]\n    CantIncreaseRateMultipleTimes {},\n\n    #[error(\"You can only change to the safe zone from the expensive zone\")]\n    OnlyFromExpensiveZone {},\n\n    #[error(\"You need to repay the expensive zone before going forward\")]\n    NeedToRepayExpensiveZone {},\n\n    #[error(\"You can only change to the expensive zone from the safe zone\")]\n    OnlyFromSafeZone {},\n\n    #[error(\"A fixed interest/duration loan, doesn't have an interest rate\")]\n    FixedLoanNoInterestRate {},\n\n    #[error(\"Unavailable for a fixed loan\")]\n    UnavailableFixedLoan {},\n\n    #[error(\"The format of your transfer message was wrong for the lender contract\")]\n    ReceiveMsgNotAccepted {},\n\n    #[error(\"The assets you sent don't match the message you used\")]\n    AssetsSentDontMatch {},\n\n    #[error(\"The value of the paramter you are trying to change is not acceptable\")]\n    ParamNotAccepted {},\n\n    #[error(\"A repaiement must cover the increasor incentives\")]\n    MustAtLeastCoverIncreasorIncentive {},\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","lender","src","execute.rs"],"content":"use crate::error::ContractError;\n#[cfg(not(feature = \"library\"))]\nuse anyhow::{anyhow, Result};\nuse cosmwasm_std::{\n    coins, to_binary, Addr, BankMsg, CosmosMsg, Deps, DepsMut, Env, MessageInfo, Response, Uint128,\n};\nuse lender_export::state::{\n    BorrowInfo, BorrowMode, BorrowZone, ContractInfo, Cw721Info, InterestType, RateIncreasor,\n    BORROWS, CONTRACT_INFO, PERCENTAGE_RATE, STATE,\n};\nuse serde::Serialize;\nuse utils::msg::into_cosmos_msg;\n\nuse crate::query::{\n    can_repay_loan, get_asset_interests, get_asset_price, get_borrower_interest_rate,\n    get_interests_with, get_last_collateral, get_liquidation_value, get_loan_value,\n    get_new_interests_accrued, get_safe_zone_limit_price, get_total_interests, get_zone,\n};\nuse cw20::Cw20ExecuteMsg;\nuse cw721::Cw721ExecuteMsg;\nuse cw_4626::msg::ExecuteMsg as Cw4626ExecuteMsg;\nuse cw_4626::state::AssetInfo;\nuse fee_distributor_export::msg::ExecuteMsg as DistributorExecuteMsg;\n\npub fn _diff_abs(x: u128, y: u128) -\u003e u128 {\n    std::cmp::max(x, y) - std::cmp::min(x, y)\n}\n\npub fn diff_abs(x: Uint128, y: Uint128) -\u003e Uint128 {\n    Uint128::from(_diff_abs(x.u128(), y.u128()))\n}\n\n// Borrow mecanism\n/// Withdraw some of the assets from the vault\n/// Updates the internal structure for the loan to be liquidated when the terms allow it\npub fn execute_borrow(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    collateral_info: Cw721Info,\n    assets_to_borrow: Uint128,\n    borrow_mode: BorrowMode,\n) -\u003e Result\u003cResponse\u003e {\n    // First we checked it is allowed to borrow assets\n    let state = STATE.load(deps.storage)?;\n    if state.borrow_locked {\n        return Err(anyhow::anyhow!(ContractError::BorrowLocked {}));\n    }\n\n    let contract_info = CONTRACT_INFO.load(deps.storage)?;\n\n    // First we query the terms of a loan involving the asset\n    let asset_price = get_asset_price(deps.as_ref(), env.clone(), collateral_info.clone())?;\n    let borrow_limit = get_safe_zone_limit_price(asset_price)?;\n    // Then we verify the borrow limit is indeed above the assets_to_borrow\n    if assets_to_borrow \u003e borrow_limit {\n        return Err(anyhow::anyhow!(ContractError::TooMuchBorrowed {\n            collateral_address: collateral_info.nft_address,\n            wanted: assets_to_borrow,\n            limit: borrow_limit\n        }));\n    }\n    // We get the interest rate depending on the mode chosen by the sender\n    let interests = get_asset_interests(\n        deps.as_ref(),\n        env.clone(),\n        collateral_info.clone(),\n        borrow_mode,\n        BorrowZone::SafeZone,\n    )?;\n\n    // We get the last collateral_id that was saved\n    let new_collateral_id = get_last_collateral(deps.as_ref(), \u0026info.sender)\n        .map(|x| x + 1)\n        .unwrap_or(0u64);\n    // We save the borrow info to memory\n    BORROWS.save(\n        deps.storage,\n        (\u0026info.sender, new_collateral_id),\n        \u0026BorrowInfo {\n            principle: assets_to_borrow,\n            interests,\n            start_block: env.block.height,\n            collateral: Some(collateral_info.clone()),\n            borrow_zone: BorrowZone::SafeZone,\n            rate_increasor: None,\n        },\n    )?;\n\n    // Then we transfer the collateral asset to this contract\n    let deposit_message = into_cosmos_msg(\n        Cw721ExecuteMsg::TransferNft {\n            recipient: env.contract.address.into(),\n            token_id: collateral_info.token_id.clone(),\n        },\n        collateral_info.nft_address.clone(),\n        None,\n    )?;\n\n    // And we transfer the borrowed assets to the lender\n    let borrow_message = into_cosmos_msg(\n        Cw4626ExecuteMsg::Borrow {\n            receiver: info.sender.to_string(),\n            assets: assets_to_borrow,\n        },\n        contract_info.vault_token,\n        None,\n    )?;\n\n    Ok(Response::new()\n        .add_message(deposit_message)\n        .add_message(borrow_message)\n        .add_attribute(\"action\", \"borrow\")\n        .add_attribute(\"collateral_address\", collateral_info.nft_address)\n        .add_attribute(\"collateral_token_id\", collateral_info.token_id)\n        .add_attribute(\"borrower\", info.sender))\n}\n\n// Borrow more assets for a same collateral\n/// Withdraw some of the assets from the vault\npub fn execute_borrow_more(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    loan_id: u64,\n    assets_to_borrow: Uint128,\n) -\u003e Result\u003cResponse\u003e {\n    // First we checked it is allowed to borrow assets\n    let state = STATE.load(deps.storage)?;\n    if state.borrow_locked {\n        return Err(anyhow::anyhow!(ContractError::BorrowLocked {}));\n    }\n    let contract_info = CONTRACT_INFO.load(deps.storage)?;\n\n    // First we make sure the loan indeed has a collateral\n    let borrower = info.sender.clone();\n    let mut borrow_info = BORROWS.load(deps.storage, (\u0026borrower, loan_id))?;\n    let collateral_info = borrow_info\n        .clone()\n        .collateral\n        .ok_or(ContractError::AssetAlreadyWithdrawn {})?;\n\n    // Then the loan type should be a continuous one to borrow more\n    if let InterestType::Fixed { .. } = borrow_info.interests {\n        return Err(anyhow!(ContractError::UnavailableFixedLoan {}));\n    }\n\n    // First you need to repay the increasor if you want to borrow more\n    if borrow_info.borrow_zone != BorrowZone::SafeZone {\n        return Err(anyhow!(ContractError::NeedToRepayExpensiveZone {}));\n    }\n\n    // We update the loan interests accrued up to there\n    _update_interests_accrued(env.clone(), \u0026mut borrow_info)?;\n\n    let asset_price = get_asset_price(deps.as_ref(), env.clone(), collateral_info.clone())?;\n    let borrow_limit = get_safe_zone_limit_price(asset_price)?;\n    let current_loan_value = get_loan_value(env.clone(), \u0026borrow_info);\n\n    // Then we verify the borrow limit is indeed above the total assets to borrow\n    if current_loan_value + assets_to_borrow \u003e borrow_limit {\n        return Err(anyhow::anyhow!(ContractError::TooMuchBorrowed {\n            collateral_address: collateral_info.nft_address,\n            wanted: current_loan_value + assets_to_borrow,\n            limit: borrow_limit\n        }));\n    }\n\n    // We set the new principle\n    borrow_info.principle += assets_to_borrow;\n\n    // We set the new interests rate\n    borrow_info.interests = get_asset_interests(\n        deps.as_ref(),\n        env.clone(),\n        collateral_info,\n        BorrowMode::Continuous,\n        BorrowZone::SafeZone,\n    )?;\n    borrow_info.start_block = env.block.height;\n\n    // We save the borrow info to memory\n    BORROWS.save(deps.storage, (\u0026info.sender, loan_id), \u0026borrow_info)?;\n\n    // And we transfer the borrowed assets to the lender\n    let borrow_message = into_cosmos_msg(\n        Cw4626ExecuteMsg::Borrow {\n            receiver: info.sender.to_string(),\n            assets: assets_to_borrow,\n        },\n        contract_info.vault_token,\n        None,\n    )?;\n\n    Ok(Response::new()\n        .add_message(borrow_message)\n        .add_attribute(\"action\", \"borrow\")\n        .add_attribute(\"borrower\", info.sender)\n        .add_attribute(\"loan_id\", loan_id.to_string())\n        .add_attribute(\"asset_borrowed\", assets_to_borrow))\n}\n\n// Borrow mecanism\n/// Repay a loan.\n/// This function has multiple use cases\n/// 1. Repay your own loans in whole and get your collateral back\n///    In order to do that, you need to send exactly or more than the amount of assets that match the value of the lonan\n/// 2. Repay parts of your loan to lower your LTV (only possible for continuous loans)\n///      This will effectively lower your LTV and allow you to continue borrowing your funds\n///     If you have a fixed loan this option is not available to you\n/// 3. Liquidate someone elses loan (only possible when the loan is defaulted)\npub fn _execute_repay(\n    deps: DepsMut,\n    env: Env,\n    sender: Addr,\n\n    borrower: String,\n    loan_id: u64,\n    assets: Uint128,\n) -\u003e Result\u003cResponse\u003e {\n    let contract_info = CONTRACT_INFO.load(deps.storage)?;\n    // We load the borrow object that they want to repay\n    let borrower = deps.api.addr_validate(\u0026borrower)?;\n    let mut borrow_info = BORROWS.load(deps.storage, (\u0026borrower, loan_id))?;\n\n    // We check the sender can repay the loan\n    can_repay_loan(\n        deps.as_ref(),\n        env.clone(),\n        sender.clone(),\n        borrower.clone(),\n        \u0026borrow_info,\n    )?;\n\n    // We check if there is even a collateral backing the loan\n    let asset_info = borrow_info\n        .clone()\n        .collateral\n        .ok_or(ContractError::AssetAlreadyWithdrawn {})?;\n    let nft_address = asset_info.nft_address.clone();\n\n    let loan_value = get_loan_value(env.clone(), \u0026borrow_info);\n\n    // First we start by dealing with the increasor incentives\n    // This function will repay the incresor their share, or fail\n\n    let (increasor_incentive, increasor_message) =\n        send_interests_to_increasor(env.clone(), contract_info.clone(), \u0026borrow_info)?\n            .unwrap_or((Uint128::zero(), vec![]));\n\n    let assets_left_to_repay: Uint128 = assets\n        .checked_sub(increasor_incentive)\n        .map_err(|_| anyhow!(ContractError::MustAtLeastCoverIncreasorIncentive {}))?;\n\n    // We erase the increasor from memory\n    borrow_info.rate_increasor = None;\n\n    // Then, we update the interests accrued to the loan\n    _update_interests_accrued(env.clone(), \u0026mut borrow_info)?;\n\n    // Now we can go to the repay part\n    let repay_messages = if sender == borrower {\n        if assets \u003e= loan_value {\n            // Case 1. The borrower repays the whole loan\n\n            // We save the interests repaid for later use\n            // This will always be safe (per construction, increasor_incentive is a perentage of the interests)\n            let interests_repaid = assets_left_to_repay - borrow_info.principle;\n\n            // We update the internal state of the contract to reflect the loan has ended\n            // The collateral has been withdrawn\n            // The principle is not existent anymore\n            borrow_info.collateral = None;\n            borrow_info.principle = Uint128::zero();\n            [\n                // We send the borrower their collateral back\n                vec![into_cosmos_msg(\n                    Cw721ExecuteMsg::TransferNft {\n                        recipient: borrower.to_string(),\n                        token_id: asset_info.token_id,\n                    },\n                    nft_address.clone(),\n                    None,\n                )?],\n                // We repay the vault and the fee_depositor\n                create_repay_and_fee_messages(\n                    contract_info,\n                    interests_repaid,\n                    assets_left_to_repay,\n                    nft_address,\n                )?,\n            ]\n            .concat()\n        } else {\n            // Case 2. If the borrower repays the loan only partially\n\n            // We repay part of the loan, interests first, principle second\n            let interests_repaid = _repay_some_loan(env.clone(), \u0026mut borrow_info, assets)?;\n\n            // We update the interest rate\n\n            let borrow_zone = get_zone(deps.as_ref(), env.clone(), \u0026borrow_info)?;\n            if borrow_zone == BorrowZone::SafeZone\n                \u0026\u0026 borrow_info.borrow_zone == BorrowZone::ExpensiveZone\n            {\n                borrow_info.borrow_zone = BorrowZone::SafeZone;\n                borrow_info.interests = get_asset_interests(\n                    deps.as_ref(),\n                    env,\n                    asset_info,\n                    BorrowMode::Continuous,\n                    BorrowZone::SafeZone,\n                )?;\n            }\n            // And we repay the vault\n            create_repay_and_fee_messages(\n                contract_info,\n                interests_repaid,\n                assets_left_to_repay,\n                borrow_info.collateral.clone().unwrap().nft_address,\n            )?\n        }\n    } else {\n        // Case 3. Someone else liquidates the collateral\n        // TODO\n        // They can only liquidate a loan if they pay enough assets to the contract (liquidation value)\n        let liquidation_value = get_liquidation_value(env, \u0026borrow_info)?;\n        if assets \u003c liquidation_value {\n            return Err(anyhow::anyhow!(ContractError::CanOnlyLiquidateWholeLoan {}));\n        }\n\n        // We save those variables to create cosmos messages\n        let interests_repaid = assets_left_to_repay - borrow_info.principle;\n\n        // The loan is ended\n        // The collateral has been withdrawn\n        // The principle is not existent anymore\n        // The loan has been liquidated\n        borrow_info.collateral = None;\n        borrow_info.principle = Uint128::zero();\n        borrow_info.borrow_zone = BorrowZone::LiquidationZone;\n\n        [\n            vec![into_cosmos_msg(\n                Cw721ExecuteMsg::TransferNft {\n                    recipient: sender.to_string(),\n                    token_id: asset_info.token_id,\n                },\n                nft_address.clone(),\n                None,\n            )?],\n            create_repay_and_fee_messages(\n                contract_info,\n                interests_repaid,\n                assets_left_to_repay,\n                nft_address,\n            )?,\n        ]\n        .concat()\n    };\n\n    // We save the changes to memory\n    BORROWS.save(deps.storage, (\u0026borrower, loan_id), \u0026borrow_info)?;\n\n    Ok(Response::new()\n        .add_messages(increasor_message)\n        .add_messages(repay_messages)\n        .add_attribute(\"action\", \"repay\")\n        .add_attribute(\"caller\", sender)\n        .add_attribute(\"borrower\", borrower)\n        .add_attribute(\"assets\", assets.to_string())\n        .add_attribute(\n            \"collateral_withdrawn\",\n            borrow_info.collateral.is_none().to_string(),\n        ))\n}\n\n// In this function, we check if there was an increasor of interest rate between the last update and now\n// If so, we need to send funds back to them when updating the interest rate\npub fn send_interests_to_increasor(\n    env: Env,\n    contract_info: ContractInfo,\n    borrow_info: \u0026BorrowInfo,\n) -\u003e Result\u003cOption\u003c(Uint128, Vec\u003cCosmosMsg\u003e)\u003e\u003e {\n    // If we had someone increase the rate of the loan\n    if let Some(increasor) = borrow_info.rate_increasor.clone() {\n        let current_rate = get_borrower_interest_rate(borrow_info)?;\n        let previous_rate = increasor.previous_rate;\n        if current_rate \u003e previous_rate {\n            // We compute their incentive\n            let incentive = get_interests_with(\n                env,\n                borrow_info.principle,\n                current_rate - previous_rate,\n                borrow_info.start_block,\n            ) * contract_info.increasor_incentives\n                / Uint128::from(PERCENTAGE_RATE);\n\n            if incentive == Uint128::zero() {\n                Ok(None)\n            } else {\n                // If there is an incentive to give, we create a message to do so\n                let send_messages = send_asset(\n                    contract_info.vault_asset,\n                    increasor.increasor.to_string(),\n                    incentive,\n                )?;\n                Ok(Some((incentive, vec![send_messages])))\n            }\n        } else {\n            Ok(None)\n        }\n    } else {\n        Ok(None)\n    }\n}\n\npub fn create_repay_and_fee_messages(\n    contract_info: ContractInfo,\n    interests_due: Uint128,\n    assets: Uint128,\n    nft_address: String,\n) -\u003e Result\u003cVec\u003cCosmosMsg\u003e\u003e {\n    let fee = interests_due * contract_info.interests_fee_rate / Uint128::from(PERCENTAGE_RATE);\n    println!(\n        \"fee : {:?}, repaiement : {:?}, interests : {:?}\",\n        fee,\n        assets - fee,\n        interests_due\n    );\n    Ok(vec![\n        // We send the fee to the fee depositor\n        send_asset_to_contract(\n            contract_info.vault_asset.clone(),\n            contract_info.fee_distributor.to_string(),\n            fee,\n            DistributorExecuteMsg::DepositFees {\n                addresses: vec![nft_address],\n            },\n        )?,\n        // We send the rest to the vault\n        send_asset_to_contract(\n            contract_info.vault_asset,\n            contract_info.vault_token.to_string(),\n            assets - fee,\n            Cw4626ExecuteMsg::Repay {\n                owner: None,\n                assets: assets - fee,\n            },\n        )?,\n    ])\n}\n\npub fn _repay_some_loan(\n    env: Env,\n    mut borrow_info: \u0026mut BorrowInfo,\n    assets: Uint128,\n) -\u003e Result\u003cUint128\u003e {\n    let total_interests = get_total_interests(env, borrow_info);\n    match borrow_info.interests {\n        InterestType::Fixed { .. } =\u003e {\n            Err(anyhow::anyhow!(ContractError::CanOnlyRepayWholeFixedLoan {\n                expected: borrow_info.principle + total_interests,\n                provided: assets\n            }))\n        }\n\n        InterestType::Continuous {\n            last_interest_rate, ..\n        } =\u003e {\n            if assets \u003e total_interests {\n                borrow_info.interests = {\n                    InterestType::Continuous {\n                        interests_accrued: Uint128::zero(),\n                        last_interest_rate,\n                    }\n                };\n                // We diminish the principle\n                if assets - total_interests \u003c= borrow_info.principle {\n                    borrow_info.principle -= assets - total_interests;\n                } else {\n                    borrow_info.principle = Uint128::zero();\n                }\n\n                Ok(total_interests)\n            } else {\n                borrow_info.interests = InterestType::Continuous {\n                    interests_accrued: total_interests - assets,\n                    last_interest_rate,\n                };\n                Ok(assets)\n            }\n        }\n    }\n}\n\npub fn send_asset(asset: AssetInfo, recipient: String, assets: Uint128) -\u003e Result\u003cCosmosMsg\u003e {\n    match asset {\n        AssetInfo::Coin(denom) =\u003e Ok(CosmosMsg::from(BankMsg::Send {\n            to_address: recipient,\n            amount: coins(assets.u128(), denom),\n        })),\n        AssetInfo::Cw20(address) =\u003e into_cosmos_msg(\n            Cw20ExecuteMsg::Transfer {\n                recipient,\n                amount: assets,\n            },\n            address,\n            None,\n        )\n        .map_err(|x| anyhow!(x)),\n    }\n}\n\npub fn send_asset_to_contract\u003cM: Serialize\u003e(\n    asset: AssetInfo,\n    contract: String,\n    assets: Uint128,\n    msg: M,\n) -\u003e Result\u003cCosmosMsg\u003e {\n    match asset {\n        AssetInfo::Coin(denom) =\u003e Ok(into_cosmos_msg(\n            msg,\n            contract,\n            Some(coins(assets.u128(), denom)),\n        )?),\n        AssetInfo::Cw20(address) =\u003e into_cosmos_msg(\n            Cw20ExecuteMsg::Send {\n                contract,\n                amount: assets,\n                msg: to_binary(\u0026msg)?,\n            },\n            address,\n            None,\n        )\n        .map_err(|x| anyhow!(x)),\n    }\n}\n\npub fn execute_raise_interest_rate(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    borrower: String,\n    loan_id: u64,\n) -\u003e Result\u003cResponse\u003e {\n    let borrower = deps.api.addr_validate(\u0026borrower)?;\n    let mut borrow_info = BORROWS.load(deps.storage, (\u0026borrower, loan_id))?;\n    let zone = get_zone(deps.as_ref(), env.clone(), \u0026borrow_info)?;\n\n    // We start by updating the interest rate accrued so far\n    _update_interests_accrued(env.clone(), \u0026mut borrow_info)?;\n\n    if zone == BorrowZone::ExpensiveZone {\n        // You can only increase the rate from the safe zone\n        if borrow_info.borrow_zone != BorrowZone::SafeZone {\n            return Err(anyhow!(ContractError::OnlyFromSafeZone {}));\n        }\n        // The sender is saved in the increasor object\n        if borrow_info.rate_increasor.is_some() {\n            return Err(anyhow!(ContractError::CantIncreaseRateMultipleTimes {}));\n        }\n        borrow_info.rate_increasor = Some(RateIncreasor {\n            increasor: info.sender,\n            previous_rate: get_borrower_interest_rate(\u0026borrow_info)?,\n        });\n\n        // We increase the interest rate\n        borrow_info.borrow_zone = BorrowZone::ExpensiveZone;\n        set_interest_rate(deps.as_ref(), env, \u0026mut borrow_info)?;\n    }\n\n    Ok(Response::new())\n}\n\npub fn set_interest_rate(deps: Deps, env: Env, borrow_info: \u0026mut BorrowInfo) -\u003e Result\u003c()\u003e {\n    match borrow_info.interests {\n        InterestType::Fixed { .. } =\u003e {\n            return Err(anyhow!(ContractError::FixedLoanNoInterestRate {}))\n        }\n        InterestType::Continuous { .. } =\u003e {\n            borrow_info.interests = get_asset_interests(\n                deps,\n                env,\n                borrow_info\n                    .collateral\n                    .clone()\n                    .ok_or(ContractError::AssetAlreadyWithdrawn {})?,\n                BorrowMode::Continuous,\n                borrow_info.borrow_zone.clone(),\n            )?;\n        }\n    };\n    Ok(())\n}\npub fn _update_interests_accrued(env: Env, borrow_info: \u0026mut BorrowInfo) -\u003e Result\u003cUint128\u003e {\n    // We get the interests accrued since the last call\n    let new_interest_accrued = get_new_interests_accrued(env.clone(), borrow_info);\n\n    // We update the borrow info accordingly (only in the continuous case)\n    // And we return the current interests due\n    match borrow_info.interests {\n        InterestType::Fixed { interests, .. } =\u003e Ok(interests),\n\n        InterestType::Continuous {\n            interests_accrued,\n            last_interest_rate,\n        } =\u003e {\n            let new_interests = interests_accrued + new_interest_accrued;\n            if new_interest_accrued \u003e Uint128::zero() {\n                borrow_info.interests = {\n                    InterestType::Continuous {\n                        interests_accrued: new_interests,\n                        last_interest_rate,\n                    }\n                };\n                borrow_info.start_block = env.block.height;\n            }\n            Ok(new_interests)\n        }\n    }\n}\n","traces":[{"line":521,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":522,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":523,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":528,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":533,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":12},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","lender","src","lib.rs"],"content":"pub mod contract;\npub mod custom_mock_querier;\npub mod error;\npub mod execute;\npub mod query;\npub mod state;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","lender","src","query.rs"],"content":"use crate::error::ContractError;\n#[cfg(not(feature = \"library\"))]\nuse anyhow::{anyhow, Result};\nuse cosmwasm_std::{Addr, Deps, Env, Order, StdResult, Uint128};\nuse cw_4626::query::QueryMsg as Cw4626QueryMsg;\nuse cw_4626::state::AssetInfo;\nuse lender_export::state::{\n    BorrowInfo, BorrowMode, BorrowZone, Cw721Info, InterestType, InterestsInfo, BORROWS,\n    MIN_BLOCK_OFFSET, PERCENTAGE_RATE,\n};\n\nconst SAFE_ZONE_LIMIT: u128 = 3_333u128;\nconst EXPENSIVE_ZONE_LIMIT: u128 = 6_666u128;\nconst ZONE_LIMIT_PERCENTAGE_POINT: u128 = 10_000u128;\n\npub fn get_vault_token_asset(deps: Deps, vault_token: String) -\u003e Result\u003cAssetInfo\u003e {\n    let asset_info: AssetInfo = deps\n        .querier\n        .query_wasm_smart(vault_token, \u0026Cw4626QueryMsg::Asset {})\n        .map_err(|x| anyhow!(x))?;\n    Ok(asset_info)\n}\n\npub fn get_asset_interests(\n    _deps: Deps,\n    _env: Env,\n    _asset_info: Cw721Info,\n    mode: BorrowMode,\n    zone: BorrowZone,\n) -\u003e StdResult\u003cInterestType\u003e {\n    // TODO, determine a borrowing strategy !\n\n    let interests_info = InterestsInfo {\n        safe_interest_rate: Uint128::from(78u128), // In 1/PERCENTAGE_RATE per block\n        expensive_interest_rate: Uint128::from(78u128), // In 1/PERCENTAGE_RATE per block\n    };\n\n    match mode {\n        BorrowMode::Fixed =\u003e Ok(InterestType::Fixed {\n            interests: Uint128::from(67u128),\n            duration: 67u64,\n        }),\n        BorrowMode::Continuous =\u003e Ok(match zone {\n            BorrowZone::SafeZone =\u003e InterestType::Continuous {\n                last_interest_rate: interests_info.safe_interest_rate,\n                interests_accrued: Uint128::zero(),\n            },\n            BorrowZone::ExpensiveZone | BorrowZone::LiquidationZone =\u003e InterestType::Continuous {\n                last_interest_rate: interests_info.expensive_interest_rate,\n                interests_accrued: Uint128::zero(),\n            },\n        }),\n    }\n}\n\npub fn get_borrower_interest_rate(borrow_info: \u0026BorrowInfo) -\u003e Result\u003cUint128\u003e {\n    match borrow_info.interests {\n        InterestType::Fixed { .. } =\u003e Err(anyhow!(ContractError::FixedLoanNoInterestRate {})),\n        InterestType::Continuous {\n            last_interest_rate, ..\n        } =\u003e Ok(last_interest_rate),\n    }\n}\n\npub fn get_asset_price(_deps: Deps, _env: Env, _asset_info: Cw721Info) -\u003e StdResult\u003cUint128\u003e {\n    // TODO, query the oracle contract for the asset price\n    Ok(Uint128::from(161_000_000u128))\n}\n\npub fn get_safe_zone_limit_price(asset_price: Uint128) -\u003e StdResult\u003cUint128\u003e {\n    Ok(asset_price * Uint128::from(SAFE_ZONE_LIMIT) / Uint128::from(ZONE_LIMIT_PERCENTAGE_POINT))\n}\n\npub fn get_expensive_zone_limit_price(asset_price: Uint128) -\u003e StdResult\u003cUint128\u003e {\n    Ok(asset_price * Uint128::from(EXPENSIVE_ZONE_LIMIT)\n        / Uint128::from(ZONE_LIMIT_PERCENTAGE_POINT))\n}\n\npub fn get_zone(deps: Deps, env: Env, borrow_info: \u0026BorrowInfo) -\u003e Result\u003cBorrowZone\u003e {\n    match borrow_info.interests {\n        InterestType::Fixed { .. } =\u003e Ok(BorrowZone::SafeZone),\n        InterestType::Continuous { .. } =\u003e {\n            let loan_value = get_loan_value(env.clone(), borrow_info);\n            let asset_price = get_asset_price(\n                deps,\n                env,\n                borrow_info\n                    .clone()\n                    .collateral\n                    .ok_or(ContractError::AssetAlreadyWithdrawn {})?,\n            )?;\n            if loan_value \u003c= get_safe_zone_limit_price(asset_price)? {\n                Ok(BorrowZone::SafeZone)\n            } else if loan_value \u003c= get_expensive_zone_limit_price(asset_price)? {\n                Ok(BorrowZone::ExpensiveZone)\n            } else {\n                Ok(BorrowZone::LiquidationZone)\n            }\n        }\n    }\n}\n\npub fn get_last_collateral(deps: Deps, owner: \u0026Addr) -\u003e Option\u003cu64\u003e {\n    let first_collateral = BORROWS\n        .prefix(owner)\n        .keys(deps.storage, None, None, Order::Descending)\n        .take(1)\n        .collect::\u003cVec\u003cStdResult\u003cu64\u003e\u003e\u003e();\n\n    if let Some(\u0026Ok(collateral)) = first_collateral.first() {\n        Some(collateral)\n    } else {\n        None\n    }\n}\n\npub fn get_total_interests(env: Env, borrow_info: \u0026BorrowInfo) -\u003e Uint128 {\n    let old_interests = match borrow_info.interests {\n        InterestType::Fixed { interests, .. } =\u003e interests,\n        InterestType::Continuous {\n            interests_accrued, ..\n        } =\u003e interests_accrued,\n    };\n    println!(\"{:?}\", old_interests);\n    old_interests + get_new_interests_accrued(env, borrow_info)\n}\n\npub fn get_loan_value(env: Env, borrow_info: \u0026BorrowInfo) -\u003e Uint128 {\n    let interests = get_total_interests(env, borrow_info);\n    borrow_info.principle + interests\n}\n\npub fn get_new_interests_accrued(env: Env, borrow_info: \u0026BorrowInfo) -\u003e Uint128 {\n    match borrow_info.interests {\n        InterestType::Fixed { .. } =\u003e Uint128::zero(),\n        InterestType::Continuous {\n            last_interest_rate, ..\n        } =\u003e get_interests_with(\n            env,\n            borrow_info.principle,\n            last_interest_rate,\n            borrow_info.start_block,\n        ),\n    }\n}\n\npub fn get_interests_with(\n    env: Env,\n    principle: Uint128,\n    interest_rate: Uint128,\n    start_block: u64,\n) -\u003e Uint128 {\n    interest_rate\n        * principle\n        * Uint128::from((env.block.height - start_block) / MIN_BLOCK_OFFSET * MIN_BLOCK_OFFSET)\n        / Uint128::from(PERCENTAGE_RATE)\n    // Here we divide and multiply by MIN_BLOCK_OFFSET to make sure the interests due don't fluctuate too much\n}\npub fn get_liquidation_value(env: Env, borrow_info: \u0026BorrowInfo) -\u003e Result\u003cUint128\u003e {\n    // TODO determine a liquidation strategy\n    Ok(get_loan_value(env, borrow_info))\n}\n\npub fn is_loan_defaulted(deps: Deps, env: Env, borrow_info: \u0026BorrowInfo) -\u003e Result\u003cbool\u003e {\n    // If a duration was specified, the loan defaults if and only if the duration has expired\n    if let InterestType::Fixed { duration, .. } = borrow_info.interests {\n        if borrow_info.start_block + duration \u003c env.block.height {\n            Ok(true)\n        } else {\n            Ok(false)\n        }\n    } else {\n        // Else, we want to rely on the price oracle to determine if the loan is liquidated\n        let asset_info = borrow_info\n            .collateral\n            .clone()\n            .ok_or(ContractError::AssetAlreadyWithdrawn {})?;\n        // We query the asset price using the on-chain oracle\n        let asset_price = get_asset_price(deps, env.clone(), asset_info)?;\n\n        // The loan is considered liquidated when the loan value is more than EXPENSIVE_ZONE_LIMIT*asset_price\n        if get_loan_value(env, borrow_info) \u003e get_expensive_zone_limit_price(asset_price)? {\n            Ok(true)\n        } else {\n            Ok(false)\n        }\n    }\n}\n\npub fn can_repay_loan(\n    deps: Deps,\n    env: Env,\n    sender: Addr,\n    borrower: Addr,\n    borrow_info: \u0026BorrowInfo,\n) -\u003e Result\u003c()\u003e {\n    let loan_defaulted = is_loan_defaulted(deps, env, borrow_info)?;\n\n    if sender == borrower {\n        if loan_defaulted {\n            Err(anyhow::anyhow!(ContractError::CannotRepayWhenDefaulted {}))\n        } else {\n            Ok(())\n        }\n    } else if loan_defaulted {\n        // If the sender is not the borrower and the loan has defaulted,\n        // The sender can repay the loan to claim the associated NFT at a discount\n        Ok(())\n    } else {\n        Err(anyhow::anyhow!(\n            ContractError::CannotLiquidateBeforeDefault {}\n        ))\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","lender","src","state.rs"],"content":"use crate::error::ContractError;\nuse anyhow::{anyhow, Result};\nuse cosmwasm_std::{Addr, DepsMut, MessageInfo, Response, Storage, Uint128};\nuse lender_export::state::{ContractInfo, CONTRACT_INFO, PERCENTAGE_RATE, STATE};\n\npub fn is_owner(storage: \u0026dyn Storage, sender: Addr) -\u003e Result\u003cContractInfo, ContractError\u003e {\n    let contract_info = CONTRACT_INFO.load(storage)?;\n    if sender == contract_info.owner {\n        Ok(contract_info)\n    } else {\n        Err(ContractError::Unauthorized {})\n    }\n}\n\npub fn set_owner(deps: DepsMut, info: MessageInfo, owner: String) -\u003e Result\u003cResponse\u003e {\n    let mut contract_info = is_owner(deps.storage, info.sender.clone())?;\n    contract_info.owner = deps.api.addr_validate(\u0026owner)?;\n    CONTRACT_INFO.save(deps.storage, \u0026contract_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"set_owner\")\n        .add_attribute(\"caller\", info.sender)\n        .add_attribute(\"owner\", owner))\n}\n\npub fn set_oracle(deps: DepsMut, info: MessageInfo, oracle: String) -\u003e Result\u003cResponse\u003e {\n    let mut contract_info = is_owner(deps.storage, info.sender.clone())?;\n    contract_info.oracle = deps.api.addr_validate(\u0026oracle)?;\n    CONTRACT_INFO.save(deps.storage, \u0026contract_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"set_oracle\")\n        .add_attribute(\"caller\", info.sender)\n        .add_attribute(\"oracle\", oracle))\n}\n\npub fn set_lock(deps: DepsMut, info: MessageInfo, lock: bool) -\u003e Result\u003cResponse\u003e {\n    is_owner(deps.storage, info.sender.clone())?;\n\n    STATE.update::\u003c_, anyhow::Error\u003e(deps.storage, |mut x| {\n        x.borrow_locked = lock;\n        Ok(x)\n    })?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"set_oracle\")\n        .add_attribute(\"caller\", info.sender)\n        .add_attribute(\"lock\", lock.to_string()))\n}\n\npub fn set_increasor_incentives(\n    deps: DepsMut,\n    info: MessageInfo,\n    incentives: Uint128,\n) -\u003e Result\u003cResponse\u003e {\n    let mut contract_info = is_owner(deps.storage, info.sender.clone())?;\n    if incentives.u128() \u003e PERCENTAGE_RATE {\n        return Err(anyhow!(ContractError::ParamNotAccepted {}));\n    }\n    contract_info.increasor_incentives = incentives;\n    CONTRACT_INFO.save(deps.storage, \u0026contract_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"set_oracle\")\n        .add_attribute(\"caller\", info.sender)\n        .add_attribute(\"increasor_incentives\", incentives.to_string()))\n}\n\npub fn set_interests_fee_rate(deps: DepsMut, info: MessageInfo, rate: Uint128) -\u003e Result\u003cResponse\u003e {\n    let mut contract_info = is_owner(deps.storage, info.sender.clone())?;\n    if rate.u128() \u003e PERCENTAGE_RATE {\n        return Err(anyhow!(ContractError::ParamNotAccepted {}));\n    }\n    contract_info.interests_fee_rate = rate;\n    CONTRACT_INFO.save(deps.storage, \u0026contract_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"set_oracle\")\n        .add_attribute(\"caller\", info.sender)\n        .add_attribute(\"interests_fee_rate\", rate.to_string()))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","nft-loans","examples","loans_schema.rs"],"content":"use std::env::current_dir;\nuse std::fs::create_dir_all;\n\nuse cosmwasm_schema::{export_schema, remove_schemas, schema_for};\n\nuse nft_loans_export::msg::{ExecuteMsg, InstantiateMsg, QueryMsg};\n\nfn main() {\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"schema\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n\n    export_schema(\u0026schema_for!(InstantiateMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(ExecuteMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(QueryMsg), \u0026out_dir);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","nft-loans","src","contract.rs"],"content":"#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\nuse cosmwasm_std::{\n    coins, to_binary, Addr, BankMsg, Binary, CosmosMsg, Deps, DepsMut, Env, MessageInfo, Order,\n    Response, StdError, StdResult, Uint128,\n};\nuse cw_storage_plus::Bound;\n\nuse crate::error::ContractError;\n\nuse crate::state::{\n    add_new_offer, can_repay_loan, get_active_loan, get_offer, is_active_lender,\n    is_collateral_withdrawable, is_lender, is_loan_acceptable, is_loan_counterable,\n    is_loan_defaulted, is_loan_modifiable, is_owner, BORROWER_INFO, COLLATERAL_INFO, CONTRACT_INFO,\n    LENDER_OFFERS,\n};\n\nuse cw1155::Cw1155ExecuteMsg;\nuse cw721::Cw721ExecuteMsg;\n\nuse nft_loans_export::msg::{\n    CollateralResponse, ExecuteMsg, InstantiateMsg, MigrateMsg, OfferResponse, QueryMsg,\n};\nuse nft_loans_export::state::{\n    BorrowerInfo, CollateralInfo, ContractInfo, LoanState, LoanTerms, OfferInfo, OfferState,\n};\nuse utils::msg::into_cosmos_msg;\nuse utils::state::{AssetInfo, Cw1155Coin, Cw721Coin};\n\nuse fee_distributor_export::msg::ExecuteMsg as FeeDistributorMsg;\n\nconst MAX_QUERY_LIMIT: u32 = 30;\nconst DEFAULT_QUERY_LIMIT: u32 = 10;\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // Verify the contract name\n    msg.validate()?;\n    // store token info\n    let data = ContractInfo {\n        name: msg.name,\n        owner: deps\n            .api\n            .addr_validate(\u0026msg.owner.unwrap_or_else(|| info.sender.to_string()))?,\n        fee_distributor: msg.fee_distributor,\n        fee_rate: msg.fee_rate,\n    };\n    CONTRACT_INFO.save(deps.storage, \u0026data)?;\n    Ok(Response::default()\n        .add_attribute(\"action\", \"initialization\")\n        .add_attribute(\"contract\", \"p2p-loans\"))\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    match msg {\n        ExecuteMsg::DepositCollateral {\n            address,\n            token_id,\n            value,\n            terms,\n        } =\u003e deposit_collateral(deps, env, info, address, token_id, value, terms),\n        ExecuteMsg::WithdrawCollateral { loan_id } =\u003e withdraw_collateral(deps, env, info, loan_id),\n\n        ExecuteMsg::SetTerms { loan_id, terms } =\u003e set_loan_terms(deps, env, info, loan_id, terms),\n        ExecuteMsg::AcceptLoan { borrower, loan_id } =\u003e {\n            accept_loan(deps, env, info, borrower, loan_id)\n        }\n\n        ExecuteMsg::AcceptOffer { loan_id, offer_id } =\u003e {\n            accept_offer(deps, env, info, loan_id, offer_id)\n        }\n        ExecuteMsg::MakeOffer {\n            borrower,\n            loan_id,\n            terms,\n        } =\u003e make_offer(deps, env, info, borrower, loan_id, terms),\n\n        ExecuteMsg::CancelOffer {\n            borrower,\n            loan_id,\n            offer_id,\n        } =\u003e cancel_offer(deps, env, info, borrower, loan_id, offer_id),\n\n        ExecuteMsg::RefuseOffer { loan_id, offer_id } =\u003e {\n            refuse_offer(deps, env, info, loan_id, offer_id)\n        }\n\n        ExecuteMsg::WithdrawRefusedOffer {\n            borrower,\n            loan_id,\n            offer_id,\n        } =\u003e withdraw_refused_offer(deps, env, info, borrower, loan_id, offer_id),\n\n        ExecuteMsg::RepayBorrowedFunds { loan_id } =\u003e {\n            repay_borrowed_funds(deps, env, info, loan_id)\n        }\n        ExecuteMsg::WithdrawDefaultedLoan { borrower, loan_id } =\u003e {\n            withdraw_defaulted_loan(deps, env, info, borrower, loan_id)\n        }\n\n        // Internal Contract Logic\n        ExecuteMsg::SetOwner { owner } =\u003e set_owner(deps, env, info, owner),\n\n        ExecuteMsg::SetFeeDistributor { fee_depositor } =\u003e {\n            set_fee_distributor(deps, env, info, fee_depositor)\n        }\n\n        ExecuteMsg::SetFeeRate { fee_rate } =\u003e set_fee_rate(deps, env, info, fee_rate),\n\n        // Generic (will have to remove at the end of development)\n        _ =\u003e Err(ContractError::Std(StdError::generic_err(\n            \"Ow whaou, please wait just a bit, it's not implemented yet !\",\n        ))),\n    }\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn migrate(_deps: DepsMut, _env: Env, _msg: MigrateMsg) -\u003e Result\u003cResponse, ContractError\u003e {\n    // No state migrations performed, just returned a Response\n    Ok(Response::default())\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::ContractInfo {} =\u003e to_binary(\u0026query_contract_info(deps)?),\n        QueryMsg::CollateralInfo { borrower, loan_id } =\u003e {\n            to_binary(\u0026query_collateral_info(deps, borrower, loan_id)?)\n        }\n        QueryMsg::BorrowerInfo { borrower } =\u003e to_binary(\u0026query_borrower_info(deps, borrower)?),\n    }\n}\n\n/// Owner only function\n/// Sets a new owner\n/// The owner can set the parameters of the contract\n/// * Owner\n/// * Fee distributor contract\n/// * Fee Rate\npub fn set_owner(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    new_owner: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut contract_info = is_owner(deps.storage, info.sender)?;\n\n    let new_owner = deps.api.addr_validate(\u0026new_owner)?;\n    contract_info.owner = new_owner.clone();\n    CONTRACT_INFO.save(deps.storage, \u0026contract_info)?;\n\n    Ok(Response::default()\n        .add_attribute(\"action\", \"changed-contract-parameter\")\n        .add_attribute(\"parameter\", \"owner\")\n        .add_attribute(\"value\", new_owner))\n}\n\n/// Owner only function\n/// Sets a new fee-distributor contract\n/// This contract distributes fees back to the projects (and Illiquidly DAO gets to keep a small amount too)\npub fn set_fee_distributor(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    new_distributor: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut contract_info = is_owner(deps.storage, info.sender)?;\n\n    contract_info.fee_distributor = new_distributor.clone();\n    CONTRACT_INFO.save(deps.storage, \u0026contract_info)?;\n\n    Ok(Response::default()\n        .add_attribute(\"action\", \"changed-contract-parameter\")\n        .add_attribute(\"parameter\", \"fee_distributor\")\n        .add_attribute(\"value\", new_distributor))\n}\n\n/// Owner only function\n/// Sets a new fee rate\n/// fee_rate is in units of a 1/100_000th, so e.g. if fee_rate=5_000, the fee_rate is 5%\n/// It correspond to the part of interests that are kept by the organisation (for redistribution and DAO purposes)\npub fn set_fee_rate(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    new_fee_rate: Uint128,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut contract_info = is_owner(deps.storage, info.sender)?;\n\n    contract_info.fee_rate = new_fee_rate;\n    CONTRACT_INFO.save(deps.storage, \u0026contract_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"changed-contract-parameter\")\n        .add_attribute(\"parameter\", \"fee_rate\")\n        .add_attribute(\"value\", new_fee_rate))\n}\n\n/// Deposit an NFT collateral\n/// This is the first entry point of the loan flow.\n/// Users deposit their collateral for other users to accept their terms in exchange of interest paid at the end of the loan duration\n/// The borrower (the person that deposits collaterals) can specify terms at which they wish to borrow funds against their collateral\n/// If terms are specified, fund lenders can accept the loan directly\n/// If not, lenders can propose terms than may be accepted by the borrower in return to start the loan\n/// This deposit function allows CW721 and CW1155 tokens to be deposited\npub fn deposit_collateral(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    address: String,\n    token_id: String,\n    value: Option\u003cUint128\u003e,\n    terms: Option\u003cLoanTerms\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let borrower = info.sender;\n\n    // We prepare for storing and transfering the token from the borrower to the contract\n    // Yes this is custodial, we could change that to make it non-custodial\n    // REQUIRED TODO make it non-custodial for the lender\n    let (asset_info, transfer_message) = if let Some(value) = value {\n        // In case of a Cw1155\n        (\n            AssetInfo::Cw1155Coin(Cw1155Coin {\n                address: address.clone(),\n                token_id: token_id.clone(),\n                value,\n            }),\n            into_cosmos_msg(\n                Cw1155ExecuteMsg::SendFrom {\n                    from: borrower.to_string(),\n                    to: env.contract.address.into(),\n                    token_id,\n                    value,\n                    msg: None,\n                },\n                address,\n                None,\n            )?,\n        )\n    } else {\n        // In case of a CW721\n        (\n            AssetInfo::Cw721Coin(Cw721Coin {\n                address: address.clone(),\n                token_id: token_id.clone(),\n            }),\n            into_cosmos_msg(\n                Cw721ExecuteMsg::TransferNft {\n                    recipient: env.contract.address.into(),\n                    token_id,\n                },\n                address,\n                None,\n            )?,\n        )\n    };\n\n    // We save the collateral info in our internal structure\n    // First we update the number of collateral a user has deposited (to make sure the id assigned is unique)\n    let loan_id = BORROWER_INFO\n        .update::\u003c_, ContractError\u003e(deps.storage, \u0026borrower.clone(), |x| match x {\n            Some(mut info) =\u003e {\n                info.last_collateral_id += 1;\n                Ok(info)\n            }\n            None =\u003e Ok(BorrowerInfo::default()),\n        })?\n        .last_collateral_id;\n    // Then we save an collateral info object\n    COLLATERAL_INFO.save(\n        deps.storage,\n        (\u0026borrower, loan_id),\n        \u0026CollateralInfo {\n            terms,\n            associated_asset: asset_info,\n            ..Default::default()\n        },\n    )?;\n\n    Ok(Response::new()\n        .add_message(transfer_message)\n        .add_attribute(\"action\", \"deposit-collateral\")\n        .add_attribute(\"borrower\", borrower)\n        .add_attribute(\"loan_id\", loan_id.to_string()))\n}\n\n/// Withdraw an NFT collateral\n/// This simply cancels the potential loan\npub fn withdraw_collateral(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    loan_id: u64,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // We query the loan info\n    let borrower = info.sender;\n    let mut collateral = COLLATERAL_INFO.load(deps.storage, (\u0026borrower, loan_id))?;\n    is_collateral_withdrawable(\u0026collateral)?;\n\n    // We start by creating the transfer message\n    let transfer_message = _withdraw_asset(\n        collateral.associated_asset.clone(),\n        env.contract.address,\n        borrower.clone(),\n    )?;\n\n    // We update the internal state, the loan proposal is no longer valid\n    collateral.state = LoanState::AssetWithdrawn;\n    COLLATERAL_INFO.save(deps.storage, (\u0026borrower, loan_id), \u0026collateral)?;\n\n    Ok(Response::new()\n        .add_message(transfer_message)\n        .add_attribute(\"action\", \"withdraw-collateral\")\n        .add_attribute(\"event\", \"cancel-loan\")\n        .add_attribute(\"borrower\", borrower)\n        .add_attribute(\"loan_id\", loan_id.to_string()))\n}\n\n/// Change the loan terms of a loan before it's accepted by anyone\n/// Or just add some terms because you didn't have the chance before\n/// If you want to update the terms of your collateral, because no-one wanted to accept it or because the market changed\npub fn set_loan_terms(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    loan_id: u64,\n    terms: LoanTerms,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // We query the loan info\n    let borrower = info.sender;\n    let mut collateral = COLLATERAL_INFO.load(deps.storage, (\u0026borrower, loan_id))?;\n    is_loan_modifiable(\u0026collateral)?;\n\n    // Update the terms\n    collateral.terms = Some(terms);\n    COLLATERAL_INFO.save(deps.storage, (\u0026borrower, loan_id), \u0026collateral)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"modify-loan_terms\")\n        .add_attribute(\"borrower\", borrower)\n        .add_attribute(\"loan_id\", loan_id.to_string()))\n}\n\n/// Make an offer (offer some terms) to lend some money against someone's collateral\n/// The borrower will then be able to accept those terms if they please them\npub fn make_offer(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    borrower: String,\n    loan_id: u64,\n    terms: LoanTerms,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // We query the loan info\n    let borrower = deps.api.addr_validate(\u0026borrower)?;\n    let mut collateral = COLLATERAL_INFO.load(deps.storage, (\u0026borrower, loan_id))?;\n    is_loan_counterable(\u0026collateral)?;\n\n    // Make sure the transaction contains funds that match the principle indicated in the terms\n    if info.funds.len() != 1 {\n        return Err(ContractError::MultipleCoins {});\n    } else if terms.principle != info.funds[0].clone() {\n        return Err(ContractError::FundsDontMatchTerms {});\n    }\n\n    let offer_id = add_new_offer(\n        deps.storage,\n        \u0026mut collateral,\n        (borrower.clone(), loan_id),\n        OfferInfo {\n            lender: info.sender.clone(),\n            terms,\n            state: OfferState::Published,\n            deposited_funds: Some(info.funds[0].clone()),\n        },\n    )?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"make-offer\")\n        .add_attribute(\"borrower\", borrower)\n        .add_attribute(\"lender\", info.sender)\n        .add_attribute(\"loan_id\", loan_id.to_string())\n        .add_attribute(\"offer_id\", offer_id.to_string()))\n}\n\n/// Cancel an offer you made in case the market changes or whatever\n/// The borrower won't be able to accept the loan if you cancel it\npub fn cancel_offer(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    borrower: String,\n    loan_id: u64,\n    offer_id: u64,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let lender = info.sender;\n    // We query the loan info\n    let borrower = deps.api.addr_validate(\u0026borrower)?;\n    let mut collateral = COLLATERAL_INFO.load(deps.storage, (\u0026borrower, loan_id))?;\n\n    // We can cancel an offer only if the Borrower is still searching for a loan\n    if collateral.state != LoanState::Published {\n        return Err(ContractError::Unauthorized {});\n    }\n    // We need to verify the offer exists and it belongs to the address calling the contract and that's in the right state to be cancelled\n    let mut offer = is_lender(lender.clone(), \u0026collateral, offer_id as usize)?;\n    if offer.state != OfferState::Published {\n        return Err(ContractError::CantChangeOfferState {\n            from: offer.state,\n            to: OfferState::Cancelled,\n        });\n    }\n\n    // The funds deposited for lending are withdrawn\n    let withdraw_response = _withdraw_offer_unsafe(\n        deps.as_ref(),\n        borrower.clone(),\n        lender.clone(),\n        loan_id,\n        offer_id as usize,\n    )?;\n\n    // We save the changes in the collateral object\n    offer.state = OfferState::Cancelled;\n    collateral.offers[offer_id as usize] = offer;\n    // And mark the deposited funds as withdrawn\n    collateral.offers[offer_id as usize].deposited_funds = None;\n    COLLATERAL_INFO.save(deps.storage, (\u0026borrower, loan_id), \u0026collateral)?;\n\n    Ok(Response::new()\n        .add_message(withdraw_response)\n        .add_attribute(\"action\", \"cancel-offer\")\n        .add_attribute(\"action\", \"withdraw-funds\")\n        .add_attribute(\"borrower\", borrower)\n        .add_attribute(\"lender\", lender)\n        .add_attribute(\"loan_id\", loan_id.to_string())\n        .add_attribute(\"offer_id\", offer_id.to_string()))\n}\n\n/// Withdraw the funds from a refused offer\n/// In case the borrower refuses your offer, you need to manually withdraw your funds\n/// This is actually done in order for you to know where your funds are and keep control of your transfers\npub fn withdraw_refused_offer(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    borrower: String,\n    loan_id: u64,\n    offer_id: u64,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let lender = info.sender;\n    // We query the loan info\n    let borrower = deps.api.addr_validate(\u0026borrower)?;\n    let mut collateral = COLLATERAL_INFO.load(deps.storage, (\u0026borrower, loan_id))?;\n\n    // We need to verify the offer exists and the sender is actually the owner of the offer\n    let offer = is_lender(lender.clone(), \u0026collateral, offer_id as usize)?;\n\n    // TODO, please verify this shit right there\n    if offer.state != OfferState::Refused {\n        return Err(ContractError::NotWithdrawable {});\n    }\n\n    // The funds deposited for lending are withdrawn\n    let withdraw_message = _withdraw_offer_unsafe(\n        deps.as_ref(),\n        borrower.clone(),\n        lender.clone(),\n        loan_id,\n        offer_id as usize,\n    )?;\n\n    // And we mark the deposited funds as withdrawn\n    collateral.offers[offer_id as usize].deposited_funds = None;\n    COLLATERAL_INFO.save(deps.storage, (\u0026borrower, loan_id), \u0026collateral)?;\n\n    Ok(Response::new()\n        .add_message(withdraw_message)\n        .add_attribute(\"action\", \"withdraw-funds\")\n        .add_attribute(\"event\", \"refused-offer\")\n        .add_attribute(\"borrower\", borrower)\n        .add_attribute(\"lender\", lender)\n        .add_attribute(\"loan_id\", loan_id.to_string())\n        .add_attribute(\"offer_id\", offer_id.to_string()))\n}\n\n/// This creates withdraw messages to withdraw the funds from an offer (to the lender of the borrower depending on the situation\n/// This function does not do any checks on the validity of the procedure\n/// Be careful when using this internal function\npub fn _withdraw_offer_unsafe(\n    deps: Deps,\n    borrower: Addr,\n    recipient: Addr,\n    loan_id: u64,\n    offer_id: usize,\n) -\u003e Result\u003cBankMsg, ContractError\u003e {\n    // We query the loan info\n    let collateral = COLLATERAL_INFO.load(deps.storage, (\u0026borrower, loan_id))?;\n    let offer = get_offer(\u0026collateral, offer_id)?;\n\n    // We get the funds to withdraw\n    let funds_to_withdraw = offer\n        .deposited_funds\n        .ok_or(ContractError::NoFundsToWithdraw {})?;\n\n    Ok(BankMsg::Send {\n        to_address: recipient.to_string(),\n        amount: vec![funds_to_withdraw],\n    })\n}\n\n/// Refuse an offer to a borrowers collateral\n/// This is needed only for printing and db procedure, and not actually needed in the flow\n/// This however blocks other interactions with the offer (except withdrawing the funds)\npub fn refuse_offer(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    loan_id: u64,\n    offer_id: u64,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // We query the loan info\n    let borrower = info.sender;\n    let mut collateral = COLLATERAL_INFO.load(deps.storage, (\u0026borrower, loan_id))?;\n\n    // Mark the offer as refused\n    let mut offer = get_offer(\u0026collateral, offer_id as usize)?;\n    offer.state = OfferState::Refused;\n    collateral.offers[offer_id as usize] = offer.clone();\n\n    // And save the changes to the collateral object\n    COLLATERAL_INFO.save(deps.storage, (\u0026borrower, loan_id), \u0026collateral)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"refuse-offer\")\n        .add_attribute(\"borrower\", borrower)\n        .add_attribute(\"lender\", offer.lender)\n        .add_attribute(\"loan_id\", loan_id.to_string())\n        .add_attribute(\"offer_id\", offer_id.to_string()))\n}\n\n/// Accept a loan and its terms directly\n/// As soon as the lender executes this messages, the loan starts and the borrower will need to repay the loan before the term\npub fn accept_loan(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    borrower: String,\n    loan_id: u64,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // We query the loan info\n    let borrower = deps.api.addr_validate(\u0026borrower)?;\n    let mut collateral = COLLATERAL_INFO.load(deps.storage, (\u0026borrower, loan_id))?;\n\n    // We verify the loan is acceptable as is\n    is_loan_acceptable(\u0026collateral)?;\n    let terms: LoanTerms = collateral\n        .terms\n        .clone()\n        .ok_or(ContractError::NoTermsSpecified {})?;\n\n    // We verify the funds received from the lender\n    if info.funds.len() != 1 {\n        return Err(ContractError::MultipleCoins {});\n    } else if terms.principle != info.funds[0].clone() {\n        return Err(ContractError::FundsDontMatchTerms {});\n    }\n\n    // Then we can save the original offer as accepted\n    collateral.state = LoanState::Started;\n    collateral.start_block = Some(env.block.height);\n\n    // We add this offer at the end of the list of offers.\n    // All other offers are marked as refused automatically (see `get_offer` in state.rs)\n    let offer_id = add_new_offer(\n        deps.storage,\n        \u0026mut collateral,\n        (borrower.clone(), loan_id),\n        OfferInfo {\n            lender: info.sender.clone(),\n            terms: terms.clone(),\n            state: OfferState::Accepted,\n            deposited_funds: Some(info.funds[0].clone()),\n        },\n    )?;\n    // We update the active loan variable\n    collateral.active_loan = Some(offer_id);\n    COLLATERAL_INFO.save(deps.storage, (\u0026borrower, loan_id), \u0026collateral)?;\n\n    // We withdraw funds to the borrower\n    let message = _withdraw_offer_unsafe(\n        deps.as_ref(),\n        borrower.clone(),\n        borrower.clone(),\n        loan_id,\n        offer_id as usize,\n    )?;\n\n    Ok(Response::new()\n        .add_message(message)\n        .add_attribute(\"action\", \"start-loan\")\n        .add_attribute(\"denom-borrowed\", terms.principle.denom)\n        .add_attribute(\"amount_borrowed\", terms.principle.amount.to_string())\n        .add_attribute(\"borrower\", borrower)\n        .add_attribute(\"lender\", info.sender)\n        .add_attribute(\"loan_id\", loan_id.to_string())\n        .add_attribute(\"offer_id\", offer_id.to_string()))\n}\n\n/// Accept an offer someone made for your collateral\n/// As soon as the borrower executes this messages, the loan starts and the they will need to repay the loan before the term\npub fn accept_offer(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    loan_id: u64,\n    offer_id: u64,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // We query the loan info\n    let borrower = info.sender;\n    let mut collateral = COLLATERAL_INFO.load(deps.storage, (\u0026borrower, loan_id))?;\n    is_loan_acceptable(\u0026collateral)?;\n    let offer_id_usize = offer_id as usize;\n    let mut offer = get_offer(\u0026collateral, offer_id_usize)?;\n\n    // We verify the offer is still valid\n    if offer.state == OfferState::Published {\n        // We can start the loan right away !\n        collateral.state = LoanState::Started;\n        collateral.start_block = Some(env.block.height);\n        collateral.active_loan = Some(offer_id);\n        offer.state = OfferState::Accepted;\n        collateral.offers[offer_id_usize] = offer.clone();\n\n        COLLATERAL_INFO.save(deps.storage, (\u0026borrower, loan_id), \u0026collateral)?;\n    } else {\n        return Err(ContractError::OfferNotFound {});\n    };\n\n    // We transfer the funds directly when the offer is accepted\n    let message = _withdraw_offer_unsafe(\n        deps.as_ref(),\n        borrower.clone(),\n        borrower.clone(),\n        loan_id,\n        offer_id as usize,\n    )?;\n\n    Ok(Response::new()\n        .add_message(message)\n        .add_attribute(\"action\", \"start-loan\")\n        .add_attribute(\"denom-borrowed\", offer.terms.principle.denom)\n        .add_attribute(\"amount_borrowed\", offer.terms.principle.amount.to_string())\n        .add_attribute(\"borrower\", borrower)\n        .add_attribute(\"lender\", offer.lender)\n        .add_attribute(\"loan_id\", loan_id.to_string())\n        .add_attribute(\"offer_id\", offer_id.to_string()))\n}\n\n/// Repay Borrowed funds and get back your collateral\n/// This function receives principle + interest funds to end the loan and unlock the collateral\npub fn repay_borrowed_funds(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    loan_id: u64,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let contract_info = CONTRACT_INFO.load(deps.storage)?;\n    // We query the loan info\n    let borrower = info.sender;\n    let mut collateral = COLLATERAL_INFO.load(deps.storage, (\u0026borrower, loan_id))?;\n    can_repay_loan(env.clone(), \u0026collateral)?;\n    let offer = get_active_loan(\u0026collateral)?;\n\n    // We verify the sent funds correspond to the principle + interests\n    let interests = offer.terms.interest;\n    if info.funds.len() != 1 {\n        return Err(ContractError::MultipleCoins {});\n    } else if offer.terms.principle.denom != info.funds[0].denom.clone() {\n        return Err(ContractError::Std(StdError::generic_err(\n            \"You didn't send the right kind of funds\",\n        )));\n    } else if offer.terms.principle.amount + interests \u003e info.funds[0].amount {\n        return Err(ContractError::Std(StdError::generic_err(\n            format!(\n                \"Fund sent do not match the loan terms (principle + interests). Needed : {needed}, Received : {received}\", \n                needed = offer.terms.principle.amount + interests,\n                received = info.funds[0].amount.clone()\n            )\n        )));\n    }\n\n    // We save the collateral state\n    collateral.state = LoanState::Ended;\n    COLLATERAL_INFO.save(deps.storage, (\u0026borrower, loan_id), \u0026collateral)?;\n\n    // We prepare the funds to send back to the lender\n    let lender_payback = offer.terms.principle.amount\n        + interests * (Uint128::new(100_000u128) - contract_info.fee_rate)\n            / Uint128::new(100_000u128);\n\n    // And the funds to send to the fee_depositor contract\n    let fee_depositor_payback = info.funds[0].amount - lender_payback;\n\n    // The fee depositor needs to know which assets where involved in the transaction\n    let collateral_address = match \u0026collateral.associated_asset {\n        AssetInfo::Cw1155Coin(cw1155) =\u003e cw1155.address.clone(),\n        AssetInfo::Cw721Coin(cw721) =\u003e cw721.address.clone(),\n        _ =\u003e {\n            return Err(ContractError::Std(StdError::generic_err(\n                \"Unreachable error\",\n            )))\n        }\n    };\n\n    Ok(Response::new()\n        // We get the funds back to the lender\n        .add_message(BankMsg::Send {\n            to_address: offer.lender.to_string(),\n            amount: coins(lender_payback.u128(), info.funds[0].denom.clone()),\n        })\n        // And the collateral back to the borrower\n        .add_message(_withdraw_asset(\n            collateral.associated_asset.clone(),\n            env.contract.address,\n            borrower.clone(),\n        )?)\n        // And we pay the fee to the treasury\n        .add_message(into_cosmos_msg(\n            FeeDistributorMsg::DepositFees {\n                addresses: vec![collateral_address],\n            },\n            contract_info.fee_distributor,\n            Some(coins(\n                fee_depositor_payback.u128(),\n                info.funds[0].denom.clone(),\n            )),\n        )?)\n        .add_attribute(\"action\", \"repay-loan\")\n        .add_attribute(\"borrower\", borrower)\n        .add_attribute(\"lender\", offer.lender)\n        .add_attribute(\"loan_id\", loan_id.to_string()))\n}\n\n/// Withdraw the collateral from a defaulted loan\n/// If the loan duration has exceeded, the collateral can be withdrawn by the lender\n/// This closes the loan and puts it in a defaulted state\npub fn withdraw_defaulted_loan(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    borrower: String,\n    loan_id: u64,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // We query the loan info\n    let borrower = deps.api.addr_validate(\u0026borrower)?;\n    let mut collateral = COLLATERAL_INFO.load(deps.storage, (\u0026borrower, loan_id))?;\n    is_loan_defaulted(env.clone(), \u0026collateral)?;\n    let offer = is_active_lender(info.sender, \u0026collateral)?;\n\n    // We need to test if the loan hasn't already been defaulted\n    if collateral.state == LoanState::Defaulted {\n        return Err(ContractError::LoanAlreadyDefaulted {});\n    }\n\n    // Saving the collateral state, the loan is defaulted, we can default it again\n    collateral.state = LoanState::Defaulted;\n    COLLATERAL_INFO.save(deps.storage, (\u0026borrower, loan_id), \u0026collateral)?;\n\n    // We create the collateral withdrawal message\n    let withdraw_message = _withdraw_asset(\n        collateral.associated_asset.clone(),\n        env.contract.address,\n        offer.lender.clone(),\n    )?;\n\n    Ok(Response::new()\n        .add_message(withdraw_message)\n        .add_attribute(\"action\", \"default-loan\")\n        .add_attribute(\"borrower\", borrower)\n        .add_attribute(\"lender\", offer.lender)\n        .add_attribute(\"loan_id\", loan_id.to_string()))\n}\n\npub fn _withdraw_asset(asset: AssetInfo, sender: Addr, recipient: Addr) -\u003e StdResult\u003cCosmosMsg\u003e {\n    match asset {\n        AssetInfo::Cw1155Coin(cw1155) =\u003e {\n            let address = cw1155.address;\n            let token_id = cw1155.token_id;\n            into_cosmos_msg(\n                Cw1155ExecuteMsg::SendFrom {\n                    from: sender.to_string(),\n                    to: recipient.to_string(),\n                    token_id,\n                    value: cw1155.value,\n                    msg: None,\n                },\n                address,\n                None,\n            )\n        }\n\n        AssetInfo::Cw721Coin(cw721) =\u003e {\n            let address = cw721.address;\n            let token_id = cw721.token_id;\n            into_cosmos_msg(\n                Cw721ExecuteMsg::TransferNft {\n                    recipient: recipient.to_string(),\n                    token_id,\n                },\n                address,\n                None,\n            )\n        }\n        _ =\u003e Err(StdError::generic_err(\"Unreachable error\")),\n    }\n}\n\n// TODO we need more queries, to query loan by user\npub fn query_contract_info(deps: Deps) -\u003e StdResult\u003cContractInfo\u003e {\n    CONTRACT_INFO.load(deps.storage)\n}\n\npub fn query_collateral_info(\n    deps: Deps,\n    borrower: String,\n    loan_id: u64,\n) -\u003e StdResult\u003cCollateralInfo\u003e {\n    let borrower = deps.api.addr_validate(\u0026borrower)?;\n    COLLATERAL_INFO\n        .load(deps.storage, (\u0026borrower, loan_id))\n        .map_err(|_| StdError::generic_err(\"LoanNotFound\"))\n}\n\npub fn query_offer_info(\n    deps: Deps,\n    borrower: String,\n    loan_id: u64,\n    offer_id: u64,\n) -\u003e StdResult\u003cOfferInfo\u003e {\n    let borrower = deps.api.addr_validate(\u0026borrower)?;\n    let collateral = COLLATERAL_INFO\n        .load(deps.storage, (\u0026borrower, loan_id))\n        .map_err(|_| StdError::generic_err(\"LoanNotFound\"))?;\n\n    get_offer(\u0026collateral, offer_id as usize).map_err(|_| StdError::generic_err(\"OfferNotFound\"))\n}\n\npub fn query_borrower_info(deps: Deps, borrower: String) -\u003e StdResult\u003cBorrowerInfo\u003e {\n    let borrower = deps.api.addr_validate(\u0026borrower)?;\n    BORROWER_INFO\n        .load(deps.storage, \u0026borrower)\n        .map_err(|_| StdError::generic_err(\"UnknownBorrower\"))\n}\n\npub fn query_collaterals(\n    deps: Deps,\n    borrower: String,\n    start_after: Option\u003cu64\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e StdResult\u003cVec\u003cCollateralResponse\u003e\u003e {\n    let borrower = deps.api.addr_validate(\u0026borrower)?;\n    let limit = limit.unwrap_or(DEFAULT_QUERY_LIMIT).min(MAX_QUERY_LIMIT) as usize;\n    let start = start_after.map(Bound::exclusive);\n\n    COLLATERAL_INFO\n        .prefix(\u0026borrower)\n        .range(deps.storage, None, start, Order::Descending)\n        .map(|result| {\n            result.map(|(loan_id, el)| CollateralResponse {\n                borrower: borrower.to_string(),\n                loan_id,\n                collateral: el,\n            })\n        })\n        .take(limit)\n        .collect()\n}\n\npub fn query_offers(\n    deps: Deps,\n    lender: String,\n    start_after: Option\u003cu32\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e StdResult\u003cVec\u003cOfferResponse\u003e\u003e {\n    let lender = deps.api.addr_validate(\u0026lender)?;\n    let limit = limit.unwrap_or(DEFAULT_QUERY_LIMIT).min(MAX_QUERY_LIMIT) as usize;\n    let start = start_after.unwrap_or(0u32) as usize;\n\n    Ok(LENDER_OFFERS\n        .load(deps.storage, \u0026lender)\n        .unwrap_or_default()\n        .iter()\n        .skip(start)\n        .map(|x| OfferResponse {\n            lender: lender.to_string(),\n            borrower: x.0.to_string(),\n            loan_id: x.1,\n            offer_id: x.2,\n        })\n        .take(limit)\n        .collect())\n}\n\n#[cfg(test)]\npub mod tests {\n    use super::*;\n    use cosmwasm_std::{\n        coin, coins,\n        testing::{mock_dependencies, mock_env, mock_info},\n        Api, Coin, SubMsg,\n    };\n\n    fn init_helper(deps: DepsMut) {\n        let instantiate_msg = InstantiateMsg {\n            name: \"nft-loan\".to_string(),\n            owner: None,\n            fee_distributor: \"T\".to_string(),\n            fee_rate: Uint128::new(5_000u128),\n        };\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n\n        instantiate(deps, env, info, instantiate_msg).unwrap();\n    }\n\n    #[test]\n    fn test_init_sanity() {\n        let mut deps = mock_dependencies();\n        let instantiate_msg = InstantiateMsg {\n            name: \"p2p-trading\".to_string(),\n            owner: Some(\"this_address\".to_string()),\n            fee_distributor: \"T\".to_string(),\n            fee_rate: Uint128::new(5_000u128),\n        };\n        let info = mock_info(\"owner\", \u0026[]);\n        let env = mock_env();\n\n        let res_init = instantiate(deps.as_mut(), env.clone(), info, instantiate_msg).unwrap();\n        assert_eq!(0, res_init.messages.len());\n\n        let contract = CONTRACT_INFO.load(\u0026deps.storage).unwrap();\n        assert_eq!(\n            contract,\n            ContractInfo {\n                name: \"p2p-trading\".to_string(),\n                owner: deps.api.addr_validate(\"this_address\").unwrap(),\n                fee_distributor: \"T\".to_string(),\n                fee_rate: Uint128::new(5_000u128),\n            }\n        );\n\n        let info = mock_info(\"this_address\", \u0026[]);\n        let bad_info = mock_info(\"bad_person\", \u0026[]);\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            ExecuteMsg::SetFeeDistributor {\n                fee_depositor: \"S\".to_string(),\n            },\n        )\n        .unwrap();\n        assert_eq!(\n            CONTRACT_INFO.load(\u0026deps.storage).unwrap().fee_distributor,\n            \"S\".to_string()\n        );\n\n        let unauthorized = execute(\n            deps.as_mut(),\n            env.clone(),\n            bad_info.clone(),\n            ExecuteMsg::SetFeeDistributor {\n                fee_depositor: \"S\".to_string(),\n            },\n        )\n        .unwrap_err();\n        assert_eq!(unauthorized, ContractError::Unauthorized {});\n\n        // We test changing the owner\n        let unauthorized = execute(\n            deps.as_mut(),\n            env.clone(),\n            bad_info.clone(),\n            ExecuteMsg::SetOwner {\n                owner: \"new_owner\".to_string(),\n            },\n        )\n        .unwrap_err();\n        assert_eq!(unauthorized, ContractError::Unauthorized {});\n\n        // We test changing the owner\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            ExecuteMsg::SetOwner {\n                owner: \"new_owner\".to_string(),\n            },\n        )\n        .unwrap();\n        assert_eq!(\n            CONTRACT_INFO.load(\u0026deps.storage).unwrap().owner,\n            \"new_owner\".to_string()\n        );\n\n        let info = mock_info(\"new_owner\", \u0026[]);\n\n        let unauthorized = execute(\n            deps.as_mut(),\n            env.clone(),\n            bad_info,\n            ExecuteMsg::SetFeeRate {\n                fee_rate: Uint128::new(500u128),\n            },\n        )\n        .unwrap_err();\n        assert_eq!(unauthorized, ContractError::Unauthorized {});\n\n        execute(\n            deps.as_mut(),\n            env,\n            info,\n            ExecuteMsg::SetFeeRate {\n                fee_rate: Uint128::new(500u128),\n            },\n        )\n        .unwrap();\n        assert_eq!(\n            CONTRACT_INFO.load(\u0026deps.storage).unwrap().fee_rate,\n            Uint128::new(500u128)\n        );\n    }\n\n    fn add_collateral_helper(\n        deps: DepsMut,\n        creator: \u0026str,\n        address: \u0026str,\n        token_id: \u0026str,\n        value: Option\u003cUint128\u003e,\n        terms: Option\u003cLoanTerms\u003e,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(creator, \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::DepositCollateral {\n                address: address.to_string(),\n                token_id: token_id.to_string(),\n                value,\n                terms,\n            },\n        )\n    }\n\n    fn set_terms_helper(\n        deps: DepsMut,\n        borrower: \u0026str,\n        loan_id: u64,\n        terms: LoanTerms,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(borrower, \u0026[]);\n        let env = mock_env();\n\n        execute(deps, env, info, ExecuteMsg::SetTerms { loan_id, terms })\n    }\n\n    fn make_offer_helper(\n        deps: DepsMut,\n        lender: \u0026str,\n        borrower: \u0026str,\n        loan_id: u64,\n        terms: LoanTerms,\n        coins: Vec\u003cCoin\u003e,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(lender, \u0026coins);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::MakeOffer {\n                borrower: borrower.to_string(),\n                loan_id,\n                terms,\n            },\n        )\n    }\n\n    fn cancel_offer_helper(\n        deps: DepsMut,\n        lender: \u0026str,\n        borrower: \u0026str,\n        loan_id: u64,\n        offer_id: u64,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(lender, \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::CancelOffer {\n                borrower: borrower.to_string(),\n                loan_id,\n                offer_id,\n            },\n        )\n    }\n\n    fn refuse_offer_helper(\n        deps: DepsMut,\n        borrower: \u0026str,\n        loan_id: u64,\n        offer_id: u64,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(borrower, \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::RefuseOffer { loan_id, offer_id },\n        )\n    }\n\n    fn accept_loan_helper(\n        deps: DepsMut,\n        lender: \u0026str,\n        borrower: \u0026str,\n        loan_id: u64,\n        coins: Vec\u003cCoin\u003e,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(lender, \u0026coins);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::AcceptLoan {\n                borrower: borrower.to_string(),\n                loan_id,\n            },\n        )\n    }\n\n    fn accept_offer_helper(\n        deps: DepsMut,\n        borrower: \u0026str,\n        loan_id: u64,\n        offer_id: u64,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(borrower, \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::AcceptOffer { loan_id, offer_id },\n        )\n    }\n\n    fn withdraw_collateral_helper(\n        deps: DepsMut,\n        creator: \u0026str,\n        loan_id: u64,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(creator, \u0026[]);\n        let env = mock_env();\n\n        execute(deps, env, info, ExecuteMsg::WithdrawCollateral { loan_id })\n    }\n\n    fn withdraw_refused_offer_helper(\n        deps: DepsMut,\n        lender: \u0026str,\n        borrower: \u0026str,\n        loan_id: u64,\n        offer_id: u64,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(lender, \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::WithdrawRefusedOffer {\n                borrower: borrower.to_string(),\n                loan_id,\n                offer_id,\n            },\n        )\n    }\n    fn repay_borrowed_funds_helper(\n        deps: DepsMut,\n        borrower: \u0026str,\n        loan_id: u64,\n        funds: Vec\u003cCoin\u003e,\n        env: Env,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(borrower, \u0026funds);\n\n        execute(deps, env, info, ExecuteMsg::RepayBorrowedFunds { loan_id })\n    }\n    fn withdraw_defaulted_loan_helper(\n        deps: DepsMut,\n        lender: \u0026str,\n        borrower: \u0026str,\n        loan_id: u64,\n        env: Env,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(lender, \u0026[]);\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::WithdrawDefaultedLoan {\n                borrower: borrower.to_string(),\n                loan_id,\n            },\n        )\n    }\n\n    #[test]\n    fn test_add_collateral() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n        // We make sure the collateral is deposited correctly\n        let res = add_collateral_helper(deps.as_mut(), \"creator\", \"nft\", \"58\", None, None).unwrap();\n        assert_eq!(1, res.messages.len());\n\n        // Other collaterals\n        add_collateral_helper(deps.as_mut(), \"creator\", \"nft\", \"59\", None, None).unwrap();\n        add_collateral_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"nft\",\n            \"59\",\n            Some(Uint128::from(459u128)),\n            None,\n        )\n        .unwrap();\n\n        let creator_addr = deps.api.addr_validate(\"creator\").unwrap();\n        let coll_info = COLLATERAL_INFO\n            .load(\u0026deps.storage, (\u0026creator_addr, 0))\n            .unwrap();\n        assert_eq!(\n            coll_info,\n            CollateralInfo {\n                associated_asset: AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft\".to_string(),\n                    token_id: \"58\".to_string()\n                }),\n                ..Default::default()\n            }\n        );\n\n        let coll_info = COLLATERAL_INFO\n            .load(\u0026deps.storage, (\u0026creator_addr, 1))\n            .unwrap();\n        assert_eq!(\n            coll_info,\n            CollateralInfo {\n                associated_asset: AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft\".to_string(),\n                    token_id: \"59\".to_string()\n                }),\n                ..Default::default()\n            }\n        );\n\n        let coll_info = COLLATERAL_INFO\n            .load(\u0026deps.storage, (\u0026creator_addr, 2))\n            .unwrap();\n        assert_eq!(\n            coll_info,\n            CollateralInfo {\n                associated_asset: AssetInfo::Cw1155Coin(Cw1155Coin {\n                    address: \"nft\".to_string(),\n                    token_id: \"59\".to_string(),\n                    value: Uint128::from(459u128)\n                }),\n                ..Default::default()\n            }\n        );\n    }\n\n    #[test]\n    fn test_withdraw_collateral() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n        add_collateral_helper(deps.as_mut(), \"creator\", \"nft\", \"58\", None, None).unwrap();\n        add_collateral_helper(deps.as_mut(), \"creator\", \"nft\", \"59\", None, None).unwrap();\n        add_collateral_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"nft\",\n            \"59\",\n            Some(Uint128::from(459u128)),\n            None,\n        )\n        .unwrap();\n\n        withdraw_collateral_helper(deps.as_mut(), \"creator\", 1).unwrap();\n        withdraw_collateral_helper(deps.as_mut(), \"creator\", 0).unwrap();\n\n        let creator_addr = deps.api.addr_validate(\"creator\").unwrap();\n        let coll_info = COLLATERAL_INFO\n            .load(\u0026deps.storage, (\u0026creator_addr, 0))\n            .unwrap();\n        assert_eq!(\n            coll_info,\n            CollateralInfo {\n                associated_asset: AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft\".to_string(),\n                    token_id: \"58\".to_string()\n                }),\n                state: LoanState::AssetWithdrawn,\n                ..Default::default()\n            }\n        );\n\n        let coll_info = COLLATERAL_INFO\n            .load(\u0026deps.storage, (\u0026creator_addr, 1))\n            .unwrap();\n        assert_eq!(\n            coll_info,\n            CollateralInfo {\n                associated_asset: AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft\".to_string(),\n                    token_id: \"59\".to_string()\n                }),\n                state: LoanState::AssetWithdrawn,\n                ..Default::default()\n            }\n        );\n\n        let coll_info = COLLATERAL_INFO\n            .load(\u0026deps.storage, (\u0026creator_addr, 2))\n            .unwrap();\n        assert_eq!(\n            coll_info,\n            CollateralInfo {\n                terms: None,\n                associated_asset: AssetInfo::Cw1155Coin(Cw1155Coin {\n                    address: \"nft\".to_string(),\n                    token_id: \"59\".to_string(),\n                    value: Uint128::from(459u128)\n                }),\n                ..Default::default()\n            }\n        );\n        // You shouldn't be able to repay the loan now\n        let repay_err = repay_borrowed_funds_helper(\n            deps.as_mut(),\n            \"creator\",\n            0,\n            coins(506, \"luna\"),\n            mock_env(),\n        )\n        .unwrap_err();\n        assert_eq!(\n            repay_err,\n            ContractError::WrongLoanState {\n                state: LoanState::AssetWithdrawn\n            }\n        )\n    }\n\n    #[test]\n    fn test_accept_loan() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n        add_collateral_helper(deps.as_mut(), \"creator\", \"nft\", \"58\", None, None).unwrap();\n        add_collateral_helper(deps.as_mut(), \"creator\", \"nft\", \"59\", None, None).unwrap();\n        add_collateral_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"nft\",\n            \"59\",\n            Some(Uint128::from(459u128)),\n            None,\n        )\n        .unwrap();\n\n        let terms = LoanTerms {\n            principle: coin(456, \"luna\"),\n            interest: Uint128::new(0),\n            duration_in_blocks: 0,\n        };\n        set_terms_helper(deps.as_mut(), \"creator\", 0, terms.clone()).unwrap();\n\n        // The funds have to match the terms\n        let err = accept_loan_helper(deps.as_mut(), \"anyone\", \"creator\", 0, coins(123, \"luna\"))\n            .unwrap_err();\n        assert_eq!(err, ContractError::FundsDontMatchTerms {});\n        let err = accept_loan_helper(\n            deps.as_mut(),\n            \"anyone\",\n            \"creator\",\n            0,\n            vec![coin(123, \"luna\"), coin(457, \"uusd\")],\n        )\n        .unwrap_err();\n        assert_eq!(err, ContractError::MultipleCoins {});\n\n        accept_loan_helper(deps.as_mut(), \"anyone\", \"creator\", 0, coins(456, \"luna\")).unwrap();\n        accept_loan_helper(\n            deps.as_mut(),\n            \"anyone_else\",\n            \"creator\",\n            0,\n            coins(456, \"luna\"),\n        )\n        .unwrap_err();\n        let creator_addr = deps.api.addr_validate(\"creator\").unwrap();\n        let coll_info = COLLATERAL_INFO\n            .load(\u0026deps.storage, (\u0026creator_addr, 0))\n            .unwrap();\n\n        assert_eq!(\n            coll_info,\n            CollateralInfo {\n                terms: Some(terms.clone()),\n                associated_asset: AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft\".to_string(),\n                    token_id: \"58\".to_string()\n                }),\n                state: LoanState::Started,\n                active_loan: Some(0),\n                start_block: Some(12345),\n                offers: vec![OfferInfo {\n                    lender: deps.api.addr_validate(\"anyone\").unwrap(),\n                    terms,\n                    state: OfferState::Accepted,\n                    deposited_funds: Some(coin(456, \"luna\")),\n                }]\n            }\n        );\n    }\n\n    #[test]\n    fn test_accept_loan_and_modify() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n\n        let terms = LoanTerms {\n            principle: coin(456, \"luna\"),\n            interest: Uint128::new(0),\n            duration_in_blocks: 0,\n        };\n        add_collateral_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"nft\",\n            \"58\",\n            Some(Uint128::from(8_u128)),\n            Some(terms.clone()),\n        )\n        .unwrap();\n        accept_loan_helper(deps.as_mut(), \"anyone\", \"creator\", 0, coins(456, \"luna\")).unwrap();\n\n        // We try to modify the loan\n        let modify_err = set_terms_helper(deps.as_mut(), \"creator\", 0, terms.clone()).unwrap_err();\n        assert_eq!(modify_err, ContractError::NotModifiable {});\n\n        // We try to counter the loan, and propose new terms\n        let offer_err = make_offer_helper(\n            deps.as_mut(),\n            \"anyone\",\n            \"creator\",\n            0,\n            terms,\n            coins(456, \"luna\"),\n        )\n        .unwrap_err();\n\n        assert_eq!(offer_err, ContractError::NotCounterable {});\n    }\n\n    #[test]\n    fn test_repay_loan_early() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n\n        let terms = LoanTerms {\n            principle: coin(456, \"luna\"),\n            interest: Uint128::new(0),\n            duration_in_blocks: 0,\n        };\n        add_collateral_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"nft\",\n            \"58\",\n            Some(Uint128::from(8_u128)),\n            Some(terms),\n        )\n        .unwrap();\n        let repay_err = repay_borrowed_funds_helper(\n            deps.as_mut(),\n            \"creator\",\n            0,\n            coins(506, \"luna\"),\n            mock_env(),\n        )\n        .unwrap_err();\n        assert_eq!(\n            repay_err,\n            ContractError::WrongLoanState {\n                state: LoanState::Published\n            }\n        )\n    }\n\n    #[test]\n    fn test_make_offer() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n        add_collateral_helper(deps.as_mut(), \"creator\", \"nft\", \"58\", None, None).unwrap();\n        add_collateral_helper(deps.as_mut(), \"creator\", \"nft\", \"59\", None, None).unwrap();\n        add_collateral_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"nft\",\n            \"59\",\n            Some(Uint128::from(459u128)),\n            None,\n        )\n        .unwrap();\n\n        let terms = LoanTerms {\n            principle: coin(456, \"luna\"),\n            interest: Uint128::new(0),\n            duration_in_blocks: 0,\n        };\n\n        let err = make_offer_helper(\n            deps.as_mut(),\n            \"anyone\",\n            \"creator\",\n            0,\n            terms.clone(),\n            coins(6765, \"luna\"),\n        )\n        .unwrap_err();\n        assert_eq!(err, ContractError::FundsDontMatchTerms {});\n\n        let err = make_offer_helper(\n            deps.as_mut(),\n            \"anyone\",\n            \"creator\",\n            0,\n            terms.clone(),\n            vec![coin(456, \"luna\"), coin(456, \"luna\")],\n        )\n        .unwrap_err();\n        assert_eq!(err, ContractError::MultipleCoins {});\n\n        make_offer_helper(\n            deps.as_mut(),\n            \"anyone\",\n            \"creator\",\n            0,\n            terms,\n            coins(456, \"luna\"),\n        )\n        .unwrap();\n    }\n\n    #[test]\n    fn test_cancel_offer() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n        add_collateral_helper(deps.as_mut(), \"creator\", \"nft\", \"58\", None, None).unwrap();\n        add_collateral_helper(deps.as_mut(), \"creator\", \"nft\", \"59\", None, None).unwrap();\n        add_collateral_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"nft\",\n            \"59\",\n            Some(Uint128::from(459u128)),\n            None,\n        )\n        .unwrap();\n\n        let terms = LoanTerms {\n            principle: coin(456, \"luna\"),\n            interest: Uint128::new(0),\n            duration_in_blocks: 0,\n        };\n\n        make_offer_helper(\n            deps.as_mut(),\n            \"anyone\",\n            \"creator\",\n            0,\n            terms,\n            coins(456, \"luna\"),\n        )\n        .unwrap();\n\n        cancel_offer_helper(deps.as_mut(), \"anyone_else\", \"creator\", 0, 0).unwrap_err();\n\n        let res = cancel_offer_helper(deps.as_mut(), \"anyone\", \"creator\", 0, 0).unwrap();\n\n        assert_eq!(\n            res.messages,\n            vec![SubMsg::new(BankMsg::Send {\n                to_address: \"anyone\".to_string(),\n                amount: coins(456, \"luna\"),\n            }),]\n        );\n\n        cancel_offer_helper(deps.as_mut(), \"anyone\", \"creator\", 0, 0).unwrap_err();\n    }\n\n    #[test]\n    fn test_refuse_offer() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n        add_collateral_helper(deps.as_mut(), \"creator\", \"nft\", \"58\", None, None).unwrap();\n        add_collateral_helper(deps.as_mut(), \"creator\", \"nft\", \"59\", None, None).unwrap();\n        add_collateral_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"nft\",\n            \"59\",\n            Some(Uint128::from(459u128)),\n            None,\n        )\n        .unwrap();\n\n        let terms = LoanTerms {\n            principle: coin(456, \"luna\"),\n            interest: Uint128::new(0),\n            duration_in_blocks: 0,\n        };\n\n        make_offer_helper(\n            deps.as_mut(),\n            \"anyone\",\n            \"creator\",\n            0,\n            terms,\n            coins(456, \"luna\"),\n        )\n        .unwrap();\n\n        refuse_offer_helper(deps.as_mut(), \"bad_person\", 0, 0).unwrap_err();\n        refuse_offer_helper(deps.as_mut(), \"creator\", 0, 0).unwrap();\n\n        let offer = COLLATERAL_INFO\n            .load(\n                \u0026deps.storage,\n                (\u0026deps.api.addr_validate(\"creator\").unwrap(), 0u64),\n            )\n            .unwrap()\n            .offers[0]\n            .clone();\n\n        assert_eq!(offer.state, OfferState::Refused);\n    }\n\n    #[test]\n    fn test_cancel_accepted() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n\n        let terms = LoanTerms {\n            principle: coin(456, \"luna\"),\n            interest: Uint128::new(0),\n            duration_in_blocks: 0,\n        };\n\n        add_collateral_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"nft\",\n            \"58\",\n            Some(Uint128::new(45u128)),\n            Some(terms),\n        )\n        .unwrap();\n\n        accept_loan_helper(deps.as_mut(), \"anyone\", \"creator\", 0, coins(456, \"luna\")).unwrap();\n\n        withdraw_collateral_helper(deps.as_mut(), \"creator\", 0).unwrap_err();\n        cancel_offer_helper(deps.as_mut(), \"anyone\", \"creator\", 0, 0).unwrap_err();\n    }\n\n    #[test]\n    fn test_withdraw_refused() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n\n        let terms = LoanTerms {\n            principle: coin(456, \"luna\"),\n            interest: Uint128::new(0),\n            duration_in_blocks: 0,\n        };\n\n        add_collateral_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"nft\",\n            \"58\",\n            Some(Uint128::new(45u128)),\n            Some(terms.clone()),\n        )\n        .unwrap();\n        make_offer_helper(\n            deps.as_mut(),\n            \"anyone\",\n            \"creator\",\n            0,\n            terms.clone(),\n            coins(456, \"luna\"),\n        )\n        .unwrap();\n\n        make_offer_helper(\n            deps.as_mut(),\n            \"anyone\",\n            \"creator\",\n            0,\n            terms,\n            coins(456, \"luna\"),\n        )\n        .unwrap();\n\n        withdraw_refused_offer_helper(deps.as_mut(), \"anyone\", \"creator\", 0, 0).unwrap_err();\n        withdraw_refused_offer_helper(deps.as_mut(), \"anyone\", \"creator\", 0, 1).unwrap_err();\n        let err =\n            withdraw_refused_offer_helper(deps.as_mut(), \"anyone\", \"creator\", 0, 2).unwrap_err();\n        assert_eq!(err, ContractError::OfferNotFound {});\n\n        let err = accept_offer_helper(deps.as_mut(), \"creator\", 0, 87).unwrap_err();\n        assert_eq!(err, ContractError::OfferNotFound {});\n        accept_offer_helper(deps.as_mut(), \"creator\", 0, 0).unwrap();\n\n        withdraw_refused_offer_helper(deps.as_mut(), \"anyone\", \"creator\", 0, 0).unwrap_err();\n        withdraw_refused_offer_helper(deps.as_mut(), \"anyone_else\", \"creator\", 0, 1).unwrap_err();\n        withdraw_refused_offer_helper(deps.as_mut(), \"anyone\", \"creator\", 0, 1).unwrap();\n        withdraw_refused_offer_helper(deps.as_mut(), \"anyone\", \"creator\", 0, 1).unwrap_err();\n    }\n    #[test]\n    fn test_accept_cancelled_offer() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n        add_collateral_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"nft\",\n            \"58\",\n            Some(Uint128::new(45u128)),\n            None,\n        )\n        .unwrap();\n\n        let terms = LoanTerms {\n            principle: coin(456, \"luna\"),\n            interest: Uint128::new(0),\n            duration_in_blocks: 0,\n        };\n\n        make_offer_helper(\n            deps.as_mut(),\n            \"anyone\",\n            \"creator\",\n            0,\n            terms,\n            coins(456, \"luna\"),\n        )\n        .unwrap();\n\n        cancel_offer_helper(deps.as_mut(), \"anyone\", \"creator\", 0, 0).unwrap();\n        let err = accept_offer_helper(deps.as_mut(), \"creator\", 0, 0).unwrap_err();\n        assert_eq!(err, ContractError::OfferNotFound {})\n    }\n\n    #[test]\n    fn test_normal_flow() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n\n        let terms = LoanTerms {\n            principle: coin(456, \"luna\"),\n            interest: Uint128::new(50),\n            duration_in_blocks: 1,\n        };\n\n        add_collateral_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"nft\",\n            \"58\",\n            Some(Uint128::new(45u128)),\n            Some(terms.clone()),\n        )\n        .unwrap();\n        make_offer_helper(\n            deps.as_mut(),\n            \"anyone\",\n            \"creator\",\n            0,\n            terms,\n            coins(456, \"luna\"),\n        )\n        .unwrap();\n\n        accept_offer_helper(deps.as_mut(), \"creator\", 0, 0).unwrap();\n        // Loan starts\n\n        let env = mock_env();\n        let not_now_err =\n            withdraw_defaulted_loan_helper(deps.as_mut(), \"anyone\", \"creator\", 0, env.clone())\n                .unwrap_err();\n        assert_eq!(\n            not_now_err,\n            ContractError::WrongLoanState {\n                state: LoanState::Started\n            }\n        );\n\n        let err = repay_borrowed_funds_helper(\n            deps.as_mut(),\n            \"creator\",\n            0,\n            coins(456, \"luna\"),\n            env.clone(),\n        )\n        .unwrap_err();\n        assert_eq!(err, ContractError::Std(\n            StdError::generic_err(\"Fund sent do not match the loan terms (principle + interests). Needed : 506, Received : 456\")\n        ));\n        let err = repay_borrowed_funds_helper(\n            deps.as_mut(),\n            \"creator\",\n            0,\n            vec![coin(456, \"luna\"), coin(456, \"luna\")],\n            env.clone(),\n        )\n        .unwrap_err();\n        assert_eq!(err, ContractError::MultipleCoins {});\n        let err = repay_borrowed_funds_helper(\n            deps.as_mut(),\n            \"creator\",\n            0,\n            coins(456, \"uust\"),\n            env.clone(),\n        )\n        .unwrap_err();\n        assert_eq!(\n            err,\n            ContractError::Std(StdError::generic_err(\n                \"You didn't send the right kind of funds\",\n            ))\n        );\n\n        repay_borrowed_funds_helper(\n            deps.as_mut(),\n            \"bad_person\",\n            0,\n            coins(506, \"luna\"),\n            env.clone(),\n        )\n        .unwrap_err();\n\n        let res = repay_borrowed_funds_helper(deps.as_mut(), \"creator\", 0, coins(506, \"luna\"), env)\n            .unwrap();\n        let env = mock_env();\n        assert_eq!(\n            res.messages,\n            vec![\n                SubMsg::new(BankMsg::Send {\n                    to_address: \"anyone\".to_string(),\n                    amount: coins(503, \"luna\"),\n                }),\n                SubMsg::new(\n                    into_cosmos_msg(\n                        Cw1155ExecuteMsg::SendFrom {\n                            from: env.contract.address.to_string(),\n                            to: \"creator\".to_string(),\n                            token_id: \"58\".to_string(),\n                            value: Uint128::new(45u128),\n                            msg: None,\n                        },\n                        \"nft\",\n                        None\n                    )\n                    .unwrap()\n                ),\n                SubMsg::new(\n                    into_cosmos_msg(\n                        FeeDistributorMsg::DepositFees {\n                            addresses: vec![\"nft\".to_string()]\n                        },\n                        \"T\",\n                        Some(coins(3, \"luna\"))\n                    )\n                    .unwrap()\n                )\n            ]\n        );\n    }\n\n    #[test]\n    fn test_defaulted_flow() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n\n        let terms = LoanTerms {\n            principle: coin(456, \"luna\"),\n            interest: Uint128::new(0),\n            duration_in_blocks: 0,\n        };\n\n        add_collateral_helper(\n            deps.as_mut(),\n            \"creator\",\n            \"nft\",\n            \"58\",\n            Some(Uint128::new(45u128)),\n            None,\n        )\n        .unwrap();\n        make_offer_helper(\n            deps.as_mut(),\n            \"anyone\",\n            \"creator\",\n            0,\n            terms,\n            coins(456, \"luna\"),\n        )\n        .unwrap();\n\n        accept_offer_helper(deps.as_mut(), \"creator\", 0, 0).unwrap();\n        let mut env = mock_env();\n        env.block.height = 12346;\n        let err = repay_borrowed_funds_helper(\n            deps.as_mut(),\n            \"creator\",\n            0,\n            coins(456, \"luna\"),\n            env.clone(),\n        )\n        .unwrap_err();\n        assert_eq!(\n            err,\n            ContractError::WrongLoanState {\n                state: LoanState::Defaulted {},\n            }\n        );\n\n        let err =\n            withdraw_defaulted_loan_helper(deps.as_mut(), \"bad_person\", \"creator\", 0, env.clone())\n                .unwrap_err();\n        assert_eq!(err, ContractError::Unauthorized {});\n        withdraw_defaulted_loan_helper(deps.as_mut(), \"anyone\", \"creator\", 0, env.clone()).unwrap();\n        withdraw_defaulted_loan_helper(deps.as_mut(), \"anyone\", \"creator\", 0, env).unwrap_err();\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","nft-loans","src","error.rs"],"content":"use cosmwasm_std::StdError;\nuse nft_loans_export::state::{LoanState, OfferState};\nuse thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized {},\n\n    #[error(\"An unplanned bug just happened :/\")]\n    ContractBug {},\n\n    #[error(\"You need to send exactly one coin with this transaction\")]\n    MultipleCoins {},\n\n    #[error(\"Fund sent do not match the loan terms\")]\n    FundsDontMatchTerms {},\n\n    #[error(\"Sorry, your asset is not withdrawable at this stage\")]\n    NotWithdrawable {},\n\n    #[error(\"Sorry, your asset is not withdrawable at this stage\")]\n    NotModifiable {},\n\n    #[error(\"Sorry, no assets to withdraw here\")]\n    NoFundsToWithdraw {},\n\n    #[error(\"Sorry, you can't accept this loan\")]\n    NotAcceptable {},\n\n    #[error(\"Sorry, you can't make an offer on this trade\")]\n    NotCounterable {},\n\n    #[error(\"This loan doesn't have any terms\")]\n    NoTermsSpecified {},\n\n    #[error(\"Sorry, this loan doesn't exist :/\")]\n    LoanNotFound {},\n\n    #[error(\"Sorry, this offer doesn't exist :/\")]\n    OfferNotFound {},\n\n    #[error(\"Wrong state of the loan for the current operation : {state:?}\")]\n    WrongLoanState { state: LoanState },\n\n    #[error(\"Can change the state of the offer from {from:?} to {to:?}\")]\n    CantChangeOfferState { from: OfferState, to: OfferState },\n\n    #[error(\"The loan has already been defaulted, you can't withdraw the funds again\")]\n    LoanAlreadyDefaulted {},\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","nft-loans","src","lib.rs"],"content":"pub mod contract;\nmod error;\npub mod state;\n\npub use crate::error::ContractError;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","nft-loans","src","query.rs"],"content":"use cosmwasm_std::{Api, Pair};\n#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::{Deps, Order, StdResult};\n\nuse cw_storage_plus::{Bound, PrimaryKey, U64Key};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse std::convert::TryInto;\n\nuse crate::state::{CONTRACT_INFO, COUNTER_TRADE_INFO, TRADE_INFO};\nuse p2p_trading_export::msg::QueryFilters;\nuse p2p_trading_export::state::{AssetInfo, ContractInfo, CounterTradeInfo, TradeInfo};\n\n// settings for pagination\nconst MAX_LIMIT: u32 = 30;\nconst DEFAULT_LIMIT: u32 = 10;\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug, Default)]\npub struct TradeResponse {\n    pub trade_id: u64,\n    pub counter_id: Option\u003cu64\u003e,\n    pub trade_info: TradeInfo,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug, Default)]\npub struct AllTradesResponse {\n    pub trades: Vec\u003cTradeResponse\u003e,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug, Default)]\npub struct AllCounterTradesResponse {\n    pub counter_trades: Vec\u003cTradeResponse\u003e,\n}\n\npub fn query_contract_info(deps: Deps) -\u003e StdResult\u003cContractInfo\u003e {\n    CONTRACT_INFO.load(deps.storage)\n}\n\n// parse trades to human readable format\nfn parse_trades(_: \u0026dyn Api, item: StdResult\u003cPair\u003cTradeInfo\u003e\u003e) -\u003e StdResult\u003cTradeResponse\u003e {\n    item.map(|(k, trade)| {\n        let trade_id = k.try_into().unwrap();\n        TradeResponse {\n            trade_id: u64::from_be_bytes(trade_id),\n            counter_id: None,\n            trade_info: trade,\n        }\n    })\n}\n\npub fn trade_filter(\n    api: \u0026dyn Api,\n    trade_info: \u0026StdResult\u003cTradeResponse\u003e,\n    filters: \u0026Option\u003cQueryFilters\u003e,\n) -\u003e bool {\n    if let Some(filters) = filters {\n        let trade = trade_info.as_ref().unwrap();\n\n        (match \u0026filters.states {\n            Some(state) =\u003e state.contains(\u0026trade.trade_info.state.to_string()),\n            None =\u003e true,\n        } \u0026\u0026 match \u0026filters.owner {\n            Some(owner) =\u003e trade.trade_info.owner == owner.clone(),\n            None =\u003e true,\n        } \u0026\u0026 match \u0026filters.whitelisted_user {\n            Some(whitelisted_user) =\u003e trade\n                .trade_info\n                .whitelisted_users\n                .contains(\u0026api.addr_validate(whitelisted_user).unwrap()),\n            None =\u003e true,\n        } \u0026\u0026 match \u0026filters.wanted_nft {\n            Some(wanted_nft) =\u003e trade\n                .trade_info\n                .additionnal_info\n                .nfts_wanted\n                .contains(\u0026api.addr_validate(wanted_nft).unwrap()),\n            None =\u003e true,\n        } \u0026\u0026 match \u0026filters.contains_token {\n            Some(token) =\u003e trade\n                .trade_info\n                .associated_assets\n                .iter()\n                .any(|asset| match asset {\n                    AssetInfo::Cw20Coin(x) =\u003e x.address == token.as_ref(),\n                    AssetInfo::Cw721Coin(x) =\u003e x.address == token.as_ref(),\n                    AssetInfo::Cw1155Coin(x) =\u003e x.address == token.as_ref(),\n                }),\n            None =\u003e true,\n        })\n    } else {\n        true\n    }\n}\n\npub fn query_all_trades(\n    deps: Deps,\n    start_after: Option\u003cu64\u003e,\n    limit: Option\u003cu32\u003e,\n    filters: Option\u003cQueryFilters\u003e,\n) -\u003e StdResult\u003cAllTradesResponse\u003e {\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n    let start = start_after.map(|s| Bound::Exclusive(U64Key::new(s).joined_key()));\n\n    let trades: StdResult\u003cVec\u003cTradeResponse\u003e\u003e = TRADE_INFO\n        .range(deps.storage, None, start, Order::Descending)\n        .map(|kv_item| parse_trades(deps.api, kv_item))\n        .filter(|response| trade_filter(deps.api, response, \u0026filters))\n        .take(limit)\n        .collect();\n\n    Ok(AllTradesResponse { trades: trades? })\n}\n\n// parse counter trades to human readable format\nfn parse_all_counter_trades(\n    _: \u0026dyn Api,\n    item: StdResult\u003cPair\u003cTradeInfo\u003e\u003e,\n) -\u003e StdResult\u003cTradeResponse\u003e {\n    item.map(|(ck, trade)| {\n        // First two bytes define size [0,8] since we know it's u64 skip it.\n        let (trade_id, counter_id) = (\u0026ck[2..10], \u0026ck[10..]);\n        let trade_id = trade_id.try_into().unwrap();\n        let counter_id = counter_id.try_into().unwrap();\n\n        TradeResponse {\n            trade_id: u64::from_be_bytes(trade_id),\n            counter_id: Some(u64::from_be_bytes(counter_id)),\n            trade_info: trade,\n        }\n    })\n}\n\npub fn query_all_counter_trades(\n    deps: Deps,\n    start_after: Option\u003cCounterTradeInfo\u003e,\n    limit: Option\u003cu32\u003e,\n    filters: Option\u003cQueryFilters\u003e,\n) -\u003e StdResult\u003cAllCounterTradesResponse\u003e {\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n\n    let start = start_after.map(|s| {\n        Bound::Exclusive((U64Key::new(s.trade_id), U64Key::new(s.counter_id)).joined_key())\n    });\n\n    let counter_trades: StdResult\u003cVec\u003cTradeResponse\u003e\u003e = COUNTER_TRADE_INFO\n        .range(deps.storage, None, start, Order::Descending)\n        .map(|kv_item| parse_all_counter_trades(deps.api, kv_item))\n        .filter(|response| trade_filter(deps.api, response, \u0026filters))\n        .take(limit)\n        .collect();\n\n    Ok(AllCounterTradesResponse {\n        counter_trades: counter_trades?,\n    })\n}\n\n// parse counter trades to human readable format\nfn parse_counter_trades(\n    _: \u0026dyn Api,\n    item: StdResult\u003cPair\u003cTradeInfo\u003e\u003e,\n    trade_id: Vec\u003cu8\u003e,\n) -\u003e StdResult\u003cTradeResponse\u003e {\n    item.map(|(counter_id, trade)| {\n        let trade_id = trade_id.try_into().unwrap();\n        let counter_id = counter_id.try_into().unwrap();\n\n        TradeResponse {\n            trade_id: u64::from_be_bytes(trade_id),\n            counter_id: Some(u64::from_be_bytes(counter_id)),\n            trade_info: trade,\n        }\n    })\n}\n\npub fn query_counter_trades(deps: Deps, trade_id: u64) -\u003e StdResult\u003cAllCounterTradesResponse\u003e {\n    let counter_trades: StdResult\u003cVec\u003cTradeResponse\u003e\u003e = COUNTER_TRADE_INFO\n        .prefix(trade_id.into())\n        .range(deps.storage, None, None, Order::Descending)\n        .map(|kv_item| parse_counter_trades(deps.api, kv_item, U64Key::new(trade_id).joined_key()))\n        .collect();\n\n    Ok(AllCounterTradesResponse {\n        counter_trades: counter_trades?,\n    })\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","nft-loans","src","state.rs"],"content":"use cw_storage_plus::{Item, Map};\n\nuse cosmwasm_std::{Addr, Env, Storage};\n\nuse crate::error::ContractError;\nuse nft_loans_export::state::{\n    BorrowerInfo, CollateralInfo, ContractInfo, LoanState, OfferInfo, OfferState,\n};\n\npub const CONTRACT_INFO: Item\u003cContractInfo\u003e = Item::new(\"contract_info\");\n\npub const COLLATERAL_INFO: Map\u003c(\u0026Addr, u64), CollateralInfo\u003e = Map::new(\"collateral_info\");\n\npub const BORROWER_INFO: Map\u003c\u0026Addr, BorrowerInfo\u003e = Map::new(\"borrower_info\");\n\npub const LENDER_OFFERS: Map\u003c\u0026Addr, Vec\u003c(Addr, u64, u64)\u003e\u003e = Map::new(\"lender_offers\");\n\npub fn is_owner(storage: \u0026dyn Storage, sender: Addr) -\u003e Result\u003cContractInfo, ContractError\u003e {\n    let contract_info = CONTRACT_INFO.load(storage)?;\n    if sender == contract_info.owner {\n        Ok(contract_info)\n    } else {\n        Err(ContractError::Unauthorized {})\n    }\n}\n\npub fn add_new_offer(\n    storage: \u0026mut dyn Storage,\n    collateral: \u0026mut CollateralInfo,\n    collateral_key: (Addr, u64),\n    offer: OfferInfo,\n) -\u003e Result\u003cu64, ContractError\u003e {\n    // We add the new offer to the collateral object\n    collateral.offers.push(offer.clone());\n    COLLATERAL_INFO.save(storage, (\u0026collateral_key.0, collateral_key.1), collateral)?;\n    let offer_id = (collateral.offers.len() - 1) as u64;\n    // We add the new offer to the lender object\n    LENDER_OFFERS.update::\u003c_, ContractError\u003e(storage, \u0026offer.lender, |x| match x {\n        Some(mut offers) =\u003e {\n            offers.push((collateral_key.0, collateral_key.1, offer_id));\n            Ok(offers)\n        }\n        None =\u003e Ok(vec![(collateral_key.0, collateral_key.1, offer_id)]),\n    })?;\n    Ok(offer_id)\n}\n\npub fn is_collateral_withdrawable(collateral: \u0026CollateralInfo) -\u003e Result\u003c(), ContractError\u003e {\n    match collateral.state {\n        LoanState::Published =\u003e Ok(()),\n        _ =\u003e Err(ContractError::NotWithdrawable {}),\n    }\n}\n\npub fn is_loan_modifiable(collateral: \u0026CollateralInfo) -\u003e Result\u003c(), ContractError\u003e {\n    match collateral.state {\n        LoanState::Published =\u003e Ok(()),\n        _ =\u003e Err(ContractError::NotModifiable {}),\n    }\n}\n\npub fn is_loan_acceptable(collateral: \u0026CollateralInfo) -\u003e Result\u003c(), ContractError\u003e {\n    match collateral.state {\n        LoanState::Published =\u003e Ok(()),\n        _ =\u003e Err(ContractError::NotAcceptable {}),\n    }\n}\n\npub fn is_loan_counterable(collateral: \u0026CollateralInfo) -\u003e Result\u003c(), ContractError\u003e {\n    match collateral.state {\n        LoanState::Published =\u003e Ok(()),\n        _ =\u003e Err(ContractError::NotCounterable {}),\n    }\n}\n\npub fn can_repay_loan(env: Env, collateral: \u0026CollateralInfo) -\u003e Result\u003c(), ContractError\u003e {\n    if is_loan_defaulted(env, collateral).is_ok() {\n        Err(ContractError::WrongLoanState {\n            state: LoanState::Defaulted {},\n        })\n    } else if collateral.state != LoanState::Started {\n        Err(ContractError::WrongLoanState {\n            state: collateral.state.clone(),\n        })\n    } else {\n        Ok(())\n    }\n}\n\npub fn is_loan_defaulted(env: Env, collateral: \u0026CollateralInfo) -\u003e Result\u003c(), ContractError\u003e {\n    // If there is no offer, the loan can't be defaulted\n    let offer = get_active_loan(collateral)?;\n    match \u0026collateral.state {\n        LoanState::Started =\u003e {\n            if collateral.start_block.unwrap() + offer.terms.duration_in_blocks \u003c env.block.height {\n                Ok(())\n            } else {\n                Err(ContractError::WrongLoanState {\n                    state: LoanState::Started,\n                })\n            }\n        }\n        LoanState::Defaulted =\u003e Ok(()),\n        _ =\u003e Err(ContractError::WrongLoanState {\n            state: collateral.state.clone(),\n        }),\n    }\n}\n\npub fn get_offer(collateral: \u0026CollateralInfo, offer_id: usize) -\u003e Result\u003cOfferInfo, ContractError\u003e {\n    if offer_id \u003c collateral.offers.len() {\n        let mut offer = collateral.offers[offer_id].clone();\n        // We check the status of the offer.\n        // A refused offer isn't marked as such but depends o=n the overlying collateral info state\n        offer.state = match \u0026offer.state {\n            OfferState::Published =\u003e {\n                if collateral.state != LoanState::Published {\n                    OfferState::Refused\n                } else {\n                    OfferState::Published\n                }\n            }\n            _ =\u003e offer.state,\n        };\n        Ok(offer)\n    } else {\n        Err(ContractError::OfferNotFound {})\n    }\n}\n\npub fn get_active_loan(collateral: \u0026CollateralInfo) -\u003e Result\u003cOfferInfo, ContractError\u003e {\n    let offer_id = collateral\n        .active_loan\n        .ok_or(ContractError::OfferNotFound {})?;\n    get_offer(collateral, offer_id as usize)\n}\n\npub fn is_lender(\n    lender: Addr,\n    collateral: \u0026CollateralInfo,\n    offer_id: usize,\n) -\u003e Result\u003cOfferInfo, ContractError\u003e {\n    let offer = get_offer(collateral, offer_id)?;\n    if lender != offer.lender {\n        return Err(ContractError::Unauthorized {});\n    }\n    Ok(offer)\n}\n\npub fn is_active_lender(\n    lender: Addr,\n    collateral: \u0026CollateralInfo,\n) -\u003e Result\u003cOfferInfo, ContractError\u003e {\n    let offer = get_active_loan(collateral)?;\n    if lender != offer.lender {\n        return Err(ContractError::Unauthorized {});\n    }\n    Ok(offer)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","oracle_contract","examples","oracle_schema.rs"],"content":"use std::env::current_dir;\nuse std::fs::create_dir_all;\n\nuse cosmwasm_schema::{export_schema, remove_schemas, schema_for};\n\nuse oracle_export::msg::{ExecuteMsg, InstantiateMsg, QueryMsg};\n\nfn main() {\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"schema\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n\n    export_schema(\u0026schema_for!(InstantiateMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(ExecuteMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(QueryMsg), \u0026out_dir);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","oracle_contract","src","contract.rs"],"content":"#[cfg(not(feature = \"library\"))]\nuse anyhow::{anyhow, Result};\nuse cosmwasm_std::{\n    entry_point, to_binary, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdError, Uint128,\n};\n\nuse crate::error::ContractError;\nuse oracle_export::msg::{ExecuteMsg, InstantiateMsg, MigrateMsg, NftPriceResponse, QueryMsg};\nuse oracle_export::state::{ContractInfo, NftPrice};\n\nuse crate::state::{is_owner, CONTRACT_INFO, NFT_PRICES};\nuse cw_4626::state::AssetInfo;\n\nconst DEFAULT_TIMEOUT: u64 = 8 * 3600; // Price timeout in seconds (8hrs)\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // Verify the contract name\n    msg.validate()?;\n    // store token info\n    let data = ContractInfo {\n        name: msg.name,\n        owner: msg\n            .owner\n            .map(|x| deps.api.addr_validate(\u0026x))\n            .unwrap_or(Ok(info.sender))?,\n        timeout: msg.timeout.unwrap_or(DEFAULT_TIMEOUT),\n    };\n    CONTRACT_INFO.save(deps.storage, \u0026data)?;\n    // Initialisation with fixed rates\n\n    Ok(Response::default().add_attribute(\"fee_contract\", \"init\"))\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg) -\u003e Result\u003cResponse\u003e {\n    match msg {\n        ExecuteMsg::SetNftPrice {\n            contract,\n            oracle_owner,\n            price,\n            unit,\n        } =\u003e execute_set_nft_price(\n            deps,\n            env,\n            info.clone(),\n            contract,\n            oracle_owner.unwrap_or_else(|| info.sender.to_string()),\n            unit,\n            price,\n        ),\n        ExecuteMsg::SetOwner { owner } =\u003e set_owner(deps, env, info, owner),\n        ExecuteMsg::SetTimeout { timeout } =\u003e set_timeout(deps, env, info, timeout),\n    }\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn migrate(_deps: DepsMut, _env: Env, _msg: MigrateMsg) -\u003e Result\u003cResponse, ContractError\u003e {\n    // No state migrations performed, just returned a Response\n    Ok(Response::default())\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, env: Env, msg: QueryMsg) -\u003e Result\u003cBinary\u003e {\n    match msg {\n        QueryMsg::ContractInfo {} =\u003e to_binary(\u0026contract_info(deps)?).map_err(|e| anyhow!(e)),\n        QueryMsg::NftPrice { contract, unit } =\u003e {\n            to_binary(\u0026query_nft_price(deps, env, contract, unit)?).map_err(|e| anyhow!(e))\n        }\n    }\n}\n\n/// This function is used to withdraw funds from an accepted trade.\n/// It uses information from the trades and counter trades to determine how much needs to be paid\n/// If the fee is sufficient, it sends the fee to the fee_depositor contract (responsible for fee distribution)\npub fn execute_set_nft_price(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    contract: String,\n    oracle_owner: String,\n    unit: AssetInfo,\n    price: Uint128,\n) -\u003e Result\u003cResponse\u003e {\n    let contract_info = CONTRACT_INFO.load(deps.storage)?;\n    let contract_addr = deps.api.addr_validate(\u0026contract)?;\n    let oracle_owner_addr = deps.api.addr_validate(\u0026oracle_owner)?;\n    NFT_PRICES.update(deps.storage, (\u0026contract_addr, unit.clone()), |x| match x {\n        Some(nft_price) =\u003e {\n            if info.sender != nft_price.oracle_owner {\n                return Err(anyhow!(ContractError::Unauthorized {}));\n            }\n            Ok(NftPrice {\n                price,\n                oracle_owner: oracle_owner_addr,\n                last_update: env.block.time,\n            })\n        }\n        None =\u003e {\n            if info.sender != contract_info.owner {\n                return Err(anyhow!(ContractError::Unauthorized {}));\n            }\n            Ok(NftPrice {\n                price,\n                oracle_owner: oracle_owner_addr,\n                last_update: env.block.time,\n            })\n        }\n    })?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"set_oracle_price\")\n        .add_attribute(\"nft\", contract)\n        .add_attribute(\"unit\", unit.to_string())\n        .add_attribute(\"price\", price.to_string()))\n}\n\npub fn set_owner(deps: DepsMut, _env: Env, info: MessageInfo, owner: String) -\u003e Result\u003cResponse\u003e {\n    is_owner(deps.as_ref(), info.sender)?;\n\n    let owner_addr = deps.api.addr_validate(\u0026owner)?;\n    CONTRACT_INFO.update::\u003c_, StdError\u003e(deps.storage, |mut x| {\n        x.owner = owner_addr;\n        Ok(x)\n    })?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"parameter_update\")\n        .add_attribute(\"parameter\", \"owner\")\n        .add_attribute(\"value\", owner))\n}\n\npub fn set_timeout(deps: DepsMut, _env: Env, info: MessageInfo, timeout: u64) -\u003e Result\u003cResponse\u003e {\n    is_owner(deps.as_ref(), info.sender)?;\n\n    CONTRACT_INFO.update::\u003c_, StdError\u003e(deps.storage, |mut x| {\n        x.timeout = timeout;\n        Ok(x)\n    })?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"parameter_update\")\n        .add_attribute(\"parameter\", \"timeout\")\n        .add_attribute(\"value\", timeout.to_string()))\n}\n\npub fn contract_info(deps: Deps) -\u003e Result\u003cContractInfo\u003e {\n    CONTRACT_INFO.load(deps.storage).map_err(|e| anyhow!(e))\n}\n\npub fn query_nft_price(\n    deps: Deps,\n    env: Env,\n    contract: String,\n    unit: AssetInfo,\n) -\u003e Result\u003cNftPriceResponse\u003e {\n    let contract_addr = deps.api.addr_validate(\u0026contract)?;\n    let nft_price = NFT_PRICES.load(deps.storage, (\u0026contract_addr, unit.clone()))?;\n    let contract_info = CONTRACT_INFO.load(deps.storage)?;\n\n    Ok(NftPriceResponse {\n        contract,\n        price: nft_price.price,\n        unit,\n        oracle_owner: nft_price.oracle_owner.to_string(),\n        timeout: nft_price.last_update.plus_seconds(contract_info.timeout) \u003c env.block.time,\n    })\n}\n\n#[cfg(test)]\npub mod tests {\n    use super::*;\n    use cosmwasm_std::testing::{mock_dependencies, mock_env, mock_info};\n    use cosmwasm_std::{Api, Timestamp};\n    //use cosmwasm_std::{coins, Coin, SubMsg};\n\n    fn init_helper(deps: DepsMut) -\u003e Response {\n        let instantiate_msg = InstantiateMsg {\n            name: \"oracle\".to_string(),\n            owner: None,\n            timeout: Some(8 * 3600u64),\n        };\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n\n        instantiate(deps, env, info, instantiate_msg).unwrap()\n    }\n\n    #[test]\n    fn test_init_sanity() {\n        let mut deps = mock_dependencies();\n        let res = init_helper(deps.as_mut());\n        assert_eq!(0, res.messages.len());\n    }\n\n    #[test]\n    fn test_owner_sanity() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n        let env = mock_env();\n        let info = mock_info(\"bad_person\", \u0026[]);\n        let err = execute(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            ExecuteMsg::SetOwner {\n                owner: \"new_person\".to_string(),\n            },\n        )\n        .unwrap_err();\n        assert_eq!(\n            err.downcast::\u003cContractError\u003e().unwrap(),\n            ContractError::Unauthorized {}\n        );\n        let info = mock_info(\"creator\", \u0026[]);\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            ExecuteMsg::SetOwner {\n                owner: \"new_person\".to_string(),\n            },\n        )\n        .unwrap();\n        let info = mock_info(\"creator\", \u0026[]);\n        let err = execute(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            ExecuteMsg::SetOwner {\n                owner: \"new_person\".to_string(),\n            },\n        )\n        .unwrap_err();\n        assert_eq!(\n            err.downcast::\u003cContractError\u003e().unwrap(),\n            ContractError::Unauthorized {}\n        );\n        let info = mock_info(\"new_person\", \u0026[]);\n        execute(\n            deps.as_mut(),\n            env,\n            info,\n            ExecuteMsg::SetOwner {\n                owner: \"creaor\".to_string(),\n            },\n        )\n        .unwrap();\n    }\n\n    #[test]\n    fn test_timeout_sanity() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n        let env = mock_env();\n        let info = mock_info(\"bad_person\", \u0026[]);\n        let err = execute(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            ExecuteMsg::SetTimeout { timeout: 4687u64 },\n        )\n        .unwrap_err();\n        assert_eq!(\n            err.downcast::\u003cContractError\u003e().unwrap(),\n            ContractError::Unauthorized {}\n        );\n        let info = mock_info(\"creator\", \u0026[]);\n        execute(\n            deps.as_mut(),\n            env,\n            info,\n            ExecuteMsg::SetTimeout { timeout: 4687u64 },\n        )\n        .unwrap();\n        let contract_info = CONTRACT_INFO.load(\u0026deps.storage).unwrap();\n        assert_eq!(\n            contract_info,\n            ContractInfo {\n                name: \"oracle\".to_string(),\n                owner: deps.api.addr_validate(\"creator\").unwrap(),\n                timeout: 4687u64,\n            }\n        );\n    }\n\n    fn execute_set_nft_price(\n        deps: DepsMut,\n        info: MessageInfo,\n        contract: \u0026str,\n        owner: \u0026str,\n        unit: AssetInfo,\n        price: u128,\n    ) -\u003e Result\u003cResponse\u003e {\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::SetNftPrice {\n                contract: contract.to_string(),\n                oracle_owner: Some(owner.to_string()),\n                unit,\n                price: Uint128::from(price),\n            },\n        )\n    }\n\n    #[test]\n    fn test_set_nft_price() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n\n        let info = mock_info(\"bad_person\", \u0026[]);\n        let asset_info = AssetInfo::Coin(\"uluna\".to_string());\n        let err = execute_set_nft_price(\n            deps.as_mut(),\n            info,\n            \"nft\",\n            \"creator\",\n            asset_info.clone(),\n            456u128,\n        )\n        .unwrap_err();\n        assert_eq!(\n            err.downcast::\u003cContractError\u003e().unwrap(),\n            ContractError::Unauthorized {}\n        );\n\n        let info = mock_info(\"creator\", \u0026[]);\n        let res = execute_set_nft_price(\n            deps.as_mut(),\n            info,\n            \"nft\",\n            \"creator\",\n            asset_info.clone(),\n            456u128,\n        )\n        .unwrap();\n        assert_eq!(\n            res,\n            Response::new()\n                .add_attribute(\"action\", \"set_oracle_price\")\n                .add_attribute(\"nft\", \"nft\")\n                .add_attribute(\"unit\", asset_info.to_string())\n                .add_attribute(\"price\", 456u128.to_string())\n        );\n        // We verify the contract storage\n        let addr = deps.api.addr_validate(\"nft\").unwrap();\n        let owner_addr = deps.api.addr_validate(\"creator\").unwrap();\n        let price = NFT_PRICES.load(\u0026deps.storage, (\u0026addr, asset_info)).unwrap();\n        assert_eq!(\n            price,\n            NftPrice {\n                price: Uint128::from(456u128),\n                oracle_owner: owner_addr,\n                last_update: Timestamp::from_nanos(1571797419879305533u64)\n            }\n        )\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","oracle_contract","src","error.rs"],"content":"use cosmwasm_std::StdError;\nuse thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized {},\n\n    #[error(\"Fee not paid correctly, required: {required:?}uust, provided {provided:?}uust\")]\n    FeeNotPaidCorrectly { required: u128, provided: u128 },\n\n    #[error(\"Fee not paid\")]\n    FeeNotPaid {},\n\n    #[error(\"Trade not accepted\")]\n    TradeNotAccepted {},\n\n    #[error(\"Fee Teers not ordered, you can't change them\")]\n    TeersNotOrdered {},\n\n    #[error(\"Error when encoding response message to binary string\")]\n    BinaryEncodingError {},\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","oracle_contract","src","lib.rs"],"content":"pub mod contract;\npub mod error;\npub mod state;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","oracle_contract","src","state.rs"],"content":"use crate::error::ContractError;\nuse cosmwasm_std::{Addr, Deps};\nuse cw_4626::state::AssetInfo;\nuse cw_storage_plus::{Item, Map};\nuse oracle_export::state::{ContractInfo, NftPrice};\npub const CONTRACT_INFO: Item\u003cContractInfo\u003e = Item::new(\"contract_info\");\npub const NFT_PRICES: Map\u003c(\u0026Addr, AssetInfo), NftPrice\u003e = Map::new(\"fee_rates\");\n\npub fn is_owner(deps: Deps, addr: Addr) -\u003e Result\u003c(), ContractError\u003e {\n    if CONTRACT_INFO.load(deps.storage)?.owner == addr {\n        Ok(())\n    } else {\n        Err(ContractError::Unauthorized {})\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","p2p-trading","examples","p2p_schema.rs"],"content":"use std::env::current_dir;\nuse std::fs::create_dir_all;\n\nuse cosmwasm_schema::{export_schema, remove_schemas, schema_for};\n\nuse p2p_trading_export::msg::{ExecuteMsg, InstantiateMsg, QueryMsg};\n\nfn main() {\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"schema\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n\n    export_schema(\u0026schema_for!(InstantiateMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(ExecuteMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(QueryMsg), \u0026out_dir);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","p2p-trading","src","contract.rs"],"content":"#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\nuse cosmwasm_std::{\n    to_binary, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdError, StdResult,\n};\n\nuse cw2::set_contract_version;\n\nuse crate::error::ContractError;\n\nuse crate::state::{\n    is_fee_contract, is_owner, load_counter_trade, load_trade, CONTRACT_INFO, COUNTER_TRADE_INFO,\n    TRADE_INFO,\n};\nuse p2p_trading_export::msg::{ExecuteMsg, InstantiateMsg, MigrateMsg, QueryMsg};\nuse p2p_trading_export::state::{AssetInfo, ContractInfo, TradeState};\n\nuse crate::counter_trade::{\n    add_asset_to_counter_trade, cancel_counter_trade, confirm_counter_trade, suggest_counter_trade,\n    withdraw_all_from_counter, withdraw_counter_trade_assets_while_creating,\n};\nuse crate::trade::{\n    accept_trade, add_asset_to_trade, add_nfts_wanted, add_whitelisted_users, cancel_trade,\n    check_and_create_withdraw_messages, confirm_trade, create_trade, refuse_counter_trade,\n    remove_nfts_wanted, remove_whitelisted_users, withdraw_all_from_trade,\n    withdraw_trade_assets_while_creating,\n};\n\nuse crate::messages::{review_counter_trade, set_comment};\nuse crate::query::{\n    query_all_counter_trades, query_all_trades, query_contract_info, query_counter_trades,\n};\n\nconst CONTRACT_NAME: \u0026str = \"illiquidly.io:p2p-trading\";\nconst CONTRACT_VERSION: \u0026str = \"0.1.0\";\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // Verify the contract name\n\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    msg.validate()?;\n    // store token info\n    let data = ContractInfo {\n        name: msg.name,\n        owner: deps\n            .api\n            .addr_validate(\u0026msg.owner.unwrap_or_else(|| info.sender.to_string()))?,\n        fee_contract: None,\n        last_trade_id: None,\n    };\n    CONTRACT_INFO.save(deps.storage, \u0026data)?;\n    Ok(Response::default()\n        .add_attribute(\"action\", \"init\")\n        .add_attribute(\"contract\", \"p2p-trading\")\n        .add_attribute(\"owner\", data.owner))\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    match msg {\n        // Trade Creation Messages\n        ExecuteMsg::CreateTrade {\n            whitelisted_users,\n            comment,\n        } =\u003e create_trade(deps, env, info, whitelisted_users, comment),\n\n        ExecuteMsg::AddAsset {\n            trade_id,\n            counter_id,\n            to_last_trade,\n            to_last_counter,\n            asset,\n        } =\u003e add_asset(\n            deps,\n            env,\n            info,\n            trade_id,\n            counter_id,\n            to_last_trade,\n            to_last_counter,\n            asset,\n        ),\n        ExecuteMsg::RemoveAssets {\n            trade_id,\n            counter_id,\n            assets,\n        } =\u003e withdraw_assets_while_creating(deps, env, info, trade_id, counter_id, assets),\n\n        ExecuteMsg::AddWhitelistedUsers {\n            trade_id,\n            whitelisted_users,\n        } =\u003e add_whitelisted_users(\n            deps.storage,\n            deps.api,\n            env,\n            info,\n            trade_id,\n            whitelisted_users,\n        ),\n\n        ExecuteMsg::RemoveWhitelistedUsers {\n            trade_id,\n            whitelisted_users,\n        } =\u003e remove_whitelisted_users(deps, env, info, trade_id, whitelisted_users),\n\n        ExecuteMsg::AddNFTsWanted {\n            trade_id,\n            nfts_wanted,\n        } =\u003e add_nfts_wanted(deps, env, info, trade_id, nfts_wanted),\n\n        ExecuteMsg::RemoveNFTsWanted {\n            trade_id,\n            nfts_wanted,\n        } =\u003e remove_nfts_wanted(deps, env, info, trade_id, nfts_wanted),\n\n        ExecuteMsg::SetComment {\n            trade_id,\n            counter_id,\n            comment,\n        } =\u003e set_comment(deps, env, info, trade_id, counter_id, comment),\n\n        ExecuteMsg::ConfirmTrade { trade_id } =\u003e confirm_trade(deps, env, info, trade_id),\n\n        //Counter Trade Creation Messages\n        ExecuteMsg::SuggestCounterTrade { trade_id, comment } =\u003e {\n            suggest_counter_trade(deps, env, info, trade_id, comment)\n        }\n\n        ExecuteMsg::ConfirmCounterTrade {\n            trade_id,\n            counter_id,\n        } =\u003e confirm_counter_trade(deps, env, info, trade_id, counter_id),\n\n        // After Create Messages\n        ExecuteMsg::AcceptTrade {\n            trade_id,\n            counter_id,\n            comment,\n        } =\u003e accept_trade(deps, env, info, trade_id, counter_id, comment),\n\n        // After Create Messages\n        ExecuteMsg::CancelTrade { trade_id } =\u003e cancel_trade(deps, env, info, trade_id),\n        ExecuteMsg::CancelCounterTrade {\n            trade_id,\n            counter_id,\n        } =\u003e cancel_counter_trade(deps, env, info, trade_id, counter_id),\n\n        ExecuteMsg::RefuseCounterTrade {\n            trade_id,\n            counter_id,\n        } =\u003e refuse_counter_trade(deps, env, info, trade_id, counter_id),\n\n        ExecuteMsg::ReviewCounterTrade {\n            trade_id,\n            counter_id,\n            comment,\n        } =\u003e review_counter_trade(deps, env, info, trade_id, counter_id, comment),\n\n        ExecuteMsg::WithdrawPendingAssets { trader, trade_id } =\u003e {\n            withdraw_accepted_funds(deps, env, info, trader, trade_id)\n        }\n\n        ExecuteMsg::WithdrawAllFromTrade { trade_id } =\u003e {\n            withdraw_all_from_trade(deps, env, info, trade_id)\n        }\n\n        ExecuteMsg::WithdrawAllFromCounter {\n            trade_id,\n            counter_id,\n        } =\u003e withdraw_all_from_counter(deps, env, info, trade_id, counter_id),\n\n        // Contract Variable\n        ExecuteMsg::SetNewOwner { owner } =\u003e set_new_owner(deps, env, info, owner),\n\n        // Contract Variable\n        ExecuteMsg::SetNewFeeContract { fee_contract } =\u003e {\n            set_new_fee_contract(deps, env, info, fee_contract)\n        }\n    }\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn migrate(_deps: DepsMut, _env: Env, _msg: MigrateMsg) -\u003e Result\u003cResponse, ContractError\u003e {\n    // No state migrations performed, just returned a Response\n    Ok(Response::default())\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::ContractInfo {} =\u003e to_binary(\u0026query_contract_info(deps)?),\n        QueryMsg::TradeInfo { trade_id } =\u003e to_binary(\n            \u0026load_trade(deps.storage, trade_id)\n                .map_err(|e| StdError::generic_err(e.to_string()))?,\n        ),\n        QueryMsg::CounterTradeInfo {\n            trade_id,\n            counter_id,\n        } =\u003e to_binary(\n            \u0026load_counter_trade(deps.storage, trade_id, counter_id)\n                .map_err(|e| StdError::generic_err(e.to_string()))?,\n        ),\n        QueryMsg::GetAllCounterTrades {\n            start_after,\n            limit,\n            filters,\n        } =\u003e to_binary(\u0026query_all_counter_trades(\n            deps,\n            start_after,\n            limit,\n            filters,\n        )?),\n        QueryMsg::GetCounterTrades {\n            trade_id,\n            start_after,\n            limit,\n            filters,\n        } =\u003e to_binary(\u0026query_counter_trades(\n            deps,\n            trade_id,\n            start_after,\n            limit,\n            filters,\n        )?),\n        QueryMsg::GetAllTrades {\n            start_after,\n            limit,\n            filters,\n        } =\u003e to_binary(\u0026query_all_trades(deps, start_after, limit, filters)?),\n    }\n}\n\n/// Replace the current contract owner with the provided owner address\n/// * `owner` must be a valid Terra address\n/// The owner has limited power on this contract :\n/// 1. Change the contract owner\n/// 2. Change the fee contract\npub fn set_new_owner(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    new_owner: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut contract_info = is_owner(deps.storage, info.sender)?;\n\n    let new_owner = deps.api.addr_validate(\u0026new_owner)?;\n    contract_info.owner = new_owner.clone();\n    CONTRACT_INFO.save(deps.storage, \u0026contract_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"modify_parameter\")\n        .add_attribute(\"parameter\", \"owner\")\n        .add_attribute(\"value\", new_owner))\n}\n\n/// Replace the current fee_contract with the provided fee_contract address\n/// * `fee_contract` must be a valid Terra address\npub fn set_new_fee_contract(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    fee_contract: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut contract_info = is_owner(deps.storage, info.sender)?;\n\n    let fee_contract = deps.api.addr_validate(\u0026fee_contract)?;\n    contract_info.fee_contract = Some(fee_contract.clone());\n    CONTRACT_INFO.save(deps.storage, \u0026contract_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"modify_parameter\")\n        .add_attribute(\"parameter\", \"fee_contract\")\n        .add_attribute(\"value\", fee_contract))\n}\n\n/// General handler to add an asset to a trade or a counter trade\n#[allow(clippy::too_many_arguments)]\npub fn add_asset(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    trade_id: Option\u003cu64\u003e,\n    counter_id: Option\u003cu64\u003e,\n    to_last_trade: Option\u003cbool\u003e,\n    to_last_counter: Option\u003cbool\u003e,\n    asset: AssetInfo,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // We implement 4 different cases here.\n    if to_last_trade.unwrap_or_default() {\n        // 1. We want to add the asset to the last trade created by the user\n        add_asset_to_trade(deps, env, info, None, asset)\n    } else if to_last_counter.unwrap_or_default() {\n        // 2. We want to add the asset to the last counter_trade created by the user\n        add_asset_to_counter_trade(\n            deps,\n            env,\n            info,\n            trade_id.ok_or(ContractError::TradeIdMissing {})?,\n            None,\n            asset,\n        )\n    } else if counter_id.is_some() {\n        // 3. We want to add the asset to a designated counter_trade (trade_id + counter_id)\n        add_asset_to_counter_trade(deps, env, info, trade_id.unwrap(), counter_id, asset)\n    } else {\n        // 4. We want to add the asset to a designated trade_id\n        add_asset_to_trade(deps, env, info, trade_id, asset)\n    }\n}\n\n/// Remove some assets from a trade when creating it.\npub fn withdraw_assets_while_creating(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    trade_id: u64,\n    counter_id: Option\u003cu64\u003e,\n    assets: Vec\u003c(u16, AssetInfo)\u003e, // We chose to number the withdrawn assets to prevent looping over all deposited assets\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    match counter_id {\n        Some(counter_id) =\u003e withdraw_counter_trade_assets_while_creating(\n            deps, env, info, trade_id, counter_id, assets,\n        ),\n        None =\u003e withdraw_trade_assets_while_creating(deps, env, info, trade_id, assets),\n    }\n}\n\n/// Withdraw assets from an accepted trade.\n/// The trader will withdraw assets from the counter_trade\n/// The counter_trader will withdraw assets from the trade\npub fn withdraw_accepted_funds(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    trader: String,\n    trade_id: u64,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // The fee contract is the only one responsible for withdrawing assets\n    is_fee_contract(deps.storage, info.sender)?;\n\n    // We load the trade and verify it has been accepted\n    let mut trade_info = load_trade(deps.storage, trade_id)?;\n    if trade_info.state != TradeState::Accepted {\n        return Err(ContractError::TradeNotAccepted {});\n    }\n\n    // We load the corresponding counter_trade\n    let counter_id = trade_info\n        .accepted_info\n        .clone()\n        .ok_or(ContractError::ContractBug {})?\n        .counter_id;\n    let mut counter_info = load_counter_trade(deps.storage, trade_id, counter_id)?;\n\n    let trader = deps.api.addr_validate(\u0026trader)?;\n    let (res, trade_type);\n\n    // We indentify who the transaction sender is (trader or counter-trader)\n    if trade_info.owner == trader {\n        // In case the trader wants to withdraw the exchanged funds (from the counter_info object)\n        res = check_and_create_withdraw_messages(env, \u0026trader, \u0026counter_info)?;\n\n        trade_type = \"counter\";\n        counter_info.assets_withdrawn = true;\n        COUNTER_TRADE_INFO.save(deps.storage, (trade_id, counter_id), \u0026counter_info)?;\n    } else if counter_info.owner == trader {\n        // In case the counter_trader wants to withdraw the exchanged funds (from the trade_info object)\n        res = check_and_create_withdraw_messages(env, \u0026trader, \u0026trade_info)?;\n\n        trade_type = \"trade\";\n        trade_info.assets_withdrawn = true;\n        TRADE_INFO.save(deps.storage, trade_id, \u0026trade_info)?;\n    } else {\n        return Err(ContractError::NotWithdrawableByYou {});\n    }\n\n    Ok(res\n        .add_attribute(\"action\", \"withdraw_funds\")\n        .add_attribute(\"type\", trade_type)\n        .add_attribute(\"trade\", trade_id.to_string())\n        .add_attribute(\"counter\", counter_id.to_string())\n        .add_attribute(\"trader\", trade_info.owner)\n        .add_attribute(\"counter_trader\", counter_info.owner))\n}\n\n#[cfg(test)]\npub mod tests {\n    use super::*;\n    use crate::state::load_trade;\n    use cosmwasm_std::testing::{mock_dependencies, mock_env, mock_info};\n    use cosmwasm_std::{coins, Addr, Attribute, BankMsg, Coin, Uint128};\n    use cw1155::Cw1155ExecuteMsg;\n    use cw20::Cw20ExecuteMsg;\n    use cw721::Cw721ExecuteMsg;\n    use p2p_trading_export::msg::into_cosmos_msg;\n    use p2p_trading_export::state::{AssetInfo, Cw1155Coin, Cw20Coin, Cw721Coin, TradeInfo};\n\n    fn init_helper(deps: DepsMut) {\n        let instantiate_msg = InstantiateMsg {\n            name: \"p2p-trading\".to_string(),\n            owner: None,\n        };\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n\n        instantiate(deps, env, info, instantiate_msg).unwrap();\n    }\n\n    fn set_fee_contract_helper(deps: DepsMut) {\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::SetNewFeeContract {\n                fee_contract: \"fee_contract\".to_string(),\n            },\n        )\n        .unwrap();\n    }\n\n    #[test]\n    fn test_init_sanity() {\n        let mut deps = mock_dependencies();\n        let instantiate_msg = InstantiateMsg {\n            name: \"p2p-trading\".to_string(),\n            owner: Some(\"this_address\".to_string()),\n        };\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n\n        let res_init = instantiate(deps.as_mut(), env, info, instantiate_msg).unwrap();\n        assert_eq!(0, res_init.messages.len());\n    }\n\n    #[test]\n    fn test_change_owner() {\n        let mut deps = mock_dependencies();\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n        init_helper(deps.as_mut());\n\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            ExecuteMsg::SetNewOwner {\n                owner: \"new_owner\".to_string(),\n            },\n        )\n        .unwrap();\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            ExecuteMsg::SetNewOwner {\n                owner: \"new_owner\".to_string(),\n            },\n        )\n        .unwrap_err();\n        let info = mock_info(\"new_owner\", \u0026[]);\n        execute(\n            deps.as_mut(),\n            env,\n            info,\n            ExecuteMsg::SetNewOwner {\n                owner: \"other_owner\".to_string(),\n            },\n        )\n        .unwrap();\n    }\n\n    fn create_trade_helper(deps: DepsMut, creator: \u0026str) -\u003e Response {\n        let info = mock_info(creator, \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::CreateTrade {\n                whitelisted_users: Some(vec![]),\n                comment: Some(\"Q\".to_string()),\n            },\n        )\n        .unwrap()\n    }\n\n    fn create_private_trade_helper(deps: DepsMut, users: Vec\u003cString\u003e) -\u003e Response {\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::CreateTrade {\n                whitelisted_users: Some(users),\n                comment: None,\n            },\n        )\n        .unwrap()\n    }\n\n    fn add_whitelisted_users(\n        deps: DepsMut,\n        trade_id: u64,\n        users: Vec\u003cString\u003e,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::AddWhitelistedUsers {\n                trade_id,\n                whitelisted_users: users,\n            },\n        )\n    }\n\n    fn remove_whitelisted_users(\n        deps: DepsMut,\n        trade_id: u64,\n        users: Vec\u003cString\u003e,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::RemoveWhitelistedUsers {\n                trade_id,\n                whitelisted_users: users,\n            },\n        )\n    }\n\n    fn add_nfts_wanted_helper(\n        deps: DepsMut,\n        trader: \u0026str,\n        trade_id: u64,\n        confirm: Vec\u003cString\u003e,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(trader, \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::AddNFTsWanted {\n                trade_id: Some(trade_id),\n                nfts_wanted: confirm,\n            },\n        )\n    }\n\n    fn remove_nfts_wanted_helper(\n        deps: DepsMut,\n        trader: \u0026str,\n        trade_id: u64,\n        confirm: Vec\u003cString\u003e,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(trader, \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::RemoveNFTsWanted {\n                trade_id,\n                nfts_wanted: confirm,\n            },\n        )\n    }\n\n    fn add_asset_to_trade_helper(\n        deps: DepsMut,\n        trader: \u0026str,\n        trade_id: u64,\n        asset: AssetInfo,\n        coins_to_send: \u0026[Coin],\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(trader, coins_to_send);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::AddAsset {\n                to_last_trade: None,\n                to_last_counter: None,\n                trade_id: Some(trade_id),\n                counter_id: None,\n                asset,\n            },\n        )\n    }\n\n    fn remove_assets_helper(\n        deps: DepsMut,\n        sender: \u0026str,\n        trade_id: u64,\n        counter_id: Option\u003cu64\u003e,\n        assets: Vec\u003c(u16, AssetInfo)\u003e,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(sender, \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::RemoveAssets {\n                trade_id,\n                counter_id,\n                assets,\n            },\n        )\n    }\n\n    fn confirm_trade_helper(\n        deps: DepsMut,\n        sender: \u0026str,\n        trade_id: u64,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(sender, \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::ConfirmTrade {\n                trade_id: Some(trade_id),\n            },\n        )\n    }\n\n    fn withdraw_helper(\n        deps: DepsMut,\n        trader: \u0026str,\n        sender: \u0026str,\n        trade_id: u64,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(sender, \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::WithdrawPendingAssets {\n                trader: trader.to_string(),\n                trade_id,\n            },\n        )\n    }\n\n    fn withdraw_cancelled_trade_helper(\n        deps: DepsMut,\n        sender: \u0026str,\n        trade_id: u64,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(sender, \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::WithdrawAllFromTrade { trade_id },\n        )\n    }\n\n    fn withdraw_aborted_counter_helper(\n        deps: DepsMut,\n        sender: \u0026str,\n        trade_id: u64,\n        counter_id: u64,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(sender, \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::WithdrawAllFromCounter {\n                trade_id,\n                counter_id,\n            },\n        )\n    }\n\n    pub mod trade_tests {\n        use super::*;\n        use crate::query::{query_counter_trades, TradeResponse};\n        use crate::trade::validate_addresses;\n        use cosmwasm_std::{coin, Api, SubMsg};\n        use p2p_trading_export::msg::QueryFilters;\n        use p2p_trading_export::state::{AdditionnalTradeInfo, Comment, CounterTradeInfo};\n        use std::collections::HashSet;\n        use std::iter::FromIterator;\n\n        #[test]\n        fn create_trade() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            let res = create_trade_helper(deps.as_mut(), \"creator\");\n\n            assert_eq!(res.messages, vec![]);\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"create_trade\"),\n                    Attribute::new(\"trade_id\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                ]\n            );\n\n            let res = create_trade_helper(deps.as_mut(), \"creator\");\n\n            assert_eq!(res.messages, vec![]);\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"create_trade\"),\n                    Attribute::new(\"trade_id\", \"1\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                ]\n            );\n\n            let new_trade_info = load_trade(\u0026deps.storage, 0).unwrap();\n\n            assert_eq!(new_trade_info.state, TradeState::Created {});\n\n            // Query all and check that trades exist, without filters specified\n            let res = query_all_trades(deps.as_ref(), None, None, None).unwrap();\n\n            assert_eq!(\n                res.trades,\n                vec![\n                    {\n                        TradeResponse {\n                            trade_id: 1,\n                            counter_id: None,\n                            trade_info: Some(TradeInfo {\n                                owner: deps.api.addr_validate(\"creator\").unwrap(),\n                                additionnal_info: AdditionnalTradeInfo {\n                                    owner_comment: Some(Comment {\n                                        comment: \"Q\".to_string(),\n                                        time: mock_env().block.time,\n                                    }),\n                                    time: mock_env().block.time,\n                                    ..Default::default()\n                                },\n                                ..Default::default()\n                            }),\n                        }\n                    },\n                    {\n                        TradeResponse {\n                            trade_id: 0,\n                            counter_id: None,\n                            trade_info: Some(TradeInfo {\n                                owner: deps.api.addr_validate(\"creator\").unwrap(),\n                                additionnal_info: AdditionnalTradeInfo {\n                                    owner_comment: Some(Comment {\n                                        comment: \"Q\".to_string(),\n                                        time: mock_env().block.time,\n                                    }),\n                                    time: mock_env().block.time,\n                                    ..Default::default()\n                                },\n                                ..Default::default()\n                            }),\n                        }\n                    }\n                ]\n            );\n        }\n\n        #[test]\n        fn create_trade_and_nfts_wanted() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            let res = add_nfts_wanted_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                vec![\"nft1\".to_string(), \"nft2\".to_string()],\n            )\n            .unwrap();\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"modify_parameter\"),\n                    Attribute::new(\"name\", \"nfts_wanted\"),\n                    Attribute::new(\"operation_type\", \"add\"),\n                    Attribute::new(\"value\", \"nft1,nft2\"),\n                    Attribute::new(\"trade_id\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\")\n                ]\n            );\n\n            let trade = load_trade(\u0026deps.storage, 0).unwrap();\n            assert_eq!(\n                trade.additionnal_info.nfts_wanted,\n                HashSet::from_iter(vec![Addr::unchecked(\"nft1\"), Addr::unchecked(\"nft2\")])\n            );\n\n            add_nfts_wanted_helper(deps.as_mut(), \"creator\", 0, vec![\"nft1\".to_string()]).unwrap();\n            remove_nfts_wanted_helper(deps.as_mut(), \"creator\", 0, vec![\"nft1\".to_string()])\n                .unwrap();\n\n            let trade = load_trade(\u0026deps.storage, 0).unwrap();\n            assert_eq!(\n                trade.additionnal_info.nfts_wanted,\n                HashSet::from_iter(vec![Addr::unchecked(\"nft2\")])\n            );\n        }\n\n        #[test]\n        fn create_multiple_trades_and_query() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            let res = create_trade_helper(deps.as_mut(), \"creator\");\n\n            assert_eq!(res.messages, vec![]);\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"create_trade\"),\n                    Attribute::new(\"trade_id\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                ]\n            );\n\n            let res = create_trade_helper(deps.as_mut(), \"creator2\");\n\n            assert_eq!(res.messages, vec![]);\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"create_trade\"),\n                    Attribute::new(\"trade_id\", \"1\"),\n                    Attribute::new(\"trader\", \"creator2\"),\n                ]\n            );\n\n            let new_trade_info = load_trade(\u0026deps.storage, 0).unwrap();\n\n            assert_eq!(new_trade_info.state, TradeState::Created {});\n\n            let new_trade_info = load_trade(\u0026deps.storage, 1).unwrap();\n            assert_eq!(new_trade_info.state, TradeState::Created {});\n\n            create_trade_helper(deps.as_mut(), \"creator2\");\n            confirm_trade_helper(deps.as_mut(), \"creator2\", 2).unwrap();\n\n            // Query all created trades check that creators are different\n            let res = query_all_trades(\n                deps.as_ref(),\n                None,\n                None,\n                Some(QueryFilters {\n                    states: Some(vec![TradeState::Created.to_string()]),\n                    ..Default::default()\n                }),\n            )\n            .unwrap();\n\n            assert_eq!(\n                res.trades,\n                vec![\n                    {\n                        TradeResponse {\n                            trade_id: 1,\n                            counter_id: None,\n                            trade_info: Some(TradeInfo {\n                                owner: deps.api.addr_validate(\"creator2\").unwrap(),\n                                additionnal_info: AdditionnalTradeInfo {\n                                    owner_comment: Some(Comment {\n                                        comment: \"Q\".to_string(),\n                                        time: mock_env().block.time,\n                                    }),\n                                    time: mock_env().block.time,\n                                    ..Default::default()\n                                },\n                                ..Default::default()\n                            }),\n                        }\n                    },\n                    {\n                        TradeResponse {\n                            trade_id: 0,\n                            counter_id: None,\n                            trade_info: Some(TradeInfo {\n                                owner: deps.api.addr_validate(\"creator\").unwrap(),\n                                additionnal_info: AdditionnalTradeInfo {\n                                    owner_comment: Some(Comment {\n                                        comment: \"Q\".to_string(),\n                                        time: mock_env().block.time,\n                                    }),\n                                    time: mock_env().block.time,\n                                    ..Default::default()\n                                },\n                                ..Default::default()\n                            }),\n                        }\n                    }\n                ]\n            );\n\n            // Verify that pagination by trade_id works\n            let res = query_all_trades(\n                deps.as_ref(),\n                Some(1),\n                None,\n                Some(QueryFilters {\n                    states: Some(vec![TradeState::Created.to_string()]),\n                    ..Default::default()\n                }),\n            )\n            .unwrap();\n\n            assert_eq!(\n                res.trades,\n                vec![{\n                    TradeResponse {\n                        trade_id: 0,\n                        counter_id: None,\n                        trade_info: Some(TradeInfo {\n                            owner: deps.api.addr_validate(\"creator\").unwrap(),\n                            additionnal_info: AdditionnalTradeInfo {\n                                owner_comment: Some(Comment {\n                                    comment: \"Q\".to_string(),\n                                    time: mock_env().block.time,\n                                }),\n                                time: mock_env().block.time,\n                                ..Default::default()\n                            },\n                            ..Default::default()\n                        }),\n                    }\n                }]\n            );\n\n            // Query that query returned only queries that are in created state and belong to creator2\n            let res = query_all_trades(\n                deps.as_ref(),\n                None,\n                None,\n                Some(QueryFilters {\n                    states: Some(vec![TradeState::Created.to_string()]),\n                    owner: Some(\"creator2\".to_string()),\n                    ..Default::default()\n                }),\n            )\n            .unwrap();\n\n            assert_eq!(\n                res.trades,\n                vec![TradeResponse {\n                    trade_id: 1,\n                    counter_id: None,\n                    trade_info: Some(TradeInfo {\n                        owner: deps.api.addr_validate(\"creator2\").unwrap(),\n                        additionnal_info: AdditionnalTradeInfo {\n                            owner_comment: Some(Comment {\n                                comment: \"Q\".to_string(),\n                                time: mock_env().block.time\n                            }),\n                            time: mock_env().block.time,\n                            ..Default::default()\n                        },\n                        ..Default::default()\n                    })\n                }]\n            );\n\n            // Check that if states are None that owner query still works\n            let res = query_all_trades(\n                deps.as_ref(),\n                None,\n                None,\n                Some(QueryFilters {\n                    owner: Some(\"creator2\".to_string()),\n                    ..Default::default()\n                }),\n            )\n            .unwrap();\n\n            assert_eq!(\n                res.trades,\n                vec![\n                    TradeResponse {\n                        trade_id: 2,\n                        counter_id: None,\n                        trade_info: Some(TradeInfo {\n                            owner: deps.api.addr_validate(\"creator2\").unwrap(),\n                            state: TradeState::Published,\n                            additionnal_info: AdditionnalTradeInfo {\n                                owner_comment: Some(Comment {\n                                    comment: \"Q\".to_string(),\n                                    time: mock_env().block.time\n                                }),\n                                time: mock_env().block.time,\n                                ..Default::default()\n                            },\n                            ..Default::default()\n                        })\n                    },\n                    TradeResponse {\n                        trade_id: 1,\n                        counter_id: None,\n                        trade_info: Some(TradeInfo {\n                            owner: deps.api.addr_validate(\"creator2\").unwrap(),\n                            additionnal_info: AdditionnalTradeInfo {\n                                owner_comment: Some(Comment {\n                                    comment: \"Q\".to_string(),\n                                    time: mock_env().block.time\n                                }),\n                                time: mock_env().block.time,\n                                ..Default::default()\n                            },\n                            ..Default::default()\n                        })\n                    }\n                ]\n            );\n\n            // Check that queries with published state do not return anything. Because none exists.\n            let res = query_all_trades(\n                deps.as_ref(),\n                None,\n                None,\n                Some(QueryFilters {\n                    states: Some(vec![TradeState::Accepted.to_string()]),\n                    ..Default::default()\n                }),\n            )\n            .unwrap();\n\n            assert_eq!(res.trades, vec![]);\n\n            // Check that queries with published state do not return anything when owner is specified. Because none exists.\n            let res = query_all_trades(\n                deps.as_ref(),\n                None,\n                None,\n                Some(QueryFilters {\n                    states: Some(vec![TradeState::Accepted.to_string()]),\n                    owner: Some(\"creator2\".to_string()),\n                    ..Default::default()\n                }),\n            )\n            .unwrap();\n            assert_eq!(res.trades, vec![]);\n        }\n\n        #[test]\n        fn create_trade_and_add_funds() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            let res = add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Coin(coin(2, \"token\")),\n                \u0026coins(2, \"token\"),\n            )\n            .unwrap();\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"add_asset\"),\n                    Attribute::new(\"asset_type\", \"fund\"),\n                    Attribute::new(\"denom\", \"token\"),\n                    Attribute::new(\"amount\", \"2\"),\n                    Attribute::new(\"trade_id\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                ]\n            );\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Coin(coin(2, \"token\")),\n                \u0026coins(2, \"token\"),\n            )\n            .unwrap();\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Coin(coin(2, \"other_token\")),\n                \u0026coins(2, \"other_token\"),\n            )\n            .unwrap();\n\n            let new_trade_info = load_trade(\u0026deps.storage, 0).unwrap();\n            assert_eq!(\n                new_trade_info.associated_assets,\n                vec![\n                    AssetInfo::Coin(Coin {\n                        amount: Uint128::from(4u64),\n                        denom: \"token\".to_string()\n                    }),\n                    AssetInfo::Coin(Coin {\n                        amount: Uint128::from(2u64),\n                        denom: \"other_token\".to_string()\n                    })\n                ]\n            );\n        }\n\n        #[test]\n        fn create_trade_and_add_cw20_tokens() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n\n            let res = add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    address: \"token\".to_string(),\n                    amount: Uint128::new(100u128),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"add_asset\"),\n                    Attribute::new(\"asset_type\", \"token\"),\n                    Attribute::new(\"token\", \"token\"),\n                    Attribute::new(\"amount\", \"100\"),\n                    Attribute::new(\"trade_id\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                ]\n            );\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    address: \"token\".to_string(),\n                    amount: Uint128::new(100u128),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    address: \"other_token\".to_string(),\n                    amount: Uint128::new(100u128),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            let new_trade_info = load_trade(\u0026deps.storage, 0).unwrap();\n            assert_eq!(\n                new_trade_info.associated_assets,\n                vec![\n                    AssetInfo::Cw20Coin(Cw20Coin {\n                        amount: Uint128::from(200u64),\n                        address: \"token\".to_string()\n                    }),\n                    AssetInfo::Cw20Coin(Cw20Coin {\n                        amount: Uint128::from(100u64),\n                        address: \"other_token\".to_string()\n                    })\n                ]\n            );\n\n            // Verify the token contain query\n            let res = query_all_trades(\n                deps.as_ref(),\n                None,\n                None,\n                Some(QueryFilters {\n                    contains_token: Some(\"other_token\".to_string()),\n                    ..Default::default()\n                }),\n            )\n            .unwrap();\n\n            let env = mock_env();\n            assert_eq!(\n                res.trades,\n                vec![{\n                    TradeResponse {\n                        trade_id: 0,\n                        counter_id: None,\n                        trade_info: Some(TradeInfo {\n                            owner: deps.api.addr_validate(\"creator\").unwrap(),\n                            state: TradeState::Created,\n                            associated_assets: vec![\n                                AssetInfo::Cw20Coin(Cw20Coin {\n                                    amount: Uint128::from(200u64),\n                                    address: \"token\".to_string(),\n                                }),\n                                AssetInfo::Cw20Coin(Cw20Coin {\n                                    amount: Uint128::from(100u64),\n                                    address: \"other_token\".to_string(),\n                                }),\n                            ],\n                            additionnal_info: AdditionnalTradeInfo {\n                                owner_comment: Some(Comment {\n                                    comment: \"Q\".to_string(),\n                                    time: env.block.time,\n                                }),\n                                time: env.block.time,\n                                ..Default::default()\n                            },\n                            ..Default::default()\n                        }),\n                    }\n                }]\n            );\n\n            // Verify it works when querying another token\n            let res = query_all_trades(\n                deps.as_ref(),\n                None,\n                None,\n                Some(QueryFilters {\n                    contains_token: Some(\"bad_token\".to_string()),\n                    ..Default::default()\n                }),\n            )\n            .unwrap();\n            assert_eq!(res.trades, vec![]);\n\n            // This triggers an error, the creator is not the same as the sender\n\n            let err = add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"bad_person\",\n                0,\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    address: \"other_token\".to_string(),\n                    amount: Uint128::new(100u128),\n                }),\n                \u0026[],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::TraderNotCreator {});\n        }\n\n        #[test]\n        fn create_trade_and_add_cw721_tokens() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n\n            let res = add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft\".to_string(),\n                    token_id: \"58\".to_string(),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"add_asset\"),\n                    Attribute::new(\"asset_type\", \"NFT\"),\n                    Attribute::new(\"nft\", \"nft\"),\n                    Attribute::new(\"token_id\", \"58\"),\n                    Attribute::new(\"trade_id\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                ]\n            );\n\n            let new_trade_info = load_trade(\u0026deps.storage, 0).unwrap();\n            assert_eq!(\n                new_trade_info.associated_assets,\n                vec![AssetInfo::Cw721Coin(Cw721Coin {\n                    token_id: \"58\".to_string(),\n                    address: \"nft\".to_string()\n                })]\n            );\n\n            // This triggers an error, the creator is not the same as the sender\n            let err = add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"bad_person\",\n                0,\n                AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"other_token\".to_string(),\n                    token_id: \"58\".to_string(),\n                }),\n                \u0026[],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::TraderNotCreator {});\n        }\n\n        #[test]\n        fn create_trade_and_add_cw1155_tokens() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n\n            let res = add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw1155Coin(Cw1155Coin {\n                    address: \"1155\".to_string(),\n                    token_id: \"58\".to_string(),\n                    value: Uint128::new(50u128),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"add_asset\"),\n                    Attribute::new(\"asset_type\", \"cw1155\"),\n                    Attribute::new(\"token\", \"1155\"),\n                    Attribute::new(\"token_id\", \"58\"),\n                    Attribute::new(\"amount\", \"50\"),\n                    Attribute::new(\"trade_id\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                ]\n            );\n\n            let new_trade_info = load_trade(\u0026deps.storage, 0).unwrap();\n            assert_eq!(\n                new_trade_info.associated_assets,\n                vec![AssetInfo::Cw1155Coin(Cw1155Coin {\n                    token_id: \"58\".to_string(),\n                    address: \"1155\".to_string(),\n                    value: Uint128::from(50u128)\n                })]\n            );\n\n            // This triggers an error, the creator is not the same as the sender\n            let err = add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"bad_person\",\n                0,\n                AssetInfo::Cw1155Coin(Cw1155Coin {\n                    address: \"1155\".to_string(),\n                    token_id: \"58\".to_string(),\n                    value: Uint128::new(50u128),\n                }),\n                \u0026[],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::TraderNotCreator {});\n        }\n        #[test]\n        fn create_trade_and_withdraw() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            create_trade_helper(deps.as_mut(), \"creator\");\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw1155Coin(Cw1155Coin {\n                    address: \"1155\".to_string(),\n                    token_id: \"58\".to_string(),\n                    value: Uint128::new(50u128),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"other_token\".to_string(),\n                    token_id: \"58\".to_string(),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            withdraw_cancelled_trade_helper(deps.as_mut(), \"bas_person\", 0).unwrap_err();\n            withdraw_cancelled_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n\n            let new_trade_info = load_trade(\u0026deps.storage, 0).unwrap();\n            assert_eq!(new_trade_info.state, TradeState::Cancelled);\n\n            withdraw_cancelled_trade_helper(deps.as_mut(), \"creator\", 0).unwrap_err();\n        }\n        #[test]\n        fn create_trade_automatic_trade_id() {\n            let mut deps = mock_dependencies();\n            let info = mock_info(\"creator\", \u0026[]);\n            let env = mock_env();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            create_trade_helper(deps.as_mut(), \"creator\");\n\n            execute(\n                deps.as_mut(),\n                env.clone(),\n                info,\n                ExecuteMsg::AddAsset {\n                    trade_id: None,\n                    counter_id: None,\n                    to_last_trade: Some(true),\n                    to_last_counter: None,\n                    asset: AssetInfo::Cw20Coin(Cw20Coin {\n                        address: \"cw20\".to_string(),\n                        amount: Uint128::from(100u64),\n                    }),\n                },\n            )\n            .unwrap();\n\n            let info = mock_info(\"creator\", \u0026coins(97u128, \"uluna\"));\n            execute(\n                deps.as_mut(),\n                env,\n                info,\n                ExecuteMsg::AddAsset {\n                    trade_id: None,\n                    counter_id: None,\n                    to_last_trade: Some(true),\n                    to_last_counter: None,\n                    asset: AssetInfo::Coin(coin(97u128, \"uluna\")),\n                },\n            )\n            .unwrap();\n\n            let trade_info = TRADE_INFO.load(\u0026deps.storage, 1u64).unwrap();\n            assert_eq!(\n                trade_info.associated_assets,\n                vec![\n                    AssetInfo::Cw20Coin(Cw20Coin {\n                        address: \"cw20\".to_string(),\n                        amount: Uint128::from(100u128)\n                    }),\n                    AssetInfo::Coin(coin(97u128, \"uluna\")),\n                ]\n            );\n        }\n\n        #[test]\n        fn create_trade_add_remove_tokens() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft\".to_string(),\n                    token_id: \"58\".to_string(),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft-2\".to_string(),\n                    token_id: \"58\".to_string(),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw1155Coin(Cw1155Coin {\n                    address: \"cw1155token\".to_string(),\n                    token_id: \"58\".to_string(),\n                    value: Uint128::new(100u128),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    address: \"token\".to_string(),\n                    amount: Uint128::new(100u128),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Coin(coin(100, \"luna\")),\n                \u0026coins(100, \"luna\"),\n            )\n            .unwrap();\n\n            let res = remove_assets_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                None,\n                vec![\n                    (\n                        0,\n                        AssetInfo::Cw721Coin(Cw721Coin {\n                            address: \"nft\".to_string(),\n                            token_id: \"58\".to_string(),\n                        }),\n                    ),\n                    (\n                        2,\n                        AssetInfo::Cw1155Coin(Cw1155Coin {\n                            address: \"cw1155token\".to_string(),\n                            token_id: \"58\".to_string(),\n                            value: Uint128::from(58u128),\n                        }),\n                    ),\n                    (\n                        3,\n                        AssetInfo::Cw20Coin(Cw20Coin {\n                            address: \"token\".to_string(),\n                            amount: Uint128::from(58u64),\n                        }),\n                    ),\n                    (4, AssetInfo::Coin(coin(58, \"luna\"))),\n                ],\n            )\n            .unwrap();\n\n            assert_eq!(\n                res.messages,\n                vec![\n                    SubMsg::new(\n                        into_cosmos_msg(\n                            Cw721ExecuteMsg::TransferNft {\n                                recipient: \"creator\".to_string(),\n                                token_id: \"58\".to_string()\n                            },\n                            \"nft\"\n                        )\n                        .unwrap()\n                    ),\n                    SubMsg::new(\n                        into_cosmos_msg(\n                            Cw1155ExecuteMsg::SendFrom {\n                                from: mock_env().contract.address.to_string(),\n                                to: \"creator\".to_string(),\n                                token_id: \"58\".to_string(),\n                                value: Uint128::from(58u128),\n                                msg: None\n                            },\n                            \"cw1155token\"\n                        )\n                        .unwrap()\n                    ),\n                    SubMsg::new(\n                        into_cosmos_msg(\n                            Cw20ExecuteMsg::Transfer {\n                                recipient: \"creator\".to_string(),\n                                amount: Uint128::from(58u64)\n                            },\n                            \"token\"\n                        )\n                        .unwrap()\n                    ),\n                    SubMsg::new(BankMsg::Send {\n                        to_address: \"creator\".to_string(),\n                        amount: coins(58, \"luna\"),\n                    })\n                ]\n            );\n\n            let new_trade_info = load_trade(\u0026deps.storage, 0).unwrap();\n            assert_eq!(\n                new_trade_info.associated_assets,\n                vec![\n                    AssetInfo::Cw721Coin(Cw721Coin {\n                        token_id: \"58\".to_string(),\n                        address: \"nft-2\".to_string()\n                    }),\n                    AssetInfo::Cw1155Coin(Cw1155Coin {\n                        value: Uint128::from(42u64),\n                        address: \"cw1155token\".to_string(),\n                        token_id: \"58\".to_string()\n                    }),\n                    AssetInfo::Cw20Coin(Cw20Coin {\n                        amount: Uint128::from(42u64),\n                        address: \"token\".to_string()\n                    }),\n                    AssetInfo::Coin(coin(42, \"luna\"))\n                ],\n            );\n\n            remove_assets_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                None,\n                vec![\n                    (\n                        1,\n                        AssetInfo::Cw1155Coin(Cw1155Coin {\n                            address: \"cw1155token\".to_string(),\n                            token_id: \"58\".to_string(),\n                            value: Uint128::from(42u64),\n                        }),\n                    ),\n                    (\n                        2,\n                        AssetInfo::Cw20Coin(Cw20Coin {\n                            address: \"token\".to_string(),\n                            amount: Uint128::from(42u64),\n                        }),\n                    ),\n                    (3, AssetInfo::Coin(coin(42, \"luna\"))),\n                ],\n            )\n            .unwrap();\n\n            let new_trade_info = load_trade(\u0026deps.storage, 0).unwrap();\n            assert_eq!(\n                new_trade_info.associated_assets,\n                vec![AssetInfo::Cw721Coin(Cw721Coin {\n                    token_id: \"58\".to_string(),\n                    address: \"nft-2\".to_string()\n                }),],\n            );\n\n            // This triggers an error, the creator is not the same as the sender\n            let err = remove_assets_helper(\n                deps.as_mut(),\n                \"bad_person\",\n                0,\n                None,\n                vec![(\n                    0,\n                    AssetInfo::Cw721Coin(Cw721Coin {\n                        address: \"nft-2\".to_string(),\n                        token_id: \"58\".to_string(),\n                    }),\n                )],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::TraderNotCreator {});\n\n            // This triggers an error, no matching funds were found\n            let err = remove_assets_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                None,\n                vec![(\n                    1,\n                    AssetInfo::Cw721Coin(Cw721Coin {\n                        address: \"nft-2\".to_string(),\n                        token_id: \"58\".to_string(),\n                    }),\n                )],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::AssetNotFound { position: 1 });\n\n            // This triggers an error, no matching funds were found\n            let err = remove_assets_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                None,\n                vec![(\n                    0,\n                    AssetInfo::Cw721Coin(Cw721Coin {\n                        address: \"nft-1\".to_string(),\n                        token_id: \"58\".to_string(),\n                    }),\n                )],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::AssetNotFound { position: 0 });\n\n            // This triggers an error, no matching funds were found\n            let err = remove_assets_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                None,\n                vec![(\n                    0,\n                    AssetInfo::Cw721Coin(Cw721Coin {\n                        address: \"nft-2\".to_string(),\n                        token_id: \"42\".to_string(),\n                    }),\n                )],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::AssetNotFound { position: 0 });\n        }\n\n        #[test]\n        fn create_trade_add_remove_tokens_errors() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft\".to_string(),\n                    token_id: \"58\".to_string(),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft-2\".to_string(),\n                    token_id: \"58\".to_string(),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    address: \"token\".to_string(),\n                    amount: Uint128::new(100u128),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Coin(coin(100, \"luna\")),\n                \u0026coins(100, \"luna\"),\n            )\n            .unwrap();\n\n            let err = remove_assets_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                None,\n                vec![(\n                    2,\n                    AssetInfo::Cw20Coin(Cw20Coin {\n                        address: \"token\".to_string(),\n                        amount: Uint128::from(101u64),\n                    }),\n                )],\n            )\n            .unwrap_err();\n\n            assert_eq!(\n                err,\n                ContractError::TooMuchWithdrawn {\n                    address: \"token\".to_string(),\n                    wanted: 101,\n                    available: 100\n                }\n            );\n\n            let err = remove_assets_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                None,\n                vec![(\n                    0,\n                    AssetInfo::Cw20Coin(Cw20Coin {\n                        address: \"token\".to_string(),\n                        amount: Uint128::from(101u64),\n                    }),\n                )],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::AssetNotFound { position: 0 });\n\n            let err = remove_assets_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                None,\n                vec![(\n                    2,\n                    AssetInfo::Cw20Coin(Cw20Coin {\n                        address: \"wrong-token\".to_string(),\n                        amount: Uint128::from(101u64),\n                    }),\n                )],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::AssetNotFound { position: 2 });\n\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n\n            let err = remove_assets_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                None,\n                vec![(\n                    2,\n                    AssetInfo::Cw20Coin(Cw20Coin {\n                        address: \"token\".to_string(),\n                        amount: Uint128::from(58u64),\n                    }),\n                )],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::TradeAlreadyPublished {});\n        }\n\n        #[test]\n        fn confirm_trade() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n\n            //Wrong trade id\n            let err = confirm_trade_helper(deps.as_mut(), \"creator\", 1).unwrap_err();\n            assert_eq!(err, ContractError::NotFoundInTradeInfo {});\n\n            //Wrong trader\n            let err = confirm_trade_helper(deps.as_mut(), \"bad_person\", 0).unwrap_err();\n            assert_eq!(err, ContractError::TraderNotCreator {});\n\n            let res = confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"confirm_trade\"),\n                    Attribute::new(\"trade_id\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                ]\n            );\n\n            // Check with query that trade is confirmed, in published state\n            let res = query_all_trades(\n                deps.as_ref(),\n                None,\n                None,\n                Some(QueryFilters {\n                    states: Some(vec![TradeState::Published.to_string()]),\n                    owner: Some(\"creator\".to_string()),\n                    ..Default::default()\n                }),\n            )\n            .unwrap();\n\n            assert_eq!(\n                res.trades,\n                vec![{\n                    TradeResponse {\n                        trade_id: 0,\n                        counter_id: None,\n                        trade_info: Some(TradeInfo {\n                            owner: deps.api.addr_validate(\"creator\").unwrap(),\n                            state: TradeState::Published,\n                            additionnal_info: AdditionnalTradeInfo {\n                                owner_comment: Some(Comment {\n                                    comment: \"Q\".to_string(),\n                                    time: mock_env().block.time,\n                                }),\n                                time: mock_env().block.time,\n                                ..Default::default()\n                            },\n                            ..Default::default()\n                        }),\n                    }\n                }]\n            );\n\n            let new_trade_info = load_trade(\u0026deps.storage, 0).unwrap();\n            assert_eq!(new_trade_info.state, TradeState::Published {});\n\n            //Already confirmed\n            let err = confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap_err();\n            assert_eq!(\n                err,\n                ContractError::CantChangeTradeState {\n                    from: TradeState::Published,\n                    to: TradeState::Published\n                }\n            );\n        }\n\n        #[test]\n        fn confirm_trade_and_try_add_assets() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n\n            // This triggers an error, we can't send funds to confirmed trade\n\n            let err = add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Coin(coin(2, \"token\")),\n                \u0026coins(2, \"token\"),\n            )\n            .unwrap_err();\n\n            assert_eq!(\n                err,\n                ContractError::WrongTradeState {\n                    state: TradeState::Published\n                }\n            );\n        }\n\n        #[test]\n        fn accept_trade() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n\n            let err = accept_trade_helper(deps.as_mut(), \"creator\", 0, 5).unwrap_err();\n            assert_eq!(err, ContractError::NotFoundInCounterTradeInfo {});\n\n            let err = accept_trade_helper(deps.as_mut(), \"creator\", 1, 0).unwrap_err();\n            assert_eq!(err, ContractError::NotFoundInTradeInfo {});\n\n            let err = accept_trade_helper(deps.as_mut(), \"bad_person\", 0, 0).unwrap_err();\n            assert_eq!(err, ContractError::TraderNotCreator {});\n\n            let err = accept_trade_helper(deps.as_mut(), \"creator\", 0, 0).unwrap_err();\n            assert_eq!(err, ContractError::CantAcceptNotPublishedCounter {});\n\n            confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap();\n\n            let res = accept_trade_helper(deps.as_mut(), \"creator\", 0, 0).unwrap();\n\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"accept_counter_trade\"),\n                    Attribute::new(\"trade_id\", \"0\"),\n                    Attribute::new(\"counter_id\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                    Attribute::new(\"counter_trader\", \"counterer\"),\n                ]\n            );\n\n            let trade_info = load_trade(\u0026deps.storage, 0).unwrap();\n            assert_eq!(trade_info.state, TradeState::Accepted {});\n            assert_eq!(\n                trade_info.accepted_info.unwrap(),\n                CounterTradeInfo {\n                    trade_id: 0,\n                    counter_id: 0\n                }\n            );\n\n            let counter_trade_info = load_counter_trade(\u0026deps.storage, 0, 0).unwrap();\n            assert_eq!(counter_trade_info.state, TradeState::Accepted {});\n\n            // Check with query that trade is confirmed, in ack state\n            let res = query_all_trades(\n                deps.as_ref(),\n                None,\n                None,\n                Some(QueryFilters {\n                    states: Some(vec![TradeState::Accepted.to_string()]),\n                    owner: Some(\"creator\".to_string()),\n                    ..Default::default()\n                }),\n            )\n            .unwrap();\n\n            assert_eq!(\n                res.trades,\n                vec![{\n                    TradeResponse {\n                        trade_id: 0,\n                        counter_id: None,\n                        trade_info: Some(TradeInfo {\n                            owner: deps.api.addr_validate(\"creator\").unwrap(),\n                            state: TradeState::Accepted,\n                            last_counter_id: Some(0),\n                            accepted_info: Some(CounterTradeInfo {\n                                trade_id: 0,\n                                counter_id: 0,\n                            }),\n                            additionnal_info: AdditionnalTradeInfo {\n                                owner_comment: Some(Comment {\n                                    comment: \"Q\".to_string(),\n                                    time: mock_env().block.time,\n                                }),\n                                time: mock_env().block.time,\n                                ..Default::default()\n                            },\n                            ..Default::default()\n                        }),\n                    }\n                }]\n            );\n\n            // Check with query by trade id that one counter is returned\n            let res = query_counter_trades(deps.as_ref(), 0, None, None, None).unwrap();\n\n            assert_eq!(\n                res.counter_trades,\n                vec![{\n                    TradeResponse {\n                        counter_id: Some(0),\n                        trade_id: 0,\n                        trade_info: Some(TradeInfo {\n                            owner: deps.api.addr_validate(\"counterer\").unwrap(),\n                            state: TradeState::Accepted,\n                            additionnal_info: AdditionnalTradeInfo {\n                                owner_comment: Some(Comment {\n                                    comment: \"Q\".to_string(),\n                                    time: mock_env().block.time,\n                                }),\n                                trader_comment: Some(Comment {\n                                    comment: \"You're very kind madam\".to_string(),\n                                    time: mock_env().block.time,\n                                }),\n                                time: mock_env().block.time,\n                                ..Default::default()\n                            },\n                            ..Default::default()\n                        }),\n                    }\n                }]\n            );\n\n            let res = query_counter_trades(deps.as_ref(), 0, Some(0), None, None).unwrap();\n            assert_eq!(res.counter_trades, vec![]);\n\n            // Check with queries that only one counter is returned by query and in accepted state\n            let res = query_all_counter_trades(deps.as_ref(), None, None, None).unwrap();\n\n            assert_eq!(\n                res.counter_trades,\n                vec![{\n                    TradeResponse {\n                        counter_id: Some(0),\n                        trade_id: 0,\n                        trade_info: Some(TradeInfo {\n                            owner: deps.api.addr_validate(\"counterer\").unwrap(),\n                            state: TradeState::Accepted,\n                            additionnal_info: AdditionnalTradeInfo {\n                                owner_comment: Some(Comment {\n                                    comment: \"Q\".to_string(),\n                                    time: mock_env().block.time,\n                                }),\n                                trader_comment: Some(Comment {\n                                    comment: \"You're very kind madam\".to_string(),\n                                    time: mock_env().block.time,\n                                }),\n                                time: mock_env().block.time,\n                                ..Default::default()\n                            },\n                            ..Default::default()\n                        }),\n                    }\n                }]\n            );\n        }\n\n        #[test]\n        fn accept_trade_with_multiple_counter() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n\n            confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap();\n            confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 1).unwrap();\n\n            let res = accept_trade_helper(deps.as_mut(), \"creator\", 0, 0).unwrap();\n\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"accept_counter_trade\"),\n                    Attribute::new(\"trade_id\", \"0\"),\n                    Attribute::new(\"counter_id\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                    Attribute::new(\"counter_trader\", \"counterer\"),\n                ]\n            );\n\n            let trade_info = load_trade(\u0026deps.storage, 0).unwrap();\n            assert_eq!(trade_info.state, TradeState::Accepted {});\n\n            let counter_trade_info = load_counter_trade(\u0026deps.storage, 0, 0).unwrap();\n            assert_eq!(counter_trade_info.state, TradeState::Accepted {});\n\n            let counter_trade_info = load_counter_trade(\u0026deps.storage, 0, 1).unwrap();\n            assert_eq!(counter_trade_info.state, TradeState::Refused {});\n\n            // Check that the only Accepted and Published counters are the accepted counter\n            let res = query_all_counter_trades(\n                deps.as_ref(),\n                None,\n                None,\n                Some(QueryFilters {\n                    states: Some(vec![\n                        TradeState::Accepted.to_string(),\n                        TradeState::Published.to_string(),\n                    ]),\n                    ..Default::default()\n                }),\n            )\n            .unwrap();\n\n            assert_eq!(\n                res.counter_trades,\n                vec![{\n                    TradeResponse {\n                        counter_id: Some(0),\n                        trade_id: 0,\n                        trade_info: Some(TradeInfo {\n                            owner: deps.api.addr_validate(\"counterer\").unwrap(),\n                            state: TradeState::Accepted,\n\n                            additionnal_info: AdditionnalTradeInfo {\n                                owner_comment: Some(Comment {\n                                    comment: \"Q\".to_string(),\n                                    time: mock_env().block.time,\n                                }),\n                                trader_comment: Some(Comment {\n                                    comment: \"You're very kind madam\".to_string(),\n                                    time: mock_env().block.time,\n                                }),\n                                time: mock_env().block.time,\n                                ..Default::default()\n                            },\n                            ..Default::default()\n                        }),\n                    }\n                }]\n            );\n            // Check that the other counters is cancelled\n            let res = query_all_counter_trades(\n                deps.as_ref(),\n                None,\n                None,\n                Some(QueryFilters {\n                    states: Some(vec![TradeState::Refused.to_string()]),\n                    ..Default::default()\n                }),\n            )\n            .unwrap();\n\n            assert_eq!(\n                res.counter_trades,\n                vec![\n                    {\n                        TradeResponse {\n                            counter_id: Some(2),\n                            trade_id: 0,\n                            trade_info: Some(TradeInfo {\n                                owner: deps.api.addr_validate(\"counterer\").unwrap(),\n                                state: TradeState::Refused,\n                                additionnal_info: AdditionnalTradeInfo {\n                                    owner_comment: Some(Comment {\n                                        comment: \"Q\".to_string(),\n                                        time: mock_env().block.time,\n                                    }),\n                                    time: mock_env().block.time,\n                                    ..Default::default()\n                                },\n                                ..Default::default()\n                            }),\n                        }\n                    },\n                    {\n                        TradeResponse {\n                            counter_id: Some(1),\n                            trade_id: 0,\n                            trade_info: Some(TradeInfo {\n                                owner: deps.api.addr_validate(\"counterer\").unwrap(),\n                                state: TradeState::Refused,\n                                additionnal_info: AdditionnalTradeInfo {\n                                    owner_comment: Some(Comment {\n                                        comment: \"Q\".to_string(),\n                                        time: mock_env().block.time,\n                                    }),\n                                    time: mock_env().block.time,\n                                    ..Default::default()\n                                },\n                                ..Default::default()\n                            }),\n                        }\n                    },\n                ]\n            );\n\n            // Check that both Accepted and Published counter queries exist, paginate to skip last counter trade\n            let res = query_all_counter_trades(\n                deps.as_ref(),\n                Some(CounterTradeInfo {\n                    trade_id: 0,\n                    counter_id: 1,\n                }),\n                None,\n                Some(QueryFilters {\n                    states: Some(vec![\n                        TradeState::Accepted.to_string(),\n                        TradeState::Published.to_string(),\n                    ]),\n                    ..Default::default()\n                }),\n            )\n            .unwrap();\n\n            assert_eq!(\n                res.counter_trades,\n                vec![{\n                    TradeResponse {\n                        counter_id: Some(0),\n                        trade_id: 0,\n                        trade_info: Some(TradeInfo {\n                            owner: deps.api.addr_validate(\"counterer\").unwrap(),\n                            state: TradeState::Accepted,\n                            additionnal_info: AdditionnalTradeInfo {\n                                owner_comment: Some(Comment {\n                                    comment: \"Q\".to_string(),\n                                    time: mock_env().block.time,\n                                }),\n                                trader_comment: Some(Comment {\n                                    comment: \"You're very kind madam\".to_string(),\n                                    time: mock_env().block.time,\n                                }),\n                                time: mock_env().block.time,\n                                ..Default::default()\n                            },\n                            ..Default::default()\n                        }),\n                    }\n                }]\n            );\n        }\n\n        #[test]\n        fn cancel_trade() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n\n            let err = cancel_trade_helper(deps.as_mut(), \"creator\", 1).unwrap_err();\n            assert_eq!(err, ContractError::NotFoundInTradeInfo {});\n\n            let err = cancel_trade_helper(deps.as_mut(), \"bad_person\", 0).unwrap_err();\n            assert_eq!(err, ContractError::TraderNotCreator {});\n\n            confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap();\n\n            let res = cancel_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"cancel_trade\"),\n                    Attribute::new(\"trade_id\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                ]\n            );\n\n            // Query all counter trades make sure counter trade is cancelled with the trade\n            let res = query_all_counter_trades(deps.as_ref(), None, None, None).unwrap();\n\n            assert_eq!(\n                res.counter_trades,\n                vec![{\n                    TradeResponse {\n                        counter_id: Some(0),\n                        trade_id: 0,\n                        trade_info: Some(TradeInfo {\n                            owner: deps.api.addr_validate(\"counterer\").unwrap(),\n                            state: TradeState::Cancelled,\n                            additionnal_info: AdditionnalTradeInfo {\n                                owner_comment: Some(Comment {\n                                    comment: \"Q\".to_string(),\n                                    time: mock_env().block.time,\n                                }),\n                                time: mock_env().block.time,\n                                ..Default::default()\n                            },\n                            ..Default::default()\n                        }),\n                    }\n                }]\n            );\n        }\n\n        #[test]\n        fn queries_with_multiple_trades_and_counter_trades() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 1).unwrap();\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 2).unwrap();\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 3).unwrap();\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 4).unwrap();\n\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer2\", 0).unwrap();\n\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 1).unwrap();\n\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 2).unwrap();\n\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 3).unwrap();\n\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 4).unwrap();\n\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer2\", 4).unwrap();\n\n            // Query all before second one, should return the first one\n            let res = query_all_counter_trades(\n                deps.as_ref(),\n                Some(CounterTradeInfo {\n                    trade_id: 0,\n                    counter_id: 1,\n                }),\n                None,\n                Some(QueryFilters {\n                    owner: Some(\"counterer2\".to_string()),\n                    ..Default::default()\n                }),\n            )\n            .unwrap();\n\n            assert_eq!(\n                res.counter_trades,\n                vec![TradeResponse {\n                    trade_id: 0,\n                    counter_id: Some(0),\n                    trade_info: Some(TradeInfo {\n                        owner: deps.api.addr_validate(\"counterer2\").unwrap(),\n                        state: TradeState::Created,\n                        additionnal_info: AdditionnalTradeInfo {\n                            owner_comment: Some(Comment {\n                                comment: \"Q\".to_string(),\n                                time: mock_env().block.time\n                            }),\n                            time: mock_env().block.time,\n                            ..Default::default()\n                        },\n                        ..Default::default()\n                    })\n                }]\n            );\n\n            // Query all before first one, should return empty array\n            let res = query_all_counter_trades(\n                deps.as_ref(),\n                Some(CounterTradeInfo {\n                    trade_id: 0,\n                    counter_id: 0,\n                }),\n                None,\n                None,\n            )\n            .unwrap();\n\n            assert_eq!(res.counter_trades, vec![]);\n\n            // Query for non existing user should return empty []\n            let res = query_all_counter_trades(\n                deps.as_ref(),\n                None,\n                None,\n                Some(QueryFilters {\n                    owner: Some(\"counterer5\".to_string()),\n                    ..Default::default()\n                }),\n            )\n            .unwrap();\n\n            assert_eq!(res.counter_trades, vec![]);\n\n            // Query by trade_id should return counter queries for trade id 4\n            let res = query_counter_trades(deps.as_ref(), 4, None, None, None).unwrap();\n\n            assert_eq!(\n                res.counter_trades,\n                vec![\n                    TradeResponse {\n                        trade_id: 4,\n                        counter_id: Some(1),\n                        trade_info: Some(TradeInfo {\n                            owner: deps.api.addr_validate(\"counterer2\").unwrap(),\n                            state: TradeState::Created,\n                            additionnal_info: AdditionnalTradeInfo {\n                                owner_comment: Some(Comment {\n                                    comment: \"Q\".to_string(),\n                                    time: mock_env().block.time\n                                }),\n                                time: mock_env().block.time,\n                                ..Default::default()\n                            },\n                            ..Default::default()\n                        })\n                    },\n                    TradeResponse {\n                        trade_id: 4,\n                        counter_id: Some(0),\n                        trade_info: Some(TradeInfo {\n                            owner: deps.api.addr_validate(\"counterer\").unwrap(),\n                            additionnal_info: AdditionnalTradeInfo {\n                                owner_comment: Some(Comment {\n                                    comment: \"Q\".to_string(),\n                                    time: mock_env().block.time\n                                }),\n                                time: mock_env().block.time,\n                                ..Default::default()\n                            },\n                            ..Default::default()\n                        })\n                    }\n                ]\n            );\n        }\n\n        #[test]\n        fn withdraw_accepted_assets() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n            set_fee_contract_helper(deps.as_mut());\n            create_trade_helper(deps.as_mut(), \"creator\");\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft\".to_string(),\n                    token_id: \"58\".to_string(),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw1155Coin(Cw1155Coin {\n                    address: \"cw1155\".to_string(),\n                    token_id: \"58\".to_string(),\n                    value: Uint128::new(100u128),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    address: \"token\".to_string(),\n                    amount: Uint128::new(100u128),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Coin(coin(9, \"other_token\")),\n                \u0026coins(9, \"other_token\"),\n            )\n            .unwrap();\n\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"other_counterer\", 0).unwrap();\n\n            add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"other_counterer\",\n                0,\n                0,\n                AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"other_counter-nft\".to_string(),\n                    token_id: \"58\".to_string(),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"other_counterer\",\n                0,\n                0,\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    address: \"other_counter-token\".to_string(),\n                    amount: Uint128::new(100u128),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"other_counterer\",\n                0,\n                0,\n                AssetInfo::Coin(coin(5, \"lunas\")),\n                \u0026coins(5, \"lunas\"),\n            )\n            .unwrap();\n\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n\n            add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                1,\n                AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"counter-nft\".to_string(),\n                    token_id: \"58\".to_string(),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                1,\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    address: \"counter-token\".to_string(),\n                    amount: Uint128::new(100u128),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                1,\n                AssetInfo::Coin(coin(2, \"token\")),\n                \u0026coins(2, \"token\"),\n            )\n            .unwrap();\n\n            confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 1).unwrap();\n\n            // Little test to start with (can't withdraw if the trade is not accepted)\n            let err = withdraw_helper(deps.as_mut(), \"anyone\", \"fee_contract\", 0).unwrap_err();\n            assert_eq!(err, ContractError::TradeNotAccepted {});\n\n            accept_trade_helper(deps.as_mut(), \"creator\", 0, 1).unwrap();\n\n            // Withdraw tests\n            let err = withdraw_helper(deps.as_mut(), \"bad_person\", \"fee_contract\", 0).unwrap_err();\n            assert_eq!(err, ContractError::NotWithdrawableByYou {});\n\n            let err = withdraw_helper(deps.as_mut(), \"creator\", \"bad_person\", 0).unwrap_err();\n            assert_eq!(err, ContractError::Unauthorized {});\n\n            let res = withdraw_helper(deps.as_mut(), \"creator\", \"fee_contract\", 0).unwrap();\n            assert_eq!(\n                res.messages,\n                vec![\n                    SubMsg::new(\n                        into_cosmos_msg(\n                            Cw721ExecuteMsg::TransferNft {\n                                recipient: \"creator\".to_string(),\n                                token_id: \"58\".to_string()\n                            },\n                            \"counter-nft\"\n                        )\n                        .unwrap()\n                    ),\n                    SubMsg::new(\n                        into_cosmos_msg(\n                            Cw20ExecuteMsg::Transfer {\n                                recipient: \"creator\".to_string(),\n                                amount: Uint128::from(100u64)\n                            },\n                            \"counter-token\"\n                        )\n                        .unwrap()\n                    ),\n                    SubMsg::new(BankMsg::Send {\n                        to_address: \"creator\".to_string(),\n                        amount: coins(2, \"token\"),\n                    })\n                ]\n            );\n\n            let err = withdraw_helper(deps.as_mut(), \"creator\", \"fee_contract\", 0).unwrap_err();\n            assert_eq!(err, ContractError::TradeAlreadyWithdrawn {});\n\n            let res = withdraw_helper(deps.as_mut(), \"counterer\", \"fee_contract\", 0).unwrap();\n            assert_eq!(\n                res.messages,\n                vec![\n                    SubMsg::new(\n                        into_cosmos_msg(\n                            Cw721ExecuteMsg::TransferNft {\n                                recipient: \"counterer\".to_string(),\n                                token_id: \"58\".to_string()\n                            },\n                            \"nft\"\n                        )\n                        .unwrap()\n                    ),\n                    SubMsg::new(\n                        into_cosmos_msg(\n                            Cw1155ExecuteMsg::SendFrom {\n                                to: \"counterer\".to_string(),\n                                from: mock_env().contract.address.to_string(),\n                                token_id: \"58\".to_string(),\n                                value: Uint128::from(100u128),\n                                msg: None\n                            },\n                            \"cw1155\"\n                        )\n                        .unwrap()\n                    ),\n                    SubMsg::new(\n                        into_cosmos_msg(\n                            Cw20ExecuteMsg::Transfer {\n                                recipient: \"counterer\".to_string(),\n                                amount: Uint128::from(100u64)\n                            },\n                            \"token\"\n                        )\n                        .unwrap()\n                    ),\n                    SubMsg::new(BankMsg::Send {\n                        to_address: \"counterer\".to_string(),\n                        amount: coins(9, \"other_token\"),\n                    }),\n                ]\n            );\n\n            let err = withdraw_helper(deps.as_mut(), \"counterer\", \"fee_contract\", 0).unwrap_err();\n            assert_eq!(err, ContractError::TradeAlreadyWithdrawn {});\n\n            let res =\n                withdraw_aborted_counter_helper(deps.as_mut(), \"other_counterer\", 0, 0).unwrap();\n            assert_eq!(\n                res.messages,\n                vec![\n                    SubMsg::new(\n                        into_cosmos_msg(\n                            Cw721ExecuteMsg::TransferNft {\n                                recipient: \"other_counterer\".to_string(),\n                                token_id: \"58\".to_string()\n                            },\n                            \"other_counter-nft\"\n                        )\n                        .unwrap()\n                    ),\n                    SubMsg::new(\n                        into_cosmos_msg(\n                            Cw20ExecuteMsg::Transfer {\n                                recipient: \"other_counterer\".to_string(),\n                                amount: Uint128::from(100u64)\n                            },\n                            \"other_counter-token\"\n                        )\n                        .unwrap()\n                    ),\n                    SubMsg::new(BankMsg::Send {\n                        to_address: \"other_counterer\".to_string(),\n                        amount: coins(5, \"lunas\"),\n                    }),\n                ]\n            );\n\n            let err = withdraw_aborted_counter_helper(deps.as_mut(), \"other_counterer\", 0, 0)\n                .unwrap_err();\n            assert_eq!(err, ContractError::TradeAlreadyWithdrawn {});\n        }\n\n        #[test]\n        fn withdraw_cancelled_trade() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n            create_trade_helper(deps.as_mut(), \"creator\");\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft\".to_string(),\n                    token_id: \"58\".to_string(),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    address: \"token\".to_string(),\n                    amount: Uint128::new(100u128),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Coin(coin(5, \"lunas\")),\n                \u0026coins(5, \"lunas\"),\n            )\n            .unwrap();\n\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n\n            add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                0,\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    address: \"other_counter-token\".to_string(),\n                    amount: Uint128::new(100u128),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            cancel_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            let res = withdraw_cancelled_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n\n            assert_eq!(\n                res.messages,\n                vec![\n                    SubMsg::new(\n                        into_cosmos_msg(\n                            Cw721ExecuteMsg::TransferNft {\n                                recipient: \"creator\".to_string(),\n                                token_id: \"58\".to_string()\n                            },\n                            \"nft\"\n                        )\n                        .unwrap()\n                    ),\n                    SubMsg::new(\n                        into_cosmos_msg(\n                            Cw20ExecuteMsg::Transfer {\n                                recipient: \"creator\".to_string(),\n                                amount: Uint128::from(100u64)\n                            },\n                            \"token\"\n                        )\n                        .unwrap()\n                    ),\n                    SubMsg::new(BankMsg::Send {\n                        to_address: \"creator\".to_string(),\n                        amount: coins(5, \"lunas\"),\n                    }),\n                ]\n            );\n\n            let err = withdraw_cancelled_trade_helper(deps.as_mut(), \"creator\", 0).unwrap_err();\n            assert_eq!(err, ContractError::TradeAlreadyWithdrawn {});\n\n            let res = withdraw_aborted_counter_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap();\n            assert_eq!(\n                res.messages,\n                vec![SubMsg::new(\n                    into_cosmos_msg(\n                        Cw20ExecuteMsg::Transfer {\n                            recipient: \"counterer\".to_string(),\n                            amount: Uint128::from(100u64)\n                        },\n                        \"other_counter-token\"\n                    )\n                    .unwrap()\n                ),]\n            );\n\n            let err =\n                withdraw_aborted_counter_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap_err();\n            assert_eq!(err, ContractError::TradeAlreadyWithdrawn {});\n        }\n\n        #[test]\n        fn private() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n            create_private_trade_helper(deps.as_mut(), vec![\"whitelist\".to_string()]);\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft\".to_string(),\n                    token_id: \"58\".to_string(),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    address: \"token\".to_string(),\n                    amount: Uint128::new(100u128),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_trade_helper(\n                deps.as_mut(),\n                \"creator\",\n                0,\n                AssetInfo::Coin(coin(5, \"lunas\")),\n                \u0026coins(5, \"lunas\"),\n            )\n            .unwrap();\n\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n\n            let err = suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap_err();\n            assert_eq!(err, ContractError::AddressNotWhitelisted {});\n\n            suggest_counter_trade_helper(deps.as_mut(), \"whitelist\", 0).unwrap();\n\n            let err = remove_whitelisted_users(deps.as_mut(), 0, vec![\"whitelist\".to_string()])\n                .unwrap_err();\n            assert_eq!(\n                err,\n                ContractError::WrongTradeState {\n                    state: TradeState::Countered\n                }\n            );\n\n            let err =\n                add_whitelisted_users(deps.as_mut(), 0, vec![\"whitelist\".to_string()]).unwrap_err();\n            assert_eq!(\n                err,\n                ContractError::WrongTradeState {\n                    state: TradeState::Countered\n                }\n            );\n\n            create_private_trade_helper(deps.as_mut(), vec![\"whitelist\".to_string()]);\n\n            remove_whitelisted_users(deps.as_mut(), 1, vec![\"whitelist\".to_string()]).unwrap();\n            let info = TRADE_INFO.load(\u0026deps.storage, 1_u64).unwrap();\n            let hash_set = HashSet::new();\n            assert_eq!(info.whitelisted_users, hash_set);\n\n            add_whitelisted_users(\n                deps.as_mut(),\n                1,\n                vec![\"whitelist-1\".to_string(), \"whitelist\".to_string()],\n            )\n            .unwrap();\n            add_whitelisted_users(\n                deps.as_mut(),\n                1,\n                vec![\"whitelist-2\".to_string(), \"whitelist\".to_string()],\n            )\n            .unwrap();\n            let info = TRADE_INFO.load(\u0026deps.storage, 1_u64).unwrap();\n\n            let whitelisted_users = vec![\n                \"whitelist\".to_string(),\n                \"whitelist-1\".to_string(),\n                \"whitelist-2\".to_string(),\n            ];\n            let hash_set =\n                HashSet::from_iter(validate_addresses(\u0026deps.api, \u0026whitelisted_users).unwrap());\n            assert_eq!(info.whitelisted_users, hash_set);\n        }\n    }\n\n    fn suggest_counter_trade_helper(\n        deps: DepsMut,\n        counterer: \u0026str,\n        trade_id: u64,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(counterer, \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::SuggestCounterTrade {\n                trade_id,\n                comment: Some(\"Q\".to_string()),\n            },\n        )\n    }\n\n    fn add_asset_to_counter_trade_helper(\n        deps: DepsMut,\n        counterer: \u0026str,\n        trade_id: u64,\n        counter_id: u64,\n        asset: AssetInfo,\n        coins_to_send: \u0026[Coin],\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(counterer, coins_to_send);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::AddAsset {\n                to_last_trade: None,\n                to_last_counter: None,\n                trade_id: Some(trade_id),\n                counter_id: Some(counter_id),\n                asset,\n            },\n        )\n    }\n\n    fn confirm_counter_trade_helper(\n        deps: DepsMut,\n        sender: \u0026str,\n        trade_id: u64,\n        counter_id: u64,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(sender, \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::ConfirmCounterTrade {\n                trade_id,\n                counter_id: Some(counter_id),\n            },\n        )\n    }\n\n    fn review_counter_trade_helper(\n        deps: DepsMut,\n        sender: \u0026str,\n        trade_id: u64,\n        counter_id: u64,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(sender, \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::ReviewCounterTrade {\n                trade_id,\n                counter_id,\n                comment: Some(\"Shit NFT my girl\".to_string()),\n            },\n        )\n    }\n\n    fn accept_trade_helper(\n        deps: DepsMut,\n        sender: \u0026str,\n        trade_id: u64,\n        counter_id: u64,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(sender, \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::AcceptTrade {\n                trade_id,\n                counter_id,\n                comment: Some(\"You're very kind madam\".to_string()),\n            },\n        )\n    }\n\n    fn cancel_trade_helper(\n        deps: DepsMut,\n        sender: \u0026str,\n        trade_id: u64,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(sender, \u0026[]);\n        let env = mock_env();\n\n        execute(deps, env, info, ExecuteMsg::CancelTrade { trade_id })\n    }\n\n    fn cancel_counter_trade_helper(\n        deps: DepsMut,\n        sender: \u0026str,\n        trade_id: u64,\n        counter_id: u64,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(sender, \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::CancelCounterTrade {\n                trade_id,\n                counter_id,\n            },\n        )\n    }\n\n    fn refuse_counter_trade_helper(\n        deps: DepsMut,\n        trader: \u0026str,\n        trade_id: u64,\n        counter_id: u64,\n    ) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(trader, \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::RefuseCounterTrade {\n                trade_id,\n                counter_id,\n            },\n        )\n    }\n\n    pub mod counter_trade_tests {\n        use super::*;\n        use crate::query::{AllTradesResponse, TradeResponse};\n        use cosmwasm_std::{coin, from_binary, Api, SubMsg};\n        use p2p_trading_export::msg::QueryFilters;\n        use p2p_trading_export::state::{AdditionnalTradeInfo, Comment, CounterTradeInfo};\n\n        #[test]\n        fn create_counter_trade() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n\n            let err = suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap_err();\n\n            assert_eq!(err, ContractError::NotCounterable {});\n\n            let err = suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 1).unwrap_err();\n\n            assert_eq!(err, ContractError::NotFoundInTradeInfo {});\n\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n\n            let res = suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"create_counter_trade\"),\n                    Attribute::new(\"trade_id\", \"0\"),\n                    Attribute::new(\"counter_id\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                    Attribute::new(\"counter_trader\", \"counterer\"),\n                ]\n            );\n            // We need to make sure it is not couterable in case the counter is accepted\n        }\n        #[test]\n        fn create_counter_trade_and_add_funds() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n\n            let res = add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                0,\n                AssetInfo::Coin(coin(2, \"token\")),\n                \u0026coins(2, \"token\"),\n            )\n            .unwrap();\n\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"add_asset\"),\n                    Attribute::new(\"asset_type\", \"fund\"),\n                    Attribute::new(\"denom\", \"token\"),\n                    Attribute::new(\"amount\", \"2\"),\n                    Attribute::new(\"trade_id\", \"0\"),\n                    Attribute::new(\"counter_id\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                    Attribute::new(\"counter_trader\", \"counterer\"),\n                ]\n            );\n\n            let counter_trade_info = load_counter_trade(\u0026deps.storage, 0, 0).unwrap();\n            assert_eq!(counter_trade_info.state, TradeState::Created);\n            assert_eq!(\n                counter_trade_info.associated_assets,\n                vec![AssetInfo::Coin(coin(2, \"token\"))]\n            );\n        }\n\n        #[test]\n        fn create_counter_trade_and_add_cw20_tokens() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n\n            let res = add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                0,\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    address: \"token\".to_string(),\n                    amount: Uint128::new(100u128),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"add_asset\"),\n                    Attribute::new(\"asset_type\", \"token\"),\n                    Attribute::new(\"token\", \"token\"),\n                    Attribute::new(\"amount\", \"100\"),\n                    Attribute::new(\"trade_id\", \"0\"),\n                    Attribute::new(\"counter_id\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                    Attribute::new(\"counter_trader\", \"counterer\"),\n                ]\n            );\n\n            let err = add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                1,\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    address: \"token\".to_string(),\n                    amount: Uint128::new(100u128),\n                }),\n                \u0026[],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::NotFoundInCounterTradeInfo {});\n\n            // Verifying the state has been changed\n            let trade_info = load_trade(\u0026deps.storage, 0).unwrap();\n            assert_eq!(trade_info.state, TradeState::Countered);\n            assert_eq!(trade_info.associated_assets, vec![]);\n\n            let counter_trade_info = load_counter_trade(\u0026deps.storage, 0, 0).unwrap();\n            assert_eq!(counter_trade_info.state, TradeState::Created);\n            assert_eq!(\n                counter_trade_info.associated_assets,\n                vec![AssetInfo::Cw20Coin(Cw20Coin {\n                    address: \"token\".to_string(),\n                    amount: Uint128::from(100u64)\n                }),]\n            );\n\n            // This triggers an error, the creator is not the same as the sender\n            let err = add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"bad_person\",\n                0,\n                0,\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    address: \"token\".to_string(),\n                    amount: Uint128::new(100u128),\n                }),\n                \u0026[],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::CounterTraderNotCreator {});\n        }\n\n        #[test]\n        fn create_trade_and_add_cw721_tokens() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n\n            let res = add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                0,\n                AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft\".to_string(),\n                    token_id: \"58\".to_string(),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"add_asset\"),\n                    Attribute::new(\"asset_type\", \"NFT\"),\n                    Attribute::new(\"nft\", \"nft\"),\n                    Attribute::new(\"token_id\", \"58\"),\n                    Attribute::new(\"trade_id\", \"0\"),\n                    Attribute::new(\"counter_id\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                    Attribute::new(\"counter_trader\", \"counterer\"),\n                ]\n            );\n\n            // Verifying the state has been changed\n            let trade_info = load_trade(\u0026deps.storage, 0).unwrap();\n            assert_eq!(trade_info.state, TradeState::Countered);\n            assert_eq!(trade_info.associated_assets, vec![]);\n\n            let counter_trade_info = load_counter_trade(\u0026deps.storage, 0, 0).unwrap();\n            assert_eq!(counter_trade_info.state, TradeState::Created);\n            assert_eq!(\n                counter_trade_info.associated_assets,\n                vec![AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft\".to_string(),\n                    token_id: \"58\".to_string()\n                }),]\n            );\n\n            // This triggers an error, the counter-trade creator is not the same as the sender\n            let err = add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"bad_person\",\n                0,\n                0,\n                AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"token\".to_string(),\n                    token_id: \"58\".to_string(),\n                }),\n                \u0026[],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::CounterTraderNotCreator {});\n        }\n\n        #[test]\n        fn create_counter_trade_automatic_trade_id() {\n            let mut deps = mock_dependencies();\n            let info = mock_info(\"creator\", \u0026[]);\n            let env = mock_env();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 1).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"creator\", 1).unwrap();\n\n            suggest_counter_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n\n            execute(\n                deps.as_mut(),\n                env.clone(),\n                info,\n                ExecuteMsg::AddAsset {\n                    trade_id: Some(0),\n                    counter_id: None,\n                    to_last_trade: None,\n                    to_last_counter: Some(true),\n                    asset: AssetInfo::Cw20Coin(Cw20Coin {\n                        address: \"cw20\".to_string(),\n                        amount: Uint128::from(100u64),\n                    }),\n                },\n            )\n            .unwrap();\n\n            let info = mock_info(\"creator\", \u0026coins(97u128, \"uluna\"));\n            execute(\n                deps.as_mut(),\n                env,\n                info,\n                ExecuteMsg::AddAsset {\n                    trade_id: Some(0),\n                    counter_id: None,\n                    to_last_trade: None,\n                    to_last_counter: Some(true),\n                    asset: AssetInfo::Coin(coin(97u128, \"uluna\")),\n                },\n            )\n            .unwrap();\n\n            let info = mock_info(\"creator\", \u0026[]);\n            let env = mock_env();\n\n            execute(\n                deps.as_mut(),\n                env,\n                info,\n                ExecuteMsg::ConfirmCounterTrade {\n                    trade_id: 0,\n                    counter_id: None,\n                },\n            )\n            .unwrap();\n\n            let trade_info = COUNTER_TRADE_INFO\n                .load(\u0026deps.storage, (0u64, 0u64))\n                .unwrap();\n            assert_eq!(\n                trade_info.associated_assets,\n                vec![\n                    AssetInfo::Cw20Coin(Cw20Coin {\n                        address: \"cw20\".to_string(),\n                        amount: Uint128::from(100u128)\n                    }),\n                    AssetInfo::Coin(coin(97, \"uluna\"))\n                ]\n            );\n            assert_eq!(trade_info.state, TradeState::Published);\n        }\n\n        #[test]\n        fn create_counter_trade_add_remove_tokens() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n\n            add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                0,\n                AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft\".to_string(),\n                    token_id: \"58\".to_string(),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                0,\n                AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft-2\".to_string(),\n                    token_id: \"58\".to_string(),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                0,\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    address: \"token\".to_string(),\n                    amount: Uint128::new(100u128),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                0,\n                AssetInfo::Coin(coin(100, \"luna\")),\n                \u0026coins(100, \"luna\"),\n            )\n            .unwrap();\n\n            let res = remove_assets_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                Some(0),\n                vec![\n                    (\n                        0,\n                        AssetInfo::Cw721Coin(Cw721Coin {\n                            address: \"nft\".to_string(),\n                            token_id: \"58\".to_string(),\n                        }),\n                    ),\n                    (\n                        2,\n                        AssetInfo::Cw20Coin(Cw20Coin {\n                            address: \"token\".to_string(),\n                            amount: Uint128::from(58u64),\n                        }),\n                    ),\n                    (3, AssetInfo::Coin(coin(58, \"luna\"))),\n                ],\n            )\n            .unwrap();\n\n            assert_eq!(res.attributes.len(), 14);\n            assert_eq!(\n                res.messages,\n                vec![\n                    SubMsg::new(\n                        into_cosmos_msg(\n                            Cw721ExecuteMsg::TransferNft {\n                                recipient: \"counterer\".to_string(),\n                                token_id: \"58\".to_string()\n                            },\n                            \"nft\"\n                        )\n                        .unwrap()\n                    ),\n                    SubMsg::new(\n                        into_cosmos_msg(\n                            Cw20ExecuteMsg::Transfer {\n                                recipient: \"counterer\".to_string(),\n                                amount: Uint128::from(58u64)\n                            },\n                            \"token\"\n                        )\n                        .unwrap()\n                    ),\n                    SubMsg::new(BankMsg::Send {\n                        to_address: \"counterer\".to_string(),\n                        amount: coins(58, \"luna\"),\n                    })\n                ]\n            );\n\n            let new_trade_info = load_counter_trade(\u0026deps.storage, 0, 0).unwrap();\n            assert_eq!(\n                new_trade_info.associated_assets,\n                vec![\n                    AssetInfo::Cw721Coin(Cw721Coin {\n                        token_id: \"58\".to_string(),\n                        address: \"nft-2\".to_string()\n                    }),\n                    AssetInfo::Cw20Coin(Cw20Coin {\n                        amount: Uint128::from(42u64),\n                        address: \"token\".to_string()\n                    }),\n                    AssetInfo::Coin(coin(42, \"luna\"))\n                ],\n            );\n\n            remove_assets_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                Some(0),\n                vec![\n                    (\n                        1,\n                        AssetInfo::Cw20Coin(Cw20Coin {\n                            address: \"token\".to_string(),\n                            amount: Uint128::from(42u64),\n                        }),\n                    ),\n                    (2, AssetInfo::Coin(coin(42, \"luna\"))),\n                ],\n            )\n            .unwrap();\n\n            let new_trade_info = load_counter_trade(\u0026deps.storage, 0, 0).unwrap();\n            assert_eq!(\n                new_trade_info.associated_assets,\n                vec![AssetInfo::Cw721Coin(Cw721Coin {\n                    token_id: \"58\".to_string(),\n                    address: \"nft-2\".to_string()\n                }),],\n            );\n\n            // This triggers an error, the counterer is not the same as the sender\n            let err = remove_assets_helper(\n                deps.as_mut(),\n                \"bad_person\",\n                0,\n                Some(0),\n                vec![(\n                    0,\n                    AssetInfo::Cw721Coin(Cw721Coin {\n                        address: \"nft-2\".to_string(),\n                        token_id: \"58\".to_string(),\n                    }),\n                )],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::CounterTraderNotCreator {});\n\n            // This triggers an error, no matching funds were found\n            let err = remove_assets_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                Some(0),\n                vec![(\n                    1,\n                    AssetInfo::Cw721Coin(Cw721Coin {\n                        address: \"nft-2\".to_string(),\n                        token_id: \"58\".to_string(),\n                    }),\n                )],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::AssetNotFound { position: 1 });\n\n            // This triggers an error, no matching funds were found\n            let err = remove_assets_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                Some(0),\n                vec![(\n                    0,\n                    AssetInfo::Cw721Coin(Cw721Coin {\n                        address: \"nft-1\".to_string(),\n                        token_id: \"58\".to_string(),\n                    }),\n                )],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::AssetNotFound { position: 0 });\n\n            // This triggers an error, no matching funds were found\n            let err = remove_assets_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                Some(0),\n                vec![(\n                    0,\n                    AssetInfo::Cw721Coin(Cw721Coin {\n                        address: \"nft-2\".to_string(),\n                        token_id: \"42\".to_string(),\n                    }),\n                )],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::AssetNotFound { position: 0 });\n        }\n\n        #[test]\n        fn create_trade_add_remove_tokens_errors() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n\n            add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                0,\n                AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft\".to_string(),\n                    token_id: \"58\".to_string(),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                0,\n                AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft-2\".to_string(),\n                    token_id: \"58\".to_string(),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                0,\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    address: \"token\".to_string(),\n                    amount: Uint128::new(100u128),\n                }),\n                \u0026[],\n            )\n            .unwrap();\n\n            add_asset_to_counter_trade_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                0,\n                AssetInfo::Coin(coin(100, \"luna\")),\n                \u0026coins(100, \"luna\"),\n            )\n            .unwrap();\n\n            let err = remove_assets_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                Some(0),\n                vec![(\n                    2,\n                    AssetInfo::Cw20Coin(Cw20Coin {\n                        address: \"token\".to_string(),\n                        amount: Uint128::from(101u64),\n                    }),\n                )],\n            )\n            .unwrap_err();\n\n            assert_eq!(\n                err,\n                ContractError::TooMuchWithdrawn {\n                    address: \"token\".to_string(),\n                    wanted: 101,\n                    available: 100\n                }\n            );\n\n            let err = remove_assets_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                Some(0),\n                vec![(\n                    0,\n                    AssetInfo::Cw20Coin(Cw20Coin {\n                        address: \"token\".to_string(),\n                        amount: Uint128::from(101u64),\n                    }),\n                )],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::AssetNotFound { position: 0 });\n\n            let err = remove_assets_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                Some(0),\n                vec![(\n                    2,\n                    AssetInfo::Cw20Coin(Cw20Coin {\n                        address: \"wrong-token\".to_string(),\n                        amount: Uint128::from(101u64),\n                    }),\n                )],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::AssetNotFound { position: 2 });\n\n            confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap();\n\n            let err = remove_assets_helper(\n                deps.as_mut(),\n                \"counterer\",\n                0,\n                Some(0),\n                vec![(\n                    2,\n                    AssetInfo::Cw20Coin(Cw20Coin {\n                        address: \"token\".to_string(),\n                        amount: Uint128::from(58u64),\n                    }),\n                )],\n            )\n            .unwrap_err();\n\n            assert_eq!(err, ContractError::CounterTradeAlreadyPublished {});\n        }\n\n        #[test]\n        fn confirm_counter_trade() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n\n            //Wrong trade id\n            let err = confirm_counter_trade_helper(deps.as_mut(), \"creator\", 1, 0).unwrap_err();\n            assert_eq!(err, ContractError::NotFoundInCounterTradeInfo {});\n\n            //Wrong counter id\n            let err = confirm_counter_trade_helper(deps.as_mut(), \"creator\", 0, 1).unwrap_err();\n            assert_eq!(err, ContractError::NotFoundInCounterTradeInfo {});\n\n            //Wrong trader\n            let err = confirm_counter_trade_helper(deps.as_mut(), \"bad_person\", 0, 0).unwrap_err();\n            assert_eq!(err, ContractError::CounterTraderNotCreator {});\n\n            // This time, it has to work fine\n            let res = confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap();\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"confirm_counter_trade\"),\n                    Attribute::new(\"trade\", \"0\"),\n                    Attribute::new(\"counter\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                    Attribute::new(\"counter_trader\", \"counterer\"),\n                ]\n            );\n\n            //Already confirmed\n            let err = confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap_err();\n            assert_eq!(\n                err,\n                ContractError::CantChangeCounterTradeState {\n                    from: TradeState::Published,\n                    to: TradeState::Published\n                }\n            );\n        }\n\n        #[test]\n        fn review_counter_trade() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n\n            //Wrong trade id\n            let err = review_counter_trade_helper(deps.as_mut(), \"creator\", 1, 0).unwrap_err();\n            assert_eq!(err, ContractError::NotFoundInTradeInfo {});\n\n            //Wrong counter id\n            let err = review_counter_trade_helper(deps.as_mut(), \"creator\", 0, 1).unwrap_err();\n            assert_eq!(err, ContractError::NotFoundInCounterTradeInfo {});\n\n            //Wrong trader\n            let err = review_counter_trade_helper(deps.as_mut(), \"bad_person\", 0, 0).unwrap_err();\n            assert_eq!(err, ContractError::TraderNotCreator {});\n\n            let err = review_counter_trade_helper(deps.as_mut(), \"creator\", 0, 0).unwrap_err();\n            assert_eq!(\n                err,\n                ContractError::CantChangeCounterTradeState {\n                    from: TradeState::Created,\n                    to: TradeState::Created\n                }\n            );\n\n            confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap();\n\n            // This time, it has to work fine\n            let res = review_counter_trade_helper(deps.as_mut(), \"creator\", 0, 0).unwrap();\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"review_counter_trade\"),\n                    Attribute::new(\"trade_id\", \"0\"),\n                    Attribute::new(\"counter_id\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                    Attribute::new(\"counter_trader\", \"counterer\"),\n                ]\n            );\n\n            // Because this was the only counter\n            let new_trade_info = load_trade(\u0026deps.storage, 0).unwrap();\n            assert_eq!(new_trade_info.state, TradeState::Countered {});\n        }\n\n        #[test]\n        fn review_counter_trade_when_accepted() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n            confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap();\n            accept_trade_helper(deps.as_mut(), \"creator\", 0, 0).unwrap();\n\n            let err = review_counter_trade_helper(deps.as_mut(), \"creator\", 0, 0).unwrap_err();\n            assert_eq!(err, ContractError::TradeAlreadyAccepted {});\n        }\n\n        #[test]\n        fn review_counter_trade_when_cancelled() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n            confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap();\n            cancel_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n\n            let err = review_counter_trade_helper(deps.as_mut(), \"creator\", 0, 0).unwrap_err();\n            assert_eq!(err, ContractError::TradeCancelled {});\n        }\n\n        #[test]\n        fn review_counter_with_multiple() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n            confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap();\n            // We suggest and confirm one more counter\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n            confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 1).unwrap();\n\n            // This time, it has to work fine\n            let res = review_counter_trade_helper(deps.as_mut(), \"creator\", 0, 0).unwrap();\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"review_counter_trade\"),\n                    Attribute::new(\"trade_id\", \"0\"),\n                    Attribute::new(\"counter_id\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                    Attribute::new(\"counter_trader\", \"counterer\"),\n                ]\n            );\n\n            let new_trade_info = load_trade(\u0026deps.storage, 0).unwrap();\n            assert_eq!(new_trade_info.state, TradeState::Countered {});\n        }\n\n        #[test]\n        fn refuse_counter_trade() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n            let res = refuse_counter_trade_helper(deps.as_mut(), \"creator\", 0, 0).unwrap();\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"refuse_counter_trade\"),\n                    Attribute::new(\"trade_id\", \"0\"),\n                    Attribute::new(\"counter_id\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                    Attribute::new(\"counter_trader\", \"counterer\"),\n                ]\n            );\n        }\n\n        #[test]\n        fn cancel_counter_trade() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n            confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap();\n            cancel_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap();\n\n            let err = accept_trade_helper(deps.as_mut(), \"creator\", 0, 0).unwrap_err();\n\n            assert_eq!(err, ContractError::CantAcceptNotPublishedCounter {});\n        }\n\n        #[test]\n        fn refuse_counter_trade_with_multiple() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n            // We suggest and confirm one more counter\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n            confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap();\n            // We suggest one more counter\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n\n            let res = refuse_counter_trade_helper(deps.as_mut(), \"creator\", 0, 0).unwrap();\n            assert_eq!(\n                res.attributes,\n                vec![\n                    Attribute::new(\"action\", \"refuse_counter_trade\"),\n                    Attribute::new(\"trade_id\", \"0\"),\n                    Attribute::new(\"counter_id\", \"0\"),\n                    Attribute::new(\"trader\", \"creator\"),\n                    Attribute::new(\"counter_trader\", \"counterer\"),\n                ]\n            );\n        }\n\n        #[test]\n        fn refuse_accepted_counter_trade() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n\n            confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap();\n            accept_trade_helper(deps.as_mut(), \"creator\", 0, 0).unwrap();\n            let err = refuse_counter_trade_helper(deps.as_mut(), \"creator\", 0, 0).unwrap_err();\n            assert_eq!(err, ContractError::TradeAlreadyAccepted {});\n        }\n\n        #[test]\n        fn cancel_accepted_counter_trade() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n\n            confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap();\n            accept_trade_helper(deps.as_mut(), \"creator\", 0, 0).unwrap();\n            let err = cancel_trade_helper(deps.as_mut(), \"creator\", 0).unwrap_err();\n            assert_eq!(\n                err,\n                ContractError::CantChangeTradeState {\n                    from: TradeState::Accepted,\n                    to: TradeState::Cancelled\n                }\n            );\n        }\n\n        #[test]\n        fn confirm_counter_trade_after_accepted() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n            confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap();\n            accept_trade_helper(deps.as_mut(), \"creator\", 0, 0).unwrap();\n\n            //Already confirmed\n            let err = confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap_err();\n            assert_eq!(\n                err,\n                ContractError::CantChangeCounterTradeState {\n                    from: TradeState::Accepted,\n                    to: TradeState::Published\n                }\n            );\n        }\n\n        #[test]\n        fn query_trades_by_counterer() {\n            let mut deps = mock_dependencies();\n            init_helper(deps.as_mut());\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 0).unwrap();\n\n            // When no counter_trades\n            let env = mock_env();\n            let res: AllTradesResponse = from_binary(\n                \u0026query(\n                    deps.as_ref(),\n                    env,\n                    QueryMsg::GetAllTrades {\n                        start_after: None,\n                        limit: None,\n                        filters: Some(QueryFilters {\n                            counterer: Some(\"counterer\".to_string()),\n                            ..QueryFilters::default()\n                        }),\n                    },\n                )\n                .unwrap(),\n            )\n            .unwrap();\n\n            assert_eq!(res.trades, vec![]);\n\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 0).unwrap();\n            confirm_counter_trade_helper(deps.as_mut(), \"counterer\", 0, 0).unwrap();\n            accept_trade_helper(deps.as_mut(), \"creator\", 0, 0).unwrap();\n\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 1).unwrap();\n            create_trade_helper(deps.as_mut(), \"creator\");\n            confirm_trade_helper(deps.as_mut(), \"creator\", 2).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"bad_person\", 1).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"bad_person\", 1).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"bad_person\", 1).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"bad_person\", 1).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"bad_person\", 1).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"bad_person\", 1).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"bad_person\", 1).unwrap();\n            suggest_counter_trade_helper(deps.as_mut(), \"bad_person\", 1).unwrap();\n\n            suggest_counter_trade_helper(deps.as_mut(), \"counterer\", 2).unwrap();\n\n            let env = mock_env();\n            let res: AllTradesResponse = from_binary(\n                \u0026query(\n                    deps.as_ref(),\n                    env,\n                    QueryMsg::GetAllTrades {\n                        start_after: None,\n                        limit: None,\n                        filters: Some(QueryFilters {\n                            counterer: Some(\"counterer\".to_string()),\n                            ..QueryFilters::default()\n                        }),\n                    },\n                )\n                .unwrap(),\n            )\n            .unwrap();\n\n            let env = mock_env();\n            assert_eq!(\n                res.trades,\n                vec![\n                    {\n                        TradeResponse {\n                            trade_id: 2,\n                            counter_id: None,\n                            trade_info: Some(TradeInfo {\n                                owner: deps.api.addr_validate(\"creator\").unwrap(),\n                                last_counter_id: Some(0),\n                                state: TradeState::Countered,\n                                additionnal_info: AdditionnalTradeInfo {\n                                    owner_comment: Some(Comment {\n                                        comment: \"Q\".to_string(),\n                                        time: env.block.time,\n                                    }),\n                                    time: env.block.time,\n                                    ..Default::default()\n                                },\n                                ..Default::default()\n                            }),\n                        }\n                    },\n                    {\n                        TradeResponse {\n                            trade_id: 0,\n                            counter_id: None,\n                            trade_info: Some(TradeInfo {\n                                owner: deps.api.addr_validate(\"creator\").unwrap(),\n                                last_counter_id: Some(3),\n                                state: TradeState::Accepted,\n                                accepted_info: Some(CounterTradeInfo {\n                                    trade_id: 0,\n                                    counter_id: 0,\n                                }),\n                                additionnal_info: AdditionnalTradeInfo {\n                                    owner_comment: Some(Comment {\n                                        comment: \"Q\".to_string(),\n                                        time: env.block.time,\n                                    }),\n                                    time: env.block.time,\n                                    ..Default::default()\n                                },\n                                ..Default::default()\n                            }),\n                        }\n                    }\n                ]\n            );\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","p2p-trading","src","counter_trade.rs"],"content":"use cosmwasm_std::{Addr, Deps, DepsMut, Env, MessageInfo, Response};\n\nuse p2p_trading_export::msg::QueryFilters;\nuse p2p_trading_export::state::{AdditionnalTradeInfo, AssetInfo, TradeInfo, TradeState};\n\nuse crate::error::ContractError;\nuse crate::messages::set_comment;\nuse crate::query::query_counter_trades;\nuse crate::state::{\n    add_cw1155_coin, add_cw20_coin, add_cw721_coin, add_funds, can_suggest_counter_trade,\n    is_counter_trader, load_trade, COUNTER_TRADE_INFO, TRADE_INFO,\n};\nuse crate::trade::{\n    _are_assets_in_trade, _create_receive_asset_messages, _create_withdraw_messages_unsafe,\n    _try_withdraw_assets_unsafe, check_and_create_withdraw_messages,\n};\n\n/// Query the last counter_trade created by the owner for the `trade_id`\n/// This should only be used in the same transaction as the counter_trade creation.\n/// Otherwise, specify the counter_id directly in the transaction and this is not needed\npub fn get_last_counter_id_created(\n    deps: Deps,\n    by: String,\n    trade_id: u64,\n) -\u003e Result\u003cu64, ContractError\u003e {\n    let counter_trade = \u0026query_counter_trades(\n        deps,\n        trade_id,\n        None,\n        Some(1),\n        Some(QueryFilters {\n            owner: Some(by),\n            ..QueryFilters::default()\n        }),\n    )?\n    .counter_trades[0];\n    Ok(counter_trade.counter_id.unwrap())\n}\n\n/// Create a new counter_trade and assign it a unique id for the specified `trade_id`\npub fn suggest_counter_trade(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    trade_id: u64,\n    comment: Option\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // We start by verifying it is possible to suggest a counter trade to that trade\n    // It also checks if the trade exists\n    // And that the sender is whitelisted (in case the trade is private)\n    let mut trade_info = can_suggest_counter_trade(deps.storage, trade_id, \u0026info.sender)?;\n\n    // We start by creating a new trade_id (simply incremented from the last id)\n    trade_info.last_counter_id = trade_info\n        .last_counter_id\n        .map_or(Some(0), |id| Some(id + 1));\n    if trade_info.state == TradeState::Published {\n        trade_info.state = TradeState::Countered;\n    }\n    TRADE_INFO.save(deps.storage, trade_id, \u0026trade_info)?;\n\n    let counter_id = trade_info.last_counter_id.unwrap(); // This is safe, as we just created a ast_counter_id` if it didn't exist.\n\n    COUNTER_TRADE_INFO.update(\n        deps.storage,\n        (trade_id, counter_id),\n        |counter| match counter {\n            // If the trade id already exists, the contract is faulty\n            // Or an external error happened, or whatever...\n            // In that case, we emit an error\n            // The priority is : We do not want to overwrite existing data\n            Some(_) =\u003e Err(ContractError::ExistsInCounterTradeInfo {}),\n            None =\u003e Ok(TradeInfo {\n                owner: info.sender.clone(),\n                additionnal_info: AdditionnalTradeInfo {\n                    time: env.block.time,\n                    ..Default::default()\n                },\n                ..Default::default()\n            }),\n        },\n    )?;\n    if let Some(comment) = comment {\n        set_comment(deps, env, info.clone(), trade_id, Some(counter_id), comment)?;\n    }\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"create_counter_trade\")\n        .add_attribute(\"trade_id\", trade_id.to_string())\n        .add_attribute(\"counter_id\", counter_id.to_string())\n        .add_attribute(\"trader\", trade_info.owner)\n        .add_attribute(\"counter_trader\", info.sender))\n}\n\npub fn counter_id_or_last(\n    deps: Deps,\n    trader: Addr,\n    trade_id: u64,\n    counter_id: Option\u003cu64\u003e,\n) -\u003e Result\u003cu64, ContractError\u003e {\n    match counter_id {\n        Some(counter_id) =\u003e Ok(counter_id),\n        None =\u003e get_last_counter_id_created(deps, trader.to_string(), trade_id),\n    }\n}\n\n/// We prepare the info before asset addition\n/// 1. If the trade_id is not specified, we get the last trade_id created by the sender\n/// 2. We verify the trade can be modified\npub fn prepare_counter_modification(\n    deps: Deps,\n    trader: Addr,\n    trade_id: u64,\n    counter_id: Option\u003cu64\u003e,\n) -\u003e Result\u003cu64, ContractError\u003e {\n    let counter_id = counter_id_or_last(deps, trader.clone(), trade_id, counter_id)?;\n\n    let counter_info = is_counter_trader(deps.storage, \u0026trader, trade_id, counter_id)?;\n\n    if counter_info.state != TradeState::Created {\n        return Err(ContractError::WrongTradeState {\n            state: counter_info.state,\n        });\n    }\n    Ok(counter_id)\n}\n\npub fn add_asset_to_counter_trade(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    trade_id: u64,\n    counter_id: Option\u003cu64\u003e,\n    asset: AssetInfo,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let counter_id =\n        prepare_counter_modification(deps.as_ref(), info.sender.clone(), trade_id, counter_id)?;\n\n    match asset.clone() {\n        AssetInfo::Coin(coin) =\u003e COUNTER_TRADE_INFO.update(\n            deps.storage,\n            (trade_id, counter_id),\n            add_funds(coin, info.funds.clone()),\n        ),\n        AssetInfo::Cw20Coin(token) =\u003e COUNTER_TRADE_INFO.update(\n            deps.storage,\n            (trade_id, counter_id),\n            add_cw20_coin(token.address.clone(), token.amount),\n        ),\n        AssetInfo::Cw721Coin(token) =\u003e COUNTER_TRADE_INFO.update(\n            deps.storage,\n            (trade_id, counter_id),\n            add_cw721_coin(token.address.clone(), token.token_id),\n        ),\n        AssetInfo::Cw1155Coin(token) =\u003e COUNTER_TRADE_INFO.update(\n            deps.storage,\n            (trade_id, counter_id),\n            add_cw1155_coin(token.address.clone(), token.token_id.clone(), token.value),\n        ),\n    }?;\n\n    // We load the trade_info for events\n    let trade_info = load_trade(deps.storage, trade_id)?;\n\n    // Now we need to transfer the token\n    Ok(_create_receive_asset_messages(env, info.clone(), asset)?\n        .add_attribute(\"trade_id\", trade_id.to_string())\n        .add_attribute(\"counter_id\", counter_id.to_string())\n        .add_attribute(\"trader\", trade_info.owner)\n        .add_attribute(\"counter_trader\", info.sender))\n}\n\n/// Allows to withdraw assets while creating a counter_trade, Refer to the `trade.rs`file for more information (similar mecanism)\npub fn withdraw_counter_trade_assets_while_creating(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    trade_id: u64,\n    counter_id: u64,\n    assets: Vec\u003c(u16, AssetInfo)\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut counter_info = is_counter_trader(deps.storage, \u0026info.sender, trade_id, counter_id)?;\n    if counter_info.state != TradeState::Created {\n        return Err(ContractError::CounterTradeAlreadyPublished {});\n    }\n    _are_assets_in_trade(\u0026counter_info, \u0026assets)?;\n\n    _try_withdraw_assets_unsafe(\u0026mut counter_info, \u0026assets)?;\n    COUNTER_TRADE_INFO.save(deps.storage, (trade_id, counter_id), \u0026counter_info)?;\n\n    let res = _create_withdraw_messages_unsafe(\n        \u0026env.contract.address,\n        \u0026info.sender,\n        \u0026assets.iter().map(|x| x.1.clone()).collect(),\n    )?;\n    // We load the trade_info for events\n    let trade_info = load_trade(deps.storage, trade_id)?;\n    Ok(res\n        .add_attribute(\"action\", \"remove_from_counter_trade\")\n        .add_attribute(\"trade\", trade_id.to_string())\n        .add_attribute(\"counter\", counter_id.to_string())\n        .add_attribute(\"trader\", trade_info.owner)\n        .add_attribute(\"counter_trader\", info.sender))\n}\n\n/// Confirm (and publish) a counter_trade when creation is finished\npub fn confirm_counter_trade(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    trade_id: u64,\n    counter_id: Option\u003cu64\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // We check the counter exists and belongs to the sender\n    let counter_id = counter_id_or_last(deps.as_ref(), info.sender.clone(), trade_id, counter_id)?;\n    let mut counter_info = is_counter_trader(deps.storage, \u0026info.sender, trade_id, counter_id)?;\n\n    // We check the counter can be confirmed\n    if counter_info.state != TradeState::Created {\n        return Err(ContractError::CantChangeCounterTradeState {\n            from: counter_info.state,\n            to: TradeState::Published,\n        });\n    }\n    // We confirm the counter_trade\n    counter_info.state = TradeState::Published;\n    COUNTER_TRADE_INFO.save(deps.storage, (trade_id, counter_id), \u0026counter_info)?;\n\n    // We load the trade_info for events\n    let trade_info = load_trade(deps.storage, trade_id)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"confirm_counter_trade\")\n        .add_attribute(\"trade\", trade_id.to_string())\n        .add_attribute(\"counter\", counter_id.to_string())\n        .add_attribute(\"trader\", trade_info.owner)\n        .add_attribute(\"counter_trader\", info.sender))\n}\n\n/// Cancel a counter_trade\n/// The counter_trade isn't modifiable, but the funds are withdrawnable after this call.\npub fn cancel_counter_trade(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    trade_id: u64,\n    counter_id: u64,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // Only the initial trader can cancel the trade\n    let mut counter_info = is_counter_trader(deps.storage, \u0026info.sender, trade_id, counter_id)?;\n\n    // We can't cancel an accepted counter_trade\n    if counter_info.state == TradeState::Accepted {\n        return Err(ContractError::CantChangeCounterTradeState {\n            from: counter_info.state,\n            to: TradeState::Cancelled,\n        });\n    }\n    counter_info.state = TradeState::Cancelled;\n\n    // We store the new trade status\n    COUNTER_TRADE_INFO.save(deps.storage, (trade_id, counter_id), \u0026counter_info)?;\n\n    // We load the trade_info for events\n    let trade_info = load_trade(deps.storage, trade_id)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"cancel_counter_trade\")\n        .add_attribute(\"trade\", trade_id.to_string())\n        .add_attribute(\"counter\", counter_id.to_string())\n        .add_attribute(\"trader\", trade_info.owner)\n        .add_attribute(\"counter_trader\", info.sender))\n}\n\n/// Withdraw all assets from a created (not published yet), refused or cancelled counter_trade\n/// If the counter_trade is only in the created state, it is automatically cancelled before withdrawing assets\npub fn withdraw_all_from_counter(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    trade_id: u64,\n    counter_id: u64,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut counter_info = is_counter_trader(deps.storage, \u0026info.sender, trade_id, counter_id)?;\n\n    // If the counter is still in the created state, we cancel it\n    if counter_info.state == TradeState::Created {\n        counter_info.state = TradeState::Cancelled;\n    }\n\n    // This fuction call is possible only if the counter was refused or if this counter was cancelled\n    if !(counter_info.state == TradeState::Refused || counter_info.state == TradeState::Cancelled) {\n        return Err(ContractError::CounterTradeNotAborted {});\n    }\n\n    // We create withdraw messages to send the funds back to the counter trader\n    let res = check_and_create_withdraw_messages(env, \u0026info.sender, \u0026counter_info)?;\n    counter_info.assets_withdrawn = true;\n    COUNTER_TRADE_INFO.save(deps.storage, (trade_id, counter_id), \u0026counter_info)?;\n\n    // We load the trade_info for events\n    let trade_info = load_trade(deps.storage, trade_id)?;\n\n    Ok(res\n        .add_attribute(\"action\", \"withdraw_all_funds\")\n        .add_attribute(\"type\", \"counter_trade\")\n        .add_attribute(\"trade\", trade_id.to_string())\n        .add_attribute(\"counter\", counter_id.to_string())\n        .add_attribute(\"trader\", trade_info.owner)\n        .add_attribute(\"counter_trader\", counter_info.owner))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","p2p-trading","src","error.rs"],"content":"use cosmwasm_std::StdError;\nuse p2p_trading_export::state::TradeState;\nuse thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized {},\n\n    #[error(\"An unplanned bug just happened :/\")]\n    ContractBug {},\n\n    #[error(\"Key already exists in TradeInfo\")]\n    ExistsInTradeInfo {},\n\n    #[error(\"Key does not exist in TradeInfo\")]\n    NotFoundInTradeInfo {},\n\n    #[error(\n        \"The trade_id field should be present when modifying the last counter_trade submitted\"\n    )]\n    TradeIdMissing {},\n\n    #[error(\"Trader not creator of the trade\")]\n    TraderNotCreator {},\n\n    #[error(\"Key already exists in CounterTradeInfo\")]\n    ExistsInCounterTradeInfo {},\n\n    #[error(\"Key does not exist in CounterTradeInfo\")]\n    NotFoundInCounterTradeInfo {},\n\n    #[error(\"Trader not creator of the CounterTrade\")]\n    CounterTraderNotCreator {},\n\n    #[error(\"Trade cannot be countered, it is not ready or is already cancelled/terminated\")]\n    NotCounterable {},\n\n    #[error(\"Wrong state of the trade for the current operation : {state:?}\")]\n    WrongTradeState { state: TradeState },\n\n    #[error(\"Can change the state of the trade from {from:?} to {to:?}\")]\n    CantChangeTradeState { from: TradeState, to: TradeState },\n\n    #[error(\"Sorry, you can't accept a counter trade that is not published yet\")]\n    TradeAlreadyAccepted {},\n\n    #[error(\"Sorry, the trade is published, you can't modify it. You can cancel it if you're not satisfied\")]\n    TradeAlreadyPublished {},\n\n    #[error(\"Sorry, this trade is not accepted yet\")]\n    TradeNotAccepted {},\n\n    #[error(\"Sorry, this trade is cancelled\")]\n    TradeCancelled {},\n\n    #[error(\"Sorry, this trade is not cancelled\")]\n    TradeNotCancelled {},\n\n    #[error(\"Assets were already withdrawn, don't try to scam the platform please\")]\n    TradeAlreadyWithdrawn {},\n\n    #[error(\"Can change the state of the counter-trade from {from:?} to {to:?}\")]\n    CantChangeCounterTradeState { from: TradeState, to: TradeState },\n\n    #[error(\"Sorry, you can't accept a counter trade that is not published yet\")]\n    CantAcceptNotPublishedCounter {},\n\n    #[error(\"Sorry, the counter trade is published, you can't modify it. You can cancel it if you're not satisfied\")]\n    CounterTradeAlreadyPublished {},\n\n    #[error(\"Sorry, the trade has to be refused or cancelled to withdraw your funds\")]\n    CounterTradeNotAborted {},\n\n    #[error(\"Only the trader or the counter-trader can withdraw assets, don't try to scam the platform please\")]\n    NotWithdrawableByYou {},\n\n    #[error(\"This trade is only allowed to a selected few, sorry :/\")]\n    AddressNotWhitelisted {},\n\n    #[error(\n        \"Asset not found in your trade (wrong position or wrong asset specified or wrong token_id)\"\n    )]\n    AssetNotFound { position: usize },\n\n    #[error(\"Asset found in your trade but you are trying to withdraw too much. address: {address:?}, wanted: {wanted:?}, available {available:?}\")]\n    TooMuchWithdrawn {\n        address: String,\n        wanted: u128,\n        available: u128,\n    },\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","p2p-trading","src","lib.rs"],"content":"pub mod contract;\npub mod counter_trade;\nmod error;\npub mod messages;\npub mod query;\npub mod state;\npub mod trade;\n\npub use crate::error::ContractError;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","p2p-trading","src","messages.rs"],"content":"use crate::error::ContractError;\nuse crate::state::{\n    is_counter_trader, is_trader, load_counter_trade, COUNTER_TRADE_INFO, TRADE_INFO,\n};\nuse cosmwasm_std::{DepsMut, Env, MessageInfo, Response};\nuse p2p_trading_export::state::{Comment, TradeState};\n\npub fn review_counter_trade(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    trade_id: u64,\n    counter_id: u64,\n    comment: Option\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // Only the initial trader can cancel the trade !\n    let trade_info = is_trader(deps.storage, \u0026info.sender, trade_id)?;\n\n    // We check the counter trade exists !\n    let mut counter_info = load_counter_trade(deps.storage, trade_id, counter_id)?;\n\n    if trade_info.state == TradeState::Accepted {\n        return Err(ContractError::TradeAlreadyAccepted {});\n    }\n    if trade_info.state == TradeState::Cancelled {\n        return Err(ContractError::TradeCancelled {});\n    }\n\n    // Only a published counter trade can be reviewed\n    if counter_info.state != TradeState::Published {\n        return Err(ContractError::CantChangeCounterTradeState {\n            from: counter_info.state,\n            to: TradeState::Created,\n        });\n    }\n\n    counter_info.state = TradeState::Created;\n    counter_info.additionnal_info.trader_comment = comment.map(|comment| Comment {\n        time: env.block.time,\n        comment,\n    });\n\n    // Then we need to change the trade status that we may have changed\n    TRADE_INFO.save(deps.storage, trade_id, \u0026trade_info)?;\n    COUNTER_TRADE_INFO.save(deps.storage, (trade_id, counter_id), \u0026counter_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"review_counter_trade\")\n        .add_attribute(\"trade_id\", trade_id.to_string())\n        .add_attribute(\"counter_id\", counter_id.to_string())\n        .add_attribute(\"trader\", trade_info.owner)\n        .add_attribute(\"counter_trader\", counter_info.owner))\n}\n\npub fn set_comment(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    trade_id: u64,\n    counter_id: Option\u003cu64\u003e,\n    comment: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let comment = Comment {\n        time: env.block.time,\n        comment,\n    };\n\n    if let Some(counter_id) = counter_id {\n        let mut counter_info = is_counter_trader(deps.storage, \u0026info.sender, trade_id, counter_id)?;\n        counter_info.additionnal_info.owner_comment = Some(comment);\n        COUNTER_TRADE_INFO.save(deps.storage, (trade_id, counter_id), \u0026counter_info)?;\n    } else {\n        let mut trade_info = is_trader(deps.storage, \u0026info.sender, trade_id)?;\n        trade_info.additionnal_info.owner_comment = Some(comment);\n        TRADE_INFO.save(deps.storage, trade_id, \u0026trade_info)?;\n    }\n    let partial_res = Response::new()\n        .add_attribute(\"action\", \"set_comment\")\n        .add_attribute(\"trade\", trade_id.to_string());\n\n    if let Some(counter_id) = counter_id {\n        Ok(partial_res.add_attribute(\"counter\", counter_id.to_string()))\n    } else {\n        Ok(partial_res)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","p2p-trading","src","query.rs"],"content":"use cosmwasm_std::Api;\n#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::{Deps, Order, StdResult, Storage};\n\nuse cw_storage_plus::Bound;\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse crate::state::{get_actual_counter_state, CONTRACT_INFO, COUNTER_TRADE_INFO, TRADE_INFO};\nuse p2p_trading_export::msg::QueryFilters;\nuse p2p_trading_export::state::{AssetInfo, ContractInfo, CounterTradeInfo, TradeInfo};\n\nuse itertools::Itertools;\n// settings for pagination\nconst MAX_LIMIT: u32 = 30;\nconst DEFAULT_LIMIT: u32 = 10;\nconst BASE_LIMIT: usize = 100;\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug, Default)]\npub struct TradeResponse {\n    pub trade_id: u64,\n    pub counter_id: Option\u003cu64\u003e,\n    pub trade_info: Option\u003cTradeInfo\u003e,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug, Default)]\npub struct AllTradesResponse {\n    pub trades: Vec\u003cTradeResponse\u003e,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug, Default)]\npub struct AllCounterTradesResponse {\n    pub counter_trades: Vec\u003cTradeResponse\u003e,\n}\n\npub fn query_contract_info(deps: Deps) -\u003e StdResult\u003cContractInfo\u003e {\n    CONTRACT_INFO.load(deps.storage)\n}\n\n// parse trades to human readable format\nfn parse_trades(_: \u0026dyn Api, item: StdResult\u003c(u64, TradeInfo)\u003e) -\u003e StdResult\u003cTradeResponse\u003e {\n    item.map(|(trade_id, trade)| TradeResponse {\n        trade_id,\n        counter_id: None,\n        trade_info: Some(trade),\n    })\n}\n\n// parse counter trades to human readable format\nfn parse_all_counter_trades(\n    _: \u0026dyn Api,\n    storage: \u0026dyn Storage,\n    item: StdResult\u003c((u64, u64), TradeInfo)\u003e,\n) -\u003e StdResult\u003cTradeResponse\u003e {\n    item.map(|((trade_id, counter_id), mut counter)| {\n        // First two bytes define size [0,8] since we know it's u64 skip it.\n        get_actual_counter_state(storage, trade_id, \u0026mut counter)?;\n        Ok(TradeResponse {\n            trade_id,\n            counter_id: Some(counter_id),\n            trade_info: Some(counter),\n        })\n    })?\n}\n\n// parse counter trades to human readable format\nfn parse_counter_trades(\n    _: \u0026dyn Api,\n    storage: \u0026dyn Storage,\n    item: StdResult\u003c(u64, TradeInfo)\u003e,\n    trade_id: u64,\n) -\u003e StdResult\u003cTradeResponse\u003e {\n    item.map(|(counter_id, mut counter)| {\n        get_actual_counter_state(storage, trade_id, \u0026mut counter)?;\n        Ok(TradeResponse {\n            trade_id,\n            counter_id: Some(counter_id),\n            trade_info: Some(counter),\n        })\n    })?\n}\n\npub fn trade_filter(\n    api: \u0026dyn Api,\n    trade_info: \u0026StdResult\u003cTradeResponse\u003e,\n    filters: \u0026Option\u003cQueryFilters\u003e,\n) -\u003e bool {\n    if let Some(filters) = filters {\n        let trade = trade_info.as_ref().unwrap();\n\n        (match \u0026filters.states {\n            Some(state) =\u003e state.contains(\u0026trade.trade_info.as_ref().unwrap().state.to_string()),\n            None =\u003e true,\n        } \u0026\u0026 match \u0026filters.owner {\n            Some(owner) =\u003e trade.trade_info.as_ref().unwrap().owner == owner.clone(),\n            None =\u003e true,\n        } \u0026\u0026 match \u0026filters.has_whitelist {\n            Some(has_whitelist) =\u003e {\n                \u0026trade\n                    .trade_info\n                    .as_ref()\n                    .unwrap()\n                    .whitelisted_users\n                    .is_empty()\n                    != has_whitelist\n            }\n            None =\u003e true,\n        } \u0026\u0026 match \u0026filters.whitelisted_user {\n            Some(whitelisted_user) =\u003e trade\n                .trade_info\n                .as_ref()\n                .unwrap()\n                .whitelisted_users\n                .contains(\u0026api.addr_validate(whitelisted_user).unwrap()),\n            None =\u003e true,\n        } \u0026\u0026 match \u0026filters.wanted_nft {\n            Some(wanted_nft) =\u003e trade\n                .trade_info\n                .as_ref()\n                .unwrap()\n                .additionnal_info\n                .nfts_wanted\n                .contains(\u0026api.addr_validate(wanted_nft).unwrap()),\n            None =\u003e true,\n        } \u0026\u0026 match \u0026filters.contains_token {\n            Some(token) =\u003e trade\n                .trade_info\n                .as_ref()\n                .unwrap()\n                .associated_assets\n                .iter()\n                .any(|asset| match asset {\n                    AssetInfo::Coin(x) =\u003e x.denom == token.as_ref(),\n                    AssetInfo::Cw20Coin(x) =\u003e x.address == token.as_ref(),\n                    AssetInfo::Cw721Coin(x) =\u003e x.address == token.as_ref(),\n                    AssetInfo::Cw1155Coin(x) =\u003e x.address == token.as_ref(),\n                }),\n            None =\u003e true,\n        } \u0026\u0026 match \u0026filters.assets_withdrawn {\n            Some(assets_withdrawn) =\u003e {\n                trade.trade_info.clone().unwrap().assets_withdrawn == *assets_withdrawn\n            }\n            None =\u003e true,\n        })\n    } else {\n        true\n    }\n}\n\npub fn query_all_trades(\n    deps: Deps,\n    start_after: Option\u003cu64\u003e,\n    limit: Option\u003cu32\u003e,\n    filters: Option\u003cQueryFilters\u003e,\n) -\u003e StdResult\u003cAllTradesResponse\u003e {\n    if let Some(f) = filters.clone() {\n        if let Some(counterer) = f.counterer {\n            query_all_trades_by_counterer(deps, start_after, limit, counterer, filters)\n        } else {\n            query_all_trades_raw(deps, start_after, limit, filters)\n        }\n    } else {\n        query_all_trades_raw(deps, start_after, limit, filters)\n    }\n}\n\npub fn query_all_trades_raw(\n    deps: Deps,\n    start_after: Option\u003cu64\u003e,\n    limit: Option\u003cu32\u003e,\n    filters: Option\u003cQueryFilters\u003e,\n) -\u003e StdResult\u003cAllTradesResponse\u003e {\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n    let start = start_after.map(Bound::exclusive);\n\n    let mut trades: Vec\u003cTradeResponse\u003e = TRADE_INFO\n        .range(deps.storage, None, start.clone(), Order::Descending)\n        .take(BASE_LIMIT)\n        .map(|kv_item| parse_trades(deps.api, kv_item))\n        .filter(|response| trade_filter(deps.api, response, \u0026filters))\n        .take(limit)\n        .collect::\u003cStdResult\u003cVec\u003cTradeResponse\u003e\u003e\u003e()?;\n\n    if trades.is_empty() {\n        let trade_id = TRADE_INFO\n            .keys(deps.storage, None, start, Order::Descending)\n            .take(BASE_LIMIT)\n            .last();\n\n        if let Some(Ok(trade_id)) = trade_id {\n            if trade_id != 0 {\n                trades = vec![TradeResponse {\n                    trade_id,\n                    counter_id: None,\n                    trade_info: None,\n                }]\n            }\n        }\n    }\n    Ok(AllTradesResponse { trades })\n}\n\npub fn query_all_trades_by_counterer(\n    deps: Deps,\n    start_after: Option\u003cu64\u003e,\n    limit: Option\u003cu32\u003e,\n    counterer: String,\n    filters: Option\u003cQueryFilters\u003e,\n) -\u003e StdResult\u003cAllTradesResponse\u003e {\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n\n    let start = start_after.map(|s| Bound::exclusive((s, 0)));\n\n    let counter_filters = Some(QueryFilters {\n        owner: Some(counterer),\n        ..QueryFilters::default()\n    });\n\n    let mut trades: Vec\u003cTradeResponse\u003e = COUNTER_TRADE_INFO\n        .range(deps.storage, None, start.clone(), Order::Descending)\n        .take(BASE_LIMIT)\n        .map(|kv_item| parse_all_counter_trades(deps.api, deps.storage, kv_item))\n        .filter(|response| trade_filter(deps.api, response, \u0026counter_filters))\n        .filter_map(|response| response.ok())\n        // Now we get back the trade_id and query the trade_info\n        .map(|response| response.trade_id)\n        .unique()\n        .map(|trade_id| Ok((trade_id, TRADE_INFO.load(deps.storage, trade_id)?)))\n        .map(|kv_item| parse_trades(deps.api, kv_item))\n        .filter(|response| trade_filter(deps.api, response, \u0026filters))\n        .take(limit)\n        .collect::\u003cStdResult\u003cVec\u003cTradeResponse\u003e\u003e\u003e()?;\n\n    if trades.is_empty() {\n        let trade_info: Option\u003cTradeResponse\u003e = COUNTER_TRADE_INFO\n            .range(deps.storage, None, start, Order::Descending)\n            .take(BASE_LIMIT)\n            .map(|kv_item| parse_all_counter_trades(deps.api, deps.storage, kv_item))\n            .filter_map(|response| response.ok())\n            .map(|response| response.trade_id)\n            .unique()\n            .map(|trade_id| Ok((trade_id, TRADE_INFO.load(deps.storage, trade_id)?)))\n            .filter_map(|kv_item| parse_trades(deps.api, kv_item).ok())\n            .last();\n\n        if let Some(trade_info) = trade_info {\n            if trade_info.trade_id != 0 || trade_info.counter_id.unwrap() != 0 {\n                trades = vec![TradeResponse {\n                    trade_id: trade_info.trade_id,\n                    counter_id: trade_info.counter_id,\n                    trade_info: None,\n                }]\n            }\n        }\n    }\n\n    Ok(AllTradesResponse { trades })\n}\n\npub fn query_all_counter_trades(\n    deps: Deps,\n    start_after: Option\u003cCounterTradeInfo\u003e,\n    limit: Option\u003cu32\u003e,\n    filters: Option\u003cQueryFilters\u003e,\n) -\u003e StdResult\u003cAllCounterTradesResponse\u003e {\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n\n    let start = start_after.map(|s| Bound::exclusive((s.trade_id, s.counter_id)));\n\n    let mut counter_trades: Vec\u003cTradeResponse\u003e = COUNTER_TRADE_INFO\n        .range(deps.storage, None, start.clone(), Order::Descending)\n        .take(BASE_LIMIT)\n        .map(|kv_item| parse_all_counter_trades(deps.api, deps.storage, kv_item))\n        .filter(|response| trade_filter(deps.api, response, \u0026filters))\n        .take(limit)\n        .collect::\u003cStdResult\u003cVec\u003cTradeResponse\u003e\u003e\u003e()?;\n\n    if counter_trades.is_empty() {\n        let id = COUNTER_TRADE_INFO\n            .keys(deps.storage, None, start, Order::Descending)\n            .take(BASE_LIMIT)\n            .last();\n\n        if let Some(Ok((trade_id, counter_id))) = id {\n            if trade_id != 0 || counter_id != 0 {\n                counter_trades = vec![TradeResponse {\n                    trade_id,\n                    counter_id: Some(counter_id),\n                    trade_info: None,\n                }]\n            }\n        }\n    }\n\n    Ok(AllCounterTradesResponse { counter_trades })\n}\n\npub fn query_counter_trades(\n    deps: Deps,\n    trade_id: u64,\n    start_after: Option\u003cu64\u003e,\n    limit: Option\u003cu32\u003e,\n    filters: Option\u003cQueryFilters\u003e,\n) -\u003e StdResult\u003cAllCounterTradesResponse\u003e {\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n\n    let start = start_after.map(Bound::exclusive);\n\n    let mut counter_trades: Vec\u003cTradeResponse\u003e = COUNTER_TRADE_INFO\n        .prefix(trade_id)\n        .range(deps.storage, None, start.clone(), Order::Descending)\n        .take(BASE_LIMIT)\n        .map(|kv_item| parse_counter_trades(deps.api, deps.storage, kv_item, trade_id))\n        .filter(|response| trade_filter(deps.api, response, \u0026filters))\n        .take(limit)\n        .collect::\u003cStdResult\u003cVec\u003cTradeResponse\u003e\u003e\u003e()?;\n\n    if counter_trades.is_empty() {\n        let counter_id = COUNTER_TRADE_INFO\n            .prefix(trade_id)\n            .keys(deps.storage, None, start, Order::Descending)\n            .take(BASE_LIMIT)\n            .last();\n\n        if let Some(Ok(counter_id)) = counter_id {\n            if trade_id != 0 || counter_id != 0 {\n                counter_trades = vec![TradeResponse {\n                    trade_id,\n                    counter_id: Some(counter_id),\n                    trade_info: None,\n                }]\n            }\n        }\n    }\n\n    Ok(AllCounterTradesResponse { counter_trades })\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","p2p-trading","src","state.rs"],"content":"use cw_storage_plus::{Item, Map};\n\nuse cosmwasm_std::{Addr, Coin, StdError, StdResult, Storage, Uint128};\n\nuse crate::error::ContractError;\nuse p2p_trading_export::state::{\n    AssetInfo, ContractInfo, Cw1155Coin, Cw20Coin, Cw721Coin, TradeInfo, TradeState,\n};\n\npub const CONTRACT_INFO: Item\u003cContractInfo\u003e = Item::new(\"contract_info\");\n\npub const TRADE_INFO: Map\u003cu64, TradeInfo\u003e = Map::new(\"trade_info\");\n\npub const COUNTER_TRADE_INFO: Map\u003c(u64, u64), TradeInfo\u003e = Map::new(\"counter_trade_info\");\n\npub fn add_funds(\n    fund: Coin,\n    info_funds: Vec\u003cCoin\u003e,\n) -\u003e impl FnOnce(Option\u003cTradeInfo\u003e) -\u003e Result\u003cTradeInfo, ContractError\u003e {\n    move |d: Option\u003cTradeInfo\u003e| -\u003e Result\u003cTradeInfo, ContractError\u003e {\n        match d {\n            Some(mut trade) =\u003e {\n                // We check the sent funds are with the right format\n                if info_funds.len() != 1 || fund != info_funds[0] {\n                    return Err(ContractError::Std(StdError::generic_err(\n                        \"Funds sent do not match message AssetInfo\",\n                    )));\n                }\n                let existing_denom = trade.associated_assets.iter_mut().find(|c| match c {\n                    AssetInfo::Coin(x) =\u003e x.denom == fund.denom,\n                    _ =\u003e false,\n                });\n\n                if let Some(existing_fund) = existing_denom {\n                    let current_amount = match existing_fund {\n                        AssetInfo::Coin(x) =\u003e x.amount,\n                        _ =\u003e Uint128::zero(),\n                    };\n                    *existing_fund = AssetInfo::Coin(Coin {\n                        denom: fund.denom,\n                        amount: current_amount + fund.amount,\n                    });\n                } else {\n                    trade.associated_assets.push(AssetInfo::Coin(fund));\n                }\n                Ok(trade)\n            }\n            //TARPAULIN : Unreachable in current code state\n            None =\u003e Err(ContractError::NotFoundInTradeInfo {}),\n        }\n    }\n}\n\npub fn add_cw20_coin(\n    address: String,\n    sent_amount: Uint128,\n) -\u003e impl FnOnce(Option\u003cTradeInfo\u003e) -\u003e Result\u003cTradeInfo, ContractError\u003e {\n    move |d: Option\u003cTradeInfo\u003e| -\u003e Result\u003cTradeInfo, ContractError\u003e {\n        match d {\n            Some(mut trade) =\u003e {\n                let existing_token = trade.associated_assets.iter_mut().find(|c| match c {\n                    AssetInfo::Cw20Coin(x) =\u003e x.address == address,\n                    _ =\u003e false,\n                });\n                if let Some(existing_token) = existing_token {\n                    let current_amount = match existing_token {\n                        AssetInfo::Cw20Coin(x) =\u003e x.amount,\n                        _ =\u003e Uint128::zero(),\n                    };\n                    *existing_token = AssetInfo::Cw20Coin(Cw20Coin {\n                        address,\n                        amount: current_amount + sent_amount,\n                    })\n                } else {\n                    trade.associated_assets.push(AssetInfo::Cw20Coin(Cw20Coin {\n                        address,\n                        amount: sent_amount,\n                    }))\n                }\n\n                Ok(trade)\n            }\n            //TARPAULIN : Unreachable in current code state\n            None =\u003e Err(ContractError::NotFoundInTradeInfo {}),\n        }\n    }\n}\n\npub fn add_cw721_coin(\n    address: String,\n    token_id: String,\n) -\u003e impl FnOnce(Option\u003cTradeInfo\u003e) -\u003e Result\u003cTradeInfo, ContractError\u003e {\n    move |d: Option\u003cTradeInfo\u003e| -\u003e Result\u003cTradeInfo, ContractError\u003e {\n        match d {\n            Some(mut one) =\u003e {\n                one.associated_assets\n                    .push(AssetInfo::Cw721Coin(Cw721Coin { address, token_id }));\n                Ok(one)\n            }\n            //TARPAULIN : Unreachable in current code state\n            None =\u003e Err(ContractError::NotFoundInTradeInfo {}),\n        }\n    }\n}\n\npub fn add_cw1155_coin(\n    address: String,\n    token_id: String,\n    value: Uint128,\n) -\u003e impl FnOnce(Option\u003cTradeInfo\u003e) -\u003e Result\u003cTradeInfo, ContractError\u003e {\n    move |d: Option\u003cTradeInfo\u003e| -\u003e Result\u003cTradeInfo, ContractError\u003e {\n        match d {\n            Some(mut trade) =\u003e {\n                let existing_token = trade.associated_assets.iter_mut().find(|c| match c {\n                    AssetInfo::Cw1155Coin(x) =\u003e x.address == address \u0026\u0026 x.token_id == token_id,\n                    _ =\u003e false,\n                });\n                if let Some(existing_token) = existing_token {\n                    let current_value = match existing_token {\n                        AssetInfo::Cw1155Coin(x) =\u003e x.value,\n                        _ =\u003e Uint128::zero(),\n                    };\n                    *existing_token = AssetInfo::Cw1155Coin(Cw1155Coin {\n                        address,\n                        token_id,\n                        value: current_value + value,\n                    })\n                } else {\n                    trade\n                        .associated_assets\n                        .push(AssetInfo::Cw1155Coin(Cw1155Coin {\n                            address,\n                            token_id,\n                            value,\n                        }))\n                }\n\n                Ok(trade)\n            }\n            //TARPAULIN : Unreachable in current code state\n            None =\u003e Err(ContractError::NotFoundInTradeInfo {}),\n        }\n    }\n}\n\npub fn is_owner(storage: \u0026dyn Storage, sender: Addr) -\u003e Result\u003cContractInfo, ContractError\u003e {\n    let contract_info = CONTRACT_INFO.load(storage)?;\n    if sender == contract_info.owner {\n        Ok(contract_info)\n    } else {\n        Err(ContractError::Unauthorized {})\n    }\n}\n\npub fn is_fee_contract(storage: \u0026dyn Storage, sender: Addr) -\u003e Result\u003c(), ContractError\u003e {\n    let contract_info = CONTRACT_INFO.load(storage)?;\n    if let Some(fee_contract) = contract_info.fee_contract {\n        if sender == fee_contract {\n            Ok(())\n        } else {\n            Err(ContractError::Unauthorized {})\n        }\n    } else {\n        Err(ContractError::Unauthorized {})\n    }\n}\n\npub fn is_trader(\n    storage: \u0026dyn Storage,\n    sender: \u0026Addr,\n    trade_id: u64,\n) -\u003e Result\u003cTradeInfo, ContractError\u003e {\n    let trade = load_trade(storage, trade_id)?;\n\n    if trade.owner == sender.clone() {\n        Ok(trade)\n    } else {\n        Err(ContractError::TraderNotCreator {})\n    }\n}\n\npub fn is_counter_trader(\n    storage: \u0026dyn Storage,\n    sender: \u0026Addr,\n    trade_id: u64,\n    counter_id: u64,\n) -\u003e Result\u003cTradeInfo, ContractError\u003e {\n    let trade = load_counter_trade(storage, trade_id, counter_id)?;\n\n    if trade.owner == sender.clone() {\n        Ok(trade)\n    } else {\n        Err(ContractError::CounterTraderNotCreator {})\n    }\n}\n\npub fn get_actual_counter_state(\n    storage: \u0026dyn Storage,\n    trade_id: u64,\n    counter_info: \u0026mut TradeInfo,\n) -\u003e StdResult\u003c()\u003e {\n    let trade_info = TRADE_INFO.load(storage, trade_id)?;\n\n    match trade_info.state {\n        TradeState::Refused =\u003e counter_info.state = TradeState::Cancelled,\n        TradeState::Cancelled =\u003e counter_info.state = TradeState::Cancelled,\n        TradeState::Accepted =\u003e match counter_info.state {\n            TradeState::Accepted =\u003e {}\n            _ =\u003e counter_info.state = TradeState::Refused,\n        },\n        _ =\u003e {}\n    }\n    Ok(())\n}\n\npub fn load_counter_trade(\n    storage: \u0026dyn Storage,\n    trade_id: u64,\n    counter_id: u64,\n) -\u003e Result\u003cTradeInfo, ContractError\u003e {\n    let mut counter = COUNTER_TRADE_INFO\n        .load(storage, (trade_id, counter_id))\n        .map_err(|_| ContractError::NotFoundInCounterTradeInfo {})?;\n\n    get_actual_counter_state(storage, trade_id, \u0026mut counter)?;\n\n    Ok(counter)\n}\n\npub fn load_trade(storage: \u0026dyn Storage, trade_id: u64) -\u003e Result\u003cTradeInfo, ContractError\u003e {\n    TRADE_INFO\n        .load(storage, trade_id)\n        .map_err(|_| ContractError::NotFoundInTradeInfo {})\n}\n\npub fn can_suggest_counter_trade(\n    storage: \u0026dyn Storage,\n    trade_id: u64,\n    sender: \u0026Addr,\n) -\u003e Result\u003cTradeInfo, ContractError\u003e {\n    if let Ok(Some(trade)) = TRADE_INFO.may_load(storage, trade_id) {\n        if (trade.state == TradeState::Published) | (trade.state == TradeState::Countered) {\n            if !trade.whitelisted_users.is_empty() {\n                if !trade.whitelisted_users.contains(sender) {\n                    Err(ContractError::AddressNotWhitelisted {})\n                } else {\n                    Ok(trade)\n                }\n            } else {\n                Ok(trade)\n            }\n        } else {\n            Err(ContractError::NotCounterable {})\n        }\n    } else {\n        Err(ContractError::NotFoundInTradeInfo {})\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","p2p-trading","src","trade.rs"],"content":"use cosmwasm_std::{\n    Addr, Api, BankMsg, Deps, DepsMut, Env, MessageInfo, Response, StdResult, Storage, Uint128,\n};\n\nuse std::collections::HashSet;\nuse std::iter::FromIterator;\n\nuse cw1155::Cw1155ExecuteMsg;\nuse cw20::Cw20ExecuteMsg;\nuse cw721::Cw721ExecuteMsg;\n\nuse p2p_trading_export::msg::{into_cosmos_msg, QueryFilters};\nuse p2p_trading_export::state::{\n    AdditionnalTradeInfo, AssetInfo, Comment, CounterTradeInfo, TradeInfo, TradeState,\n};\n\nuse crate::error::ContractError;\nuse crate::messages::set_comment;\nuse crate::query::query_all_trades;\nuse crate::state::{\n    add_cw1155_coin, add_cw20_coin, add_cw721_coin, add_funds, is_trader, load_counter_trade,\n    CONTRACT_INFO, COUNTER_TRADE_INFO, TRADE_INFO,\n};\n\n/// Query the last trade created by the owner.\n/// This should only be used in the same transaction as the trade creation.\n/// Otherwise, specify the trade_id directly in the transaction\npub fn get_last_trade_id_created(deps: Deps, by: String) -\u003e Result\u003cu64, ContractError\u003e {\n    Ok(query_all_trades(\n        deps,\n        None,\n        Some(1),\n        Some(QueryFilters {\n            owner: Some(by),\n            ..QueryFilters::default()\n        }),\n    )?\n    .trades[0]\n        .trade_id)\n}\n\n/// Create a new trade and assign it a unique id\npub fn create_trade(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    whitelisted_users: Option\u003cVec\u003cString\u003e\u003e,\n    comment: Option\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // We start by creating a new trade_id (simply incremented from the last id)\n    let trade_id: u64 = CONTRACT_INFO\n        .update(deps.storage, |mut c| -\u003e StdResult\u003c_\u003e {\n            c.last_trade_id = c.last_trade_id.map_or(Some(0), |id| Some(id + 1));\n            Ok(c)\n        })?\n        .last_trade_id\n        .unwrap(); // This is safe because of the function architecture just there\n\n    TRADE_INFO.update(deps.storage, trade_id, |trade| match trade {\n        // If the trade id already exists, the contract is faulty\n        // Or an external error happened, or whatever...\n        // In that case, we emit an error\n        // The priority is : We do not want to overwrite existing data\n        Some(_) =\u003e Err(ContractError::ExistsInTradeInfo {}),\n        None =\u003e Ok(TradeInfo {\n            owner: info.sender.clone(),\n            additionnal_info: AdditionnalTradeInfo {\n                time: env.block.time,\n                ..Default::default()\n            },\n            ..Default::default()\n        }),\n    })?;\n\n    // We add withlisted addresses\n    if let Some(whitelist) = whitelisted_users {\n        add_whitelisted_users(\n            deps.storage,\n            deps.api,\n            env.clone(),\n            info.clone(),\n            trade_id,\n            whitelist,\n        )?;\n    }\n\n    // And the eventual comment sent along with the transaction\n    if let Some(comment) = comment {\n        set_comment(deps, env, info.clone(), trade_id, None, comment)?;\n    }\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"create_trade\")\n        .add_attribute(\"trade_id\", trade_id.to_string())\n        .add_attribute(\"trader\", info.sender))\n}\n\n/// We verify the trader is indeed the sender and the trade can be modified\npub fn can_modify_trade(\n    storage: \u0026dyn Storage,\n    trader: Addr,\n    trade_id: u64,\n) -\u003e Result\u003cTradeInfo, ContractError\u003e {\n    let trade_info = is_trader(storage, \u0026trader, trade_id)?;\n    // 3.\n    if trade_info.state != TradeState::Created {\n        return Err(ContractError::WrongTradeState {\n            state: trade_info.state,\n        });\n    }\n    Ok(trade_info)\n}\n\npub fn trade_id_or_last(\n    deps: Deps,\n    trader: Addr,\n    trade_id: Option\u003cu64\u003e,\n) -\u003e Result\u003cu64, ContractError\u003e {\n    match trade_id {\n        Some(trade_id) =\u003e Ok(trade_id),\n        None =\u003e get_last_trade_id_created(deps, trader.to_string()),\n    }\n}\n\n/// We prepare the info before asset addition\n/// 1. If the trade_id is not specified, we get the last trade_id created by the sender\n/// 2. We verify the trade can be modified\npub fn prepare_trade_modification(\n    deps: Deps,\n    trader: Addr,\n    trade_id: Option\u003cu64\u003e,\n) -\u003e Result\u003c(u64, TradeInfo), ContractError\u003e {\n    let trade_id = trade_id_or_last(deps, trader.clone(), trade_id)?;\n    let trade_info = can_modify_trade(deps.storage, trader, trade_id)?;\n    Ok((trade_id, trade_info))\n}\n\npub fn _create_receive_asset_messages(\n    env: Env,\n    info: MessageInfo,\n    asset: AssetInfo,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    Ok(match asset {\n        AssetInfo::Coin(coin) =\u003e Response::new()\n            .add_attribute(\"action\", \"add_asset\")\n            .add_attribute(\"asset_type\", \"fund\")\n            .add_attribute(\"denom\", coin.denom)\n            .add_attribute(\"amount\", coin.amount),\n        AssetInfo::Cw20Coin(token) =\u003e {\n            let message = Cw20ExecuteMsg::TransferFrom {\n                owner: info.sender.to_string(),\n                recipient: env.contract.address.into(),\n                amount: token.amount,\n            };\n            Response::new()\n                .add_message(into_cosmos_msg(message, token.address.clone())?)\n                .add_attribute(\"action\", \"add_asset\")\n                .add_attribute(\"asset_type\", \"token\")\n                .add_attribute(\"token\", token.address)\n                .add_attribute(\"amount\", token.amount)\n        }\n        AssetInfo::Cw721Coin(token) =\u003e {\n            let message = Cw721ExecuteMsg::TransferNft {\n                recipient: env.contract.address.into(),\n                token_id: token.token_id.clone(),\n            };\n\n            Response::new()\n                .add_message(into_cosmos_msg(message, token.address.clone())?)\n                .add_attribute(\"action\", \"add_asset\")\n                .add_attribute(\"asset_type\", \"NFT\")\n                .add_attribute(\"nft\", token.address)\n                .add_attribute(\"token_id\", token.token_id)\n        }\n        AssetInfo::Cw1155Coin(token) =\u003e {\n            let message = Cw1155ExecuteMsg::SendFrom {\n                from: info.sender.to_string(),\n                to: env.contract.address.into(),\n                token_id: token.token_id.clone(),\n                value: token.value,\n                msg: None,\n            };\n\n            Response::new()\n                .add_message(into_cosmos_msg(message, token.address.clone())?)\n                .add_attribute(\"action\", \"add_asset\")\n                .add_attribute(\"asset_type\", \"cw1155\")\n                .add_attribute(\"token\", token.address)\n                .add_attribute(\"token_id\", token.token_id)\n                .add_attribute(\"amount\", token.value)\n        }\n    })\n}\n\n/// Adding a new asset to a trade.\n/// This function handles 4 different types of assets\npub fn add_asset_to_trade(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    trade_id: Option\u003cu64\u003e,\n    asset: AssetInfo,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let (trade_id, _trade_info) =\n        prepare_trade_modification(deps.as_ref(), info.sender.clone(), trade_id)?;\n\n    match asset.clone() {\n        AssetInfo::Coin(coin) =\u003e {\n            TRADE_INFO.update(deps.storage, trade_id, add_funds(coin, info.funds.clone()))\n        }\n        AssetInfo::Cw20Coin(token) =\u003e TRADE_INFO.update(\n            deps.storage,\n            trade_id,\n            add_cw20_coin(token.address.clone(), token.amount),\n        ),\n        AssetInfo::Cw721Coin(token) =\u003e TRADE_INFO.update(\n            deps.storage,\n            trade_id,\n            add_cw721_coin(token.address.clone(), token.token_id),\n        ),\n        AssetInfo::Cw1155Coin(token) =\u003e TRADE_INFO.update(\n            deps.storage,\n            trade_id,\n            add_cw1155_coin(token.address.clone(), token.token_id.clone(), token.value),\n        ),\n    }?;\n\n    // Now we need to transfer the token\n    Ok(_create_receive_asset_messages(env, info.clone(), asset)?\n        .add_attribute(\"trade_id\", trade_id.to_string())\n        .add_attribute(\"trader\", info.sender))\n}\n\n/// Allows to withdraw assets while creating a trade\n/// The assets vector specifies a position (u16) and an asset Info (AssetInfo)\n/// The u16 is simply the position of the asset in the associated_assets vector of the TradeInfo struct\n/// This position is accessible when querying the TradeInfo.\n/// We made this choice to avoid looping over assets when withdrawing unique assets.\n/// This allows users to withdraw single assets without a risk of running out of gas.\npub fn withdraw_trade_assets_while_creating(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    trade_id: u64,\n    assets: Vec\u003c(u16, AssetInfo)\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // We verify the sender is allowed to withdraw funds\n    let mut trade_info = is_trader(deps.storage, \u0026info.sender, trade_id)?;\n    if trade_info.state != TradeState::Created {\n        return Err(ContractError::TradeAlreadyPublished {});\n    }\n    _are_assets_in_trade(\u0026trade_info, \u0026assets)?;\n\n    // We withdraw the assets\n    _try_withdraw_assets_unsafe(\u0026mut trade_info, \u0026assets)?;\n    TRADE_INFO.save(deps.storage, trade_id, \u0026trade_info)?;\n\n    // We send the assets back to the sender\n    let res = _create_withdraw_messages_unsafe(\n        \u0026env.contract.address,\n        \u0026info.sender,\n        \u0026assets.iter().map(|x| x.1.clone()).collect(),\n    )?;\n    Ok(res\n        .add_attribute(\"action\", \"remove_from_trade\")\n        .add_attribute(\"trade_id\", trade_id.to_string())\n        .add_attribute(\"trader\", trade_info.owner))\n}\n\n/// Helper function to verify the specified `assets` indeed exist in the trade and have the right position specified\npub fn _are_assets_in_trade(\n    trade_info: \u0026TradeInfo,\n    assets: \u0026[(u16, AssetInfo)],\n) -\u003e Result\u003c(), ContractError\u003e {\n    // We first treat the assets\n    for (position, asset) in assets {\n        let position: usize = (*position).into();\n\n        if position \u003e= trade_info.associated_assets.len() {\n            return Err(ContractError::AssetNotFound { position });\n        }\n        let asset_info: AssetInfo = trade_info.associated_assets[position].clone();\n        match asset_info {\n            AssetInfo::Coin(fund_info) =\u003e {\n                // We check the fund is the one we want\n                if let AssetInfo::Coin(fund) = asset {\n                    // We verify the sent information matches the saved fund\n                    if fund_info.denom != fund.denom {\n                        return Err(ContractError::AssetNotFound { position });\n                    }\n                    if fund_info.amount \u003c fund.amount {\n                        return Err(ContractError::TooMuchWithdrawn {\n                            address: fund_info.denom,\n                            wanted: fund.amount.u128(),\n                            available: fund_info.amount.u128(),\n                        });\n                    }\n                }\n            }\n\n            AssetInfo::Cw20Coin(token_info) =\u003e {\n                // We check the token is the one we want\n                if let AssetInfo::Cw20Coin(token) = asset {\n                    // We verify the sent information matches the saved token\n                    if token_info.address != token.address {\n                        return Err(ContractError::AssetNotFound { position });\n                    }\n                    if token_info.amount \u003c token.amount {\n                        return Err(ContractError::TooMuchWithdrawn {\n                            address: token_info.address,\n                            wanted: token.amount.u128(),\n                            available: token_info.amount.u128(),\n                        });\n                    }\n                } else {\n                    return Err(ContractError::AssetNotFound { position });\n                }\n            }\n            AssetInfo::Cw721Coin(nft_info) =\u003e {\n                // We check the token is the one we want\n                if let AssetInfo::Cw721Coin(nft) = asset {\n                    // We verify the sent information matches the saved nft\n                    if nft_info.address != nft.address {\n                        return Err(ContractError::AssetNotFound { position });\n                    }\n                    if nft_info.token_id != nft.token_id {\n                        return Err(ContractError::AssetNotFound { position });\n                    }\n                } else {\n                    return Err(ContractError::AssetNotFound { position });\n                }\n            }\n            AssetInfo::Cw1155Coin(cw1155_info) =\u003e {\n                // We check the token is the one we want\n                if let AssetInfo::Cw1155Coin(cw1155) = asset {\n                    // We verify the sent information matches the saved nft\n                    if cw1155_info.address != cw1155.address {\n                        return Err(ContractError::AssetNotFound { position });\n                    }\n                    if cw1155_info.token_id != cw1155.token_id {\n                        return Err(ContractError::AssetNotFound { position });\n                    }\n                    if cw1155_info.value \u003c cw1155.value {\n                        return Err(ContractError::TooMuchWithdrawn {\n                            address: cw1155_info.address.to_string(),\n                            wanted: cw1155.value.u128(),\n                            available: cw1155_info.value.u128(),\n                        });\n                    }\n                } else {\n                    return Err(ContractError::AssetNotFound { position });\n                }\n            }\n        }\n    }\n\n    Ok(())\n}\n\n/// Helper function to remove withdrawn assets from the trade in the internal data_structure\npub fn _try_withdraw_assets_unsafe(\n    trade_info: \u0026mut TradeInfo,\n    assets: \u0026[(u16, AssetInfo)],\n) -\u003e Result\u003c(), ContractError\u003e {\n    for (position, asset) in assets {\n        let position: usize = (*position).into();\n        let asset_info = trade_info.associated_assets[position].clone();\n        match asset_info {\n            AssetInfo::Coin(mut fund_info) =\u003e {\n                if let AssetInfo::Coin(fund) = asset {\n                    // If everything is in order, we remove the coin from the trade\n                    fund_info.amount -= fund.amount;\n                    trade_info.associated_assets[position] = AssetInfo::Coin(fund_info);\n                }\n            }\n            AssetInfo::Cw20Coin(mut token_info) =\u003e {\n                if let AssetInfo::Cw20Coin(token) = asset {\n                    token_info.amount -= token.amount;\n                    trade_info.associated_assets[position] = AssetInfo::Cw20Coin(token_info);\n                }\n            }\n            AssetInfo::Cw721Coin(mut nft_info) =\u003e {\n                if let AssetInfo::Cw721Coin(_) = asset {\n                    nft_info.address = \"\".to_string();\n                    trade_info.associated_assets[position] = AssetInfo::Cw721Coin(nft_info);\n                }\n            }\n            AssetInfo::Cw1155Coin(mut cw1155_info) =\u003e {\n                if let AssetInfo::Cw1155Coin(cw1155) = asset {\n                    cw1155_info.value -= cw1155.value;\n                    trade_info.associated_assets[position] = AssetInfo::Cw1155Coin(cw1155_info);\n                }\n            }\n        }\n    }\n\n    // Then we remove empty assets from the trade\n    trade_info.associated_assets.retain(|asset| match asset {\n        AssetInfo::Coin(fund) =\u003e fund.amount != Uint128::zero(),\n        AssetInfo::Cw20Coin(token) =\u003e token.amount != Uint128::zero(),\n        AssetInfo::Cw721Coin(nft) =\u003e !nft.address.is_empty(),\n        AssetInfo::Cw1155Coin(cw1155) =\u003e cw1155.value != Uint128::zero(),\n    });\n\n    Ok(())\n}\n\n/// Helper function to create withdraw messages based on a slice of assets.\n/// This function doesn't do any checks and mus be used with caution\n/// We must always verify the sender has the right to withdraw before calling this function\n#[allow(clippy::ptr_arg)]\npub fn _create_withdraw_messages_unsafe(\n    contract_address: \u0026Addr,\n    recipient: \u0026Addr,\n    assets: \u0026Vec\u003cAssetInfo\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut res = Response::new();\n\n    // First the assets\n    for asset in assets {\n        match asset {\n            AssetInfo::Coin(fund) =\u003e {\n                let message = BankMsg::Send {\n                    to_address: recipient.to_string(),\n                    amount: vec![fund.clone()],\n                };\n                res = res\n                    .add_message(message)\n                    .add_attribute(\"asset_type\", \"fund\")\n                    .add_attribute(\"denom\", fund.denom.clone())\n                    .add_attribute(\"amount\", fund.amount);\n            }\n            AssetInfo::Cw20Coin(token) =\u003e {\n                let message = Cw20ExecuteMsg::Transfer {\n                    recipient: recipient.to_string(),\n                    amount: token.amount,\n                };\n                res = res\n                    .add_message(into_cosmos_msg(message, token.address.clone())?)\n                    .add_attribute(\"asset_type\", \"token\")\n                    .add_attribute(\"token\", token.address.clone())\n                    .add_attribute(\"amount\", token.amount);\n            }\n            AssetInfo::Cw721Coin(nft) =\u003e {\n                let message = Cw721ExecuteMsg::TransferNft {\n                    recipient: recipient.to_string(),\n                    token_id: nft.token_id.clone(),\n                };\n                res = res\n                    .add_message(into_cosmos_msg(message, nft.address.clone())?)\n                    .add_attribute(\"asset_type\", \"NFT\")\n                    .add_attribute(\"nft\", nft.address.clone())\n                    .add_attribute(\"token_id\", nft.token_id.clone());\n            }\n            AssetInfo::Cw1155Coin(cw1155) =\u003e {\n                let message = Cw1155ExecuteMsg::SendFrom {\n                    from: contract_address.to_string(),\n                    to: recipient.to_string(),\n                    token_id: cw1155.token_id.clone(),\n                    value: cw1155.value,\n                    msg: None,\n                };\n                res = res\n                    .add_message(into_cosmos_msg(message, cw1155.address.clone())?)\n                    .add_attribute(\"asset_type\", \"Cw1155\")\n                    .add_attribute(\"token\", cw1155.address.clone())\n                    .add_attribute(\"token_id\", cw1155.token_id.clone())\n                    .add_attribute(\"amount\", cw1155.value);\n            }\n        }\n    }\n\n    Ok(res)\n}\n\n/// Check the assets are not already withdrawn and then creates the withdraw messages\npub fn check_and_create_withdraw_messages(\n    env: Env,\n    recipient: \u0026Addr,\n    trade_info: \u0026TradeInfo,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    if trade_info.assets_withdrawn {\n        return Err(ContractError::TradeAlreadyWithdrawn {});\n    }\n    _create_withdraw_messages_unsafe(\n        \u0026env.contract.address,\n        recipient,\n        \u0026trade_info.associated_assets,\n    )\n}\n\n/// Helper to validate a slice of addresses\npub fn validate_addresses(api: \u0026dyn Api, whitelisted_users: \u0026[String]) -\u003e StdResult\u003cVec\u003cAddr\u003e\u003e {\n    whitelisted_users\n        .iter()\n        .map(|x| api.addr_validate(x))\n        .collect()\n}\n\n/// Add new whitelisted users to a trade\npub fn add_whitelisted_users(\n    storage: \u0026mut dyn Storage,\n    api: \u0026dyn Api,\n    _env: Env,\n    info: MessageInfo,\n    trade_id: u64,\n    whitelisted_users: Vec\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // We verify the trade can be modified\n    let mut trade_info = can_modify_trade(storage, info.sender.clone(), trade_id)?;\n    // We modify the whitelist\n    let hash_set: HashSet\u003cAddr\u003e = HashSet::from_iter(validate_addresses(api, \u0026whitelisted_users)?);\n    trade_info.whitelisted_users = trade_info\n        .whitelisted_users\n        .union(\u0026hash_set)\n        .cloned()\n        .collect();\n    TRADE_INFO.save(storage, trade_id, \u0026trade_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"modify_parameter\")\n        .add_attribute(\"name\", \"whitelisted_users\")\n        .add_attribute(\"operation_type\", \"add\")\n        .add_attribute(\"value\", whitelisted_users.join(\",\"))\n        .add_attribute(\"trade_id\", trade_id.to_string())\n        .add_attribute(\"trader\", info.sender))\n}\n\n/// Remove whitelisted users from a trade\npub fn remove_whitelisted_users(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    trade_id: u64,\n    whitelisted_users: Vec\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // We verify the trade can be modified\n    let mut trade_info = can_modify_trade(deps.storage, info.sender.clone(), trade_id)?;\n    // We modify the whitelist\n    let valid_whitelisted_users = validate_addresses(deps.api, \u0026whitelisted_users)?;\n    for user in \u0026valid_whitelisted_users {\n        trade_info.whitelisted_users.remove(user);\n    }\n    TRADE_INFO.save(deps.storage, trade_id, \u0026trade_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"modify_parameter\")\n        .add_attribute(\"name\", \"whitelisted_users\")\n        .add_attribute(\"operation_type\", \"remove\")\n        .add_attribute(\"value\", whitelisted_users.join(\",\"))\n        .add_attribute(\"trade_id\", trade_id.to_string())\n        .add_attribute(\"trader\", info.sender))\n}\n\n/// Add wanted nfts (only informational) to a trade\npub fn add_nfts_wanted(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    trade_id: Option\u003cu64\u003e,\n    nfts_wanted: Vec\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // We verify the trade can be modified\n    let (trade_id, mut trade_info) =\n        prepare_trade_modification(deps.as_ref(), info.sender.clone(), trade_id)?;\n    // We modify the nfts wanted\n    let hash_set: HashSet\u003cAddr\u003e = HashSet::from_iter(validate_addresses(deps.api, \u0026nfts_wanted)?);\n    trade_info.additionnal_info.nfts_wanted = trade_info\n        .additionnal_info\n        .nfts_wanted\n        .union(\u0026hash_set)\n        .cloned()\n        .collect();\n\n    TRADE_INFO.save(deps.storage, trade_id, \u0026trade_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"modify_parameter\")\n        .add_attribute(\"name\", \"nfts_wanted\")\n        .add_attribute(\"operation_type\", \"add\")\n        .add_attribute(\"value\", nfts_wanted.join(\",\"))\n        .add_attribute(\"trade_id\", trade_id.to_string())\n        .add_attribute(\"trader\", info.sender))\n}\n\n/// Remove wanted nfts (only informational) from a trade\npub fn remove_nfts_wanted(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    trade_id: u64,\n    nfts_wanted: Vec\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // We verify the trade can be modified\n    let mut trade_info = can_modify_trade(deps.storage, info.sender.clone(), trade_id)?;\n    // We modify the whitelist\n    let valid_nfts_wanted = validate_addresses(deps.api, \u0026nfts_wanted)?;\n    for nft in \u0026valid_nfts_wanted {\n        trade_info.additionnal_info.nfts_wanted.remove(nft);\n    }\n    TRADE_INFO.save(deps.storage, trade_id, \u0026trade_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"modify_parameter\")\n        .add_attribute(\"name\", \"nfts_wanted\")\n        .add_attribute(\"operation_type\", \"remove\")\n        .add_attribute(\"value\", nfts_wanted.join(\",\"))\n        .add_attribute(\"trade_id\", trade_id.to_string())\n        .add_attribute(\"trader\", info.sender))\n}\n\n/// Confirm (and publish) a trade when creation is finished\npub fn confirm_trade(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    trade_id: Option\u003cu64\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // We verify the trade can ve published\n    let trade_id = trade_id_or_last(deps.as_ref(), info.sender.clone(), trade_id)?;\n    let mut trade_info = is_trader(deps.storage, \u0026info.sender, trade_id)?;\n    if trade_info.state != TradeState::Created {\n        return Err(ContractError::CantChangeTradeState {\n            from: trade_info.state,\n            to: TradeState::Published,\n        });\n    }\n    // We set the state as published\n    trade_info.state = TradeState::Published;\n    TRADE_INFO.save(deps.storage, trade_id, \u0026trade_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"confirm_trade\")\n        .add_attribute(\"trade_id\", trade_id.to_string())\n        .add_attribute(\"trader\", info.sender))\n}\n\n/// Accept a counter trade\npub fn accept_trade(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    trade_id: u64,\n    counter_id: u64,\n    comment: Option\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // Only the initial trader can accept a trade\n    let mut trade_info = is_trader(deps.storage, \u0026info.sender, trade_id)?;\n    // We check the counter trade exists\n    let mut counter_info = load_counter_trade(deps.storage, trade_id, counter_id)?;\n\n    // We check we can accept the trade\n    if trade_info.state != TradeState::Countered {\n        // TARPAULIN : This code does not seem to be reachable\n        return Err(ContractError::CantChangeTradeState {\n            from: trade_info.state,\n            to: TradeState::Accepted,\n        });\n    }\n    // We check this specific counter trade can be accepted\n    if counter_info.state != TradeState::Published {\n        return Err(ContractError::CantAcceptNotPublishedCounter {});\n    }\n\n    // We accept the trade\n    // We update the trade accepted info to make indexing easier\n    let accepted_info = CounterTradeInfo {\n        trade_id,\n        counter_id,\n    };\n    trade_info.state = TradeState::Accepted;\n    trade_info.accepted_info = Some(accepted_info);\n    TRADE_INFO.save(deps.storage, trade_id, \u0026trade_info)?;\n\n    // We update the coounter info comment and state\n    counter_info.additionnal_info.trader_comment = comment.map(|comment| Comment {\n        time: env.block.time,\n        comment,\n    });\n    counter_info.state = TradeState::Accepted;\n    COUNTER_TRADE_INFO.save(deps.storage, (trade_id, counter_id), \u0026counter_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"accept_counter_trade\")\n        .add_attribute(\"trade_id\", trade_id.to_string())\n        .add_attribute(\"counter_id\", counter_id.to_string())\n        .add_attribute(\"trader\", trade_info.owner)\n        .add_attribute(\"counter_trader\", counter_info.owner))\n}\n\n/// Refuse a counter trade\n/// This function is only informational and not needed if the user doesn't deem it necessary\npub fn refuse_counter_trade(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    trade_id: u64,\n    counter_id: u64,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // Only the initial trader can refuse a trade\n    let trade_info = is_trader(deps.storage, \u0026info.sender, trade_id)?;\n    // We check the counter trade exists\n    let mut counter_info = load_counter_trade(deps.storage, trade_id, counter_id)?;\n\n    if trade_info.state == TradeState::Accepted {\n        return Err(ContractError::TradeAlreadyAccepted {});\n    }\n    if trade_info.state == TradeState::Cancelled {\n        return Err(ContractError::TradeCancelled {});\n    }\n    counter_info.state = TradeState::Refused;\n    COUNTER_TRADE_INFO.save(deps.storage, (trade_id, counter_id), \u0026counter_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"refuse_counter_trade\")\n        .add_attribute(\"trade_id\", trade_id.to_string())\n        .add_attribute(\"counter_id\", counter_id.to_string())\n        .add_attribute(\"trader\", trade_info.owner)\n        .add_attribute(\"counter_trader\", counter_info.owner))\n}\n\n/// Cancel a trade\n/// The trade isn't modifiable, but the funds are withdrawnable after this call.\npub fn cancel_trade(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    trade_id: u64,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // Only the initial trader can cancel the trade\n    let mut trade_info = is_trader(deps.storage, \u0026info.sender, trade_id)?;\n\n    // We can't cancel an accepted trade\n    if trade_info.state == TradeState::Accepted {\n        return Err(ContractError::CantChangeTradeState {\n            from: trade_info.state,\n            to: TradeState::Cancelled,\n        });\n    }\n\n    // We change the trade state\n    trade_info.state = TradeState::Cancelled;\n    TRADE_INFO.save(deps.storage, trade_id, \u0026trade_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"cancel_trade\")\n        .add_attribute(\"trade_id\", trade_id.to_string())\n        .add_attribute(\"trader\", trade_info.owner))\n}\n\n/// Withdraw all assets from a created (not published yet) or cancelled trade\n/// If the trade is only in the created state, it is automatically cancelled before withdrawing assets\npub fn withdraw_all_from_trade(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    trade_id: u64,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // We load the trade and verify it has the right trader\n    let mut trade_info = is_trader(deps.storage, \u0026info.sender, trade_id)?;\n\n    // If the trade was just created, we cancel it on the spot\n    if trade_info.state == TradeState::Created {\n        trade_info.state = TradeState::Cancelled;\n    }\n    // This funtion is only callable if the trade is cancelled\n    if trade_info.state != TradeState::Cancelled {\n        return Err(ContractError::TradeNotCancelled {});\n    }\n\n    let res = check_and_create_withdraw_messages(env, \u0026info.sender, \u0026trade_info)?;\n    trade_info.assets_withdrawn = true;\n    TRADE_INFO.save(deps.storage, trade_id, \u0026trade_info)?;\n\n    Ok(res\n        .add_attribute(\"action\", \"withdraw_all_funds\")\n        .add_attribute(\"type\", \"trade\")\n        .add_attribute(\"trade_id\", trade_id.to_string())\n        .add_attribute(\"trader\", trade_info.owner))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","raffles","examples","p2p_schema.rs"],"content":"use std::env::current_dir;\nuse std::fs::create_dir_all;\n\nuse cosmwasm_schema::{export_schema, remove_schemas, schema_for};\n\nuse raffles_export::msg::{ExecuteMsg, InstantiateMsg, QueryMsg};\n\nfn main() {\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"schema\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n\n    export_schema(\u0026schema_for!(InstantiateMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(ExecuteMsg), \u0026out_dir);\n    export_schema(\u0026schema_for!(QueryMsg), \u0026out_dir);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","raffles","src","contract.rs"],"content":"use anyhow::{anyhow, Result};\nuse cosmwasm_std::entry_point;\nuse cosmwasm_std::{\n    from_binary, to_binary, Addr, Binary, Coin, Deps, DepsMut, Env, Event, MessageInfo, Reply,\n    Response, StdError, StdResult, SubMsgResult, Timestamp, Uint128,\n};\n#[cfg(not(feature = \"library\"))]\nuse std::convert::TryInto;\n\nuse cw2::set_contract_version;\n\nuse crate::error::ContractError;\n\nuse crate::state::{\n    assert_randomness_origin_and_order, can_buy_ticket, get_asset_amount,\n    get_raffle_owner_finished_messages, get_raffle_state, get_raffle_winner,\n    get_raffle_winner_message, is_owner, load_raffle, CONTRACT_INFO, RAFFLE_INFO,\n};\nuse raffles_export::msg::{\n    into_cosmos_msg, DrandRandomness, ExecuteMsg, InstantiateMsg, MigrateMsg, QueryMsg,\n};\nuse raffles_export::state::{\n    AssetInfo, ContractInfo, Cw1155Coin, Cw20Coin, Cw721Coin, RaffleInfo, RaffleState,\n    MAXIMUM_PARTICIPANT_NUMBER, MINIMUM_RAFFLE_DURATION, MINIMUM_RAFFLE_TIMEOUT, MINIMUM_RAND_FEE,\n};\n\nuse cw1155::Cw1155ExecuteMsg;\nuse cw20::Cw20ExecuteMsg;\nuse cw721::Cw721ExecuteMsg;\n\nuse crate::query::{query_all_raffles, query_contract_info};\n\nconst CONTRACT_NAME: \u0026str = \"illiquidlabs.io:raffles\";\nconst CONTRACT_VERSION: \u0026str = \"0.1.0\";\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // Verify the contract name\n\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    msg.validate()?;\n    // store token info\n    let data = ContractInfo {\n        name: msg.name,\n        owner: deps\n            .api\n            .addr_validate(\u0026msg.owner.unwrap_or_else(|| info.sender.to_string()))?,\n        fee_addr: deps\n            .api\n            .addr_validate(\u0026msg.fee_addr.unwrap_or_else(|| info.sender.to_string()))?,\n        last_raffle_id: None,\n        minimum_raffle_duration: msg\n            .minimum_raffle_duration\n            .unwrap_or(MINIMUM_RAFFLE_DURATION)\n            .max(MINIMUM_RAFFLE_DURATION),\n        minimum_raffle_timeout: msg\n            .minimum_raffle_timeout\n            .unwrap_or(MINIMUM_RAFFLE_TIMEOUT)\n            .max(MINIMUM_RAFFLE_TIMEOUT),\n        raffle_fee: msg.raffle_fee.unwrap_or(Uint128::zero()),\n        rand_fee: msg\n            .rand_fee\n            .unwrap_or_else(|| Uint128::from(MINIMUM_RAND_FEE)),\n        lock: false,\n        drand_url: msg\n            .drand_url\n            .unwrap_or_else(|| \"https://api.drand.sh/\".to_string()),\n        random_pubkey: msg.random_pubkey,\n        verify_signature_contract: deps.api.addr_validate(\u0026msg.verify_signature_contract)?,\n    };\n    CONTRACT_INFO.save(deps.storage, \u0026data)?;\n    Ok(Response::default()\n        .add_attribute(\"action\", \"init\")\n        .add_attribute(\"contract\", \"raffle\")\n        .add_attribute(\"owner\", data.owner))\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg) -\u003e Result\u003cResponse\u003e {\n    match msg {\n        ExecuteMsg::CreateRaffle {\n            asset,\n            raffle_start_timestamp,\n            raffle_duration,\n            raffle_timeout,\n            comment,\n            raffle_ticket_price,\n            max_participant_number,\n        } =\u003e execute_create_raffle(\n            deps,\n            env,\n            info,\n            asset,\n            raffle_start_timestamp,\n            raffle_duration,\n            raffle_timeout,\n            comment,\n            raffle_ticket_price,\n            max_participant_number,\n        ),\n        ExecuteMsg::BuyTicket {\n            raffle_id,\n            sent_assets,\n        } =\u003e execute_buy_ticket(deps, env, info, raffle_id, sent_assets),\n        ExecuteMsg::Receive {\n            sender,\n            amount,\n            msg,\n        } =\u003e execute_receive(deps, env, info, sender, amount, msg),\n        ExecuteMsg::ReceiveNft {\n            sender,\n            token_id,\n            msg,\n        } =\u003e execute_receive_nft(deps, env, info, sender, token_id, msg),\n        ExecuteMsg::Cw1155ReceiveMsg {\n            operator,\n            from,\n            token_id,\n            amount,\n            msg,\n        } =\u003e execute_receive_1155(\n            deps,\n            env,\n            info,\n            from.unwrap_or(operator),\n            token_id,\n            amount,\n            msg,\n        ),\n        ExecuteMsg::ClaimNft { raffle_id } =\u003e execute_claim(deps, env, info, raffle_id),\n        ExecuteMsg::UpdateRandomness {\n            raffle_id,\n            randomness,\n        } =\u003e execute_update_randomness(deps, env, info, raffle_id, randomness),\n\n        // Admin messages\n        ExecuteMsg::ToggleLock { lock } =\u003e execute_toggle_lock(deps, env, info, lock),\n        ExecuteMsg::Renounce {} =\u003e execute_renounce(deps, env, info),\n        ExecuteMsg::ChangeParameter { parameter, value } =\u003e {\n            execute_change_parameter(deps, env, info, parameter, value)\n        }\n    }\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn migrate(_deps: DepsMut, _env: Env, _msg: MigrateMsg) -\u003e Result\u003cResponse, ContractError\u003e {\n    // No state migrations performed, just returned a Response\n    Ok(Response::default())\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, env: Env, msg: QueryMsg) -\u003e Result\u003cBinary\u003e {\n    match msg {\n        QueryMsg::ContractInfo {} =\u003e to_binary(\u0026query_contract_info(deps)?).map_err(|x| anyhow!(x)),\n        QueryMsg::RaffleInfo { raffle_id } =\u003e {\n            to_binary(\u0026load_raffle(deps.storage, raffle_id)?).map_err(|x| anyhow!(x))\n        }\n\n        QueryMsg::GetAllRaffles {\n            start_after,\n            limit,\n            filters,\n        } =\u003e to_binary(\u0026query_all_raffles(deps, env, start_after, limit, filters)?)\n            .map_err(|x| anyhow!(x)),\n    }\n}\n\n/// Replace the current contract owner with the provided owner address\n/// * `owner` must be a valid Terra address\n/// The owner has limited power on this contract :\n/// 1. Change the contract owner\n/// 2. Change the fee contract\npub fn execute_renounce(deps: DepsMut, env: Env, info: MessageInfo) -\u003e Result\u003cResponse\u003e {\n    let mut contract_info = is_owner(deps.storage, info.sender)?;\n\n    contract_info.owner = env.contract.address;\n    CONTRACT_INFO.save(deps.storage, \u0026contract_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"modify_parameter\")\n        .add_attribute(\"parameter\", \"owner\")\n        .add_attribute(\"value\", contract_info.owner))\n}\n\n/// Replace the current fee_contract with the provided fee_contract address\n/// * `fee_addr` must be a valid Terra address\npub fn set_new_fee_addr(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    fee_addr: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut contract_info = is_owner(deps.storage, info.sender)?;\n\n    let fee_addr = deps.api.addr_validate(\u0026fee_addr)?;\n    contract_info.fee_addr = fee_addr.clone();\n    CONTRACT_INFO.save(deps.storage, \u0026contract_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"modify_parameter\")\n        .add_attribute(\"parameter\", \"fee_addr\")\n        .add_attribute(\"value\", fee_addr))\n}\n\npub fn execute_toggle_lock(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    lock: bool,\n) -\u003e Result\u003cResponse\u003e {\n    let mut contract_info = is_owner(deps.storage, info.sender)?;\n\n    contract_info.lock = lock;\n    CONTRACT_INFO.save(deps.storage, \u0026contract_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"modify_parameter\")\n        .add_attribute(\"parameter\", \"contract_lock\")\n        .add_attribute(\"value\", lock.to_string()))\n}\n\npub fn execute_change_parameter(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    parameter: String,\n    value: String,\n) -\u003e Result\u003cResponse\u003e {\n    let mut contract_info = is_owner(deps.storage, info.sender)?;\n\n    match parameter.as_str() {\n        \"fee_addr\" =\u003e {\n            let addr = deps.api.addr_validate(\u0026value)?;\n            contract_info.fee_addr = addr;\n        }\n        \"minimum_raffle_duration\" =\u003e {\n            let time = value.parse::\u003cu64\u003e()?;\n            contract_info.minimum_raffle_duration = time;\n        }\n        \"minimum_raffle_timeout\" =\u003e {\n            let time = value.parse::\u003cu64\u003e()?;\n            contract_info.minimum_raffle_timeout = time;\n        }\n        \"raffle_fee\" =\u003e {\n            let fee = Uint128::from(value.parse::\u003cu128\u003e()?);\n            contract_info.raffle_fee = fee;\n        }\n        \"rand_fee\" =\u003e {\n            let fee = Uint128::from(value.parse::\u003cu128\u003e()?);\n            contract_info.rand_fee = fee;\n        }\n        \"drand_url\" =\u003e {\n            contract_info.drand_url = value.clone();\n        }\n        \"verify_signature_contract\" =\u003e {\n            let addr = deps.api.addr_validate(\u0026value)?;\n            contract_info.verify_signature_contract = addr;\n        }\n        \"random_pubkey\" =\u003e {\n            contract_info.random_pubkey = Binary::from_base64(\u0026value).unwrap();\n        }\n        _ =\u003e return Err(anyhow!(ContractError::ParameterNotFound {})),\n    }\n\n    CONTRACT_INFO.save(deps.storage, \u0026contract_info)?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"modify_parameter\")\n        .add_attribute(\"parameter\", parameter)\n        .add_attribute(\"value\", value))\n}\n\n/// Create a new raffle by depositing assets\n#[allow(clippy::too_many_arguments)]\npub fn execute_create_raffle(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    asset: AssetInfo,\n    raffle_start_timestamp: Option\u003cu64\u003e,\n    raffle_duration: Option\u003cu64\u003e,\n    raffle_timeout: Option\u003cu64\u003e,\n    comment: Option\u003cString\u003e,\n    raffle_ticket_price: AssetInfo,\n    max_participant_number: Option\u003cu64\u003e,\n) -\u003e Result\u003cResponse\u003e {\n    let contract_info = CONTRACT_INFO.load(deps.storage)?;\n\n    if contract_info.lock {\n        return Err(anyhow!(ContractError::ContractIsLocked {}));\n    }\n\n    // First we physcially transfer the AssetInfo\n    let transfer_message = match \u0026asset {\n        AssetInfo::Cw721Coin(token) =\u003e {\n            let message = Cw721ExecuteMsg::TransferNft {\n                recipient: env.contract.address.clone().into(),\n                token_id: token.token_id.clone(),\n            };\n\n            into_cosmos_msg(message, token.address.clone())?\n        }\n        AssetInfo::Cw1155Coin(token) =\u003e {\n            let message = Cw1155ExecuteMsg::SendFrom {\n                from: info.sender.to_string(),\n                to: env.contract.address.clone().into(),\n                token_id: token.token_id.clone(),\n                value: token.value,\n                msg: None,\n            };\n\n            into_cosmos_msg(message, token.address.clone())?\n        }\n        _ =\u003e return Err(anyhow!(ContractError::WrongAssetType {})),\n    };\n    // Then we create the internal raffle structure\n    let raffle_id = _create_raffle(\n        deps,\n        env,\n        info.sender.clone(),\n        asset,\n        raffle_start_timestamp,\n        raffle_duration,\n        raffle_timeout,\n        comment,\n        raffle_ticket_price,\n        max_participant_number,\n    )?;\n\n    Ok(Response::new()\n        .add_message(transfer_message)\n        .add_attribute(\"action\", \"create_raffle\")\n        .add_attribute(\"raffle_id\", raffle_id.to_string())\n        .add_attribute(\"owner\", info.sender))\n}\n\n/// Create a new raffle by depositing assets\npub fn execute_receive_nft(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    sender: String,\n    token_id: String,\n    msg: Binary,\n) -\u003e Result\u003cResponse\u003e {\n    let sender = deps.api.addr_validate(\u0026sender)?;\n    match from_binary(\u0026msg)? {\n        ExecuteMsg::CreateRaffle {\n            asset,\n            raffle_start_timestamp,\n            raffle_duration,\n            raffle_timeout,\n            comment,\n            raffle_ticket_price,\n            max_participant_number,\n        } =\u003e {\n            // First we make sure the received NFT is the one specified in the message\n\n            match asset.clone() {\n                AssetInfo::Cw721Coin(Cw721Coin {\n                    address: address_received,\n                    token_id: token_id_received,\n                }) =\u003e {\n                    if deps.api.addr_validate(\u0026address_received)? == info.sender\n                        \u0026\u0026 token_id_received == token_id\n                    {\n                        // The asset is a match, we can create the raffle object and return\n                        let raffle_id = _create_raffle(\n                            deps,\n                            env,\n                            sender,\n                            asset,\n                            raffle_start_timestamp,\n                            raffle_duration,\n                            raffle_timeout,\n                            comment,\n                            raffle_ticket_price,\n                            max_participant_number,\n                        )?;\n\n                        Ok(Response::new()\n                            .add_attribute(\"action\", \"create_raffle\")\n                            .add_attribute(\"raffle_id\", raffle_id.to_string())\n                            .add_attribute(\"owner\", info.sender))\n                    } else {\n                        Err(anyhow!(ContractError::AssetMismatch {}))\n                    }\n                }\n                _ =\u003e Err(anyhow!(ContractError::AssetMismatch {})),\n            }\n        }\n        _ =\u003e Err(anyhow!(ContractError::Unauthorized {})),\n    }\n}\n\n/// Create a new raffle by depositing assets\npub fn execute_receive_1155(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    from: String,\n    token_id: String,\n    amount: Uint128,\n    msg: Binary,\n) -\u003e Result\u003cResponse\u003e {\n    let sender = deps.api.addr_validate(\u0026from)?;\n    match from_binary(\u0026msg)? {\n        ExecuteMsg::CreateRaffle {\n            asset,\n            raffle_start_timestamp,\n            raffle_duration,\n            raffle_timeout,\n            comment,\n            raffle_ticket_price,\n            max_participant_number,\n        } =\u003e {\n            // First we make sure the received NFT is the one specified in the message\n            match asset.clone() {\n                AssetInfo::Cw1155Coin(Cw1155Coin {\n                    address: address_received,\n                    token_id: token_id_received,\n                    value: value_received,\n                }) =\u003e {\n                    if deps.api.addr_validate(\u0026address_received)? == info.sender\n                        \u0026\u0026 token_id_received == token_id\n                        \u0026\u0026 value_received == amount\n                    {\n                        // The asset is a match, we can create the raffle object and return\n                        let raffle_id = _create_raffle(\n                            deps,\n                            env,\n                            sender,\n                            asset,\n                            raffle_start_timestamp,\n                            raffle_duration,\n                            raffle_timeout,\n                            comment,\n                            raffle_ticket_price,\n                            max_participant_number,\n                        )?;\n\n                        Ok(Response::new()\n                            .add_attribute(\"action\", \"create_raffle\")\n                            .add_attribute(\"raffle_id\", raffle_id.to_string())\n                            .add_attribute(\"owner\", info.sender))\n                    } else {\n                        Err(anyhow!(ContractError::AssetMismatch {}))\n                    }\n                }\n                _ =\u003e Err(anyhow!(ContractError::AssetMismatch {})),\n            }\n        }\n        _ =\u003e Err(anyhow!(ContractError::Unauthorized {})),\n    }\n}\n\n/// Create a new raffle and assign it a unique id\n#[allow(clippy::too_many_arguments)]\npub fn _create_raffle(\n    deps: DepsMut,\n    env: Env,\n    owner: Addr,\n    asset: AssetInfo,\n    raffle_start_timestamp: Option\u003cu64\u003e,\n    raffle_duration: Option\u003cu64\u003e,\n    raffle_timeout: Option\u003cu64\u003e,\n    comment: Option\u003cString\u003e,\n    raffle_ticket_price: AssetInfo,\n    max_participant_number: Option\u003cu64\u003e,\n) -\u003e Result\u003cu64\u003e {\n    let contract_info = CONTRACT_INFO.load(deps.storage)?;\n\n    // We start by creating a new trade_id (simply incremented from the last id)\n    let raffle_id: u64 = CONTRACT_INFO\n        .update(deps.storage, |mut c| -\u003e StdResult\u003c_\u003e {\n            c.last_raffle_id = c.last_raffle_id.map_or(Some(0), |id| Some(id + 1));\n            Ok(c)\n        })?\n        .last_raffle_id\n        .unwrap(); // This is safe because of the function architecture just there\n\n    RAFFLE_INFO.update(deps.storage, raffle_id, |trade| match trade {\n        // If the trade id already exists, the contract is faulty\n        // Or an external error happened, or whatever...\n        // In that case, we emit an error\n        // The priority is : We do not want to overwrite existing data\n        Some(_) =\u003e Err(ContractError::ExistsInRaffleInfo {}),\n        None =\u003e Ok(RaffleInfo {\n            owner,\n            asset,\n            raffle_start_timestamp: raffle_start_timestamp\n                .map(Timestamp::from_seconds)\n                .unwrap_or(env.block.time),\n            raffle_duration: raffle_duration\n                .unwrap_or(contract_info.minimum_raffle_duration)\n                .max(contract_info.minimum_raffle_duration),\n            raffle_timeout: raffle_timeout\n                .unwrap_or(contract_info.minimum_raffle_timeout)\n                .max(contract_info.minimum_raffle_timeout),\n            comment,\n            raffle_ticket_price: raffle_ticket_price.clone(),\n            accumulated_ticket_fee: match raffle_ticket_price {\n                AssetInfo::Cw20Coin(coin) =\u003e AssetInfo::Cw20Coin(Cw20Coin {\n                    address: coin.address,\n                    amount: Uint128::zero(),\n                }),\n                AssetInfo::Coin(coin) =\u003e AssetInfo::Coin(Coin {\n                    denom: coin.denom,\n                    amount: Uint128::zero(),\n                }),\n                _ =\u003e return Err(ContractError::WrongFundsType {}),\n            },\n            tickets: vec![],\n            randomness_owner: None,\n            randomness: \u003c[u8; 32]\u003e::default(),\n            randomness_round: 0,\n            max_participant_number: max_participant_number\n                .unwrap_or(MAXIMUM_PARTICIPANT_NUMBER)\n                .min(MAXIMUM_PARTICIPANT_NUMBER),\n            winner: None,\n        }),\n    })?;\n    Ok(raffle_id)\n}\n\npub fn execute_buy_ticket(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    raffle_id: u64,\n    assets: AssetInfo,\n) -\u003e Result\u003cResponse\u003e {\n    // First we physcially transfer the AssetInfo\n    let transfer_messages = match \u0026assets {\n        AssetInfo::Cw20Coin(token) =\u003e {\n            let message = Cw20ExecuteMsg::Transfer {\n                recipient: env.contract.address.clone().into(),\n                amount: token.amount,\n            };\n\n            vec![into_cosmos_msg(message, token.address.clone())?]\n        }\n        // or verify the sent coins match the message coins\n        AssetInfo::Coin(coin) =\u003e {\n            if info.funds.len() != 1 {\n                return Err(anyhow!(ContractError::AssetMismatch {}));\n            }\n            if info.funds[0].denom != coin.denom || info.funds[0].amount != coin.amount {\n                return Err(anyhow!(ContractError::AssetMismatch {}));\n            }\n            vec![]\n        }\n        _ =\u003e return Err(anyhow!(ContractError::WrongAssetType {})),\n    };\n    // Then we verify the funds sent match the raffle conditions and we save the ticket that was bought\n    _buy_ticket(deps, env, info.sender.clone(), raffle_id, assets)?;\n\n    Ok(Response::new()\n        .add_messages(transfer_messages)\n        .add_attribute(\"action\", \"buy_ticket\")\n        .add_attribute(\"raffle_id\", raffle_id.to_string())\n        .add_attribute(\"owner\", info.sender))\n}\n/// Create a new raffle by depositing assets\npub fn execute_receive(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    sender: String,\n    amount: Uint128,\n    msg: Binary,\n) -\u003e Result\u003cResponse\u003e {\n    let sender = deps.api.addr_validate(\u0026sender)?;\n    match from_binary(\u0026msg)? {\n        ExecuteMsg::BuyTicket {\n            raffle_id,\n            sent_assets,\n        } =\u003e {\n            // First we make sure the received Assets is the one specified in the message\n            match sent_assets.clone() {\n                AssetInfo::Cw20Coin(Cw20Coin {\n                    address: address_received,\n                    amount: amount_received,\n                }) =\u003e {\n                    if deps.api.addr_validate(\u0026address_received)? == info.sender\n                        \u0026\u0026 amount_received == amount\n                    {\n                        // The asset is a match, we can create the raffle object and return\n                        _buy_ticket(deps, env, sender, raffle_id, sent_assets)?;\n\n                        Ok(Response::new()\n                            .add_attribute(\"action\", \"create_raffle\")\n                            .add_attribute(\"raffle_id\", raffle_id.to_string())\n                            .add_attribute(\"owner\", info.sender))\n                    } else {\n                        Err(anyhow!(ContractError::AssetMismatch {}))\n                    }\n                }\n                _ =\u003e Err(anyhow!(ContractError::AssetMismatch {})),\n            }\n        }\n        _ =\u003e Err(anyhow!(ContractError::Unauthorized {})),\n    }\n}\n\npub fn _buy_ticket(\n    deps: DepsMut,\n    env: Env,\n    owner: Addr,\n    raffle_id: u64,\n    assets: AssetInfo,\n) -\u003e Result\u003c()\u003e {\n    let mut raffle_info = RAFFLE_INFO.load(deps.storage, raffle_id)?;\n\n    // We first check the raffle is in the right state\n    can_buy_ticket(env, raffle_info.clone())?;\n\n    // We then check the sent assets match the raffle assets\n    if raffle_info.raffle_ticket_price != assets {\n        return Err(anyhow!(ContractError::PaiementNotSufficient {\n            assets_wanted: raffle_info.raffle_ticket_price,\n            assets_received: assets\n        }));\n    }\n\n    // Then we save the sender to the bought tickets\n    if raffle_info.tickets.len() \u003e= raffle_info.max_participant_number as usize {\n        return Err(anyhow!(ContractError::TooMuchTickets {}));\n    }\n    raffle_info.tickets.push(owner);\n    let ticket_amount = get_asset_amount(raffle_info.raffle_ticket_price.clone())?;\n    let accumulated_amount = get_asset_amount(raffle_info.accumulated_ticket_fee)?;\n    raffle_info.accumulated_ticket_fee = match raffle_info.raffle_ticket_price.clone() {\n        AssetInfo::Cw20Coin(coin) =\u003e AssetInfo::Cw20Coin(Cw20Coin {\n            address: coin.address,\n            amount: accumulated_amount + ticket_amount,\n        }),\n        AssetInfo::Coin(coin) =\u003e AssetInfo::Coin(Coin {\n            denom: coin.denom,\n            amount: accumulated_amount + ticket_amount,\n        }),\n        _ =\u003e return Err(anyhow!(ContractError::WrongFundsType {})),\n    };\n    RAFFLE_INFO.save(deps.storage, raffle_id, \u0026raffle_info)?;\n\n    Ok(())\n}\n\npub fn execute_update_randomness(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    raffle_id: u64,\n    randomness: DrandRandomness,\n) -\u003e Result\u003cResponse\u003e {\n    let raffle_info = RAFFLE_INFO.load(deps.storage, raffle_id)?;\n    let raffle_state = get_raffle_state(env, raffle_info);\n    if raffle_state != RaffleState::Closed {\n        return Err(anyhow!(ContractError::WrongStateForRandmness {\n            status: raffle_state\n        }));\n    }\n    // We assert the randomness is correct\n    assert_randomness_origin_and_order(deps.as_ref(), info.sender, raffle_id, randomness)\n}\n\npub fn execute_claim(\n    deps: DepsMut,\n    env: Env,\n    _info: MessageInfo,\n    raffle_id: u64,\n) -\u003e Result\u003cResponse\u003e {\n    // Loading the raffle object\n    let mut raffle_info = RAFFLE_INFO.load(deps.storage, raffle_id)?;\n\n    // We make sure the raffle is ended\n    let raffle_state = get_raffle_state(env.clone(), raffle_info.clone());\n    if raffle_state != RaffleState::Finished {\n        return Err(anyhow!(ContractError::WrongStateForClaim {\n            status: raffle_state\n        }));\n    }\n\n    // If there was no participant, the winner is the raffle owner and we pay no fees whatsoever\n    if raffle_info.tickets.is_empty() {\n        raffle_info.winner = Some(raffle_info.owner.clone());\n    } else {\n        // We get the winner of the raffle and save it to the contract. The raffle is now claimed !\n        let winner = get_raffle_winner(raffle_info.clone())?;\n        raffle_info.winner = Some(winner);\n    }\n    RAFFLE_INFO.save(deps.storage, raffle_id, \u0026raffle_info)?;\n\n    // We send the asset to the winner\n    let winner_transfer_message = get_raffle_winner_message(env.clone(), raffle_info.clone())?;\n    let funds_transfer_messages =\n        get_raffle_owner_finished_messages(deps.storage, env, raffle_info.clone())?;\n    // We distribute the ticket prices to the owner and in part to the treasury\n    Ok(Response::new()\n        .add_message(winner_transfer_message)\n        .add_messages(funds_transfer_messages)\n        .add_attribute(\"action\", \"claim\")\n        .add_attribute(\"raffle_id\", raffle_id.to_string())\n        .add_attribute(\"winner\", raffle_info.winner.unwrap()))\n}\n\n// Messages triggered after random generation\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn reply(deps: DepsMut, env: Env, msg: Reply) -\u003e Result\u003cResponse, ContractError\u003e {\n    match msg.id {\n        0 =\u003e Ok(verify(deps, env, msg.result)?),\n        _ =\u003e Err(ContractError::Unauthorized {}),\n    }\n}\n\npub fn verify(deps: DepsMut, _env: Env, msg: SubMsgResult) -\u003e Result\u003cResponse, StdError\u003e {\n    match msg {\n        SubMsgResult::Ok(subcall) =\u003e {\n            let event: Event = subcall\n                .events\n                .into_iter()\n                .find(|e| e.ty == \"wasm\")\n                .ok_or_else(|| StdError::generic_err(\"no wasm result\"))?;\n\n            let round = event\n                .attributes\n                .clone()\n                .into_iter()\n                .find(|attr| attr.key == \"round\")\n                .map_or(Err(StdError::generic_err(\"np round response\")), |round| {\n                    round\n                        .value\n                        .parse::\u003cu64\u003e()\n                        .map_err(|_| StdError::generic_err(\"round value is shit\"))\n                })?;\n\n            let randomness: String = event\n                .attributes\n                .clone()\n                .into_iter()\n                .find(|attr| attr.key == \"randomness\")\n                .map(|rand| rand.value)\n                .ok_or_else(|| StdError::generic_err(\"randomnesss value error\"))?;\n\n            let raffle_id: u64 = event\n                .attributes\n                .clone()\n                .into_iter()\n                .find(|attr| attr.key == \"raffle_id\")\n                .map(|raffle_id| raffle_id.value.parse::\u003cu64\u003e())\n                .transpose()\n                .map_err(|_| StdError::generic_err(\"raffle_id parse error\"))?\n                .ok_or_else(|| StdError::generic_err(\"raffle_id parse error 1\"))?;\n\n            let owner = deps.api.addr_validate(\n                \u0026event\n                    .attributes\n                    .into_iter()\n                    .find(|attr| attr.key == \"owner\")\n                    .map(|raffle_id| raffle_id.value)\n                    .ok_or_else(|| StdError::generic_err(\"owner parse err\"))?,\n            )?;\n\n            let mut raffle_info = RAFFLE_INFO.load(deps.storage, raffle_id)?;\n\n            raffle_info.randomness = Binary::from_base64(\u0026randomness)?\n                .as_slice()\n                .try_into()\n                .map_err(|_| StdError::generic_err(\"randomness parse err\"))?;\n            raffle_info.randomness_round = round;\n            raffle_info.randomness_owner = Some(owner.clone());\n            RAFFLE_INFO.save(deps.storage, raffle_id, \u0026raffle_info)?;\n\n            Ok(Response::new()\n                .add_attribute(\"action\", \"update_randomness\")\n                .add_attribute(\"raffle_id\", raffle_id.to_string())\n                .add_attribute(\"sender\", owner))\n        }\n        SubMsgResult::Err(_) =\u003e Err(StdError::generic_err(\"err\")),\n    }\n}\n\n#[cfg(test)]\npub mod tests {\n    use super::*;\n    use base64;\n    use cosmwasm_std::{\n        coin, coins,\n        testing::{mock_dependencies, mock_env, mock_info, MOCK_CONTRACT_ADDR},\n        Api, BankMsg, Coin, SubMsg,\n    };\n    use raffles_export::msg::VerifierExecuteMsg;\n    const HEX_PUBKEY: \u0026str = \"868f005eb8e6e4ca0a47c8a77ceaa5309a47978a7c71bc5cce96366b5d7a569937c529eeda66c7293784a9402801af31\";\n    fn init_helper(deps: DepsMut) {\n        let instantiate_msg = InstantiateMsg {\n            name: \"nft-raffle\".to_string(),\n            owner: None,\n            random_pubkey: Binary::from_base64(\u0026base64::encode(HEX_PUBKEY)).unwrap(),\n            drand_url: None,\n            verify_signature_contract: \"verifier\".to_string(),\n            fee_addr: None,\n            minimum_raffle_timeout: None,\n            minimum_raffle_duration: None,\n            raffle_fee: Some(Uint128::from(2u128)),\n            rand_fee: None,\n        };\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n\n        instantiate(deps, env, info, instantiate_msg).unwrap();\n    }\n\n    fn create_raffle(deps: DepsMut) -\u003e Result\u003cResponse\u003e {\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::CreateRaffle {\n                asset: AssetInfo::Cw721Coin(Cw721Coin {\n                    address: \"nft\".to_string(),\n                    token_id: \"token_id\".to_string(),\n                }),\n                raffle_start_timestamp: None,\n                raffle_duration: None,\n                raffle_timeout: None,\n                comment: None,\n                raffle_ticket_price: AssetInfo::Coin(coin(10000u128, \"uluna\")),\n                max_participant_number: None,\n            },\n        )\n    }\n\n    fn create_raffle_cw1155(deps: DepsMut) -\u003e Result\u003cResponse\u003e {\n        let info = mock_info(\"creator\", \u0026[]);\n        let env = mock_env();\n\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::CreateRaffle {\n                asset: AssetInfo::Cw1155Coin(Cw1155Coin {\n                    address: \"nft\".to_string(),\n                    token_id: \"token_id\".to_string(),\n                    value: Uint128::from(675u128),\n                }),\n                raffle_start_timestamp: None,\n                raffle_duration: None,\n                raffle_timeout: None,\n                comment: None,\n                raffle_ticket_price: AssetInfo::Coin(coin(10000u128, \"uluna\")),\n                max_participant_number: None,\n            },\n        )\n    }\n\n    fn buy_ticket_coin(\n        deps: DepsMut,\n        raffle_id: u64,\n        buyer: \u0026str,\n        c: Coin,\n        delta: u64,\n    ) -\u003e Result\u003cResponse\u003e {\n        let info = mock_info(buyer, \u0026[c.clone()]);\n        let mut env = mock_env();\n        env.block.time = env.block.time.plus_seconds(delta);\n        execute(\n            deps,\n            env,\n            info,\n            ExecuteMsg::BuyTicket {\n                raffle_id,\n                sent_assets: AssetInfo::Coin(c),\n            },\n        )\n    }\n\n    fn claim_nft(deps: DepsMut, raffle_id: u64, time_delta: u64) -\u003e Result\u003cResponse\u003e {\n        let info = mock_info(\"creator\", \u0026[]);\n        let mut env = mock_env();\n        env.block.time = env.block.time.plus_seconds(time_delta);\n        execute(deps, env, info, ExecuteMsg::ClaimNft { raffle_id })\n    }\n\n    #[test]\n    fn test_init_sanity() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n    }\n\n    #[test]\n    fn test_create_raffle() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n        create_raffle(deps.as_mut()).unwrap();\n    }\n\n    #[test]\n    fn test_claim_raffle() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n        create_raffle(deps.as_mut()).unwrap();\n\n        // Update the randomness internally\n        let mut raffle_info = RAFFLE_INFO.load(\u0026deps.storage, 0).unwrap();\n\n        let mut randomness: [u8; 32] = [0; 32];\n        hex::decode_to_slice(\n            \"89580f6a639add6c90dcf3d222e35415f89d9ee2cd6ef6fc4f23134cdffa5d1e\",\n            randomness.as_mut_slice(),\n        )\n        .unwrap();\n        raffle_info.randomness = randomness;\n        raffle_info.randomness_round = 2098475u64;\n        raffle_info.randomness_owner = Some(deps.api.addr_validate(\"rand_provider\").unwrap());\n        RAFFLE_INFO\n            .save(deps.as_mut().storage, 0, \u0026raffle_info)\n            .unwrap();\n\n        claim_nft(deps.as_mut(), 0, 1000u64).unwrap();\n    }\n\n    #[test]\n    fn test_ticket_and_claim_raffle() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n        create_raffle(deps.as_mut()).unwrap();\n\n        //Buy some tickets\n        buy_ticket_coin(deps.as_mut(), 0, \"first\", coin(10, \"uluna\"), 0u64).unwrap_err();\n        buy_ticket_coin(deps.as_mut(), 0, \"first\", coin(1000000, \"uluna\"), 0u64).unwrap_err();\n        buy_ticket_coin(deps.as_mut(), 0, \"first\", coin(10000, \"uluna\"), 0u64).unwrap();\n        buy_ticket_coin(deps.as_mut(), 0, \"first\", coin(10000, \"uluna\"), 0u64).unwrap();\n        buy_ticket_coin(deps.as_mut(), 0, \"second\", coin(10000, \"uluna\"), 0u64).unwrap();\n        buy_ticket_coin(deps.as_mut(), 0, \"third\", coin(10000, \"uluna\"), 0u64).unwrap();\n        buy_ticket_coin(deps.as_mut(), 0, \"fourth\", coin(10000, \"uluna\"), 0u64).unwrap();\n\n        // Update the randomness internally\n        let mut raffle_info = RAFFLE_INFO.load(\u0026deps.storage, 0).unwrap();\n\n        let mut randomness: [u8; 32] = [0; 32];\n        hex::decode_to_slice(\n            \"89580f6a639add6c90dcf3d222e35415f89d9ee2cd6ef6fc4f23134cdffa5d1e\",\n            randomness.as_mut_slice(),\n        )\n        .unwrap();\n        raffle_info.randomness = randomness;\n        raffle_info.randomness_round = 2098475u64;\n        raffle_info.randomness_owner = Some(deps.api.addr_validate(\"rand_provider\").unwrap());\n        RAFFLE_INFO\n            .save(deps.as_mut().storage, 0, \u0026raffle_info)\n            .unwrap();\n\n        let response = claim_nft(deps.as_mut(), 0, 1000u64).unwrap();\n\n        assert_eq!(\n            response.messages,\n            vec![\n                SubMsg::new(\n                    into_cosmos_msg(\n                        Cw721ExecuteMsg::TransferNft {\n                            recipient: \"first\".to_string(),\n                            token_id: \"token_id\".to_string()\n                        },\n                        \"nft\".to_string()\n                    )\n                    .unwrap()\n                ),\n                SubMsg::new(BankMsg::Send {\n                    to_address: \"rand_provider\".to_string(),\n                    amount: coins(5, \"uluna\")\n                }),\n                SubMsg::new(BankMsg::Send {\n                    to_address: \"creator\".to_string(),\n                    amount: coins(10, \"uluna\")\n                }),\n                SubMsg::new(BankMsg::Send {\n                    to_address: \"creator\".to_string(),\n                    amount: coins(49985u128, \"uluna\")\n                }),\n            ]\n        );\n\n        // You can't buy tickets when the raffle is over\n        buy_ticket_coin(deps.as_mut(), 0, \"first\", coin(10000, \"uluna\"), 100u64).unwrap_err();\n        buy_ticket_coin(deps.as_mut(), 0, \"first\", coin(10000, \"uluna\"), 1000u64).unwrap_err();\n    }\n\n    #[test]\n    fn test_ticket_and_claim_raffle_cw1155() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n        create_raffle_cw1155(deps.as_mut()).unwrap();\n\n        //Buy some tickets\n        buy_ticket_coin(deps.as_mut(), 0, \"first\", coin(10, \"uluna\"), 0u64).unwrap_err();\n        buy_ticket_coin(deps.as_mut(), 0, \"first\", coin(1000000, \"uluna\"), 0u64).unwrap_err();\n        buy_ticket_coin(deps.as_mut(), 0, \"first\", coin(10000, \"uluna\"), 0u64).unwrap();\n        buy_ticket_coin(deps.as_mut(), 0, \"first\", coin(10000, \"uluna\"), 0u64).unwrap();\n        buy_ticket_coin(deps.as_mut(), 0, \"second\", coin(10000, \"uluna\"), 0u64).unwrap();\n        buy_ticket_coin(deps.as_mut(), 0, \"third\", coin(10000, \"uluna\"), 0u64).unwrap();\n        buy_ticket_coin(deps.as_mut(), 0, \"fourth\", coin(10000, \"uluna\"), 0u64).unwrap();\n\n        // Update the randomness internally\n        let mut raffle_info = RAFFLE_INFO.load(\u0026deps.storage, 0).unwrap();\n\n        let mut randomness: [u8; 32] = [0; 32];\n        hex::decode_to_slice(\n            \"89580f6a639add6c90dcf3d222e35415f89d9ee2cd6ef6fc4f23134cdffa5d1e\",\n            randomness.as_mut_slice(),\n        )\n        .unwrap();\n        raffle_info.randomness = randomness;\n        raffle_info.randomness_round = 2098475u64;\n        raffle_info.randomness_owner = Some(deps.api.addr_validate(\"rand_provider\").unwrap());\n        RAFFLE_INFO\n            .save(deps.as_mut().storage, 0, \u0026raffle_info)\n            .unwrap();\n\n        let response = claim_nft(deps.as_mut(), 0, 1000u64).unwrap();\n\n        assert_eq!(\n            response.messages,\n            vec![\n                SubMsg::new(\n                    into_cosmos_msg(\n                        Cw1155ExecuteMsg::SendFrom {\n                            from: MOCK_CONTRACT_ADDR.to_string(),\n                            to: \"first\".to_string(),\n                            token_id: \"token_id\".to_string(),\n                            value: Uint128::from(675u128),\n                            msg: None,\n                        },\n                        \"nft\".to_string()\n                    )\n                    .unwrap()\n                ),\n                SubMsg::new(BankMsg::Send {\n                    to_address: \"rand_provider\".to_string(),\n                    amount: coins(5, \"uluna\")\n                }),\n                SubMsg::new(BankMsg::Send {\n                    to_address: \"creator\".to_string(),\n                    amount: coins(10, \"uluna\")\n                }),\n                SubMsg::new(BankMsg::Send {\n                    to_address: \"creator\".to_string(),\n                    amount: coins(49985u128, \"uluna\")\n                }),\n            ]\n        );\n\n        // You can't buy tickets when the raffle is over\n        buy_ticket_coin(deps.as_mut(), 0, \"first\", coin(10000, \"uluna\"), 100u64).unwrap_err();\n        buy_ticket_coin(deps.as_mut(), 0, \"first\", coin(10000, \"uluna\"), 1000u64).unwrap_err();\n    }\n\n    #[test]\n    fn test_randomness_provider() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n        create_raffle_cw1155(deps.as_mut()).unwrap();\n        let mut env = mock_env();\n        env.block.time = env.block.time.plus_seconds(2u64);\n        let info = mock_info(\"anyone\", \u0026[]);\n        let randomness = DrandRandomness {\n            round: 90,\n            signature: Binary::from_base64(\"quid\").unwrap(),\n            previous_signature: Binary::from_base64(\"quid\").unwrap(),\n        };\n        let response = execute(\n            deps.as_mut(),\n            env,\n            info,\n            ExecuteMsg::UpdateRandomness {\n                raffle_id: 0,\n                randomness: randomness.clone(),\n            },\n        )\n        .unwrap();\n        let msg = VerifierExecuteMsg::Verify {\n            randomness,\n            pubkey: Binary::from_base64(\u0026base64::encode(HEX_PUBKEY)).unwrap(),\n            raffle_id: 0,\n            owner: \"anyone\".to_string(),\n        };\n        \n        assert_eq!(\n            response.messages,\n            vec![SubMsg::reply_on_success(\n                into_cosmos_msg(msg, \"verifier\".to_string()).unwrap(),\n                0\n            )]\n        );\n    }\n\n    // Admin functions\n    #[test]\n    fn test_renounce() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n        let info = mock_info(\"bad_person\", \u0026[]);\n        let env = mock_env();\n        execute(deps.as_mut(), env.clone(), info, ExecuteMsg::Renounce {}).unwrap_err();\n\n        let info = mock_info(\"creator\", \u0026[]);\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            ExecuteMsg::Renounce {},\n        )\n        .unwrap();\n\n        execute(deps.as_mut(), env, info, ExecuteMsg::Renounce {}).unwrap_err();\n    }\n\n    #[test]\n    fn test_lock() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n        assert!(!CONTRACT_INFO.load(\u0026deps.storage).unwrap().lock);\n\n        let info = mock_info(\"bad_person\", \u0026[]);\n        let env = mock_env();\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            ExecuteMsg::ToggleLock { lock: false },\n        )\n        .unwrap_err();\n\n        let info = mock_info(\"creator\", \u0026[]);\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            ExecuteMsg::ToggleLock { lock: true },\n        )\n        .unwrap();\n        assert!(CONTRACT_INFO.load(\u0026deps.storage).unwrap().lock);\n\n        execute(\n            deps.as_mut(),\n            env,\n            info,\n            ExecuteMsg::ToggleLock { lock: false },\n        )\n        .unwrap();\n        assert!(!CONTRACT_INFO.load(\u0026deps.storage).unwrap().lock);\n    }\n\n    #[test]\n    fn test_change_parameter() {\n        let mut deps = mock_dependencies();\n        init_helper(deps.as_mut());\n\n        let info = mock_info(\"bad_person\", \u0026[]);\n        let env = mock_env();\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info,\n            ExecuteMsg::ChangeParameter {\n                parameter: \"any\".to_string(),\n                value: \"any\".to_string(),\n            },\n        )\n        .unwrap_err();\n\n        let info = mock_info(\"creator\", \u0026[]);\n        execute(\n            deps.as_mut(),\n            env.clone(),\n            info.clone(),\n            ExecuteMsg::ChangeParameter {\n                parameter: \"any\".to_string(),\n                value: \"any\".to_string(),\n            },\n        )\n        .unwrap_err();\n\n        execute(\n            deps.as_mut(),\n            env,\n            info,\n            ExecuteMsg::ChangeParameter {\n                parameter: \"fee_addr\".to_string(),\n                value: \"any\".to_string(),\n            },\n        )\n        .unwrap();\n        assert_eq!(\n            CONTRACT_INFO\n                .load(\u0026deps.storage)\n                .unwrap()\n                .fee_addr\n                .to_string(),\n            \"any\"\n        );\n    }\n}\n","traces":[{"line":37,"address":[1072672,1078329],"length":1,"stats":{"Line":7},"fn_name":"instantiate"},{"line":45,"address":[1073148,1072996,1072934,1072730],"length":1,"stats":{"Line":7},"fn_name":null},{"line":47,"address":[1073210,1073405,1073560,1072966],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[1073268],"length":1,"stats":{"Line":7},"fn_name":null},{"line":51,"address":[1073299,1074135,1073811,1073691,1073745],"length":1,"stats":{"Line":8},"fn_name":null},{"line":54,"address":[1074421,1074501,1073901,1074754,1074367],"length":1,"stats":{"Line":14},"fn_name":null},{"line":58,"address":[1074587,1074952],"length":1,"stats":{"Line":8},"fn_name":null},{"line":62,"address":[1075016],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[1075071],"length":1,"stats":{"Line":7},"fn_name":null},{"line":67,"address":[1075169],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[1075215],"length":1,"stats":{"Line":7},"fn_name":null},{"line":74,"address":[1075292],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[1075330,1075512,1075929,1075446],"length":1,"stats":{"Line":8},"fn_name":null},{"line":77,"address":[1076500,1076632,1076804],"length":1,"stats":{"Line":7},"fn_name":null},{"line":78,"address":[1077419,1076614,1077555],"length":1,"stats":{"Line":15},"fn_name":null},{"line":81,"address":[1077515],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[1081745,1078352],"length":1,"stats":{"Line":1},"fn_name":"execute"},{"line":86,"address":[1078417],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[1078650],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[1078737],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[1078763],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[1078789],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[1078807],"length":1,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[1078833],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[1078881],"length":1,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[1079049],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[1079330],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[1079629],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[1080167],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[1080199],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[1080234],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[1080301],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[1080344],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[1081425],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[1081465],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[1080458],"length":1,"stats":{"Line":1},"fn_name":null},{"line":137,"address":[1080600],"length":1,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[1080814],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[1080962],"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[1081090],"length":1,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[1081162],"length":1,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[1081894,1081776],"length":1,"stats":{"Line":0},"fn_name":"migrate"},{"line":154,"address":[1081803],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[1083728,1081936],"length":1,"stats":{"Line":0},"fn_name":"query"},{"line":159,"address":[1081968],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[837904,837911],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":161,"address":[1082091],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[838160,838167],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":165,"address":[1082143],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[838423,838416],"length":1,"stats":{"Line":0},"fn_name":"{closure#2}"},{"line":179,"address":[1017551,1016496],"length":1,"stats":{"Line":1},"fn_name":"execute_renounce"},{"line":180,"address":[1016673,1016531,1016930,1016829],"length":1,"stats":{"Line":3},"fn_name":null},{"line":182,"address":[1016993,1017067,1016775],"length":1,"stats":{"Line":2},"fn_name":null},{"line":183,"address":[1017424,1017255,1017033,1017179],"length":1,"stats":{"Line":2},"fn_name":null},{"line":185,"address":[1017240,1017613,1017749],"length":1,"stats":{"Line":3},"fn_name":null},{"line":188,"address":[1017709],"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[1018320,1020167],"length":1,"stats":{"Line":0},"fn_name":"set_new_fee_addr"},{"line":199,"address":[1018485,1018622,1018721,1018363],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[1019145,1018787,1018584,1018844,1018993],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[1019202,1019336,1018978,1019267],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[1019299,1019481,1019653,1019427],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[1019466,1019942,1019806],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[1019902],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[1021404,1020192],"length":1,"stats":{"Line":1},"fn_name":"execute_toggle_lock"},{"line":217,"address":[1020608,1020237,1020363,1020507],"length":1,"stats":{"Line":3},"fn_name":null},{"line":219,"address":[1020464],"length":1,"stats":{"Line":1},"fn_name":null},{"line":220,"address":[1020719,1020935,1020766,1020674,1020475],"length":1,"stats":{"Line":3},"fn_name":null},{"line":222,"address":[1021150,1021026,1020751,1021255],"length":1,"stats":{"Line":4},"fn_name":null},{"line":224,"address":[1021122],"length":1,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[1021201,1021350,1021143],"length":1,"stats":{"Line":1},"fn_name":null},{"line":228,"address":[1021424,1026450],"length":1,"stats":{"Line":1},"fn_name":"execute_change_parameter"},{"line":235,"address":[1021490,1021932,1021663,1021804],"length":1,"stats":{"Line":3},"fn_name":null},{"line":237,"address":[1021778,1021997],"length":1,"stats":{"Line":2},"fn_name":null},{"line":238,"address":[1022093,1022019],"length":1,"stats":{"Line":2},"fn_name":null},{"line":239,"address":[1022160,1022446,1022606],"length":1,"stats":{"Line":1},"fn_name":null},{"line":240,"address":[1022376,1022655,1022713],"length":1,"stats":{"Line":2},"fn_name":null},{"line":242,"address":[1022872,1022115],"length":1,"stats":{"Line":2},"fn_name":null},{"line":243,"address":[1023195,1022931],"length":1,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[1023174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[1022894,1023239],"length":1,"stats":{"Line":2},"fn_name":null},{"line":247,"address":[1023298,1023562],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[1023541],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[1023261,1023606],"length":1,"stats":{"Line":2},"fn_name":null},{"line":251,"address":[1023665],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[1023900],"length":1,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[1023928,1023628],"length":1,"stats":{"Line":2},"fn_name":null},{"line":255,"address":[1023984],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[1024195],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[1024362,1024220,1023950],"length":1,"stats":{"Line":2},"fn_name":null},{"line":259,"address":[1024276,1024367],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[1024446,1024242],"length":1,"stats":{"Line":2},"fn_name":null},{"line":262,"address":[1024772,1024510,1024935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[1024962,1024702,1025023],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[1025354,1025131,1024468],"length":1,"stats":{"Line":2},"fn_name":null},{"line":266,"address":[1025211,1025359],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[1026103,1025137],"length":1,"stats":{"Line":2},"fn_name":null},{"line":271,"address":[1022825,1025507,1025450,1025662],"length":1,"stats":{"Line":2},"fn_name":null},{"line":273,"address":[1025689,1025776,1025858,1025489],"length":1,"stats":{"Line":4},"fn_name":null},{"line":275,"address":[1025745],"length":1,"stats":{"Line":1},"fn_name":null},{"line":276,"address":[1025827],"length":1,"stats":{"Line":1},"fn_name":null},{"line":281,"address":[1026480,1031279],"length":1,"stats":{"Line":1},"fn_name":"execute_create_raffle"},{"line":293,"address":[1027248,1027096,1026765,1026994],"length":1,"stats":{"Line":3},"fn_name":null},{"line":295,"address":[1027069],"length":1,"stats":{"Line":2},"fn_name":null},{"line":296,"address":[1027348,1027578],"length":1,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[1027302],"length":1,"stats":{"Line":1},"fn_name":null},{"line":301,"address":[1027751],"length":1,"stats":{"Line":2},"fn_name":null},{"line":303,"address":[1028989,1027771],"length":1,"stats":{"Line":3},"fn_name":null},{"line":304,"address":[1029004],"length":1,"stats":{"Line":1},"fn_name":null},{"line":307,"address":[1029259,1029111,1029481],"length":1,"stats":{"Line":3},"fn_name":null},{"line":309,"address":[1027809],"length":1,"stats":{"Line":1},"fn_name":null},{"line":311,"address":[1027837],"length":1,"stats":{"Line":1},"fn_name":null},{"line":312,"address":[1028046],"length":1,"stats":{"Line":1},"fn_name":null},{"line":313,"address":[1028137],"length":1,"stats":{"Line":1},"fn_name":null},{"line":314,"address":[1028168],"length":1,"stats":{"Line":1},"fn_name":null},{"line":318,"address":[1028540,1028759,1028344],"length":1,"stats":{"Line":2},"fn_name":null},{"line":320,"address":[1027847,1027666],"length":1,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[1028845],"length":1,"stats":{"Line":1},"fn_name":null},{"line":325,"address":[1028880],"length":1,"stats":{"Line":2},"fn_name":null},{"line":326,"address":[1028963],"length":1,"stats":{"Line":1},"fn_name":null},{"line":327,"address":[1029631],"length":1,"stats":{"Line":2},"fn_name":null},{"line":331,"address":[1029702],"length":1,"stats":{"Line":1},"fn_name":null},{"line":332,"address":[1029733],"length":1,"stats":{"Line":2},"fn_name":null},{"line":336,"address":[1031033,1030739,1030829,1030179,1030964],"length":1,"stats":{"Line":11},"fn_name":null},{"line":337,"address":[1030579],"length":1,"stats":{"Line":1},"fn_name":null},{"line":338,"address":[1030794],"length":1,"stats":{"Line":1},"fn_name":null},{"line":339,"address":[1030880,1031007,1030802],"length":1,"stats":{"Line":3},"fn_name":null},{"line":340,"address":[1030933],"length":1,"stats":{"Line":3},"fn_name":null},{"line":344,"address":[1037604,1031312],"length":1,"stats":{"Line":0},"fn_name":"execute_receive_nft"},{"line":352,"address":[1031409,1031833,1031681,1031993],"length":1,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[1031815,1032106,1032058],"length":1,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[1032653],"length":1,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[1033282,1032957],"length":1,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[1033403],"length":1,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[1034357,1033907,1033850,1036463,1034266,1034385,1034310,1033443],"length":1,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[1034336,1034272,1034210,1034366],"length":1,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[1034547],"length":1,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[1034582],"length":1,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[1034649],"length":1,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[1034689],"length":1,"stats":{"Line":0},"fn_name":null},{"line":382,"address":[1034777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[1034817],"length":1,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[1035177,1035945,1036163,1036232,1036028],"length":1,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[1035993],"length":1,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[1036001,1036079,1036206],"length":1,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[1036132],"length":1,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[1034395,1036291],"length":1,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[1033732,1033501],"length":1,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[1033197,1032967],"length":1,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[1044070,1037664],"length":1,"stats":{"Line":0},"fn_name":"execute_receive_1155"},{"line":412,"address":[1038201,1038361,1038049,1037777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[1038183,1038474,1038426],"length":1,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[1039021],"length":1,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[1039650,1039325],"length":1,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[1039771],"length":1,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[1039843,1042929,1040250,1040823,1040757,1040851,1040666,1040710,1040307],"length":1,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[1040736],"length":1,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[1040672,1040802,1040610,1040832],"length":1,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[1041013],"length":1,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[1041048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[1041115],"length":1,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[1041155],"length":1,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[1041243],"length":1,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[1041283],"length":1,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[1042411,1041643,1042629,1042698,1042494],"length":1,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[1042459],"length":1,"stats":{"Line":0},"fn_name":null},{"line":450,"address":[1042467,1042545,1042672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[1042598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":453,"address":[1040861,1042757],"length":1,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[1040132,1039901],"length":1,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[1039565,1039335],"length":1,"stats":{"Line":0},"fn_name":null},{"line":465,"address":[1044128,1046592],"length":1,"stats":{"Line":1},"fn_name":"_create_raffle"},{"line":477,"address":[1044480,1044323,1044862,1044630],"length":1,"stats":{"Line":3},"fn_name":null},{"line":480,"address":[1044972,1045231,1045377,1044605,1044924],"length":1,"stats":{"Line":5},"fn_name":null},{"line":481,"address":[833298,833104],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":482,"address":[833337,833328,833125],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":483,"address":[833200],"length":1,"stats":{"Line":2},"fn_name":null},{"line":488,"address":[833424,833463,835935],"length":1,"stats":{"Line":5},"fn_name":"{closure#1}"},{"line":493,"address":[833717],"length":1,"stats":{"Line":0},"fn_name":null},{"line":494,"address":[835215],"length":1,"stats":{"Line":3},"fn_name":null},{"line":495,"address":[833576],"length":1,"stats":{"Line":1},"fn_name":null},{"line":496,"address":[833607],"length":1,"stats":{"Line":2},"fn_name":null},{"line":497,"address":[833812,833675],"length":1,"stats":{"Line":2},"fn_name":null},{"line":499,"address":[833804],"length":1,"stats":{"Line":3},"fn_name":null},{"line":500,"address":[833881,833892,833925,833873],"length":1,"stats":{"Line":4},"fn_name":null},{"line":501,"address":[833888,833877],"length":1,"stats":{"Line":6},"fn_name":null},{"line":502,"address":[833917],"length":1,"stats":{"Line":3},"fn_name":null},{"line":503,"address":[834000,833967,833949],"length":1,"stats":{"Line":3},"fn_name":null},{"line":504,"address":[833945,833963],"length":1,"stats":{"Line":6},"fn_name":null},{"line":505,"address":[833992],"length":1,"stats":{"Line":3},"fn_name":null},{"line":506,"address":[834020],"length":1,"stats":{"Line":3},"fn_name":null},{"line":507,"address":[834058],"length":1,"stats":{"Line":2},"fn_name":null},{"line":508,"address":[834088],"length":1,"stats":{"Line":1},"fn_name":null},{"line":509,"address":[834256,834896],"length":1,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[834309],"length":1,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[834341],"length":1,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[834719,834373],"length":1,"stats":{"Line":4},"fn_name":null},{"line":514,"address":[834426],"length":1,"stats":{"Line":1},"fn_name":null},{"line":515,"address":[834458],"length":1,"stats":{"Line":3},"fn_name":null},{"line":517,"address":[834177],"length":1,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[834876],"length":1,"stats":{"Line":3},"fn_name":null},{"line":520,"address":[835029],"length":1,"stats":{"Line":1},"fn_name":null},{"line":521,"address":[835041],"length":1,"stats":{"Line":3},"fn_name":null},{"line":523,"address":[835109,835191],"length":1,"stats":{"Line":4},"fn_name":null},{"line":526,"address":[835203],"length":1,"stats":{"Line":1},"fn_name":null},{"line":529,"address":[1046461],"length":1,"stats":{"Line":1},"fn_name":null},{"line":532,"address":[1046608,1050255],"length":1,"stats":{"Line":1},"fn_name":"execute_buy_ticket"},{"line":540,"address":[1046671],"length":1,"stats":{"Line":1},"fn_name":null},{"line":541,"address":[1046906],"length":1,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[1048134,1046926],"length":1,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[1048149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":547,"address":[1048235,1048437,1049113,1048633],"length":1,"stats":{"Line":0},"fn_name":null},{"line":550,"address":[1046964],"length":1,"stats":{"Line":1},"fn_name":null},{"line":551,"address":[1047272,1046984],"length":1,"stats":{"Line":2},"fn_name":null},{"line":552,"address":[1047320],"length":1,"stats":{"Line":0},"fn_name":null},{"line":554,"address":[1047286,1047573],"length":1,"stats":{"Line":2},"fn_name":null},{"line":555,"address":[1047718],"length":1,"stats":{"Line":0},"fn_name":null},{"line":557,"address":[1047708],"length":1,"stats":{"Line":1},"fn_name":null},{"line":559,"address":[1047171,1046821,1047010],"length":1,"stats":{"Line":0},"fn_name":null},{"line":562,"address":[1049164,1049517,1049469,1047990,1049368],"length":1,"stats":{"Line":3},"fn_name":null},{"line":564,"address":[1049997,1050074,1049451,1049862,1049772],"length":1,"stats":{"Line":10},"fn_name":null},{"line":565,"address":[1049708],"length":1,"stats":{"Line":2},"fn_name":null},{"line":566,"address":[1049827],"length":1,"stats":{"Line":2},"fn_name":null},{"line":567,"address":[1049913,1050040,1049835],"length":1,"stats":{"Line":2},"fn_name":null},{"line":568,"address":[1049966],"length":1,"stats":{"Line":2},"fn_name":null},{"line":571,"address":[1054891,1050288],"length":1,"stats":{"Line":0},"fn_name":"execute_receive"},{"line":579,"address":[1050632,1050400,1050784,1050944],"length":1,"stats":{"Line":0},"fn_name":null},{"line":580,"address":[1051057,1051009,1050766],"length":1,"stats":{"Line":0},"fn_name":null},{"line":581,"address":[1051428],"length":1,"stats":{"Line":0},"fn_name":null},{"line":586,"address":[1051875,1051556],"length":1,"stats":{"Line":0},"fn_name":null},{"line":587,"address":[1051948],"length":1,"stats":{"Line":0},"fn_name":null},{"line":591,"address":[1052833,1052379,1054340,1052789,1052436,1052020,1052902,1052874],"length":1,"stats":{"Line":0},"fn_name":null},{"line":592,"address":[1052795,1052736,1052859,1052883],"length":1,"stats":{"Line":0},"fn_name":null},{"line":595,"address":[1053357,1053392,1052994],"length":1,"stats":{"Line":0},"fn_name":null},{"line":597,"address":[1054111,1054042,1053339,1053824,1053907],"length":1,"stats":{"Line":0},"fn_name":null},{"line":598,"address":[1053872],"length":1,"stats":{"Line":0},"fn_name":null},{"line":599,"address":[1054085,1053880,1053958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":600,"address":[1054011],"length":1,"stats":{"Line":0},"fn_name":null},{"line":602,"address":[1052912,1054170],"length":1,"stats":{"Line":0},"fn_name":null},{"line":605,"address":[1052066,1052276],"length":1,"stats":{"Line":0},"fn_name":null},{"line":608,"address":[1051566,1051793],"length":1,"stats":{"Line":0},"fn_name":null},{"line":612,"address":[1059993,1054944],"length":1,"stats":{"Line":1},"fn_name":"_buy_ticket"},{"line":619,"address":[1055459,1055216,1055011,1055635],"length":1,"stats":{"Line":2},"fn_name":null},{"line":622,"address":[1055929,1055820,1055366,1055985,1055697],"length":1,"stats":{"Line":4},"fn_name":null},{"line":625,"address":[1055907,1056041],"length":1,"stats":{"Line":2},"fn_name":null},{"line":626,"address":[1056236],"length":1,"stats":{"Line":1},"fn_name":null},{"line":627,"address":[1056081],"length":1,"stats":{"Line":1},"fn_name":null},{"line":628,"address":[1056169],"length":1,"stats":{"Line":1},"fn_name":null},{"line":633,"address":[1056657,1056047],"length":1,"stats":{"Line":2},"fn_name":null},{"line":634,"address":[1056732],"length":1,"stats":{"Line":0},"fn_name":null},{"line":636,"address":[1056675],"length":1,"stats":{"Line":2},"fn_name":null},{"line":637,"address":[1056985,1057251,1057310],"length":1,"stats":{"Line":2},"fn_name":null},{"line":638,"address":[1057513,1057353,1057460,1057140],"length":1,"stats":{"Line":4},"fn_name":null},{"line":639,"address":[1057437,1058339,1057540],"length":1,"stats":{"Line":6},"fn_name":null},{"line":640,"address":[1058481,1057685],"length":1,"stats":{"Line":0},"fn_name":null},{"line":641,"address":[1057741],"length":1,"stats":{"Line":0},"fn_name":null},{"line":642,"address":[1057773],"length":1,"stats":{"Line":0},"fn_name":null},{"line":644,"address":[1058206,1057823],"length":1,"stats":{"Line":4},"fn_name":null},{"line":645,"address":[1057879],"length":1,"stats":{"Line":2},"fn_name":null},{"line":646,"address":[1057911],"length":1,"stats":{"Line":2},"fn_name":null},{"line":648,"address":[1058106,1057593,1057935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":650,"address":[1058880,1058762,1059053],"length":1,"stats":{"Line":2},"fn_name":null},{"line":652,"address":[1058846],"length":1,"stats":{"Line":2},"fn_name":null},{"line":655,"address":[1061454,1060032],"length":1,"stats":{"Line":1},"fn_name":"execute_update_randomness"},{"line":662,"address":[1060248,1060650,1060498,1060091],"length":1,"stats":{"Line":2},"fn_name":null},{"line":663,"address":[1060373,1060708],"length":1,"stats":{"Line":2},"fn_name":null},{"line":664,"address":[1060715,1060790],"length":1,"stats":{"Line":2},"fn_name":null},{"line":665,"address":[1060829],"length":1,"stats":{"Line":0},"fn_name":null},{"line":666,"address":[1060822],"length":1,"stats":{"Line":0},"fn_name":null},{"line":670,"address":[1061238,1060812],"length":1,"stats":{"Line":2},"fn_name":null},{"line":673,"address":[1066106,1061488],"length":1,"stats":{"Line":1},"fn_name":"execute_claim"},{"line":680,"address":[1062005,1061853,1061728,1061534],"length":1,"stats":{"Line":2},"fn_name":null},{"line":683,"address":[1061838,1062059,1062131,1062249],"length":1,"stats":{"Line":3},"fn_name":null},{"line":684,"address":[1062272,1062219],"length":1,"stats":{"Line":2},"fn_name":null},{"line":685,"address":[1062307],"length":1,"stats":{"Line":0},"fn_name":null},{"line":686,"address":[1062300],"length":1,"stats":{"Line":0},"fn_name":null},{"line":691,"address":[1062278,1062572,1062734,1063242],"length":1,"stats":{"Line":5},"fn_name":null},{"line":692,"address":[1062620,1062736],"length":1,"stats":{"Line":1},"fn_name":null},{"line":695,"address":[1062594,1063108,1063151,1062888],"length":1,"stats":{"Line":4},"fn_name":null},{"line":696,"address":[1063178,1063247,1063012],"length":1,"stats":{"Line":4},"fn_name":null},{"line":698,"address":[1062824,1063375,1063434,1063589],"length":1,"stats":{"Line":2},"fn_name":null},{"line":701,"address":[1064189,1064221,1063419,1063616],"length":1,"stats":{"Line":2},"fn_name":null},{"line":702,"address":[1064546,1064394,1064602,1064069,1064271],"length":1,"stats":{"Line":2},"fn_name":null},{"line":705,"address":[1065262,1064531,1065070,1065367,1064980,1064868],"length":1,"stats":{"Line":6},"fn_name":null},{"line":706,"address":[1064708],"length":1,"stats":{"Line":1},"fn_name":null},{"line":707,"address":[1064916],"length":1,"stats":{"Line":1},"fn_name":null},{"line":708,"address":[1065035],"length":1,"stats":{"Line":1},"fn_name":null},{"line":709,"address":[1065244,1065043,1065121],"length":1,"stats":{"Line":1},"fn_name":null},{"line":710,"address":[1065174,1065313,1065484],"length":1,"stats":{"Line":1},"fn_name":null},{"line":715,"address":[1083776,1084534],"length":1,"stats":{"Line":0},"fn_name":"reply"},{"line":716,"address":[1083808],"length":1,"stats":{"Line":0},"fn_name":null},{"line":717,"address":[1084192,1084144,1083865,1084462],"length":1,"stats":{"Line":0},"fn_name":null},{"line":718,"address":[1084067],"length":1,"stats":{"Line":0},"fn_name":null},{"line":722,"address":[1066144,1072647],"length":1,"stats":{"Line":0},"fn_name":"verify"},{"line":723,"address":[1066194],"length":1,"stats":{"Line":0},"fn_name":null},{"line":724,"address":[1066245],"length":1,"stats":{"Line":0},"fn_name":null},{"line":725,"address":[1066281,1066904,1066495,1066560,1066620],"length":1,"stats":{"Line":0},"fn_name":null},{"line":728,"address":[836576,836603],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":729,"address":[836652,836640],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":731,"address":[1067082,1067367,1067392,1067267,1067594,1066998],"length":1,"stats":{"Line":0},"fn_name":null},{"line":735,"address":[836688,836715],"length":1,"stats":{"Line":0},"fn_name":"{closure#2}"},{"line":736,"address":[836925,836752],"length":1,"stats":{"Line":0},"fn_name":"{closure#3}"},{"line":737,"address":[836779,836875],"length":1,"stats":{"Line":0},"fn_name":null},{"line":740,"address":[836979,836960],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":743,"address":[1068103,1067680,1067832],"length":1,"stats":{"Line":0},"fn_name":null},{"line":747,"address":[837035,837008],"length":1,"stats":{"Line":0},"fn_name":"{closure#4}"},{"line":748,"address":[837095,837072],"length":1,"stats":{"Line":0},"fn_name":"{closure#5}"},{"line":749,"address":[837148,837136],"length":1,"stats":{"Line":0},"fn_name":"{closure#6}"},{"line":751,"address":[1068170,1068254,1068755,1068356,1068670,1068959],"length":1,"stats":{"Line":0},"fn_name":null},{"line":755,"address":[837184,837211],"length":1,"stats":{"Line":0},"fn_name":"{closure#7}"},{"line":756,"address":[837248,837257],"length":1,"stats":{"Line":0},"fn_name":"{closure#8}"},{"line":758,"address":[837443,837424],"length":1,"stats":{"Line":0},"fn_name":"{closure#9}"},{"line":759,"address":[837472,837484],"length":1,"stats":{"Line":0},"fn_name":"{closure#10}"},{"line":761,"address":[1069928,1069598,1069652,1069045],"length":1,"stats":{"Line":0},"fn_name":null},{"line":762,"address":[1069509,1069228,1069063],"length":1,"stats":{"Line":0},"fn_name":null},{"line":765,"address":[837547,837520],"length":1,"stats":{"Line":0},"fn_name":"{closure#11}"},{"line":766,"address":[837584,837607],"length":1,"stats":{"Line":0},"fn_name":"{closure#12}"},{"line":767,"address":[837648,837660],"length":1,"stats":{"Line":0},"fn_name":"{closure#13}"},{"line":770,"address":[1070452,1070093,1070300],"length":1,"stats":{"Line":0},"fn_name":null},{"line":772,"address":[1071286,1070911,1070272,1070587,1070984,1070511],"length":1,"stats":{"Line":0},"fn_name":null},{"line":775,"address":[837707,837696],"length":1,"stats":{"Line":0},"fn_name":"{closure#14}"},{"line":776,"address":[1071384],"length":1,"stats":{"Line":0},"fn_name":null},{"line":777,"address":[1071551,1071408],"length":1,"stats":{"Line":0},"fn_name":null},{"line":778,"address":[1071854,1071642,1071699,1071506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":780,"address":[1071681,1072366,1072161,1072078,1072297],"length":1,"stats":{"Line":0},"fn_name":null},{"line":781,"address":[1072126],"length":1,"stats":{"Line":0},"fn_name":null},{"line":782,"address":[1072212,1072134,1072340],"length":1,"stats":{"Line":0},"fn_name":null},{"line":783,"address":[1072257],"length":1,"stats":{"Line":0},"fn_name":null},{"line":785,"address":[1066339],"length":1,"stats":{"Line":0},"fn_name":null},{"line":800,"address":[1185673,1185504],"length":1,"stats":{"Line":6},"fn_name":"init_helper"},{"line":802,"address":[1185532],"length":1,"stats":{"Line":6},"fn_name":null},{"line":804,"address":[1185569,1185698,1185758],"length":1,"stats":{"Line":18},"fn_name":null},{"line":806,"address":[1185800],"length":1,"stats":{"Line":1},"fn_name":null},{"line":810,"address":[1185863,1185944],"length":1,"stats":{"Line":7},"fn_name":null},{"line":813,"address":[1186451,1186535],"length":1,"stats":{"Line":8},"fn_name":null},{"line":814,"address":[1186543],"length":1,"stats":{"Line":6},"fn_name":null},{"line":816,"address":[1186857,1186567],"length":1,"stats":{"Line":2},"fn_name":null},{"line":819,"address":[1186976,1188240],"length":1,"stats":{"Line":1},"fn_name":"create_raffle"},{"line":820,"address":[1186997],"length":1,"stats":{"Line":2},"fn_name":null},{"line":821,"address":[1187064],"length":1,"stats":{"Line":1},"fn_name":null},{"line":824,"address":[1187084],"length":1,"stats":{"Line":2},"fn_name":null},{"line":825,"address":[1187119],"length":1,"stats":{"Line":1},"fn_name":null},{"line":826,"address":[1187195],"length":1,"stats":{"Line":2},"fn_name":null},{"line":827,"address":[1187713],"length":1,"stats":{"Line":1},"fn_name":null},{"line":828,"address":[1187386],"length":1,"stats":{"Line":1},"fn_name":null},{"line":829,"address":[1187250],"length":1,"stats":{"Line":1},"fn_name":null},{"line":830,"address":[1187318],"length":1,"stats":{"Line":2},"fn_name":null},{"line":832,"address":[1187510],"length":1,"stats":{"Line":2},"fn_name":null},{"line":833,"address":[1187522],"length":1,"stats":{"Line":1},"fn_name":null},{"line":834,"address":[1187534],"length":1,"stats":{"Line":2},"fn_name":null},{"line":835,"address":[1187546],"length":1,"stats":{"Line":1},"fn_name":null},{"line":836,"address":[1187641,1187558],"length":1,"stats":{"Line":3},"fn_name":null},{"line":837,"address":[1187701],"length":1,"stats":{"Line":2},"fn_name":null},{"line":842,"address":[1188272,1189649],"length":1,"stats":{"Line":1},"fn_name":"create_raffle_cw1155"},{"line":843,"address":[1188294],"length":1,"stats":{"Line":1},"fn_name":null},{"line":844,"address":[1188361],"length":1,"stats":{"Line":1},"fn_name":null},{"line":847,"address":[1188382],"length":1,"stats":{"Line":1},"fn_name":null},{"line":848,"address":[1188417],"length":1,"stats":{"Line":1},"fn_name":null},{"line":849,"address":[1188496],"length":1,"stats":{"Line":1},"fn_name":null},{"line":850,"address":[1189122],"length":1,"stats":{"Line":1},"fn_name":null},{"line":851,"address":[1188763],"length":1,"stats":{"Line":1},"fn_name":null},{"line":852,"address":[1188551],"length":1,"stats":{"Line":1},"fn_name":null},{"line":853,"address":[1188619],"length":1,"stats":{"Line":1},"fn_name":null},{"line":854,"address":[1188687],"length":1,"stats":{"Line":1},"fn_name":null},{"line":856,"address":[1188919],"length":1,"stats":{"Line":1},"fn_name":null},{"line":857,"address":[1188931],"length":1,"stats":{"Line":1},"fn_name":null},{"line":858,"address":[1188943],"length":1,"stats":{"Line":1},"fn_name":null},{"line":859,"address":[1188955],"length":1,"stats":{"Line":1},"fn_name":null},{"line":860,"address":[1188967,1189050],"length":1,"stats":{"Line":2},"fn_name":null},{"line":861,"address":[1189110],"length":1,"stats":{"Line":1},"fn_name":null},{"line":866,"address":[1190710,1189680],"length":1,"stats":{"Line":1},"fn_name":"buy_ticket_coin"},{"line":873,"address":[1189951,1189767],"length":1,"stats":{"Line":2},"fn_name":null},{"line":874,"address":[1190011],"length":1,"stats":{"Line":1},"fn_name":null},{"line":875,"address":[1190076],"length":1,"stats":{"Line":1},"fn_name":null},{"line":877,"address":[1190149],"length":1,"stats":{"Line":1},"fn_name":null},{"line":878,"address":[1190184],"length":1,"stats":{"Line":1},"fn_name":null},{"line":879,"address":[1190280],"length":1,"stats":{"Line":1},"fn_name":null},{"line":880,"address":[1190430],"length":1,"stats":{"Line":1},"fn_name":null},{"line":882,"address":[1190327],"length":1,"stats":{"Line":1},"fn_name":null},{"line":887,"address":[1191341,1190752],"length":1,"stats":{"Line":1},"fn_name":"claim_nft"},{"line":888,"address":[1190800],"length":1,"stats":{"Line":1},"fn_name":null},{"line":889,"address":[1190867],"length":1,"stats":{"Line":1},"fn_name":null},{"line":890,"address":[1190888,1190986],"length":1,"stats":{"Line":2},"fn_name":null},{"line":891,"address":[1190991],"length":1,"stats":{"Line":1},"fn_name":null},{"line":895,"address":[1191376,1191469],"length":1,"stats":{"Line":3},"fn_name":"test_init_sanity"},{"line":896,"address":[1191383],"length":1,"stats":{"Line":1},"fn_name":null},{"line":897,"address":[1191404],"length":1,"stats":{"Line":1},"fn_name":null},{"line":901,"address":[1191675,1191504],"length":1,"stats":{"Line":3},"fn_name":"test_create_raffle"},{"line":902,"address":[1191511],"length":1,"stats":{"Line":1},"fn_name":null},{"line":903,"address":[1191528],"length":1,"stats":{"Line":1},"fn_name":null},{"line":904,"address":[1191590],"length":1,"stats":{"Line":1},"fn_name":null},{"line":908,"address":[1192674,1191712],"length":1,"stats":{"Line":3},"fn_name":"test_claim_raffle"},{"line":909,"address":[1191719],"length":1,"stats":{"Line":1},"fn_name":null},{"line":910,"address":[1191743],"length":1,"stats":{"Line":1},"fn_name":null},{"line":911,"address":[1191815],"length":1,"stats":{"Line":1},"fn_name":null},{"line":914,"address":[1191890],"length":1,"stats":{"Line":1},"fn_name":null},{"line":916,"address":[1191959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":919,"address":[1191986],"length":1,"stats":{"Line":1},"fn_name":null},{"line":922,"address":[1192153],"length":1,"stats":{"Line":1},"fn_name":null},{"line":923,"address":[1192217],"length":1,"stats":{"Line":1},"fn_name":null},{"line":924,"address":[1192229,1192398],"length":1,"stats":{"Line":1},"fn_name":null},{"line":925,"address":[1192489],"length":1,"stats":{"Line":1},"fn_name":null},{"line":926,"address":[1192391,1192473],"length":1,"stats":{"Line":2},"fn_name":null},{"line":929,"address":[1192559],"length":1,"stats":{"Line":1},"fn_name":null},{"line":933,"address":[1192704,1196818],"length":1,"stats":{"Line":3},"fn_name":"test_ticket_and_claim_raffle"},{"line":934,"address":[1192717],"length":1,"stats":{"Line":1},"fn_name":null},{"line":935,"address":[1192755],"length":1,"stats":{"Line":1},"fn_name":null},{"line":936,"address":[1192833],"length":1,"stats":{"Line":1},"fn_name":null},{"line":939,"address":[1192924],"length":1,"stats":{"Line":1},"fn_name":null},{"line":940,"address":[1193107],"length":1,"stats":{"Line":1},"fn_name":null},{"line":941,"address":[1193290],"length":1,"stats":{"Line":1},"fn_name":null},{"line":942,"address":[1193453],"length":1,"stats":{"Line":1},"fn_name":null},{"line":943,"address":[1193616],"length":1,"stats":{"Line":1},"fn_name":null},{"line":944,"address":[1193779],"length":1,"stats":{"Line":1},"fn_name":null},{"line":945,"address":[1193942],"length":1,"stats":{"Line":1},"fn_name":null},{"line":948,"address":[1194089],"length":1,"stats":{"Line":1},"fn_name":null},{"line":950,"address":[1194161],"length":1,"stats":{"Line":1},"fn_name":null},{"line":953,"address":[1194188],"length":1,"stats":{"Line":1},"fn_name":null},{"line":956,"address":[1194357],"length":1,"stats":{"Line":1},"fn_name":null},{"line":957,"address":[1194421],"length":1,"stats":{"Line":1},"fn_name":null},{"line":958,"address":[1194608,1194433],"length":1,"stats":{"Line":1},"fn_name":null},{"line":959,"address":[1194699],"length":1,"stats":{"Line":1},"fn_name":null},{"line":960,"address":[1194601,1194683],"length":1,"stats":{"Line":2},"fn_name":null},{"line":963,"address":[1194772],"length":1,"stats":{"Line":1},"fn_name":null},{"line":965,"address":[1196215],"length":1,"stats":{"Line":1},"fn_name":null},{"line":967,"address":[1195628,1194864,1194985,1195872,1196087,1195384],"length":1,"stats":{"Line":2},"fn_name":null},{"line":968,"address":[1195315],"length":1,"stats":{"Line":1},"fn_name":null},{"line":969,"address":[1195166,1195250],"length":1,"stats":{"Line":2},"fn_name":null},{"line":970,"address":[1195014],"length":1,"stats":{"Line":1},"fn_name":null},{"line":971,"address":[1194886],"length":1,"stats":{"Line":1},"fn_name":null},{"line":972,"address":[1194953],"length":1,"stats":{"Line":1},"fn_name":null},{"line":974,"address":[1195098],"length":1,"stats":{"Line":1},"fn_name":null},{"line":978,"address":[1195424],"length":1,"stats":{"Line":1},"fn_name":null},{"line":979,"address":[1195322],"length":1,"stats":{"Line":1},"fn_name":null},{"line":980,"address":[1195349],"length":1,"stats":{"Line":1},"fn_name":null},{"line":982,"address":[1195668],"length":1,"stats":{"Line":1},"fn_name":null},{"line":983,"address":[1195564],"length":1,"stats":{"Line":1},"fn_name":null},{"line":984,"address":[1195591],"length":1,"stats":{"Line":1},"fn_name":null},{"line":986,"address":[1195912],"length":1,"stats":{"Line":1},"fn_name":null},{"line":987,"address":[1195808],"length":1,"stats":{"Line":1},"fn_name":null},{"line":988,"address":[1195835],"length":1,"stats":{"Line":1},"fn_name":null},{"line":994,"address":[1196431],"length":1,"stats":{"Line":1},"fn_name":null},{"line":995,"address":[1196608],"length":1,"stats":{"Line":1},"fn_name":null},{"line":999,"address":[1201209,1196848],"length":1,"stats":{"Line":3},"fn_name":"test_ticket_and_claim_raffle_cw1155"},{"line":1000,"address":[1196861],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1001,"address":[1196899],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1002,"address":[1196977],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1005,"address":[1197068],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1006,"address":[1197251],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1007,"address":[1197434],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1008,"address":[1197597],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1009,"address":[1197760],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1010,"address":[1197923],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1011,"address":[1198086],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1014,"address":[1198233],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1016,"address":[1198305],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1019,"address":[1198332],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1022,"address":[1198513],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1023,"address":[1198577],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1024,"address":[1198589,1198764],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1025,"address":[1198855],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1026,"address":[1198839,1198757],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1029,"address":[1198928],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1031,"address":[1200606],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1033,"address":[1199020,1199775,1200263,1200478,1200019,1199141],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1034,"address":[1199706],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1035,"address":[1199557,1199641],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1036,"address":[1199325],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1037,"address":[1199042],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1038,"address":[1199109],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1039,"address":[1199170],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1040,"address":[1199235],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1041,"address":[1199313],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1043,"address":[1199489],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1047,"address":[1199815],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1048,"address":[1199713],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1049,"address":[1199740],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1051,"address":[1200059],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1052,"address":[1199955],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1053,"address":[1199982],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1055,"address":[1200303],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1056,"address":[1200199],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1057,"address":[1200226],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1063,"address":[1200822],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1064,"address":[1200999],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1068,"address":[1203859,1201232],"length":1,"stats":{"Line":3},"fn_name":"test_randomness_provider"},{"line":1069,"address":[1201239],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1070,"address":[1201327],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1071,"address":[1201399],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1072,"address":[1201474],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1073,"address":[1201493],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1074,"address":[1201551,1201635],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1077,"address":[1201643],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1078,"address":[1201742],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1081,"address":[1201938],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1082,"address":[1201945],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1083,"address":[1202049],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1084,"address":[1202177],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1086,"address":[1202129],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1092,"address":[1202704,1202526,1202644],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1094,"address":[1202734],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1097,"address":[1203477],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1099,"address":[1203391,1203345,1203011],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1100,"address":[1203074,1203355],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1108,"address":[1205087,1203888],"length":1,"stats":{"Line":3},"fn_name":"test_renounce"},{"line":1109,"address":[1203895],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1110,"address":[1203951],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1111,"address":[1204010],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1112,"address":[1204061],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1113,"address":[1204080,1204210,1204165],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1115,"address":[1204380],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1117,"address":[1204444],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1118,"address":[1204467,1204515],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1119,"address":[1204539],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1120,"address":[1204546],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1124,"address":[1204731],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1128,"address":[1206743,1205120],"length":1,"stats":{"Line":3},"fn_name":"test_lock"},{"line":1129,"address":[1205127],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1130,"address":[1205183],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1131,"address":[1205389,1205242],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1133,"address":[1205421,1205346],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1134,"address":[1205429],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1136,"address":[1205469],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1137,"address":[1205533],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1138,"address":[1205578],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1139,"address":[1205634],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1143,"address":[1205756],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1145,"address":[1205820],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1146,"address":[1205891,1205843],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1147,"address":[1205915],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1148,"address":[1205922],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1151,"address":[1206228,1206102],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1154,"address":[1206221],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1155,"address":[1206261],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1156,"address":[1206349],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1157,"address":[1206405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1160,"address":[1206513,1206653],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1164,"address":[1209202,1206768],"length":1,"stats":{"Line":3},"fn_name":"test_change_parameter"},{"line":1165,"address":[1206775],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1166,"address":[1206871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1168,"address":[1206930],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1169,"address":[1206981],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1171,"address":[1207021],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1172,"address":[1207085,1207130],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1173,"address":[1207138],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1174,"address":[1207297],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1175,"address":[1207202],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1176,"address":[1207229],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1181,"address":[1207598],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1183,"address":[1207662],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1184,"address":[1207733,1207685],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1185,"address":[1207757],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1186,"address":[1207902],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1187,"address":[1207772],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1188,"address":[1207837],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1194,"address":[1208204],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1195,"address":[1208211],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1196,"address":[1208307],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1197,"address":[1208466],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1198,"address":[1208371],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1199,"address":[1208398],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1203,"address":[1208848],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1204,"address":[1208753],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":403,"coverable":562},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","raffles","src","error.rs"],"content":"use cosmwasm_std::StdError;\nuse raffles_export::state::{AssetInfo, RaffleState};\nuse thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized {},\n\n    #[error(\"An unplanned bug just happened :/\")]\n    ContractBug {},\n\n    #[error(\"This action is not allowed, the contract is locked\")]\n    ContractIsLocked {},\n\n    #[error(\"Key already exists in RaffleInfo\")]\n    ExistsInRaffleInfo {},\n\n    #[error(\"Raffle ID does not exist\")]\n    NotFoundInRaffleInfo {},\n\n    #[error(\"You can't buy tickets on this raffle anymore\")]\n    CantBuyTickets {},\n\n    #[error(\"A raffle can only be done with CW721 or CW1155 assets\")]\n    WrongAssetType {},\n\n    #[error(\"Tickets to a raffle can only be bought with native assets or CW20 coins\")]\n    WrongFundsType {},\n\n    #[error(\"The sent asset doesn't match the asset in the message sent along with it\")]\n    AssetMismatch {},\n\n    #[error(\"The sent assets ({assets_received:?}) don't match the required assets ({assets_wanted:?}) for this raffle\")]\n    PaiementNotSufficient {\n        assets_wanted: AssetInfo,\n        assets_received: AssetInfo,\n    },\n\n    #[error(\"Too much tickets were already purchased for this raffle\")]\n    TooMuchTickets {},\n\n    #[error(\"The provided randomness is invalid current round : {round:?}\")]\n    RandomnessNotAccepted { round: u64 },\n\n    #[error(\"This raffle is not ready to accept new randomness. Only Closed raffles can be decided upon. Current status : {status:?}\")]\n    WrongStateForRandmness { status: RaffleState },\n\n    #[error(\"This raffle is not ready to be claimed.  Current status : {status:?}\")]\n    WrongStateForClaim { status: RaffleState },\n\n    #[error(\"The public key you indicated is invalid\")]\n    InvalidPubkey {},\n\n    #[error(\"The randomness signatur is invalid\")]\n    InvalidSignature {},\n\n    #[error(\"Wrong Format for the verify response\")]\n    ParseReplyError {},\n\n    #[error(\"This parameter name was not found, you can't change it !\")]\n    ParameterNotFound {},\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","raffles","src","lib.rs"],"content":"pub mod contract;\nmod error;\npub mod query;\npub mod rand;\npub mod state;\n\npub use crate::error::ContractError;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","raffles","src","query.rs"],"content":"use anyhow::Result;\n#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::{Addr, Api, Deps, Env, Order, StdResult};\n\nuse cw_storage_plus::Bound;\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse crate::state::{get_raffle_state, CONTRACT_INFO, RAFFLE_INFO};\nuse raffles_export::msg::QueryFilters;\nuse raffles_export::state::{AssetInfo, ContractInfo, RaffleInfo};\n\n// settings for pagination\nconst MAX_LIMIT: u32 = 30;\nconst DEFAULT_LIMIT: u32 = 10;\nconst BASE_LIMIT: usize = 100;\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug, Default)]\npub struct RaffleResponse {\n    pub raffle_id: u64,\n    pub raffle_info: Option\u003cRaffleInfo\u003e,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug, Default)]\npub struct AllRafflesResponse {\n    pub raffles: Vec\u003cRaffleResponse\u003e,\n}\n\npub fn query_contract_info(deps: Deps) -\u003e StdResult\u003cContractInfo\u003e {\n    CONTRACT_INFO.load(deps.storage)\n}\n\n/*\n\n         QueryMsg::GetTickets {\n            raffle_id,\n            start_after,\n            limit,\n            filters,\n        } =\u003e query_tickets(deps, env, raffle_id, start_after, limit, filters),\n         QueryMsg::GetAllTickets {\n            start_after,\n            limit,\n            filters,\n        } =\u003e query_all_tickets(deps, env, start_after, limit, filters),\n\n*/\n\n// parse raffles to human readable format\nfn parse_raffles(_: \u0026dyn Api, item: StdResult\u003c(u64, RaffleInfo)\u003e) -\u003e StdResult\u003cRaffleResponse\u003e {\n    item.map(|(raffle_id, raffle)| RaffleResponse {\n        raffle_id,\n        raffle_info: Some(raffle),\n    })\n}\n\npub fn raffle_filter(\n    _api: \u0026dyn Api,\n    env: Env,\n    raffle_info: \u0026StdResult\u003cRaffleResponse\u003e,\n    filters: \u0026Option\u003cQueryFilters\u003e,\n) -\u003e bool {\n    if let Some(filters) = filters {\n        let raffle = raffle_info.as_ref().unwrap();\n\n        (match \u0026filters.states {\n            Some(state) =\u003e state\n                .contains(\u0026get_raffle_state(env, raffle.raffle_info.clone().unwrap()).to_string()),\n            None =\u003e true,\n        } \u0026\u0026 match \u0026filters.owner {\n            Some(owner) =\u003e raffle.raffle_info.as_ref().unwrap().owner == owner.clone(),\n            None =\u003e true,\n        } \u0026\u0026 match \u0026filters.ticket_depositor {\n            Some(ticket_depositor) =\u003e raffle\n                .raffle_info\n                .as_ref()\n                .unwrap()\n                .tickets\n                .contains(ticket_depositor),\n            None =\u003e true,\n        } \u0026\u0026 match \u0026filters.contains_token {\n            Some(token) =\u003e match raffle.raffle_info.clone().unwrap().asset {\n                AssetInfo::Coin(x) =\u003e x.denom == token.as_ref(),\n                AssetInfo::Cw20Coin(x) =\u003e x.address == token.as_ref(),\n                AssetInfo::Cw721Coin(x) =\u003e x.address == token.as_ref(),\n                AssetInfo::Cw1155Coin(x) =\u003e x.address == token.as_ref(),\n            },\n            None =\u003e true,\n        })\n    } else {\n        true\n    }\n}\n\npub fn query_ticket_number(\n    deps: Deps,\n    _env: Env,\n    raffle_id: u64,\n    ticket_depositor: Addr,\n) -\u003e Result\u003cu64\u003e {\n    let raffle_info = RAFFLE_INFO.load(deps.storage, raffle_id)?;\n    Ok(raffle_info\n        .tickets\n        .iter()\n        .filter(|\u0026t| *t == ticket_depositor)\n        .count() as u64)\n}\npub fn query_all_raffles(\n    deps: Deps,\n    env: Env,\n    start_after: Option\u003cu64\u003e,\n    limit: Option\u003cu32\u003e,\n    filters: Option\u003cQueryFilters\u003e,\n) -\u003e StdResult\u003cAllRafflesResponse\u003e {\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n    let start = start_after.map(Bound::exclusive);\n\n    let mut raffles: Vec\u003cRaffleResponse\u003e = RAFFLE_INFO\n        .range(deps.storage, None, start.clone(), Order::Descending)\n        .take(BASE_LIMIT)\n        .map(|kv_item| parse_raffles(deps.api, kv_item))\n        .filter(|response| raffle_filter(deps.api, env.clone(), response, \u0026filters))\n        .take(limit)\n        .collect::\u003cStdResult\u003cVec\u003cRaffleResponse\u003e\u003e\u003e()?;\n\n    if raffles.is_empty() {\n        let raffle_id = RAFFLE_INFO\n            .keys(deps.storage, None, start, Order::Descending)\n            .take(BASE_LIMIT)\n            .last();\n\n        if let Some(Ok(raffle_id)) = raffle_id {\n            if raffle_id != 0 {\n                raffles = vec![RaffleResponse {\n                    raffle_id,\n                    raffle_info: None,\n                }]\n            }\n        }\n    }\n    Ok(AllRafflesResponse { raffles })\n}\n","traces":[{"line":29,"address":[819504],"length":1,"stats":{"Line":0},"fn_name":"query_contract_info"},{"line":30,"address":[819512],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[819552],"length":1,"stats":{"Line":0},"fn_name":"parse_raffles"},{"line":51,"address":[819598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[1172548],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[822672,819648],"length":1,"stats":{"Line":0},"fn_name":"raffle_filter"},{"line":63,"address":[819711],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[819777,819843,819922],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[821027,820751,820442,819930,822703],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[819982,820352],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[820065,820382],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[819961],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[820473],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[820538],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[820509],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[820798],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[820863],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[820834],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[821074],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[821139],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[821519],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[821245,822047],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[821921,821331],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[821417,821795],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[821110],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[819800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[823515,822768],"length":1,"stats":{"Line":0},"fn_name":"query_ticket_number"},{"line":101,"address":[822886,823219,823004,822796],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[822972,823407,823325],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[1172673,1172656],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":108,"address":[823536,825548],"length":1,"stats":{"Line":0},"fn_name":"query_all_raffles"},{"line":115,"address":[823766,823653],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[823789],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[824191,824513,824069,823890,824012],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[823812,823947,824038],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[824061],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[824143],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[824675,824363],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[824966],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[824899],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[825068,825130],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[825392,825151],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[825196,825167,825337,825397],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[825184],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[824733],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":45},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","raffles","src","rand.rs"],"content":"// Credits to the scrtlabs raffle contract : https://github.com/scrtlabs/secret-raffle/blob/master/src/rand.rs\n\nuse rand_chacha::ChaChaRng;\nuse rand_core::{RngCore, SeedableRng};\n\nuse sha2::{Digest, Sha256};\n\npub struct Prng {\n    seed: Vec\u003cu8\u003e,\n    pos: u128,\n}\n\nimpl Prng {\n    pub fn new(seed: \u0026[u8]) -\u003e Self {\n        Self {\n            seed: seed.to_vec(),\n            pos: 0,\n        }\n    }\n\n    /// Return a random number (inclusive) between `from` and `to`\n    pub fn random_between(\u0026mut self, from: u32, to: u32) -\u003e u32 {\n        if from \u003e to {\n            return 0;\n        }\n\n        from + (self.rand_u32() % (to - from + 1))\n    }\n\n    fn rand_u32(\u0026mut self) -\u003e u32 {\n        let mut hasher = Sha256::new();\n\n        // write input message\n        hasher.update(\u0026self.seed);\n        let hash = hasher.finalize();\n\n        let mut result = [0u8; 32];\n        result.copy_from_slice(hash.as_slice());\n\n        let mut rng: ChaChaRng = ChaChaRng::from_seed(result);\n\n        rng.set_word_pos(self.pos);\n        self.pos += 8;\n\n        rng.next_u32()\n    }\n}\n","traces":[{"line":14,"address":[629552],"length":1,"stats":{"Line":2},"fn_name":"new"},{"line":16,"address":[629575],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[629648],"length":1,"stats":{"Line":2},"fn_name":"random_between"},{"line":23,"address":[629678],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[629698],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[629904,629723,629687],"length":1,"stats":{"Line":4},"fn_name":null},{"line":30,"address":[629936],"length":1,"stats":{"Line":2},"fn_name":"rand_u32"},{"line":31,"address":[629956],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[629971],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[629981],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[630025],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[630045],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[630115],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[630205],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[630306,630231],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[630287],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":15,"coverable":16},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","raffles","src","state.rs"],"content":"use anyhow::{anyhow, Result};\nuse cw_storage_plus::{Item, Map};\n\nuse cosmwasm_std::{\n    coins, Addr, BankMsg, CosmosMsg, Deps, Env, Response, StdError, Storage, SubMsg, Uint128,\n};\n\nuse crate::error::ContractError;\nuse crate::rand::Prng;\nuse raffles_export::msg::{into_cosmos_msg, DrandRandomness, VerifierExecuteMsg};\nuse raffles_export::state::{AssetInfo, ContractInfo, RaffleInfo, RaffleState};\n\nuse cw1155::Cw1155ExecuteMsg;\nuse cw20::Cw20ExecuteMsg;\nuse cw721::Cw721ExecuteMsg;\n\npub const CONTRACT_INFO: Item\u003cContractInfo\u003e = Item::new(\"contract_info\");\n\npub const RAFFLE_INFO: Map\u003cu64, RaffleInfo\u003e = Map::new(\"raffle_info\");\npub const USER_TICKETS: Map\u003c(\u0026Addr, u64), u64\u003e = Map::new(\"uset_tickets\");\n\n// This function is largely inspired (and even directly copied) from https://github.com/confio/rand/.\n// Part of the randomness flow was inspired from https://github.com/scrtlabs/secret-raffle/ and https://github.com/LoTerra/terrand-contract-step1/\n\npub fn assert_randomness_origin_and_order(\n    deps: Deps,\n    owner: Addr,\n    raffle_id: u64,\n    randomness: DrandRandomness,\n) -\u003e Result\u003cResponse\u003e {\n    let raffle_info = load_raffle(deps.storage, raffle_id)?;\n    let contract_info = CONTRACT_INFO.load(deps.storage)?;\n\n    if randomness.round \u003c= raffle_info.randomness_round {\n        return Err(anyhow!(ContractError::RandomnessNotAccepted {\n            round: randomness.round\n        }));\n    }\n\n    let msg = VerifierExecuteMsg::Verify {\n        randomness,\n        pubkey: contract_info.random_pubkey,\n        raffle_id,\n        owner: owner.to_string(),\n    };\n    let res = into_cosmos_msg(msg, contract_info.verify_signature_contract.to_string())?;\n\n    let msg = SubMsg::reply_on_success(res, 0);\n    Ok(Response::new().add_submessage(msg))\n}\n\npub fn is_owner(storage: \u0026dyn Storage, sender: Addr) -\u003e Result\u003cContractInfo, ContractError\u003e {\n    let contract_info = CONTRACT_INFO.load(storage)?;\n    if sender == contract_info.owner {\n        Ok(contract_info)\n    } else {\n        Err(ContractError::Unauthorized {})\n    }\n}\n\npub fn get_raffle_winner(raffle_info: RaffleInfo) -\u003e Result\u003cAddr\u003e {\n    // We initiate the random number generator\n    let mut rng: Prng = Prng::new(\u0026raffle_info.randomness);\n\n    // We pick a winner id\n    let winner_id = rng.random_between(0u32, raffle_info.tickets.len() as u32);\n    let winner = raffle_info.tickets[winner_id as usize].clone();\n\n    Ok(winner)\n}\n\npub fn get_raffle_state(env: Env, raffle_info: RaffleInfo) -\u003e RaffleState {\n    if env.block.time \u003c raffle_info.raffle_start_timestamp {\n        RaffleState::Created\n    } else if env.block.time\n        \u003c raffle_info\n            .raffle_start_timestamp\n            .plus_seconds(raffle_info.raffle_duration)\n    {\n        RaffleState::Started\n    } else if env.block.time\n        \u003c raffle_info\n            .raffle_start_timestamp\n            .plus_seconds(raffle_info.raffle_duration)\n            .plus_seconds(raffle_info.raffle_timeout)\n        || raffle_info.randomness_owner.is_none()\n    {\n        RaffleState::Closed\n    } else if raffle_info.winner.is_none() {\n        RaffleState::Finished\n    } else {\n        RaffleState::Claimed\n    }\n}\n\npub fn load_ticket_number(storage: \u0026dyn Storage, raffle_id: u64, owner: Addr) -\u003e Result\u003cu64\u003e {\n    let raffle_info = RAFFLE_INFO\n        .load(storage, raffle_id)\n        .map_err(|_| ContractError::NotFoundInRaffleInfo {})?;\n\n    Ok(raffle_info\n        .tickets\n        .iter()\n        .filter(|\u0026ticket_owner| *ticket_owner == owner)\n        .count() as u64)\n}\n\npub fn load_raffle(storage: \u0026dyn Storage, raffle_id: u64) -\u003e Result\u003cRaffleInfo\u003e {\n    RAFFLE_INFO\n        .load(storage, raffle_id)\n        .map_err(|_| anyhow!(ContractError::NotFoundInRaffleInfo {}))\n}\n\npub fn can_buy_ticket(env: Env, raffle_info: RaffleInfo) -\u003e Result\u003c()\u003e {\n    if get_raffle_state(env, raffle_info) == RaffleState::Started {\n        Ok(())\n    } else {\n        Err(anyhow!(ContractError::CantBuyTickets {}))\n    }\n}\n\npub fn get_asset_amount(asset: AssetInfo) -\u003e Result\u003cUint128\u003e {\n    match asset {\n        AssetInfo::Cw20Coin(coin) =\u003e Ok(coin.amount),\n        AssetInfo::Coin(coin) =\u003e Ok(coin.amount),\n        _ =\u003e Err(anyhow!(ContractError::WrongFundsType {})),\n    }\n}\n\npub fn get_raffle_winner_message(env: Env, raffle_info: RaffleInfo) -\u003e Result\u003cCosmosMsg\u003e {\n    match raffle_info.asset {\n        AssetInfo::Cw721Coin(nft) =\u003e {\n            let message = Cw721ExecuteMsg::TransferNft {\n                recipient: raffle_info.winner.unwrap().to_string(),\n                token_id: nft.token_id.clone(),\n            };\n            into_cosmos_msg(message, nft.address)\n        }\n        AssetInfo::Cw1155Coin(cw1155) =\u003e {\n            let message = Cw1155ExecuteMsg::SendFrom {\n                from: env.contract.address.to_string(),\n                to: raffle_info.winner.unwrap().to_string(),\n                token_id: cw1155.token_id.clone(),\n                value: cw1155.value,\n                msg: None,\n            };\n            into_cosmos_msg(message, cw1155.address)\n        }\n        _ =\u003e Err(anyhow!(StdError::generic_err(\n            \"Unreachable, wrong asset type raffled\"\n        ))),\n    }\n}\n\npub fn get_raffle_owner_finished_messages(\n    storage: \u0026dyn Storage,\n    _env: Env,\n    raffle_info: RaffleInfo,\n) -\u003e Result\u003cVec\u003cCosmosMsg\u003e\u003e {\n    let contract_info = CONTRACT_INFO.load(storage)?;\n    match raffle_info.accumulated_ticket_fee {\n        AssetInfo::Cw20Coin(coin) =\u003e {\n            // We start by splitting the fees between owner, treasury and radomness provider\n            let rand_amount = coin.amount * contract_info.rand_fee / Uint128::from(10_000u128);\n            let treasury_amount =\n                coin.amount * contract_info.raffle_fee / Uint128::from(10_000u128);\n            let owner_amount = coin.amount - rand_amount - treasury_amount;\n\n            let mut messages: Vec\u003cCosmosMsg\u003e = vec![];\n            if rand_amount != Uint128::zero() {\n                messages.push(into_cosmos_msg(\n                    Cw20ExecuteMsg::Transfer {\n                        recipient: raffle_info.randomness_owner.unwrap().to_string(),\n                        amount: rand_amount,\n                    },\n                    coin.address.clone(),\n                )?);\n            };\n            if treasury_amount != Uint128::zero() {\n                messages.push(into_cosmos_msg(\n                    Cw20ExecuteMsg::Transfer {\n                        recipient: contract_info.fee_addr.to_string(),\n                        amount: treasury_amount,\n                    },\n                    coin.address.clone(),\n                )?);\n            };\n            if owner_amount != Uint128::zero() {\n                messages.push(into_cosmos_msg(\n                    Cw20ExecuteMsg::Transfer {\n                        recipient: raffle_info.owner.to_string(),\n                        amount: owner_amount,\n                    },\n                    coin.address,\n                )?);\n            };\n            Ok(messages)\n        }\n        AssetInfo::Coin(coin) =\u003e {\n            // We start by splitting the fees between owner, treasury and radomness provider\n            let rand_amount = coin.amount * contract_info.rand_fee / Uint128::from(10_000u128);\n            let treasury_amount =\n                coin.amount * contract_info.raffle_fee / Uint128::from(10_000u128);\n            let owner_amount = coin.amount - rand_amount - treasury_amount;\n\n            let mut messages: Vec\u003cCosmosMsg\u003e = vec![];\n            if rand_amount != Uint128::zero() {\n                messages.push(\n                    BankMsg::Send {\n                        to_address: raffle_info.randomness_owner.unwrap().to_string(),\n                        amount: coins(rand_amount.u128(), coin.denom.clone()),\n                    }\n                    .into(),\n                );\n            };\n            if treasury_amount != Uint128::zero() {\n                messages.push(\n                    BankMsg::Send {\n                        to_address: contract_info.fee_addr.to_string(),\n                        amount: coins(treasury_amount.u128(), coin.denom.clone()),\n                    }\n                    .into(),\n                );\n            };\n            if owner_amount != Uint128::zero() {\n                messages.push(\n                    BankMsg::Send {\n                        to_address: raffle_info.owner.to_string(),\n                        amount: coins(owner_amount.u128(), coin.denom),\n                    }\n                    .into(),\n                );\n            };\n\n            Ok(messages)\n        }\n        _ =\u003e Err(anyhow!(ContractError::WrongFundsType {})),\n    }\n}\n","traces":[{"line":25,"address":[705472,708865],"length":1,"stats":{"Line":1},"fn_name":"assert_randomness_origin_and_order"},{"line":31,"address":[705793,705825,705668,705526],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[706047,705759,705887,705932,706199],"length":1,"stats":{"Line":3},"fn_name":null},{"line":34,"address":[706020],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[706601,706384],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[706381],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[706318],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[706366],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[707024,706824,707650,707607],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[708107,707436],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[708285,708171,708123],"length":1,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[708880,709564],"length":1,"stats":{"Line":1},"fn_name":"is_owner"},{"line":53,"address":[709307,709136,709015,708924],"length":1,"stats":{"Line":4},"fn_name":null},{"line":54,"address":[709351,709442,709112],"length":1,"stats":{"Line":8},"fn_name":null},{"line":55,"address":[709444],"length":1,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[709400],"length":1,"stats":{"Line":3},"fn_name":null},{"line":61,"address":[709584,709893],"length":1,"stats":{"Line":2},"fn_name":"get_raffle_winner"},{"line":63,"address":[709606],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[709635,709697,709760],"length":1,"stats":{"Line":6},"fn_name":null},{"line":67,"address":[709767],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[709817],"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[710431,709936],"length":1,"stats":{"Line":1},"fn_name":"get_raffle_state"},{"line":73,"address":[709953],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[710067],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[710187,710031,710106],"length":1,"stats":{"Line":3},"fn_name":null},{"line":76,"address":[710040,710101,710051],"length":1,"stats":{"Line":3},"fn_name":null},{"line":78,"address":[710047],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[710182],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[710244,710351,710146,710297],"length":1,"stats":{"Line":4},"fn_name":null},{"line":82,"address":[710166,710208,710155,710199],"length":1,"stats":{"Line":4},"fn_name":null},{"line":84,"address":[710162],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[710204],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[710279],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[710346],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[710394,710384,710360,710328],"length":1,"stats":{"Line":5},"fn_name":null},{"line":90,"address":[710389],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[710379],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[711163,710464],"length":1,"stats":{"Line":0},"fn_name":"load_ticket_number"},{"line":97,"address":[710819,710611,710512],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[635159,635136],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":101,"address":[710975,711060,710707],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[635201,635184],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":108,"address":[711184],"length":1,"stats":{"Line":1},"fn_name":"load_raffle"},{"line":109,"address":[711233],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[635260,635248],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":114,"address":[711608,711280],"length":1,"stats":{"Line":1},"fn_name":"can_buy_ticket"},{"line":115,"address":[711298,711647],"length":1,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[711460],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[711623,711482,711397],"length":1,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[711664,712306],"length":1,"stats":{"Line":2},"fn_name":"get_asset_amount"},{"line":123,"address":[711686],"length":1,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[711834],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[711923],"length":1,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[712020,711758,712180],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[712448,715564],"length":1,"stats":{"Line":1},"fn_name":"get_raffle_winner_message"},{"line":131,"address":[712475],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[712636],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[712679,714061],"length":1,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[714109],"length":1,"stats":{"Line":1},"fn_name":null},{"line":137,"address":[714320],"length":1,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[712760],"length":1,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[712824],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[713322,713197],"length":1,"stats":{"Line":2},"fn_name":null},{"line":143,"address":[713367],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[713435],"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[713711],"length":1,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[712597,712846,712971],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[715600,723809],"length":1,"stats":{"Line":1},"fn_name":"get_raffle_owner_finished_messages"},{"line":160,"address":[716016,715841,716168,715667],"length":1,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[715959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[716297],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[718969,716358,718860],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[719028],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[719214],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[719360],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[719485,720313,719367],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[719766,719863,720214,719889],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[719630],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[719523],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[719614],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[719698],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[719491,720328,721036],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[720639,720539,720665,720990],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[720444],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[720405],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[720428],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[720512],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[722677,721051,720381],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[721743,721385],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[721261],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[721238],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[721245],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[721321],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[721112],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[716428],"length":1,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[716489,716800,716909],"length":1,"stats":{"Line":3},"fn_name":null},{"line":202,"address":[716968],"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[717154],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[717312],"length":1,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[717455,717319],"length":1,"stats":{"Line":2},"fn_name":null},{"line":208,"address":[717885],"length":1,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[717770],"length":1,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[717499],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[717590,717666,717763],"length":1,"stats":{"Line":3},"fn_name":null},{"line":216,"address":[717930,717461],"length":1,"stats":{"Line":2},"fn_name":null},{"line":217,"address":[718299],"length":1,"stats":{"Line":2},"fn_name":null},{"line":218,"address":[718184],"length":1,"stats":{"Line":2},"fn_name":null},{"line":219,"address":[718019],"length":1,"stats":{"Line":1},"fn_name":null},{"line":220,"address":[718042,718177],"length":1,"stats":{"Line":4},"fn_name":null},{"line":225,"address":[717989,718327],"length":1,"stats":{"Line":2},"fn_name":null},{"line":226,"address":[718797],"length":1,"stats":{"Line":2},"fn_name":null},{"line":227,"address":[718682],"length":1,"stats":{"Line":2},"fn_name":null},{"line":228,"address":[718520],"length":1,"stats":{"Line":2},"fn_name":null},{"line":229,"address":[718527],"length":1,"stats":{"Line":2},"fn_name":null},{"line":235,"address":[718394],"length":1,"stats":{"Line":1},"fn_name":null},{"line":237,"address":[716712,716551,716217],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":79,"coverable":116},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","randomness_verifier","examples","oracle_schema.rs"],"content":"use std::env::current_dir;\nuse std::fs::create_dir_all;\n\nuse cosmwasm_schema::{export_schema, remove_schemas, schema_for};\n\nuse raffles_export::msg::{VerifierExecuteMsg};\n\nfn main() {\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"schema\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n\n    export_schema(\u0026schema_for!(VerifierExecuteMsg), \u0026out_dir);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","randomness_verifier","src","contract.rs"],"content":"#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::{\n    entry_point, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdError, StdResult,\n};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse raffles_export::msg::{DrandRandomness, VerifierExecuteMsg};\n\nuse drand_verify::{derive_randomness, g1_from_variable, verify};\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct EmptyMsg {}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    _deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    _msg: EmptyMsg,\n) -\u003e StdResult\u003cResponse\u003e {\n    // store token info\n    Ok(Response::default().add_attribute(\"fee_contract\", \"randomness_verifier\"))\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    _deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    msg: VerifierExecuteMsg,\n) -\u003e StdResult\u003cResponse\u003e {\n    match msg {\n        VerifierExecuteMsg::Verify {\n            randomness,\n            pubkey,\n            raffle_id,\n            owner,\n        } =\u003e execute_verify(randomness, pubkey, raffle_id, owner),\n    }\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(_deps: Deps, _env: Env, _msg: EmptyMsg) -\u003e StdResult\u003cBinary\u003e {\n    Err(StdError::generic_err(\"No queries\"))\n}\n\npub fn execute_verify(\n    randomness: DrandRandomness,\n    pubkey: Binary,\n    raffle_id: u64,\n    owner: String,\n) -\u003e StdResult\u003cResponse\u003e {\n    let pk = g1_from_variable(\u0026pubkey).map_err(|_| StdError::generic_err(\"Invalid Public Key\"))?;\n    let valid = verify(\n        \u0026pk,\n        randomness.round,\n        randomness.previous_signature.as_slice(),\n        randomness.signature.as_slice(),\n    )\n    .unwrap_or(false);\n\n    if !valid {\n        return Err(StdError::generic_err(\"Invalid Signature\"));\n    }\n\n    let randomness_result = derive_randomness(\u0026randomness.signature);\n\n    Ok(Response::new()\n        .add_attribute(\"round\", randomness.round.to_string())\n        .add_attribute(\"randomness\", Binary::from(randomness_result).to_string())\n        .add_attribute(\"raffle_id\", raffle_id.to_string())\n        .add_attribute(\"owner\", owner.to_string()))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","contracts","randomness_verifier","src","lib.rs"],"content":"pub mod contract;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","CW4626","src","lib.rs"],"content":"pub mod msg;\npub mod query;\npub mod state;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","CW4626","src","msg.rs"],"content":"use cosmwasm_std::{StdError, StdResult};\nuse cw20_base::msg::InstantiateMarketingInfo;\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse crate::state::AssetInfo;\nuse cosmwasm_std::{Binary, Uint128};\nuse cw20::{Cw20Coin, Expiration, Logo, MinterResponse};\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct InstantiateMsg {\n    pub name: String,\n    pub symbol: String,\n    pub decimals: u8,\n    pub initial_balances: Vec\u003cCw20Coin\u003e,\n    pub mint: Option\u003cMinterResponse\u003e,\n    pub marketing: Option\u003cInstantiateMarketingInfo\u003e,\n    pub asset: AssetInfo,\n    pub borrower: Option\u003cString\u003e,\n}\n\nimpl InstantiateMsg {\n    pub fn get_cap(\u0026self) -\u003e Option\u003cUint128\u003e {\n        self.mint.as_ref().and_then(|v| v.cap)\n    }\n\n    pub fn validate(\u0026self) -\u003e StdResult\u003c()\u003e {\n        // Check name, symbol, decimals\n        if !is_valid_name(\u0026self.name) {\n            return Err(StdError::generic_err(\n                \"Name is not in the expected format (3-50 UTF-8 bytes)\",\n            ));\n        }\n        if !is_valid_symbol(\u0026self.symbol) {\n            return Err(StdError::generic_err(\n                \"Ticker symbol is not in expected format [a-zA-Z\\\\-]{3,12}\",\n            ));\n        }\n        if self.decimals \u003e 18 {\n            return Err(StdError::generic_err(\"Decimals must not exceed 18\"));\n        }\n        Ok(())\n    }\n}\n\nfn is_valid_name(name: \u0026str) -\u003e bool {\n    let bytes = name.as_bytes();\n    if bytes.len() \u003c 3 || bytes.len() \u003e 50 {\n        return false;\n    }\n    true\n}\n\nfn is_valid_symbol(symbol: \u0026str) -\u003e bool {\n    let bytes = symbol.as_bytes();\n    if bytes.len() \u003c 3 || bytes.len() \u003e 12 {\n        return false;\n    }\n    for byte in bytes.iter() {\n        if (*byte != 45) \u0026\u0026 (*byte \u003c 65 || *byte \u003e 90) \u0026\u0026 (*byte \u003c 97 || *byte \u003e 122) {\n            return false;\n        }\n    }\n    true\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub enum ExecuteMsg {\n    /// Transfer is a base message to move tokens to another account without triggering actions\n    Transfer { recipient: String, amount: Uint128 },\n    /// Burn is a base message to destroy tokens forever\n    Burn { amount: Uint128 },\n    /// Send is a base message to transfer tokens to a contract and trigger an action\n    /// on the receiving contract.\n    Send {\n        contract: String,\n        amount: Uint128,\n        msg: Binary,\n    },\n    /// Only with \"approval\" extension. Allows spender to access an additional amount tokens\n    /// from the owner's (env.sender) account. If expires is Some(), overwrites current allowance\n    /// expiration with this one.\n    IncreaseAllowance {\n        spender: String,\n        amount: Uint128,\n        expires: Option\u003cExpiration\u003e,\n    },\n    /// Only with \"approval\" extension. Lowers the spender's access of tokens\n    /// from the owner's (env.sender) account by amount. If expires is Some(), overwrites current\n    /// allowance expiration with this one.\n    DecreaseAllowance {\n        spender: String,\n        amount: Uint128,\n        expires: Option\u003cExpiration\u003e,\n    },\n    /// Only with \"approval\" extension. Transfers amount tokens from owner -\u003e recipient\n    /// if `env.sender` has sufficient pre-approval.\n    TransferFrom {\n        owner: String,\n        recipient: String,\n        amount: Uint128,\n    },\n    /// Only with \"approval\" extension. Sends amount tokens from owner -\u003e contract\n    /// if `env.sender` has sufficient pre-approval.\n    SendFrom {\n        owner: String,\n        contract: String,\n        amount: Uint128,\n        msg: Binary,\n    },\n    /// Only with \"approval\" extension. Destroys tokens forever\n    BurnFrom { owner: String, amount: Uint128 },\n    /// Only with the \"marketing\" extension. If authorized, updates marketing metadata.\n    /// Setting None/null for any of these will leave it unchanged.\n    /// Setting Some(\"\") will clear this field on the contract storage\n    UpdateMarketing {\n        /// A URL pointing to the project behind this token.\n        project: Option\u003cString\u003e,\n        /// A longer description of the token and it's utility. Designed for tooltips or such\n        description: Option\u003cString\u003e,\n        /// The address (if any) who can update this data structure\n        marketing: Option\u003cString\u003e,\n    },\n    /// If set as the \"marketing\" role on the contract, upload a new URL, SVG, or PNG for the token\n    UploadLogo(Logo),\n\n    // EIP4626 specific functions\n    /// Deposit an exact amount of assets in the vault (will mint some shares of the asset to the receiver)\n    Deposit { assets: Uint128, receiver: String },\n    /// Deposit an variable amount of assets in the vault to mint exactly the indicated number of shares to the receiver\n    Mint { shares: Uint128, receiver: String },\n    /// Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n    Withdraw {\n        assets: Uint128,\n        owner: String,\n        receiver: String,\n    },\n    /// Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n    Redeem {\n        shares: Uint128,\n        owner: String,\n        receiver: String,\n    },\n\n    // Treasury borrow specific functions (outside of EIP 4626, but still needed in most cases, let us do that plz)\n    /// Borrow some underlying assets to get yield elsewhere\n    Borrow { receiver: String, assets: Uint128 },\n    Repay {\n        owner: Option\u003cString\u003e,\n        assets: Uint128,\n    },\n    Receive {\n        sender: String,\n        amount: Uint128,\n        msg: Binary,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub enum ReceiveMsg {\n    Repay { assets: Uint128 },\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","CW4626","src","query.rs"],"content":"use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_std::Uint128;\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    /// Returns the current balance of the given address, 0 if unset.\n    /// Return type: BalanceResponse.\n    Balance { address: String },\n    /// Returns metadata on the contract - name, decimals, supply, etc.\n    /// Return type: TokenInfoResponse.\n    TokenInfo {},\n    /// Only with \"allowance\" extension.\n    /// Returns how much spender can use from owner account, 0 if unset.\n    /// Return type: AllowanceResponse.\n    Allowance { owner: String, spender: String },\n    /// Only with \"mintable\" extension.\n    /// Returns who can mint and the hard cap on maximum tokens after minting.\n    /// Return type: MinterResponse.\n    Minter {},\n    /// Only with \"marketing\" extension\n    /// Returns more metadata on the contract to display in the client:\n    /// - description, logo, project url, etc.\n    /// Return type: MarketingInfoResponse.\n    MarketingInfo {},\n    /// Only with \"marketing\" extension\n    /// Downloads the embedded logo data (if stored on chain). Errors if no logo data stored for\n    /// this contract.\n    /// Return type: DownloadLogoResponse.\n    DownloadLogo {},\n    /// Only with \"enumerable\" extension (and \"allowances\")\n    /// Returns all allowances this owner has approved. Supports pagination.\n    /// Return type: AllAllowancesResponse.\n    AllAllowances {\n        owner: String,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    },\n    /// Only with \"enumerable\" extension\n    /// Returns all accounts that have balances. Supports pagination.\n    /// Return type: AllAccountsResponse.\n    AllAccounts {\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    },\n\n    // EIP4626 specific functions\n    /// Returns info about the underlying asset\n    Asset {},\n    /// Returns the total number of underlying assets backing the token\n    TotalAssets {},\n    /// Converts the asset to shares of the token\n    ConvertToShares { assets: Uint128 },\n    /// Converts the shares of the token to assets\n    ConvertToAssets { shares: Uint128 },\n    /// Converts the shares of the token to assets\n    MaxDeposit { receiver: String },\n    /// Converts the shares of the token to assets\n    PreviewDeposit { assets: Uint128 },\n    /// Maximum amount that can be minted to someone in one call\n    MaxMint { receiver: String },\n    /// Allows to preview what happens when minting\n    PreviewMint { shares: Uint128 },\n    /// Maximum amount that can be withdrawn (in assets) to someone in one call\n    MaxWithdraw { owner: String },\n    /// Allows to preview what happens when withdrawing funds (exactly the indicated number of underlying asset)\n    PreviewWithdraw { assets: Uint128 },\n    /// Maximum amount that can be redeemed (in shares) to someone in one call\n    MaxRedeem { owner: String },\n    /// Allows to preview what happens when redeeming funds (exactly the indicated number of pool shares)\n    PreviewRedeem { shares: Uint128 },\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","CW4626","src","state.rs"],"content":"use cosmwasm_std::{\n    to_binary, Addr, BalanceResponse, BankQuery, Deps, Env, QueryRequest, StdError, StdResult,\n    Uint128, WasmQuery,\n};\n\nuse cw20::{Cw20QueryMsg, TokenInfoResponse};\nuse cw_storage_plus::{Item, Key, KeyDeserialize, PrimaryKey};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\npub const STATE: Item\u003cState\u003e = Item::new(\"contract_state\");\n\n/// EIP specific 4626 info\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct State {\n    pub underlying_asset: AssetInfo,\n    pub total_underlying_asset_supply: Uint128,\n    pub total_assets_borrowed: Uint128,\n    pub borrower: Option\u003cAddr\u003e,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\npub struct MinterData {\n    pub minter: Addr,\n    /// cap is how many more tokens can be issued by the minter\n    pub cap: Option\u003cUint128\u003e,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub enum AssetInfo {\n    Coin(String),\n    Cw20(String),\n}\n\nimpl ToString for AssetInfo {\n    fn to_string(\u0026self) -\u003e String {\n        match self {\n            AssetInfo::Coin(x) =\u003e {\n                let mut ret = \"coin_\".to_string();\n                ret.push_str(x);\n                ret\n            }\n            AssetInfo::Cw20(x) =\u003e {\n                let mut ret = \"cw20_\".to_string();\n                ret.push_str(x);\n                ret\n            }\n        }\n    }\n}\n\nimpl KeyDeserialize for AssetInfo {\n    type Output = AssetInfo;\n\n    #[inline(always)]\n    fn from_vec(value: Vec\u003cu8\u003e) -\u003e StdResult\u003cSelf::Output\u003e {\n        let string_rep = String::from_utf8(value).map_err(StdError::invalid_utf8)?;\n        if let Some(coin_name) = string_rep.strip_prefix(\"coin_\") {\n            Ok(AssetInfo::Coin(coin_name.to_string()))\n        } else if let Some(cw20_name) = string_rep.strip_prefix(\"cw20_\") {\n            Ok(AssetInfo::Cw20(cw20_name.to_string()))\n        } else {\n            Err(StdError::generic_err(\"Wrong asset info saved in memory\"))\n        }\n    }\n}\n\n// Provide a string version of this to raw encode strings\nimpl\u003c'a\u003e PrimaryKey\u003c'a\u003e for AssetInfo {\n    type Prefix = ();\n    type SubPrefix = ();\n    type Suffix = Self;\n    type SuperSuffix = Self;\n\n    fn key(\u0026self) -\u003e Vec\u003cKey\u003e {\n        match self {\n            AssetInfo::Coin(x) =\u003e {\n                let mut keys = \"coin_\".key();\n                keys.extend(x.key());\n                keys\n            }\n            AssetInfo::Cw20(x) =\u003e {\n                let mut keys = \"cw20_\".key();\n                keys.extend(x.key());\n                keys\n            }\n        }\n    }\n}\n\npub fn query_asset_balance(deps: Deps, env: Env) -\u003e Result\u003cUint128, StdError\u003e {\n    let state = STATE.load(deps.storage)?;\n\n    match state.underlying_asset {\n        AssetInfo::Coin(denom) =\u003e query_fund_balance(deps, env.contract.address, denom),\n        AssetInfo::Cw20(address) =\u003e query_cw20_supply(deps, deps.api.addr_validate(\u0026address)?),\n    }\n}\n\npub fn query_asset_liabilities(deps: Deps, _env: Env) -\u003e Result\u003cUint128, StdError\u003e {\n    let state = STATE.load(deps.storage)?;\n    Ok(state.total_assets_borrowed)\n}\n\npub fn query_fund_balance(deps: Deps, account_addr: Addr, denom: String) -\u003e StdResult\u003cUint128\u003e {\n    // load price form the oracle\n    let balance: BalanceResponse = deps.querier.query(\u0026QueryRequest::Bank(BankQuery::Balance {\n        address: account_addr.to_string(),\n        denom,\n    }))?;\n    Ok(balance.amount.amount)\n}\n\npub fn query_cw20_supply(deps: Deps, contract_addr: Addr) -\u003e StdResult\u003cUint128\u003e {\n    // load price form the oracle\n    let token_info: TokenInfoResponse =\n        deps.querier.query(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n            contract_addr: contract_addr.to_string(),\n            msg: to_binary(\u0026Cw20QueryMsg::TokenInfo {})?,\n        }))?;\n\n    Ok(token_info.total_supply)\n}\n","traces":[{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":17},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","bignumber","src","lib.rs"],"content":"mod math;\n\npub use crate::math::{Decimal256, Uint256};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","bignumber","src","math.rs"],"content":"use schemars::JsonSchema;\nuse serde::{de, ser, Deserialize, Deserializer, Serialize};\nuse std::convert::TryFrom;\nuse std::fmt::{self, Write};\nuse std::ops;\nuse std::str::FromStr;\n\nuse bigint::U256;\nuse cosmwasm_std::{Decimal, StdError, Uint128};\n\n/// A fixed-point decimal value with 18 fractional digits, i.e. Decimal256(1_000_000_000_000_000_000) == 1.0\n/// The greatest possible value that can be represented is 115792089237316195423570985008687907853269984665640564039457.584007913129639935 (which is (2^128 - 1) / 10^18)\n#[derive(Copy, Clone, Default, Debug, PartialEq, Eq, PartialOrd, Ord, JsonSchema)]\npub struct Decimal256(#[schemars(with = \"String\")] pub U256);\n\nimpl Decimal256 {\n    pub const MAX: Decimal256 = Decimal256(U256::MAX);\n    pub const DECIMAL_FRACTIONAL: U256 = U256([1_000_000_000_000_000_000u64, 0, 0, 0]);\n\n    /// Create a 1.0 Decimal256\n    pub const fn one() -\u003e Decimal256 {\n        Decimal256(Decimal256::DECIMAL_FRACTIONAL)\n    }\n\n    /// Create a 0.0 Decimal256\n    pub const fn zero() -\u003e Decimal256 {\n        Decimal256(U256([0, 0, 0, 0]))\n    }\n\n    /// Convert x% into Decimal256\n    pub fn percent(x: u64) -\u003e Decimal256 {\n        Decimal256(U256::from(x) * U256::from(10_000_000_000_000_000u64))\n    }\n\n    /// Convert permille (x/1000) into Decimal256\n    pub fn permille(x: u64) -\u003e Decimal256 {\n        Decimal256(U256::from(x) * U256::from(1_000_000_000_000_000u64))\n    }\n\n    /// Returns the ratio (nominator / denominator) as a Decimal256\n    pub fn from_ratio\u003cA: Into\u003cU256\u003e, B: Into\u003cU256\u003e\u003e(nominator: A, denominator: B) -\u003e Decimal256 {\n        let nominator: U256 = nominator.into();\n        let denominator: U256 = denominator.into();\n        if denominator.is_zero() {\n            panic!(\"Denominator must not be zero\");\n        }\n\n        Decimal256(nominator * Decimal256::DECIMAL_FRACTIONAL / denominator)\n    }\n\n    pub fn from_uint256\u003cA: Into\u003cUint256\u003e\u003e(val: A) -\u003e Decimal256 {\n        let num: Uint256 = val.into();\n        Decimal256(num.0 * Decimal256::DECIMAL_FRACTIONAL)\n    }\n\n    pub fn is_zero(\u0026self) -\u003e bool {\n        self.0.is_zero()\n    }\n}\n\nimpl From\u003cDecimal\u003e for Decimal256 {\n    fn from(val: Decimal) -\u003e Self {\n        Decimal256::from_str(\u0026val.to_string()).unwrap()\n    }\n}\n\nimpl From\u003cDecimal256\u003e for Decimal {\n    fn from(n: Decimal256) -\u003e Self {\n        let U256(ref arr) = n.0;\n        assert!(arr[2] == 0u64);\n        assert!(arr[3] == 0u64);\n        Decimal::from_str(\u0026n.to_string()).unwrap()\n    }\n}\n\nimpl FromStr for Decimal256 {\n    type Err = StdError;\n\n    /// Converts the decimal string to a Decimal256\n    /// Possible inputs: \"1.23\", \"1\", \"000012\", \"1.123000000\"\n    /// Disallowed: \"\", \".23\"\n    ///\n    /// This never performs any kind of rounding.\n    /// More than 18 fractional digits, even zeros, result in an error.\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let parts: Vec\u003c\u0026str\u003e = input.split('.').collect();\n        match parts.len() {\n            1 =\u003e {\n                let whole = U256::from_dec_str(parts[0])\n                    .map_err(|_| StdError::generic_err(\"Error parsing whole\"))?;\n\n                let whole_as_atomics = whole * Decimal256::DECIMAL_FRACTIONAL;\n                Ok(Decimal256(whole_as_atomics))\n            }\n            2 =\u003e {\n                let whole = U256::from_dec_str(parts[0])\n                    .map_err(|_| StdError::generic_err(\"Error parsing whole\"))?;\n                let fractional = U256::from_dec_str(parts[1])\n                    .map_err(|_| StdError::generic_err(\"Error parsing fractional\"))?;\n                let exp = (18usize.checked_sub(parts[1].len())).ok_or_else(|| {\n                    StdError::generic_err(\"Cannot parse more than 18 fractional digits\")\n                })?;\n                let fractional_factor = U256::from(10).pow(exp.into());\n\n                let whole_as_atomics = whole * Decimal256::DECIMAL_FRACTIONAL;\n                let atomics = whole_as_atomics + fractional * fractional_factor;\n                Ok(Decimal256(atomics))\n            }\n            _ =\u003e Err(StdError::generic_err(\"Unexpected number of dots\")),\n        }\n    }\n}\n\nimpl fmt::Display for Decimal256 {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        let whole = (self.0) / Decimal256::DECIMAL_FRACTIONAL;\n        let fractional = (self.0) % Decimal256::DECIMAL_FRACTIONAL;\n\n        if fractional.is_zero() {\n            write!(f, \"{}\", whole)\n        } else {\n            let fractional_string = fractional.to_string();\n            let fractional_string = \"0\".repeat(18 - fractional_string.len()) + \u0026fractional_string;\n\n            f.write_str(\u0026whole.to_string())?;\n            f.write_char('.')?;\n            f.write_str(fractional_string.trim_end_matches('0'))?;\n\n            Ok(())\n        }\n    }\n}\n\nimpl ops::Add for Decimal256 {\n    type Output = Self;\n\n    fn add(self, rhs: Self) -\u003e Self {\n        Decimal256(self.0 + rhs.0)\n    }\n}\n\nimpl ops::AddAssign for Decimal256 {\n    fn add_assign(\u0026mut self, rhs: Self) {\n        self.0 = self.0 + rhs.0;\n    }\n}\n\nimpl ops::Sub for Decimal256 {\n    type Output = Self;\n\n    fn sub(self, rhs: Self) -\u003e Self {\n        assert!(self.0 \u003e= rhs.0);\n        Decimal256(self.0 - rhs.0)\n    }\n}\n\nimpl ops::Mul for Decimal256 {\n    type Output = Self;\n\n    fn mul(self, rhs: Self) -\u003e Self {\n        Decimal256(self.0 * rhs.0 / Decimal256::DECIMAL_FRACTIONAL)\n    }\n}\n\nimpl ops::Div for Decimal256 {\n    type Output = Self;\n\n    fn div(self, rhs: Self) -\u003e Self {\n        assert!(!rhs.is_zero());\n\n        Decimal256(self.0 * Decimal256::DECIMAL_FRACTIONAL / rhs.0)\n    }\n}\n\n/// Serializes as a decimal string\nimpl Serialize for Decimal256 {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: ser::Serializer,\n    {\n        serializer.serialize_str(\u0026self.to_string())\n    }\n}\n\n/// Deserializes as a base64 string\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for Decimal256 {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cDecimal256, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_str(Decimal256Visitor)\n    }\n}\n\nstruct Decimal256Visitor;\n\nimpl\u003c'de\u003e de::Visitor\u003c'de\u003e for Decimal256Visitor {\n    type Value = Decimal256;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"string-encoded decimal\")\n    }\n\n    fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: de::Error,\n    {\n        match Decimal256::from_str(v) {\n            Ok(d) =\u003e Ok(d),\n            Err(e) =\u003e Err(E::custom(format!(\"Error parsing decimal '{}': {}\", v, e))),\n        }\n    }\n}\n\n//*** Uint256 ***/\n#[derive(Copy, Clone, Default, Debug, PartialEq, Eq, PartialOrd, Ord, JsonSchema)]\npub struct Uint256(#[schemars(with = \"String\")] pub U256);\n\nimpl Uint256 {\n    /// Creates a Uint256(0)\n    pub const fn zero() -\u003e Self {\n        Uint256(U256([0, 0, 0, 0]))\n    }\n\n    /// Create a 1.0 Decimal256\n    pub const fn one() -\u003e Self {\n        Uint256(U256([1, 0, 0, 0]))\n    }\n\n    pub fn is_zero(\u0026self) -\u003e bool {\n        self.0.is_zero()\n    }\n}\n\nimpl From\u003cU256\u003e for Uint256 {\n    fn from(val: U256) -\u003e Self {\n        Uint256(val)\n    }\n}\n\nimpl From\u003cUint256\u003e for U256 {\n    fn from(val: Uint256) -\u003e Self {\n        val.0\n    }\n}\n\n#[inline(always)]\nfn split_u128(a: u128) -\u003e (u64, u64) {\n    ((a \u003e\u003e 64) as _, (a \u0026 0xFFFFFFFFFFFFFFFF) as _)\n}\n\nimpl From\u003cUint128\u003e for Uint256 {\n    fn from(val: Uint128) -\u003e Self {\n        Uint256::from(val.u128())\n    }\n}\n\nimpl From\u003cu128\u003e for Uint256 {\n    fn from(val: u128) -\u003e Self {\n        let (hi, low) = split_u128(val);\n        Uint256(U256([low, hi, 0, 0]))\n    }\n}\n\nimpl From\u003cu64\u003e for Uint256 {\n    fn from(val: u64) -\u003e Self {\n        Uint256(val.into())\n    }\n}\n\nimpl TryFrom\u003c\u0026str\u003e for Uint256 {\n    type Error = StdError;\n\n    fn try_from(val: \u0026str) -\u003e Result\u003cSelf, Self::Error\u003e {\n        match U256::from_dec_str(val) {\n            Ok(u) =\u003e Ok(Uint256(u)),\n            Err(_e) =\u003e Err(StdError::generic_err(format!(\"invalid Uint256 '{}'\", val))),\n        }\n    }\n}\n\nimpl FromStr for Uint256 {\n    type Err = StdError;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let number =\n            U256::from_dec_str(input).map_err(|_| StdError::generic_err(\"Error parsing number\"))?;\n        Ok(Uint256(number))\n    }\n}\n\nimpl From\u003cUint256\u003e for String {\n    fn from(n: Uint256) -\u003e Self {\n        n.0.to_string()\n    }\n}\n\nimpl From\u003cUint256\u003e for u128 {\n    fn from(n: Uint256) -\u003e Self {\n        let U256(ref arr) = n.0;\n        assert!(arr[2] == 0u64);\n        assert!(arr[3] == 0u64);\n\n        let (hi, low) = (arr[1], arr[0]);\n        ((hi as u128) \u003c\u003c 64) + (low as u128)\n    }\n}\n\nimpl From\u003cUint256\u003e for Uint128 {\n    fn from(n: Uint256) -\u003e Self {\n        let num: u128 = n.into();\n        Uint128::from(num)\n    }\n}\n\nimpl fmt::Display for Uint256 {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl ops::Add for Uint256 {\n    type Output = Self;\n\n    fn add(self, rhs: Self) -\u003e Self {\n        Uint256(self.0 + rhs.0)\n    }\n}\n\nimpl ops::AddAssign for Uint256 {\n    fn add_assign(\u0026mut self, other: Self) {\n        self.0 = self.0 + other.0;\n    }\n}\n\nimpl ops::Sub for Uint256 {\n    type Output = Self;\n\n    fn sub(self, rhs: Self) -\u003e Self::Output {\n        assert!(self.0 \u003e= rhs.0);\n        Uint256(self.0 - rhs.0)\n    }\n}\n\nimpl ops::Mul\u003cUint256\u003e for Uint256 {\n    type Output = Self;\n\n    #[allow(clippy::suspicious_arithmetic_impl)]\n    fn mul(self, rhs: Uint256) -\u003e Self::Output {\n        // 0*a and b*0 is always 0\n        if self.is_zero() || rhs.is_zero() {\n            return Uint256::zero();\n        }\n\n        Uint256(self.0 * rhs.0)\n    }\n}\n\n/// Both d*u and u*d with d: Decimal256 and u: Uint256 returns an Uint256. There is no\n/// specific reason for this decision other than the initial use cases we have. If you\n/// need a Decimal256 result for the same calculation, use Decimal256(d*u) or Decimal256(u*d).\nimpl ops::Mul\u003cDecimal256\u003e for Uint256 {\n    type Output = Self;\n\n    #[allow(clippy::suspicious_arithmetic_impl)]\n    fn mul(self, rhs: Decimal256) -\u003e Self::Output {\n        // 0*a and b*0 is always 0\n        if self.is_zero() || rhs.is_zero() {\n            return Uint256::zero();\n        }\n\n        self.multiply_ratio(rhs.0, Decimal256::DECIMAL_FRACTIONAL)\n    }\n}\n\nimpl ops::Div\u003cDecimal256\u003e for Uint256 {\n    type Output = Self;\n\n    fn div(self, rhs: Decimal256) -\u003e Self::Output {\n        assert!(!rhs.is_zero());\n\n        if self.is_zero() {\n            return Uint256::zero();\n        }\n\n        self.multiply_ratio(Decimal256::DECIMAL_FRACTIONAL, rhs.0)\n    }\n}\n\nimpl ops::Mul\u003cUint256\u003e for Decimal256 {\n    type Output = Uint256;\n\n    fn mul(self, rhs: Uint256) -\u003e Self::Output {\n        rhs * self\n    }\n}\n\nimpl Uint256 {\n    /// returns self * nom / denom\n    pub fn multiply_ratio\u003cA: Into\u003cU256\u003e, B: Into\u003cU256\u003e\u003e(\u0026self, nom: A, denom: B) -\u003e Uint256 {\n        let nominator: U256 = nom.into();\n        let denominator: U256 = denom.into();\n        if denominator.is_zero() {\n            panic!(\"Denominator must not be zero\");\n        }\n\n        // TODO: minimize rounding that takes place (using gcd algorithm)\n        let val = self.0 * nominator / denominator;\n        Uint256::from(val)\n    }\n}\n\n/// Serializes as a base64 string\nimpl Serialize for Uint256 {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: ser::Serializer,\n    {\n        serializer.serialize_str(\u0026self.to_string())\n    }\n}\n\n/// Deserializes as a base64 string\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for Uint256 {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cUint256, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_str(Uint256Visitor)\n    }\n}\n\nstruct Uint256Visitor;\n\nimpl\u003c'de\u003e de::Visitor\u003c'de\u003e for Uint256Visitor {\n    type Value = Uint256;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"string-encoded integer\")\n    }\n\n    fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: de::Error,\n    {\n        match U256::from_dec_str(v) {\n            Ok(u) =\u003e Ok(Uint256(u)),\n            Err(_e) =\u003e Err(E::custom(format!(\"invalid Uint256 '{}'\", v))),\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use cosmwasm_std::{from_slice, to_vec, StdResult};\n    use std::convert::TryInto;\n\n    #[test]\n    fn decimal_one() {\n        let value = Decimal256::one();\n        assert_eq!(value.0, Decimal256::DECIMAL_FRACTIONAL);\n    }\n\n    #[test]\n    fn decimal_zero() {\n        let value = Decimal256::zero();\n        assert_eq!(value.0, U256::zero());\n    }\n\n    #[test]\n    fn decimal_percent() {\n        let value = Decimal256::percent(50);\n        assert_eq!(value.0, Decimal256::DECIMAL_FRACTIONAL / 2.into());\n    }\n\n    #[test]\n    fn decimal_permille() {\n        let value = Decimal256::permille(125);\n        assert_eq!(value.0, Decimal256::DECIMAL_FRACTIONAL / 8.into());\n    }\n\n    #[test]\n    fn decimal_from_ratio_works() {\n        // 1.0\n        assert_eq!(Decimal256::from_ratio(1, 1), Decimal256::one());\n        assert_eq!(Decimal256::from_ratio(53, 53), Decimal256::one());\n        assert_eq!(Decimal256::from_ratio(125, 125), Decimal256::one());\n\n        // 1.5\n        assert_eq!(Decimal256::from_ratio(3, 2), Decimal256::percent(150));\n        assert_eq!(Decimal256::from_ratio(150, 100), Decimal256::percent(150));\n        assert_eq!(Decimal256::from_ratio(333, 222), Decimal256::percent(150));\n\n        // 0.125\n        assert_eq!(Decimal256::from_ratio(1, 8), Decimal256::permille(125));\n        assert_eq!(Decimal256::from_ratio(125, 1000), Decimal256::permille(125));\n\n        // 1/3 (result floored)\n        assert_eq!(\n            Decimal256::from_ratio(1, 3),\n            Decimal256(333_333_333_333_333_333u64.into())\n        );\n\n        // 2/3 (result floored)\n        assert_eq!(\n            Decimal256::from_ratio(2, 3),\n            Decimal256(666_666_666_666_666_666u64.into())\n        );\n    }\n\n    #[test]\n    #[should_panic(expected = \"Denominator must not be zero\")]\n    fn decimal_from_ratio_panics_for_zero_denominator() {\n        Decimal256::from_ratio(1, 0);\n    }\n\n    #[test]\n    fn decimal_from_str_works() {\n        // Integers\n        assert_eq!(Decimal256::from_str(\"\").unwrap(), Decimal256::percent(0));\n        assert_eq!(Decimal256::from_str(\"0\").unwrap(), Decimal256::percent(0));\n        assert_eq!(Decimal256::from_str(\"1\").unwrap(), Decimal256::percent(100));\n        assert_eq!(Decimal256::from_str(\"5\").unwrap(), Decimal256::percent(500));\n        assert_eq!(\n            Decimal256::from_str(\"42\").unwrap(),\n            Decimal256::percent(4200)\n        );\n        assert_eq!(Decimal256::from_str(\"000\").unwrap(), Decimal256::percent(0));\n        assert_eq!(\n            Decimal256::from_str(\"001\").unwrap(),\n            Decimal256::percent(100)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"005\").unwrap(),\n            Decimal256::percent(500)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"0042\").unwrap(),\n            Decimal256::percent(4200)\n        );\n\n        // Decimal256s\n        assert_eq!(\n            Decimal256::from_str(\"1.\").unwrap(),\n            Decimal256::percent(100)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"1.0\").unwrap(),\n            Decimal256::percent(100)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"1.5\").unwrap(),\n            Decimal256::percent(150)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"0.5\").unwrap(),\n            Decimal256::percent(50)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"0.123\").unwrap(),\n            Decimal256::permille(123)\n        );\n\n        assert_eq!(\n            Decimal256::from_str(\"40.00\").unwrap(),\n            Decimal256::percent(4000)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"04.00\").unwrap(),\n            Decimal256::percent(400)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"00.40\").unwrap(),\n            Decimal256::percent(40)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"00.04\").unwrap(),\n            Decimal256::percent(4)\n        );\n\n        // Can handle 18 fractional digits\n        assert_eq!(\n            Decimal256::from_str(\"7.123456789012345678\").unwrap(),\n            Decimal256(7123456789012345678u64.into())\n        );\n        assert_eq!(\n            Decimal256::from_str(\"7.999999999999999999\").unwrap(),\n            Decimal256(7999999999999999999u64.into())\n        );\n\n        // Works for documented max value\n        assert_eq!(\n            Decimal256::from_str(\n                \"115792089237316195423570985008687907853269984665640564039457.584007913129639935\"\n            )\n            .unwrap(),\n            Decimal256::MAX\n        );\n    }\n\n    #[test]\n    fn decimal_from_str_errors_for_broken_whole_part() {\n        match Decimal256::from_str(\" \").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Error parsing whole\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n\n        match Decimal256::from_str(\"-1\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Error parsing whole\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn decimal_from_str_errors_for_broken_fractinal_part() {\n        match Decimal256::from_str(\"1. \").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Error parsing fractional\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n\n        match Decimal256::from_str(\"1.e\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Error parsing fractional\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n\n        match Decimal256::from_str(\"1.2e3\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Error parsing fractional\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn decimal_from_str_errors_for_more_than_18_fractional_digits() {\n        match Decimal256::from_str(\"7.1234567890123456789\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e {\n                assert_eq!(msg, \"Cannot parse more than 18 fractional digits\")\n            }\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n\n        // No special rules for trailing zeros. This could be changed but adds gas cost for the happy path.\n        match Decimal256::from_str(\"7.1230000000000000000\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e {\n                assert_eq!(msg, \"Cannot parse more than 18 fractional digits\")\n            }\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn decimal_from_str_errors_for_invalid_number_of_dots() {\n        match Decimal256::from_str(\"1.2.3\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Unexpected number of dots\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n\n        match Decimal256::from_str(\"1.2.3.4\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Unexpected number of dots\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    #[should_panic(expected = \"arithmetic operation overflow\")]\n    fn decimal_from_str_errors_for_more_than_max_value_integer_part() {\n        let _ =\n            Decimal256::from_str(\"115792089237316195423570985008687907853269984665640564039458\");\n    }\n\n    #[test]\n    #[should_panic(expected = \"arithmetic operation overflow\")]\n    fn decimal_from_str_errors_for_more_than_max_value_integer_part_with_decimal() {\n        let _ =\n            Decimal256::from_str(\"115792089237316195423570985008687907853269984665640564039458.0\");\n    }\n    #[test]\n    #[should_panic(expected = \"arithmetic operation overflow\")]\n    fn decimal_from_str_errors_for_more_than_max_value_decimal_part() {\n        let _ = Decimal256::from_str(\n            \"115792089237316195423570985008687907853269984665640564039457.584007913129639936\",\n        );\n    }\n\n    #[test]\n    fn decimal_is_zero_works() {\n        assert!(Decimal256::zero().is_zero());\n        assert!(Decimal256::percent(0).is_zero());\n        assert!(Decimal256::permille(0).is_zero());\n\n        assert!(!Decimal256::one().is_zero());\n        assert!(!Decimal256::percent(123).is_zero());\n        assert!(!Decimal256::permille(1234).is_zero());\n    }\n\n    #[test]\n    fn decimal_add() {\n        let value = Decimal256::one() + Decimal256::percent(50); // 1.5\n        assert_eq!(\n            value.0,\n            Decimal256::DECIMAL_FRACTIONAL * U256::from(3) / U256::from(2)\n        );\n    }\n\n    #[test]\n    fn decimal_sub() {\n        assert_eq!(\n            Decimal256::percent(50),\n            Decimal256::one() - Decimal256::percent(50)\n        );\n    }\n\n    #[test]\n    fn decimal_mul() {\n        assert_eq!(\n            Decimal256::percent(25),\n            Decimal256::percent(50) * Decimal256::percent(50)\n        );\n    }\n\n    #[test]\n    fn decimal_div() {\n        assert_eq!(\n            Decimal256::one() + Decimal256::one(),\n            Decimal256::percent(50) / Decimal256::percent(25)\n        );\n    }\n\n    #[test]\n    fn decimal_to_string() {\n        // Integers\n        assert_eq!(Decimal256::zero().to_string(), \"0\");\n        assert_eq!(Decimal256::one().to_string(), \"1\");\n        assert_eq!(Decimal256::percent(500).to_string(), \"5\");\n\n        // Decimal256s\n        assert_eq!(Decimal256::percent(125).to_string(), \"1.25\");\n        assert_eq!(Decimal256::percent(42638).to_string(), \"426.38\");\n        assert_eq!(Decimal256::percent(1).to_string(), \"0.01\");\n        assert_eq!(Decimal256::permille(987).to_string(), \"0.987\");\n\n        assert_eq!(Decimal256(1u64.into()).to_string(), \"0.000000000000000001\");\n        assert_eq!(Decimal256(10u64.into()).to_string(), \"0.00000000000000001\");\n        assert_eq!(Decimal256(100u64.into()).to_string(), \"0.0000000000000001\");\n        assert_eq!(Decimal256(1000u64.into()).to_string(), \"0.000000000000001\");\n        assert_eq!(Decimal256(10000u64.into()).to_string(), \"0.00000000000001\");\n        assert_eq!(Decimal256(100000u64.into()).to_string(), \"0.0000000000001\");\n        assert_eq!(Decimal256(1000000u64.into()).to_string(), \"0.000000000001\");\n        assert_eq!(Decimal256(10000000u64.into()).to_string(), \"0.00000000001\");\n        assert_eq!(Decimal256(100000000u64.into()).to_string(), \"0.0000000001\");\n        assert_eq!(Decimal256(1000000000u64.into()).to_string(), \"0.000000001\");\n        assert_eq!(Decimal256(10000000000u64.into()).to_string(), \"0.00000001\");\n        assert_eq!(Decimal256(100000000000u64.into()).to_string(), \"0.0000001\");\n        assert_eq!(Decimal256(10000000000000u64.into()).to_string(), \"0.00001\");\n        assert_eq!(Decimal256(100000000000000u64.into()).to_string(), \"0.0001\");\n        assert_eq!(Decimal256(1000000000000000u64.into()).to_string(), \"0.001\");\n        assert_eq!(Decimal256(10000000000000000u64.into()).to_string(), \"0.01\");\n        assert_eq!(Decimal256(100000000000000000u64.into()).to_string(), \"0.1\");\n    }\n\n    #[test]\n    fn decimal_serialize() {\n        assert_eq!(to_vec(\u0026Decimal256::zero()).unwrap(), br#\"\"0\"\"#);\n        assert_eq!(to_vec(\u0026Decimal256::one()).unwrap(), br#\"\"1\"\"#);\n        assert_eq!(to_vec(\u0026Decimal256::percent(8)).unwrap(), br#\"\"0.08\"\"#);\n        assert_eq!(to_vec(\u0026Decimal256::percent(87)).unwrap(), br#\"\"0.87\"\"#);\n        assert_eq!(to_vec(\u0026Decimal256::percent(876)).unwrap(), br#\"\"8.76\"\"#);\n        assert_eq!(to_vec(\u0026Decimal256::percent(8765)).unwrap(), br#\"\"87.65\"\"#);\n    }\n\n    #[test]\n    fn decimal_deserialize() {\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"0\"\"#).unwrap(),\n            Decimal256::zero()\n        );\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"1\"\"#).unwrap(),\n            Decimal256::one()\n        );\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"000\"\"#).unwrap(),\n            Decimal256::zero()\n        );\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"001\"\"#).unwrap(),\n            Decimal256::one()\n        );\n\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"0.08\"\"#).unwrap(),\n            Decimal256::percent(8)\n        );\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"0.87\"\"#).unwrap(),\n            Decimal256::percent(87)\n        );\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"8.76\"\"#).unwrap(),\n            Decimal256::percent(876)\n        );\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"87.65\"\"#).unwrap(),\n            Decimal256::percent(8765)\n        );\n    }\n\n    #[test]\n    fn to_and_from_uint256() {\n        let a: Uint256 = 12345u64.into();\n        assert_eq!(U256::from(12345), a.0);\n        assert_eq!(\"12345\", a.to_string());\n\n        let a: Uint256 = \"34567\".try_into().unwrap();\n        assert_eq!(U256::from(34567), a.0);\n        assert_eq!(\"34567\", a.to_string());\n\n        let a: StdResult\u003cUint256\u003e = \"1.23\".try_into();\n        assert!(a.is_err());\n    }\n\n    #[test]\n    fn uint256_is_zero_works() {\n        assert!(Uint256::zero().is_zero());\n        assert!(Uint256::from(0u64).is_zero());\n\n        assert!(!Uint256::from(1u64).is_zero());\n        assert!(!Uint256::from(123u64).is_zero());\n    }\n\n    #[test]\n    fn uint256_json() {\n        let orig = Uint256::from(1234567890987654321u64);\n        let serialized = to_vec(\u0026orig).unwrap();\n        assert_eq!(serialized.as_slice(), b\"\\\"1234567890987654321\\\"\");\n        let parsed: Uint256 = from_slice(\u0026serialized).unwrap();\n        assert_eq!(parsed, orig);\n    }\n\n    #[test]\n    fn uint256_compare() {\n        let a = Uint256::from(12345u64);\n        let b = Uint256::from(23456u64);\n\n        assert!(a \u003c b);\n        assert!(b \u003e a);\n        assert_eq!(a, Uint256::from(12345u64));\n    }\n\n    #[test]\n    fn uint256_math() {\n        let a = Uint256::from(12345u64);\n        let b = Uint256::from(23456u64);\n\n        // test + and - for valid values\n        assert_eq!(a + b, Uint256::from(35801u64));\n        assert_eq!(b - a, Uint256::from(11111u64));\n\n        // test +=\n        let mut c = Uint256::from(300000u64);\n        c += b;\n        assert_eq!(c, Uint256::from(323456u64));\n    }\n    #[test]\n    #[should_panic]\n    fn uint256_math_sub_underflow() {\n        let _ = Uint256::from(12345u64) - Uint256::from(23456u64);\n    }\n\n    #[test]\n    #[should_panic]\n    fn uint256_math_overflow_panics() {\n        // almost_max is 2^256 - 10\n        let almost_max = Uint256::from(U256([\n            18446744073709551615,\n            18446744073709551615,\n            18446744073709551615,\n            18446744073709551615,\n        ]));\n        let _ = almost_max + Uint256::from(12u64);\n    }\n\n    #[test]\n    // in this test the Decimal256 is on the right\n    fn uint256_decimal_multiply() {\n        // a*b\n        let left = Uint256::from(300u64);\n        let right = Decimal256::one() + Decimal256::percent(50); // 1.5\n        assert_eq!(left * right, Uint256::from(450u64));\n\n        // a*0\n        let left = Uint256::from(300u64);\n        let right = Decimal256::zero();\n        assert_eq!(left * right, Uint256::from(0u64));\n\n        // 0*a\n        let left = Uint256::zero();\n        let right = Decimal256::one() + Decimal256::percent(50); // 1.5\n        assert_eq!(left * right, Uint256::zero());\n    }\n\n    #[test]\n    fn u256_multiply_ratio_works() {\n        let base = Uint256::from(500u64);\n\n        // factor 1/1\n        assert_eq!(base.multiply_ratio(1, 1), Uint256::from(500u64));\n        assert_eq!(base.multiply_ratio(3, 3), Uint256::from(500u64));\n        assert_eq!(base.multiply_ratio(654321, 654321), Uint256::from(500u64));\n\n        // factor 3/2\n        assert_eq!(base.multiply_ratio(3, 2), Uint256::from(750u64));\n        assert_eq!(base.multiply_ratio(333333, 222222), Uint256::from(750u64));\n\n        // factor 2/3 (integer devision always floors the result)\n        assert_eq!(base.multiply_ratio(2, 3), Uint256::from(333u64));\n        assert_eq!(base.multiply_ratio(222222, 333333), Uint256::from(333u64));\n\n        // factor 5/6 (integer devision always floors the result)\n        assert_eq!(base.multiply_ratio(5, 6), Uint256::from(416u64));\n        assert_eq!(base.multiply_ratio(100, 120), Uint256::from(416u64));\n    }\n\n    #[test]\n    fn u256_from_u128() {\n        assert_eq!(Uint256::from(100u64), Uint256::from(100u128));\n        let num = Uint256::from(1_000_000_000_000_000_000_000_000u128);\n        assert_eq!(num.to_string(), \"1000000000000000000000000\");\n    }\n\n    #[test]\n    #[should_panic(expected = \"Denominator must not be zero\")]\n    fn u256_multiply_ratio_panics_for_zero_denominator() {\n        Uint256::from(500u64).multiply_ratio(1, 0);\n    }\n\n    #[test]\n    fn u256_zero_one() {\n        assert_eq!(Uint256::zero().0, U256::zero());\n        assert_eq!(Uint256::one().0, U256::one());\n    }\n\n    #[test]\n    fn u256_into_u128() {\n        let val: u128 = Uint256::from(1234556700000000000999u128).into();\n        assert_eq!(val, 1234556700000000000999u128);\n    }\n\n    #[test]\n    #[should_panic]\n    fn u256_into_u128_panics_for_overflow() {\n        let _: u128 = Uint256::from_str(\"2134982317498312749832174923184732198471983247\")\n            .unwrap()\n            .into();\n    }\n\n    #[test]\n    // in this test the Decimal256 is on the left\n    fn decimal_uint256_multiply() {\n        // a*b\n        let left = Decimal256::one() + Decimal256::percent(50); // 1.5\n        let right = Uint256::from(300u64);\n        assert_eq!(left * right, Uint256::from(450u64));\n\n        // 0*a\n        let left = Decimal256::zero();\n        let right = Uint256::from(300u64);\n        assert_eq!(left * right, Uint256::from(0u64));\n\n        // a*0\n        let left = Decimal256::one() + Decimal256::percent(50); // 1.5\n        let right = Uint256::from(0u64);\n        assert_eq!(left * right, Uint256::from(0u64));\n    }\n}\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":32},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","fee_contract","src","error.rs"],"content":"use cosmwasm_std::StdError;\nuse thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized {},\n\n    #[error(\"Fee not paid correctly, required: {required:?}uust, provided {provided:?}uust\")]\n    FeeNotPaidCorrectly { required: u128, provided: u128 },\n\n    #[error(\"Fee not paid\")]\n    FeeNotPaid {},\n\n    #[error(\"Trade not accepted\")]\n    TradeNotAccepted {},\n\n    #[error(\"Fee Teers not ordered, you can't change them\")]\n    TeersNotOrdered {},\n\n    #[error(\"Error when encoding response message to binary string\")]\n    BinaryEncodingError {},\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","fee_contract","src","lib.rs"],"content":"pub mod error;\npub mod msg;\npub mod state;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","fee_contract","src","msg.rs"],"content":"use cosmwasm_std::{StdError, StdResult, Uint128};\nuse p2p_trading_export::state::AssetInfo;\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse utils::msg::is_valid_name;\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct MigrateMsg {}\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct InstantiateMsg {\n    pub name: String,\n    pub owner: Option\u003cString\u003e,\n    pub p2p_contract: String,\n    pub fee_distributor: String,\n}\n\nimpl InstantiateMsg {\n    pub fn validate(\u0026self) -\u003e StdResult\u003c()\u003e {\n        // Check name, symbol, decimals\n        if !is_valid_name(\u0026self.name) {\n            return Err(StdError::generic_err(\n                \"Name is not in the expected format (3-50 UTF-8 bytes)\",\n            ));\n        }\n        Ok(())\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum ExecuteMsg {\n    PayFeeAndWithdraw {\n        trade_id: u64,\n    },\n    UpdateFeeRates {\n        asset_fee_rate: Option\u003cUint128\u003e, // In thousandths (fee rate for liquid assets (terra native funds))\n        fee_max: Option\u003cUint128\u003e, // In uusd (max asset fee paid (outside of terra native funds))\n        first_teer_limit: Option\u003cUint128\u003e, // Max number of NFT to fall into the first tax teer\n        first_teer_rate: Option\u003cUint128\u003e, // Fee per asset in the first teer\n        second_teer_limit: Option\u003cUint128\u003e, // Max number of NFT to fall into the second tax teer\n        second_teer_rate: Option\u003cUint128\u003e, // Fee per asset in the second teer\n        third_teer_rate: Option\u003cUint128\u003e, // Fee per asset in the third teer\n        acceptable_fee_deviation: Option\u003cUint128\u003e, // To account for fluctuations in terra native prices, we allow the provided fee the deviate from the quoted fee (non simultaeous operations)\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    Fee {\n        trade_id: u64,\n        counter_id: Option\u003cu64\u003e,\n    },\n    SimulateFee {\n        trade_id: u64,\n        counter_assets: Vec\u003cAssetInfo\u003e,\n    },\n    ContractInfo {},\n    FeeRates {},\n}\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct FeeResponse {\n    pub fee: Uint128,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","fee_contract","src","state.rs"],"content":"use cosmwasm_std::{Addr, Uint128};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct ContractInfo {\n    pub name: String,\n    pub owner: Addr,\n    pub p2p_contract: Addr,\n    pub fee_distributor: Addr,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct FeeInfo {\n    pub asset_fee_rate: Uint128, // In thousandths\n    pub fee_max: Uint128,        // In uusd\n    pub first_teer_limit: Uint128,\n    pub first_teer_rate: Uint128,\n    pub second_teer_limit: Uint128,\n    pub second_teer_rate: Uint128,\n    pub third_teer_rate: Uint128,\n    pub acceptable_fee_deviation: Uint128, // In thousands\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","fee_distributor","src","lib.rs"],"content":"pub mod msg;\npub mod state;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","fee_distributor","src","msg.rs"],"content":"use cosmwasm_std::{StdError, StdResult, Uint128};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse utils::msg::is_valid_name;\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct MigrateMsg {}\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct InstantiateMsg {\n    pub name: String,\n    pub owner: Option\u003cString\u003e,\n    pub treasury: String,\n}\n\nimpl InstantiateMsg {\n    pub fn validate(\u0026self) -\u003e StdResult\u003c()\u003e {\n        // Check name, symbol, decimals\n        if !is_valid_name(\u0026self.name) {\n            return Err(StdError::generic_err(\n                \"Name is not in the expected format (3-50 UTF-8 bytes)\",\n            ));\n        }\n        Ok(())\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum ExecuteMsg {\n    ModifyContractInfo {\n        owner: Option\u003cString\u003e,\n        treasury: Option\u003cString\u003e,\n        projects_allocation: Option\u003cUint128\u003e,\n    },\n    DepositFees {\n        addresses: Vec\u003cString\u003e,\n    },\n    WithdrawFees {\n        addresses: Vec\u003cString\u003e,\n    },\n    AddAssociatedAddress {\n        address: String,\n        fee_address: String,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    ContractInfo {},\n    Amount {\n        address: String,\n    },\n    Addresses {\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    },\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","fee_distributor","src","state.rs"],"content":"use cosmwasm_std::{Addr, Uint128};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct ContractInfo {\n    pub name: String,\n    pub owner: Addr,\n    pub treasury: Addr,\n    pub projects_allocation: Uint128, // In percent\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","lender","src","lib.rs"],"content":"pub mod msg;\npub mod state;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","lender","src","msg.rs"],"content":"use cosmwasm_std::{Binary, StdError, StdResult};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse crate::state::{BorrowMode, BorrowZone, Cw721Info};\nuse cosmwasm_std::Uint128;\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct InstantiateMsg {\n    pub name: String,\n    pub owner: Option\u003cString\u003e,\n    pub oracle: Option\u003cString\u003e,\n    pub vault_token: String,\n    pub increasor_incentives: Uint128,\n    pub interests_fee_rate: Uint128,\n    pub fee_distributor: String,\n}\n\nimpl InstantiateMsg {\n    pub fn validate(\u0026self) -\u003e StdResult\u003c()\u003e {\n        // Check name, symbol, decimals\n        if !is_valid_name(\u0026self.name) {\n            return Err(StdError::generic_err(\n                \"Name is not in the expected format (3-50 UTF-8 bytes)\",\n            ));\n        }\n        Ok(())\n    }\n}\n\nfn is_valid_name(name: \u0026str) -\u003e bool {\n    let bytes = name.as_bytes();\n    if bytes.len() \u003c 3 || bytes.len() \u003e 50 {\n        return false;\n    }\n    true\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub enum ExecuteMsg {\n    // User accessible functions\n    Borrow {\n        asset_info: Cw721Info,\n        assets_to_borrow: Uint128,\n        borrow_mode: BorrowMode,\n    },\n    BorrowMore {\n        loan_id: u64,\n        assets_to_borrow: Uint128,\n    },\n    Repay {\n        borrower: String,\n        loan_id: u64,\n        assets: Uint128,\n    },\n    Receive {\n        sender: String,\n        amount: Uint128,\n        msg: Binary,\n    },\n    RaiseRate {\n        borrower: String,\n        loan_id: u64,\n    },\n    // Admin specific\n    SetOwner {\n        owner: String,\n    },\n    SetOracle {\n        oracle: String,\n    },\n    ToggleLock {\n        lock: bool,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    /// Returns the current state of the contract (locked)\n    /// Return type: StateResponse.\n    State {},\n    /// Returns metadata on the contract - name, owner, oracle, etc.\n    /// Return type: ContractInfoResponse.\n    ContratInfo {},\n    /// Returns the borrow info of the designated loan\n    BorrowInfo {\n        borrower: String,\n        loan_id: u64,\n    },\n    BorrowZones {\n        asset_info: Cw721Info,\n    },\n    BorrowTerms {\n        asset_info: Cw721Info,\n        borrow_mode: BorrowMode,\n        borrow_zone: BorrowZone,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct ZonesResponse {\n    pub safe_zone_limit: Uint128,\n    pub expensive_zone_limit: Uint128,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","lender","src","state.rs"],"content":"use cosmwasm_std::{Addr, Uint128};\nuse cw_storage_plus::{Item, Map};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cw_4626::state::AssetInfo;\npub const CONTRACT_INFO: Item\u003cContractInfo\u003e = Item::new(\"contract_info\");\npub const STATE: Item\u003cState\u003e = Item::new(\"state\");\npub const BORROWS: Map\u003c(\u0026Addr, u64), BorrowInfo\u003e = Map::new(\"borrows\");\n\n// This allows the interest to pay to be stable (at the scale of a human) with the blocks mined\npub const MIN_BLOCK_OFFSET: u64 = 10u64;\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct ContractInfo {\n    pub name: String,\n    pub vault_token: Addr,\n    pub vault_asset: AssetInfo,\n    pub owner: Addr,\n    pub oracle: Addr,\n    pub increasor_incentives: Uint128, // In 1/PERCENTAGE_RATE of the intersts surplus generated\n    pub interests_fee_rate: Uint128,   // In 1/PERCENTAGE_RATE of the total interests\n    pub fee_distributor: Addr,\n}\n\n/// Internal state of the contract\n/// Can be changed at anytime (without time locks for now) by the owner of the contract\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct State {\n    pub borrow_locked: bool,\n}\n\n/// Terms of borrowing for a contract\n/// If duration is not specified, the loan can be liquidated using info from the oracle contract\n/// The borrower has more risk so the terms should be favorable in that cas\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct BorrowTerms {\n    pub principle: Uint128,\n    pub interests: InterestType,\n}\n\npub const PERCENTAGE_RATE: u128 = 10_000u128;\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\npub enum InterestType {\n    Fixed {\n        interests: Uint128,\n        duration: u64,\n    },\n    Continuous {\n        last_interest_rate: Uint128, // In 1/PERCENTAGE_RATE per block\n        interests_accrued: Uint128,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\npub struct InterestsInfo {\n    pub safe_interest_rate: Uint128, // In 1/PERCENTAGE_RATE per block\n    pub expensive_interest_rate: Uint128, // In 1/PERCENTAGE_RATE per block\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\npub enum BorrowMode {\n    Fixed,\n    Continuous,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\npub enum BorrowZone {\n    SafeZone,\n    ExpensiveZone,\n    LiquidationZone,\n}\n\n/// Structure to hold the borrow informations\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct BorrowInfo {\n    pub collateral: Option\u003cCw721Info\u003e,\n    pub principle: Uint128,\n    pub interests: InterestType,\n    pub start_block: u64,\n    pub borrow_zone: BorrowZone,\n    pub rate_increasor: Option\u003cRateIncreasor\u003e,\n}\n\n/// Information about the increasor (their address, and the rate of the safe zone at the time of triggering)\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct RateIncreasor {\n    pub increasor: Addr,\n    pub previous_rate: Uint128,\n}\n\n/// Structure to hold the borrow informations\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct Cw721Info {\n    pub nft_address: String,\n    pub token_id: String,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","nft-loans","src","lib.rs"],"content":"pub mod msg;\npub mod state;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","nft-loans","src","msg.rs"],"content":"use cosmwasm_std::{StdError, StdResult, Uint128};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse utils::msg::is_valid_name;\n\nuse crate::state::{CollateralInfo, LoanTerms};\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct MigrateMsg {}\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct InstantiateMsg {\n    pub name: String,\n    pub owner: Option\u003cString\u003e,\n    pub fee_distributor: String,\n    pub fee_rate: Uint128,\n}\n\nimpl InstantiateMsg {\n    pub fn validate(\u0026self) -\u003e StdResult\u003c()\u003e {\n        // Check name, symbol, decimals\n        if !is_valid_name(\u0026self.name) {\n            return Err(StdError::generic_err(\n                \"Name is not in the expected format (3-50 UTF-8 bytes)\",\n            ));\n        }\n        Ok(())\n    }\n}\n/// This contract nevers holds any funds\n/// In case it does, it's that an error occured\n/// TODO, we need to provide a way to make sure we can get those funds back\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum ExecuteMsg {\n    //// We support both Cw721 and Cw1155\n    DepositCollateral {\n        address: String,\n        token_id: String,\n        value: Option\u003cUint128\u003e,\n        terms: Option\u003cLoanTerms\u003e,\n    },\n    /// Used to withdraw the collateral before the loan starts\n    WithdrawCollateral {\n        loan_id: u64,\n    },\n    SetTerms {\n        loan_id: u64,\n        terms: LoanTerms,\n    },\n    MakeOffer {\n        borrower: String,\n        loan_id: u64,\n        terms: LoanTerms,\n    },\n    CancelOffer {\n        borrower: String,\n        loan_id: u64,\n        offer_id: u64,\n    },\n    RefuseOffer {\n        loan_id: u64,\n        offer_id: u64,\n    },\n    WithdrawRefusedOffer {\n        borrower: String,\n        loan_id: u64,\n        offer_id: u64,\n    },\n    AcceptOffer {\n        loan_id: u64,\n        offer_id: u64,\n    },\n    AcceptLoan {\n        borrower: String,\n        loan_id: u64,\n    },\n    RepayBorrowedFunds {\n        loan_id: u64,\n    },\n    ForceDefault {\n        borrower: String,\n        loan_id: u64,\n    },\n    /// Used only when the loan can be paid back late\n    WithdrawDefaultedLoan {\n        borrower: String,\n        loan_id: u64,\n    },\n    /// Internal state\n    SetOwner {\n        owner: String,\n    },\n    SetFeeDistributor {\n        fee_depositor: String,\n    },\n    SetFeeRate {\n        fee_rate: Uint128,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    ContractInfo {},\n    CollateralInfo { borrower: String, loan_id: u64 },\n    BorrowerInfo { borrower: String },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct CollateralResponse {\n    pub borrower: String,\n    pub loan_id: u64,\n    pub collateral: CollateralInfo,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct OfferResponse {\n    pub lender: String,\n    pub borrower: String,\n    pub loan_id: u64,\n    pub offer_id: u64,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","nft-loans","src","state.rs"],"content":"use strum_macros;\n\nuse cosmwasm_std::{Addr, Coin, Uint128};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse utils::state::{AssetInfo, Cw20Coin};\n// We neep a map per user of all loans that are happening right now !\n// The info should be redondant and linked\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct CollateralInfo {\n    pub terms: Option\u003cLoanTerms\u003e,\n    pub associated_asset: AssetInfo,\n    pub state: LoanState,\n    pub offers: Vec\u003cOfferInfo\u003e,\n    pub active_loan: Option\u003cu64\u003e,\n    pub start_block: Option\u003cu64\u003e,\n}\n\nimpl Default for CollateralInfo {\n    fn default() -\u003e Self {\n        Self {\n            terms: None,\n            associated_asset: AssetInfo::Cw20Coin(Cw20Coin {\n                address: \"\".to_string(),\n                amount: Uint128::zero(),\n            }),\n            state: LoanState::Published,\n            offers: vec![],\n            active_loan: None,\n            start_block: None,\n        }\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug, Default)]\n#[serde(rename_all = \"snake_case\")]\npub struct BorrowerInfo {\n    pub last_collateral_id: u64,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct OfferInfo {\n    pub lender: Addr,\n    pub terms: LoanTerms,\n    pub state: OfferState,\n    pub deposited_funds: Option\u003cCoin\u003e,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema, Default)]\n#[serde(rename_all = \"snake_case\")]\npub struct LoanTerms {\n    pub principle: Coin,\n    pub interest: Uint128,\n    pub duration_in_blocks: u64,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug, strum_macros::Display)]\n#[serde(rename_all = \"snake_case\")]\npub enum LoanState {\n    Published,\n    Started,\n    Defaulted,\n    Ended,\n    AssetWithdrawn,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug, strum_macros::Display)]\n#[serde(rename_all = \"snake_case\")]\npub enum OfferState {\n    Published,\n    Accepted,\n    Refused,\n    Cancelled,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct ContractInfo {\n    pub name: String,\n    pub owner: Addr,\n    pub fee_distributor: String,\n    pub fee_rate: Uint128,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","oracle","src","lib.rs"],"content":"pub mod msg;\npub mod state;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","oracle","src","msg.rs"],"content":"use cosmwasm_std::{StdError, StdResult, Uint128};\nuse cw_4626::state::AssetInfo;\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse utils::msg::is_valid_name;\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct MigrateMsg {}\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct InstantiateMsg {\n    pub name: String,\n    pub owner: Option\u003cString\u003e,\n    pub timeout: Option\u003cu64\u003e,\n}\n\nimpl InstantiateMsg {\n    pub fn validate(\u0026self) -\u003e StdResult\u003c()\u003e {\n        // Check name, symbol, decimals\n        if !is_valid_name(\u0026self.name) {\n            return Err(StdError::generic_err(\n                \"Name is not in the expected format (3-50 UTF-8 bytes)\",\n            ));\n        }\n        Ok(())\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum ExecuteMsg {\n    SetNftPrice {\n        contract: String,\n        oracle_owner: Option\u003cString\u003e,\n        price: Uint128,\n        unit: AssetInfo,\n    },\n    SetOwner {\n        owner: String,\n    },\n    SetTimeout {\n        timeout: u64,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    NftPrice { contract: String, unit: AssetInfo },\n    ContractInfo {},\n}\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct NftPriceResponse {\n    pub contract: String,\n    pub price: Uint128,\n    pub unit: AssetInfo,\n    pub oracle_owner: String,\n    pub timeout: bool,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","oracle","src","state.rs"],"content":"use cosmwasm_std::{Addr, Timestamp, Uint128};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct ContractInfo {\n    pub name: String,\n    pub owner: Addr,\n    pub timeout: u64,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct NftPrice {\n    pub price: Uint128,\n    pub oracle_owner: Addr,\n    pub last_update: Timestamp,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","p2p-trading","src","lib.rs"],"content":"pub mod msg;\npub mod query;\npub mod state;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","p2p-trading","src","msg.rs"],"content":"use crate::state::{AssetInfo, CounterTradeInfo};\nuse cosmwasm_std::{to_binary, Binary, CosmosMsg, StdError, StdResult, WasmMsg};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nfn is_valid_name(name: \u0026str) -\u003e bool {\n    let bytes = name.as_bytes();\n    if bytes.len() \u003c 3 || bytes.len() \u003e 50 {\n        return false;\n    }\n    true\n}\n\npub fn into_binary\u003cM: Serialize\u003e(msg: M) -\u003e StdResult\u003cBinary\u003e {\n    to_binary(\u0026msg)\n}\n\npub fn into_cosmos_msg\u003cM: Serialize, T: Into\u003cString\u003e\u003e(\n    message: M,\n    contract_addr: T,\n) -\u003e StdResult\u003cCosmosMsg\u003e {\n    let msg = into_binary(message)?;\n    let execute = WasmMsg::Execute {\n        contract_addr: contract_addr.into(),\n        msg,\n        funds: vec![],\n    };\n    Ok(execute.into())\n}\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct InstantiateMsg {\n    pub name: String,\n    pub owner: Option\u003cString\u003e,\n}\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct MigrateMsg {}\n\nimpl InstantiateMsg {\n    pub fn validate(\u0026self) -\u003e StdResult\u003c()\u003e {\n        // Check name, symbol, decimals\n        if !is_valid_name(\u0026self.name) {\n            return Err(StdError::generic_err(\n                \"Name is not in the expected format (3-50 UTF-8 bytes)\",\n            ));\n        }\n        Ok(())\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum ExecuteMsg {\n    CreateTrade {\n        whitelisted_users: Option\u003cVec\u003cString\u003e\u003e,\n        comment: Option\u003cString\u003e,\n    },\n    AddAsset {\n        trade_id: Option\u003cu64\u003e,\n        counter_id: Option\u003cu64\u003e,\n        to_last_trade: Option\u003cbool\u003e,\n        to_last_counter: Option\u003cbool\u003e,\n        asset: AssetInfo,\n    },\n    RemoveAssets {\n        trade_id: u64,\n        counter_id: Option\u003cu64\u003e,\n        assets: Vec\u003c(u16, AssetInfo)\u003e,\n    },\n    AddWhitelistedUsers {\n        trade_id: u64,\n        whitelisted_users: Vec\u003cString\u003e,\n    },\n    RemoveWhitelistedUsers {\n        trade_id: u64,\n        whitelisted_users: Vec\u003cString\u003e,\n    },\n    SetComment {\n        trade_id: u64,\n        counter_id: Option\u003cu64\u003e,\n        comment: String,\n    },\n    AddNFTsWanted {\n        trade_id: Option\u003cu64\u003e,\n        nfts_wanted: Vec\u003cString\u003e,\n    },\n    RemoveNFTsWanted {\n        trade_id: u64,\n        nfts_wanted: Vec\u003cString\u003e,\n    },\n    /// Is used by the Trader to confirm they completed their end of the trade.\n    ConfirmTrade {\n        trade_id: Option\u003cu64\u003e,\n    },\n    /// Can be used to initiate Counter Trade, but also to add new tokens to it\n    SuggestCounterTrade {\n        trade_id: u64,\n        comment: Option\u003cString\u003e,\n    },\n    /// Is used by the Client to confirm they completed their end of the trade.\n    ConfirmCounterTrade {\n        trade_id: u64,\n        counter_id: Option\u003cu64\u003e,\n    },\n    /// Accept the Trade plain and simple, swap it up !\n    AcceptTrade {\n        trade_id: u64,\n        counter_id: u64,\n        comment: Option\u003cString\u003e,\n    },\n    /// Cancel the Trade :/ No luck there mate ?\n    CancelTrade {\n        trade_id: u64,\n    },\n    /// Cancel the Counter Trade :/ No luck there mate ?\n    CancelCounterTrade {\n        trade_id: u64,\n        counter_id: u64,\n    },\n    /// Refuse the Trade plain and simple, no madam, I'm not interested in your tokens !\n    RefuseCounterTrade {\n        trade_id: u64,\n        counter_id: u64,\n    },\n    /// Some parts of the traded tokens were interesting, but you can't accept the trade as is\n    ReviewCounterTrade {\n        trade_id: u64,\n        counter_id: u64,\n        comment: Option\u003cString\u003e,\n    },\n    /// The fee contract can Withdraw funds via this function only when the trade is accepted.\n    WithdrawPendingAssets {\n        trader: String,\n        trade_id: u64,\n    },\n    /// You can Withdraw funds only at specific steps of the trade, but you're allowed to try anytime !\n    WithdrawAllFromTrade {\n        trade_id: u64,\n    },\n    /// You can Withdraw funds when your counter trade is aborted (refused or cancelled)\n    /// Or when you are creating the trade and you just want to cancel it all\n    WithdrawAllFromCounter {\n        trade_id: u64,\n        counter_id: u64,\n    },\n    SetNewOwner {\n        owner: String,\n    },\n    SetNewFeeContract {\n        fee_contract: String,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema, Default)]\n#[serde(rename_all = \"snake_case\")]\npub struct QueryFilters {\n    pub states: Option\u003cVec\u003cString\u003e\u003e,\n    pub owner: Option\u003cString\u003e,\n    pub counterer: Option\u003cString\u003e,\n    pub has_whitelist: Option\u003cbool\u003e,\n    pub whitelisted_user: Option\u003cString\u003e,\n    pub contains_token: Option\u003cString\u003e,\n    pub wanted_nft: Option\u003cString\u003e,\n    pub assets_withdrawn: Option\u003cbool\u003e,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    ContractInfo {},\n    TradeInfo {\n        trade_id: u64,\n    },\n    CounterTradeInfo {\n        trade_id: u64,\n        counter_id: u64,\n    },\n    GetAllTrades {\n        start_after: Option\u003cu64\u003e,\n        limit: Option\u003cu32\u003e,\n        filters: Option\u003cQueryFilters\u003e,\n    },\n    GetCounterTrades {\n        trade_id: u64,\n        start_after: Option\u003cu64\u003e,\n        limit: Option\u003cu32\u003e,\n        filters: Option\u003cQueryFilters\u003e,\n    },\n    GetAllCounterTrades {\n        start_after: Option\u003cCounterTradeInfo\u003e,\n        limit: Option\u003cu32\u003e,\n        filters: Option\u003cQueryFilters\u003e,\n    },\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":6},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","p2p-trading","src","query.rs"],"content":"use cosmwasm_std::{to_binary, Addr, Deps, QueryRequest, StdError, StdResult, WasmQuery};\n\nuse crate::msg::QueryMsg as P2PQueryMsg;\nuse crate::state::TradeInfo;\n\n/// Load a trade and the provided counter trade\n/// If it isn't provided, the function will try to query the accepted counter trade if it exists\npub fn load_trade_and_accepted_counter_trade(\n    deps: Deps,\n    p2p_contract: Addr,\n    trade_id: u64,\n    counter_id: Option\u003cu64\u003e,\n) -\u003e StdResult\u003c(TradeInfo, TradeInfo)\u003e {\n    let trade_info = load_trade(deps, p2p_contract.clone(), trade_id)?;\n\n    let counter_id = match counter_id {\n        Some(counter_id) =\u003e counter_id,\n        None =\u003e {\n            trade_info\n                .clone()\n                .accepted_info\n                .ok_or_else(|| StdError::generic_err(\"Trade not accepted\"))?\n                .counter_id\n        }\n    };\n\n    let counter_info = load_counter_trade(deps, p2p_contract, trade_id, counter_id)?;\n\n    Ok((trade_info, counter_info))\n}\n\n/// Load a trade from the P2P contract\npub fn load_trade(deps: Deps, p2p_contract: Addr, trade_id: u64) -\u003e StdResult\u003cTradeInfo\u003e {\n    deps.querier.query(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n        contract_addr: p2p_contract.to_string(),\n        msg: to_binary(\u0026P2PQueryMsg::TradeInfo { trade_id })?,\n    }))\n}\n\n/// Load a counter_trade from the P2P contract\npub fn load_counter_trade(\n    deps: Deps,\n    p2p_contract: Addr,\n    trade_id: u64,\n    counter_id: u64,\n) -\u003e StdResult\u003cTradeInfo\u003e {\n    deps.querier.query(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n        contract_addr: p2p_contract.to_string(),\n        msg: to_binary(\u0026P2PQueryMsg::CounterTradeInfo {\n            trade_id,\n            counter_id,\n        })?,\n    }))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","p2p-trading","src","state.rs"],"content":"use strum_macros;\n\nuse cosmwasm_std::{Addr, Coin, Timestamp, Uint128};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse std::collections::HashSet;\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct Cw1155Coin {\n    pub address: String,\n    pub token_id: String,\n    pub value: Uint128,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct Cw721Coin {\n    pub address: String,\n    pub token_id: String,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct Cw20Coin {\n    pub address: String,\n    pub amount: Uint128,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub enum AssetInfo {\n    Cw20Coin(Cw20Coin),\n    Cw721Coin(Cw721Coin),\n    Cw1155Coin(Cw1155Coin),\n    Coin(Coin),\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug, strum_macros::Display)]\n#[serde(rename_all = \"snake_case\")]\npub enum TradeState {\n    Created,\n    Published,\n    Countered,\n    Refused,\n    Accepted,\n    Cancelled,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct ContractInfo {\n    pub name: String,\n    pub owner: Addr,\n    pub fee_contract: Option\u003cAddr\u003e,\n    pub last_trade_id: Option\u003cu64\u003e,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct CounterTradeInfo {\n    pub trade_id: u64,\n    pub counter_id: u64,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug, Default)]\n#[serde(rename_all = \"snake_case\")]\npub struct AdditionnalTradeInfo {\n    pub time: Timestamp,\n    pub owner_comment: Option\u003cComment\u003e,\n    pub trader_comment: Option\u003cComment\u003e,\n    pub nfts_wanted: HashSet\u003cAddr\u003e,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug, Default)]\n#[serde(rename_all = \"snake_case\")]\npub struct Comment {\n    pub time: Timestamp,\n    pub comment: String,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct TradeInfo {\n    pub owner: Addr,\n    pub associated_assets: Vec\u003cAssetInfo\u003e,\n    pub state: TradeState,\n    pub last_counter_id: Option\u003cu64\u003e,\n    pub whitelisted_users: HashSet\u003cAddr\u003e,\n    pub additionnal_info: AdditionnalTradeInfo,\n    pub accepted_info: Option\u003cCounterTradeInfo\u003e,\n    pub assets_withdrawn: bool,\n}\n\nimpl Default for TradeInfo {\n    fn default() -\u003e Self {\n        Self {\n            owner: Addr::unchecked(\"\"),\n            associated_assets: vec![],\n            state: TradeState::Created,\n            last_counter_id: None,\n            whitelisted_users: HashSet::new(),\n            additionnal_info: AdditionnalTradeInfo::default(),\n            accepted_info: None,\n            assets_withdrawn: false,\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","raffles","src","lib.rs"],"content":"pub mod msg;\npub mod state;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","raffles","src","msg.rs"],"content":"use crate::state::AssetInfo;\nuse anyhow::Result;\nuse cosmwasm_std::{to_binary, Addr, Binary, CosmosMsg, StdError, StdResult, Uint128, WasmMsg};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nfn is_valid_name(name: \u0026str) -\u003e bool {\n    let bytes = name.as_bytes();\n    if bytes.len() \u003c 3 || bytes.len() \u003e 50 {\n        return false;\n    }\n    true\n}\n\npub fn into_binary\u003cM: Serialize\u003e(msg: M) -\u003e StdResult\u003cBinary\u003e {\n    to_binary(\u0026msg)\n}\n\npub fn into_cosmos_msg\u003cM: Serialize, T: Into\u003cString\u003e\u003e(\n    message: M,\n    contract_addr: T,\n) -\u003e Result\u003cCosmosMsg\u003e {\n    let msg = into_binary(message)?;\n    let execute = WasmMsg::Execute {\n        contract_addr: contract_addr.into(),\n        msg,\n        funds: vec![],\n    };\n    Ok(execute.into())\n}\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct InstantiateMsg {\n    pub name: String,\n    pub owner: Option\u003cString\u003e,\n    pub fee_addr: Option\u003cString\u003e,\n    pub minimum_raffle_duration: Option\u003cu64\u003e,\n    pub minimum_raffle_timeout: Option\u003cu64\u003e,\n    pub raffle_fee: Option\u003cUint128\u003e, // in 10_000\n    pub rand_fee: Option\u003cUint128\u003e,   // in 10_000\n    pub drand_url: Option\u003cString\u003e,\n    pub random_pubkey: Binary,\n    pub verify_signature_contract: String,\n}\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct MigrateMsg {}\n\nimpl InstantiateMsg {\n    pub fn validate(\u0026self) -\u003e StdResult\u003c()\u003e {\n        // Check name, symbol, decimals\n        if !is_valid_name(\u0026self.name) {\n            return Err(StdError::generic_err(\n                \"Name is not in the expected format (3-50 UTF-8 bytes)\",\n            ));\n        }\n        Ok(())\n    }\n}\n\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct DrandRandomness {\n    pub round: u64,\n    pub previous_signature: Binary,\n    pub signature: Binary,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum ExecuteMsg {\n    CreateRaffle {\n        asset: AssetInfo,\n        raffle_start_timestamp: Option\u003cu64\u003e, // If not specified, starts immediately\n        raffle_duration: Option\u003cu64\u003e,\n        raffle_timeout: Option\u003cu64\u003e,\n        comment: Option\u003cString\u003e,\n        raffle_ticket_price: AssetInfo,\n        max_participant_number: Option\u003cu64\u003e,\n    },\n    BuyTicket {\n        raffle_id: u64,\n        sent_assets: AssetInfo,\n    },\n    Receive {\n        sender: String,\n        amount: Uint128,\n        msg: Binary,\n    },\n    ReceiveNft {\n        sender: String,\n        token_id: String,\n        msg: Binary,\n    },\n    Cw1155ReceiveMsg {\n        operator: String,\n        from: Option\u003cString\u003e,\n        token_id: String,\n        amount: Uint128,\n        msg: Binary,\n    },\n    ClaimNft {\n        raffle_id: u64,\n    },\n    UpdateRandomness {\n        raffle_id: u64,\n        randomness: DrandRandomness,\n    },\n\n    // Admin messages\n    ToggleLock {\n        lock: bool,\n    },\n    Renounce {},\n    ChangeParameter{\n        parameter: String,\n        value: String\n    }\n}\n\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema, Default)]\n#[serde(rename_all = \"snake_case\")]\npub struct QueryFilters {\n    pub states: Option\u003cVec\u003cString\u003e\u003e,\n    pub owner: Option\u003cAddr\u003e,\n    pub ticket_depositor: Option\u003cAddr\u003e,\n    pub contains_token: Option\u003cString\u003e,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    ContractInfo {},\n    RaffleInfo {\n        raffle_id: u64,\n    },\n    GetAllRaffles {\n        start_after: Option\u003cu64\u003e,\n        limit: Option\u003cu32\u003e,\n        filters: Option\u003cQueryFilters\u003e,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum VerifierExecuteMsg {\n    Verify {\n        randomness: DrandRandomness,\n        pubkey: Binary,\n        raffle_id: u64,\n        owner: String,\n    },\n}\n","traces":[{"line":7,"address":[2382352],"length":1,"stats":{"Line":6},"fn_name":"is_valid_name"},{"line":8,"address":[2382400],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[2382414],"length":1,"stats":{"Line":7},"fn_name":null},{"line":10,"address":[2382458],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[2382451],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[1084864,1085122,1085218,1085056,1085152,1084960,1085026,1084930],"length":1,"stats":{"Line":4},"fn_name":"into_binary\u003ccw1155::msg::Cw1155ExecuteMsg\u003e"},{"line":16,"address":[1084881,1085169,1084977,1085073],"length":1,"stats":{"Line":3},"fn_name":null},{"line":19,"address":[1085248,1087323,1088384,1089428,1087360,1086288,1086248,1088416],"length":1,"stats":{"Line":4},"fn_name":"into_cosmos_msg\u003ccw721::msg::Cw721ExecuteMsg, alloc::string::String\u003e"},{"line":23,"address":[1085270,1087573,1088617,1085746,1088926,1086821,1085587,1088438,1086517,1087882,1087723,1086663,1088767,1085437,1087382,1086314],"length":1,"stats":{"Line":7},"fn_name":null},{"line":25,"address":[1087657,1085521,1088701,1086597],"length":1,"stats":{"Line":3},"fn_name":null},{"line":27,"address":[1089000,1085820,1086895,1087956],"length":1,"stats":{"Line":4},"fn_name":null},{"line":29,"address":[1088124,1086185,1085988,1089365,1087063,1089168,1088321,1087260],"length":1,"stats":{"Line":7},"fn_name":null},{"line":50,"address":[2382480],"length":1,"stats":{"Line":7},"fn_name":"validate"},{"line":52,"address":[2382512],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[2382569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[2382561],"length":1,"stats":{"Line":6},"fn_name":null}],"covered":14,"coverable":16},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","raffles","src","state.rs"],"content":"use strum_macros;\n\nuse cosmwasm_std::{Addr, Binary, Coin, Timestamp, Uint128};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\n/*\npub const MINIMUM_RAFFLE_DURATION: u64 = 3600; // A raffle last at least 1 hour\npub const MINIMUM_RAFFLE_TIMEOUT: u64 = 120; // The raffle duration is a least 2 minutes\npub const MINIMUM_RAND_FEE: u128 = 1; // The randomness provider gets at least 1/10_000 of the total raffle price\npub const MAXIMUM_PARTICIPANT_NUMBER: u64 = 1000;\n*/\n\npub const MINIMUM_RAFFLE_DURATION: u64 = 1; \npub const MINIMUM_RAFFLE_TIMEOUT: u64 = 120; // The raffle duration is a least 2 minutes\npub const MINIMUM_RAND_FEE: u128 = 1; // The randomness provider gets at least 1/10_000 of the total raffle price\npub const MAXIMUM_PARTICIPANT_NUMBER: u64 = 1000;\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct Cw1155Coin {\n    pub address: String,\n    pub token_id: String,\n    pub value: Uint128,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct Cw721Coin {\n    pub address: String,\n    pub token_id: String,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct Cw20Coin {\n    pub address: String,\n    pub amount: Uint128,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub enum AssetInfo {\n    Cw20Coin(Cw20Coin),\n    Cw721Coin(Cw721Coin),\n    Cw1155Coin(Cw1155Coin),\n    Coin(Coin),\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug, strum_macros::Display)]\n#[serde(rename_all = \"snake_case\")]\npub enum RaffleState {\n    Created,\n    Started,\n    Closed,\n    Finished,\n    Claimed,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct ContractInfo {\n    pub name: String,\n    pub owner: Addr,\n    pub fee_addr: Addr,\n    pub last_raffle_id: Option\u003cu64\u003e,\n    pub minimum_raffle_duration: u64,\n    pub minimum_raffle_timeout: u64,\n    pub raffle_fee: Uint128, // in 10_000\n    pub rand_fee: Uint128,   // in 10_000\n    pub lock: bool,\n    pub drand_url: String, \n    pub verify_signature_contract: Addr,\n    pub random_pubkey: Binary,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct RaffleTicket {\n    pub raffle_id: u64,\n    pub owner: Addr,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub struct RaffleInfo {\n    pub owner: Addr,\n    pub asset: AssetInfo,\n    pub raffle_start_timestamp: Timestamp,\n    pub raffle_duration: u64,\n    pub raffle_timeout: u64,\n    pub comment: Option\u003cString\u003e,\n    pub raffle_ticket_price: AssetInfo,\n    pub accumulated_ticket_fee: AssetInfo,\n    pub tickets: Vec\u003cAddr\u003e,\n    pub randomness: [u8; 32],\n    pub randomness_round: u64,\n    pub randomness_owner: Option\u003cAddr\u003e,\n    pub max_participant_number: u64,\n    pub winner: Option\u003cAddr\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","utils","src","lib.rs"],"content":"pub mod msg;\npub mod state;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","utils","src","msg.rs"],"content":"use cosmwasm_std::{to_binary, Binary, Coin, CosmosMsg, StdResult, WasmMsg};\nuse serde::Serialize;\n\npub fn is_valid_name(name: \u0026str) -\u003e bool {\n    let bytes = name.as_bytes();\n    if bytes.len() \u003c 3 || bytes.len() \u003e 50 {\n        return false;\n    }\n    true\n}\n\npub fn into_binary\u003cM: Serialize\u003e(msg: M) -\u003e StdResult\u003cBinary\u003e {\n    to_binary(\u0026msg)\n}\n\npub fn into_cosmos_msg\u003cM: Serialize, T: Into\u003cString\u003e\u003e(\n    message: M,\n    contract_addr: T,\n    funds: Option\u003cVec\u003cCoin\u003e\u003e,\n) -\u003e StdResult\u003cCosmosMsg\u003e {\n    let msg = into_binary(message)?;\n    let execute = WasmMsg::Execute {\n        contract_addr: contract_addr.into(),\n        msg,\n        funds: funds.unwrap_or_default(),\n    };\n    Ok(execute.into())\n}\n\n/*\n#[derive(Serialize, Deserialize, JsonSchema, Debug, Clone, PartialEq)]\npub struct TradeInfoResponse {\n    pub trade_info: TradeInfo,\n}\n*/\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":6},{"path":["/","home","kayanski","Terra","illiquidly-contracts","packages","utils","src","state.rs"],"content":"use cosmwasm_std::{Addr, Api, StdResult, Uint128};\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct Cw1155Coin {\n    pub address: String,\n    pub token_id: String,\n    pub value: Uint128,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct Cw721Coin {\n    pub address: String,\n    pub token_id: String,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct Cw20Coin {\n    pub address: String,\n    pub amount: Uint128,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]\n#[serde(rename_all = \"snake_case\")]\npub enum AssetInfo {\n    Cw20Coin(Cw20Coin),\n    Cw721Coin(Cw721Coin),\n    Cw1155Coin(Cw1155Coin),\n}\n\npub fn maybe_addr(api: \u0026dyn Api, human: Option\u003cString\u003e) -\u003e StdResult\u003cOption\u003cAddr\u003e\u003e {\n    human.map(|x| api.addr_validate(\u0026x)).transpose()\n}\n","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, pathToString(file.path)),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('div', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('pre', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>